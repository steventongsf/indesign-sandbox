//========================================================================================
//  
//  $File: //depot/devtech/14.0/plugin/source/sdksamples/transparencyeffect/TranFxMatteFactory.h $
//  
//  Owner: Adobe Developer Technologies
//  
//  $Author: pmbuilder $
//  
//  $DateTime: 2018/09/10 00:46:19 $
//  
//  $Revision: #2 $
//  
//  $Change: 1031899 $
//  
//  Copyright 1997-2010 Adobe Systems Incorporated. All rights reserved.
//  
//  NOTICE:  Adobe permits you to use, modify, and distribute this file in accordance 
//  with the terms of the Adobe license agreement accompanying it.  If you have received
//  this file from a source other than Adobe, then your use, modification, or 
//  distribution of it requires the prior written permission of Adobe.
//  
//========================================================================================

#ifndef __TranFxHelper_H_DEFINED__
#define __TranFxHelper_H_DEFINED__

class IShape;
class AGMImageAccessor;
class IGraphicStyleDescriptor;
class IHierarchy;

/** Helps with the creation and caching of this plug-in's effect images.

	
	@ingroup transparencyeffect
	@see TranFxConvolutionFilter
	@see SnapshotUtils
	@see IImageCacheMgr
	@see IImageCache
*/
class TranFxMatteFactory
{

public:
	/** Constructor.
	 */
	TranFxMatteFactory();

	/** Destructor.
	 */
	virtual                 ~TranFxMatteFactory();

public:
	// Effect image methods:

	/** Generate a grey level matte image based on the current effect control flags.
		@param iShape IN the object for which matte is to be generated.
		@param resolution IN desired resolution of the matte.
		@param drawOptionsSet IN draw options controlling matte quality.
		@param enableCaching IN kTrue to enable caching or matte via IImageCacheMgr, kFalse otherwise
		@return pointer to AGMImageAccessor containing the matte image (the caller should
		not delete this memory).
	 */
	const AGMImageAccessor* MakeMatte(IShape* iShape, const PMReal& resolution, const DrawOptionsSet& drawOptionsSet, const bool16 enableCaching);

	/** Return the bounds of the matte in pasteboard co-ordinates.
		@param iShape IN the object whose matte bounds are desired.
		@return the bounds of the matte image.
	 */
	PBPMRect                  GetBoundingBox(IShape* iShape) const;

	/** Get the painted bounds of the given shape not including the area that would
		be drawn by the matte effect. This uses IShape::GetPaintedBBox
		so if the given shape draws outside of its bounds (e.g. text on a path) 
		bounds returned will reflect this. Since this IShape call will result
		in our adornment's TranFxAdornment::GetPaintedBBox being called, the implementation
		checks and blocks recursive calls.
		@param iShape IN the object whose painted bounds are desired.
		@param bounds IN/OUT the painted bounding box (caller must check the return value is kTrue before relying on this value).
		@return kTrue if the painted bounds are available, kFalse if a recursive call
			has been detected and the bounds are not being returned.
	 */
	bool16                  GetPaintedBBoxWithoutMatte(IShape* iShape, PBPMRect& bounds) const;

public:
	// Cache management methods:

	/** Purge cached images for the given itemList.
		@param itemList IN objects whose cached images are to be purged.
	 */
	void                    PurgeImageCache(const UIDList& itemList);

	/** Purge all images this plug-in has cached for the given document.
		@param documentUIDRef IN document containing objects whose cached images are to be purged.
	 */
	void                    PurgeWholeCache(const UIDRef& documentUIDRef);

private:
	/** Cache an image.
		@param image
		@param startTime
		@param itemUIDRef
		@param resolution
		@param checksum
	 */
	void                    AddToCache(const AGMImageAccessor* image, uint32 startTime, const UIDRef& itemUIDRef, const PMReal& resolution, uint32 checksum);

	/** Lookup cached image for the given shape, resolution and checksum.
		@param currentShapeRef
		@param resolution
		@param checksum
		@return pointer to cached image mask, nil otherwise.
	 */
	const AGMImageAccessor* FindInCache(const UIDRef& currentShapeRef, const PMReal& resolution, uint32 checksum);

	/**	@param iShape. 
		@return kTrue if it is safe to cache this object.
	 */
	bool16                  InkingIsSafeToCache(IShape* iShape);

	/** Recursive method that checks whether hierarchy has objects
		that are safe to cache.
		@param iPageItem
		@param childCount
		@return kTrue if it is safe to cache this object.
	 */
	bool16                  InkingIsSafeToCacheRecursive(IHierarchy* iPageItem, int32& childCount);

	/**
			@return kTrue if object has no colour.
	 */
	bool16                  ObjectHasNoColor(IGraphicStyleDescriptor* gsDesc);

	/** Set the fMaskImage pointer maintained by this class. If
		mask generated by this class is not cached in IImageCacheMgr
		the pointer to the image is held until this class goes out of
		scope or a new ma\sk is generated.
		@param image
	 */
	void                    SetMaskImage(const AGMImageAccessor* image);

private:
	AGMImageAccessor*       fMaskImage;
};

#endif // __TranFxHelper_H_DEFINED__

