//========================================================================================
//  
//  $File: //depot/devtech/14.0/plugin/source/sdksamples/basicdrwevthandler/BscDEHDrwEvtHandler.cpp $
//  
//  Owner: Adobe Developer Technologies
//  
//  $Author: pmbuilder $
//  
//  $DateTime: 2018/09/10 00:46:19 $
//  
//  $Revision: #2 $
//  
//  $Change: 1031899 $
//  
//  Copyright 1997-2010 Adobe Systems Incorporated. All rights reserved.
//  
//  NOTICE:  Adobe permits you to use, modify, and distribute this file in accordance 
//  with the terms of the Adobe license agreement accompanying it.  If you have received
//  this file from a source other than Adobe, then your use, modification, or 
//  distribution of it requires the prior written permission of Adobe.
//  
//========================================================================================

#include "VCPlugInHeaders.h"

// Interface includes:
#include "IDrwEvtHandler.h"
#include "IDrwEvtDispatcher.h"
#include "IShape.h"
#include "IViewPortAttributes.h"
#include "IPDFLibraryUtilsPublic.h"

// General includes:
#include "DocumentContextID.h"
#include "K2Vector.tpp"
#include "KeyValuePair.h"

// Project includes:
#include "BscDEHID.h"


/** BscDEHDrwEvtHandler
	This class provides the service of handling draw events.  The class registers for
	draw events of interest.  As a demo, this particular implementation registers for
	all draw events.  Once registered, the class handles draw events sent by the draw
	event dispatcher.

	
	@ingroup basicdrwevthandler
*/
class BscDEHDrwEvtHandler : public CPMUnknown<IDrwEvtHandler>
{
	public:
		/**
			Constructor.
			Builds a list of event IDs of interest.  The list ensures consistency in the
			register and unregister methods.
			@param boss interface ptr from boss object on which this interface is aggregated.
		*/
		BscDEHDrwEvtHandler(IPMUnknown *boss);

		/** Destructor */
		virtual 		~BscDEHDrwEvtHandler();

		/** 
			Tells the draw event dispatcher what draw events this implementation wants to handle.
			Uses the list of event IDs built by the constructor.
			@param eventDispatcher Active draw event dispatcher.
		*/
		virtual void	Register(IDrwEvtDispatcher* eventDispatcher);

		/**
			Tells the draw event dispatcher this class doesn't want to receive draw events anymore.
			Actually, this implementation will be unregistered automatically when the application 
			quits because this draw event handler implementation appears on a service provider boss. 
			However, this method explicitly unregisters using the list generated by the constructor 
			so it could be used outside the context of a service provider.
			@param eventDispatcher Active draw event dispatcher.
		*/
		virtual void	UnRegister(IDrwEvtDispatcher* eventDispatcher);

		/**
			Takes action based on the event ID.
			Always returns kFalse, meaning that the draw event has not been handled.
			Returning kTrue would tell the draw event manager to stop calling draw event
			handlers, and would also tell the broadcasting agent (e.g. page item) to
			stop drawing.
			@param eventID ID of the specific event.  Should never be something the DEH isn't registered for.
			@param eventData Ptr to the draw event data.  May be one of several classes, depending on the specific event.
		*/
		virtual bool16	HandleDrawEvent(ClassID eventID, void* eventData);

	private:

		/** Stores the event IDs handled by BscDEH, and a PMString description for TRACE */
		K2Vector<KeyValuePair<ClassID, PMString> >  fSupportedEventIDs;

};

/* CREATE_PMINTERFACE
 Binds the C++ implementation class onto its
 ImplementationID making the C++ code callable by the
 application.
*/
CREATE_PMINTERFACE(BscDEHDrwEvtHandler, kBscDEHDrwEvtHandlerImpl)

/* BscDEHDrwEvtHandler Constructor
*/
BscDEHDrwEvtHandler::BscDEHDrwEvtHandler(IPMUnknown* boss) : 
	CPMUnknown<IDrwEvtHandler>(boss) 

{
	
	// Build a list of event IDs that BscDEH is supposed to handle.
	// Add corresponding strings for each event ID
	fSupportedEventIDs.clear();
	
	// Spread drawing messages
	::InsertKeyValue(fSupportedEventIDs, ClassID(kDrawSpreadMessage), PMString("kDrawSpreadMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kBeginSpreadMessage), PMString("kBeginSpreadMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kEndSpreadMessage), PMString("kEndSpreadMessage"));

	// Spread pages
	::InsertKeyValue(fSupportedEventIDs, ClassID(kDrawSpreadPageMessage), PMString("kDrawSpreadPageMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kBeginSpreadPageMessage), PMString("kBeginSpreadPageMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kEndSpreadPageMessage), PMString("kEndSpreadPageMessage"));

	// Layers 
	::InsertKeyValue(fSupportedEventIDs, ClassID(kDrawLayerMessage), PMString("kDrawLayerMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kBeginLayerMessage), PMString("kBeginLayerMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kEndLayerMessage), PMString("kEndLayerMessage"));

	// Pages
	::InsertKeyValue(fSupportedEventIDs, ClassID(kDrawPageMessage), PMString("kDrawPageMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kBeginPageMessage), PMString("kBeginPageMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kEndPageMessage), PMString("kEndPageMessage"));

	// Groups
	::InsertKeyValue(fSupportedEventIDs, ClassID(kDrawGroupMessage), PMString("kDrawGroupMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kBeginGroupMessage), PMString("kBeginGroupMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kEndGroupMessage), PMString("kEndGroupMessage"));

	// Shapes
	::InsertKeyValue(fSupportedEventIDs, ClassID(kDrawShapeMessage), PMString("kDrawShapeMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kBeginShapeMessage), PMString("kBeginShapeMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kEndShapeMessage), PMString("kEndShapeMessage"));

	// Master Spreads
	::InsertKeyValue(fSupportedEventIDs, ClassID(kDrawMasterSpreadMessage), PMString("kDrawMasterSpreadMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kBeginMasterSpreadMessage), PMString("kBeginMasterSpreadMessage"));
	::InsertKeyValue(fSupportedEventIDs, ClassID(kEndMasterSpreadMessage), PMString("kEndMasterSpreadMessage"));

	if (fSupportedEventIDs.size()<=0)
	{
		ASSERT_FAIL("BscDEHDrwEvtHandler must support at least 1 event ID");
		::InsertKeyValue(fSupportedEventIDs, ClassID(kInvalidClass), PMString("kInvalidClass"));
	}

}

/* BscDEHDrwEvtHandler Destructor
*/
BscDEHDrwEvtHandler::~BscDEHDrwEvtHandler()
{
}


/* Register
*/
void BscDEHDrwEvtHandler::Register(IDrwEvtDispatcher* eventDispatcher)
{

	int32 numEventIDs = fSupportedEventIDs.size();
	for (int32 i=0; i<numEventIDs; i++)
	{
		eventDispatcher->RegisterHandler(fSupportedEventIDs[i].Key(), this, kDEHLowestPriority);
	}
}


/* UnRegister
*/
void BscDEHDrwEvtHandler::UnRegister(IDrwEvtDispatcher* eventDispatcher)
{
	int32 numEventIDs = fSupportedEventIDs.size();
	for (int32 i=0; i<numEventIDs; i++)
	{
		eventDispatcher->UnRegisterHandler(fSupportedEventIDs[i].Key(), this);
	}
}



/* HandleEvent
*/
bool16 BscDEHDrwEvtHandler::HandleDrawEvent(ClassID eventID, void* eventData)
{

	// Initialize pointers in case we receive a draw event
	DrawEventData* ded = nil;
	GraphicsData* gdp = nil;

	// For building an output string
	PMString whatWeGot;

	do {

		// Get the data from the base class event data: the change agent and drawing flags
		CDrawEventData* evtDataObj = static_cast<CDrawEventData*>(eventData);
		if (evtDataObj == nil)
		{
			// This should never be nil
			ASSERT_FAIL("Received nil CDrawEventData* - BscDEHDrwEvtHandler::HandleEvent");
			break;
		}

		// Get the IShape drawing flags.  Quick way to tell if drawing to screen or not.
		int32 drwFlags = evtDataObj->flags;

		// What event occurred?  Look it up by event ID in our registration list.
		int32 index = ::FindLocation(fSupportedEventIDs, eventID);
		if (index >= 0)
		{
			// Received one of the events for which BscDEH is registered.
			// Output the corresponding string to trace
			whatWeGot.Append(fSupportedEventIDs[index].Value());

			// The graphics data object will give more information about the draw context
			// than the IShape drawing flags.  So grab a pointer to the graphics data from the draw event data.
			ded = static_cast<DrawEventData*>(eventData);
			if (ded == nil)
			{
				// Because BscDEH only registers for draw events, there should always be a valid DrawEventData*
				ASSERT_FAIL("Received nil DrawEventData* - BscDEHDrwEvtHandler::HandleEvent");
				break;
			}
			gdp = ded->gd;
		}
		else
		{
			// Shouldn't receive something BscDEH isn't registered for, but capture it anyway.
			// Don't assert, just output to trace.
			whatWeGot.Append("Unregistered event #");
			whatWeGot.AppendNumber(eventID.Get());
		}

		// Add a context description to the string
		whatWeGot.Append(" received by BscDEHDrwEvtHandler during");
		bool16 contextFound = kFalse;
		if (gdp != nil)
		{
			// The GraphicsData* gives us everything we need for drawing. Keeping it simple,
			// just extract the drawing context from the graphics data.  The first step
			// is to get the view port attribues for the current draw
			IViewPortAttributes* iViewPortAtt = gdp->GetViewPortAttributes();

			// Is it PDF?
			if (Utils<IPDFLibraryUtilsPublic>()->IsPDFExportPort(iViewPortAtt))
			{
				// PDF export...
				whatWeGot.Append(" PDF Output");
				contextFound = kTrue;
			}
			else
			{
				// Not PDF, is it printing?  Ask the viewport to find out.
				if (iViewPortAtt->GetViewPortIsPrintingPort())
				{
					// Ok, it's printing.
					whatWeGot.Append(" Printing");
					contextFound = kTrue;
				}
			}
		}
		else
		{
			// Extract the limited information about the drawing context from the IShape flags
			if (drwFlags & IShape::kPrinting)
			{
				whatWeGot.Append(" Printing or PDF Output");
				contextFound = kTrue;
			}
		}

		// If it's not PDF or print, it must be screen drawing
		if (contextFound == kFalse)
		{
			whatWeGot.Append(" Screen Drawing");
			contextFound = kTrue;
		}

		// Now add information about the broadcasting agent
		IPMUnknown* agent = evtDataObj->changedBy;
		ClassID agentID = ::GetClass(agent);
		InterfacePtr<IObjectModel> om (GetExecutionContextSession(), IID_IOBJECTMODEL);
		if (om == nil)
		{
			ASSERT_FAIL("Nil IObjectModel* from the session - BscDEHDrwEvtHandler::HandleEvent");
			break;
		}
		const char* agentBossName = om->GetIDName(agentID);
		whatWeGot.Append(" from ");
		whatWeGot.Append(agentBossName);
		whatWeGot.Append(", UID");

		// Output
		TRACEFLOW("BasicDrwEvtHandler", "%s 0x%x\n", whatWeGot.GetUTF8String().c_str(), ::GetUID(agent).Get());

	} while(false);

	// Tell the draw event dispatcher to keep calling other handlers and allow the drawing agent
	// to complete its draw.
	return kFalse;
}

// End, BscDEHDrwEvtHandler.cpp.






