<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_master_spread_utils</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_master_spread_utils.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_master_spread_utils-members.html">List of all members</a></div><div class="headertitle"><div class="title">IMasterSpreadUtils Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_master_spread_utils_8h_source.html">IMasterSpreadUtils.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IMasterSpreadUtils:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_master_spread_utils.png" usemap="#IMasterSpreadUtils_map" /><map id="IMasterSpreadUtils_map" name="IMasterSpreadUtils_map"><area alt="IPMUnknown" coords="0,0,118,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a6e86adfcae765466bb6bd3aba6d4efa2"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IMASTERSPREADUTILS }</td></tr><tr class="separator:a6e86adfcae765466bb6bd3aba6d4efa2"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a8aa95ff7a41379d2f5f18aa7a7d5bb12"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#a8aa95ff7a41379d2f5f18aa7a7d5bb12">_IsFrontViewAMaster</a> ()=0</td></tr><tr class="separator:a8aa95ff7a41379d2f5f18aa7a7d5bb12"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a00fb3ffeacf04134149bbdb92959c968"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#a00fb3ffeacf04134149bbdb92959c968">BuildMasterSpreadList</a> (<a class="el" href="class_i_string_list_control_data.html">IStringListControlData</a> *stringData, <a class="el" href="class_u_i_d_list.html">UIDList</a> *masterUIDs, bool16 bIncludeNone, <a class="el" href="class_i_d_type.html">UID</a> excludeUID)=0</td></tr><tr class="separator:a00fb3ffeacf04134149bbdb92959c968"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2c2b6a9ec5fefee61e3a4fd4ff9ad731"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#a2c2b6a9ec5fefee61e3a4fd4ff9ad731">IsAnAncestorOf</a> (<a class="el" href="class_i_master_spread_list.html">IMasterSpreadList</a> *masterList, <a class="el" href="class_i_d_type.html">UID</a> masterA, <a class="el" href="class_i_d_type.html">UID</a> masterB)=0</td></tr><tr class="separator:a2c2b6a9ec5fefee61e3a4fd4ff9ad731"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae9d802e9fb03dc914d81c0e2ac272c43"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#ae9d802e9fb03dc914d81c0e2ac272c43">GetAncestorsOf</a> (<a class="el" href="class_i_master_spread_list.html">IMasterSpreadList</a> *masterSpreadList, <a class="el" href="class_i_d_type.html">UID</a> masterUID, <a class="el" href="class_u_i_d_list.html">UIDList</a> *ancestors)=0</td></tr><tr class="separator:ae9d802e9fb03dc914d81c0e2ac272c43"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a28d5a7801ff04e001700c530a4cd98dc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#a28d5a7801ff04e001700c530a4cd98dc">TopoSortMasterSpread</a> (<a class="el" href="class_i_master_spread_list.html">IMasterSpreadList</a> *masterSpreadList, <a class="el" href="class_u_i_d_list.html">UIDList</a> *sortedList)=0</td></tr><tr class="separator:a28d5a7801ff04e001700c530a4cd98dc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af1d4a61dab4c9c2a5debe139829559f6"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#af1d4a61dab4c9c2a5debe139829559f6">IsMasterAppliedToPage</a> (<a class="el" href="class_i_d_type.html">UID</a> masterUID, <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *page) const =0</td></tr><tr class="separator:af1d4a61dab4c9c2a5debe139829559f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acc3cdc9c74ba43a5eab45943b75476bf"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_list.html">UIDList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#acc3cdc9c74ba43a5eab45943b75476bf">GetUnusedMasterUIDs</a> (<a class="el" href="class_i_document.html">IDocument</a> *doc)=0</td></tr><tr class="separator:acc3cdc9c74ba43a5eab45943b75476bf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab8d5c9f0410d01a54481d5cbea86ca43"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#ab8d5c9f0410d01a54481d5cbea86ca43">CountPagesWithMaster</a> (<a class="el" href="class_u_i_d_list.html">UIDList</a> *masterUIDs, int32 *mastersWithMaster=nil, <a class="el" href="class_u_i_d_list.html">UIDList</a> *pageUIDs=nil)=0</td></tr><tr class="separator:ab8d5c9f0410d01a54481d5cbea86ca43"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a85012457438f5a430824e0cb326c0dd9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#a85012457438f5a430824e0cb326c0dd9">OverrideMasterPageItem</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> masterItem, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> pageToOverrideOn, <a class="el" href="class_i_command.html#a9b7f77ae8c7947d4dcf20b808a2c9f37">ICommand::Undoability</a> undoability=<a class="el" href="class_i_command.html#a9b7f77ae8c7947d4dcf20b808a2c9f37a4d6414d928ccbdb418cfd97c70619d14">ICommand::kAutoUndo</a>, <a class="el" href="class_u_i_d_ref.html">UIDRef</a> *overriddenItem=nil)=0</td></tr><tr class="separator:a85012457438f5a430824e0cb326c0dd9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac076f884801c36dd3d0542fd3c3806be"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#ac076f884801c36dd3d0542fd3c3806be">IsMasterItemOverriddenOnPage</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> masterItem, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> startPageUIDRef)=0</td></tr><tr class="separator:ac076f884801c36dd3d0542fd3c3806be"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afe4cf0049bb5fbc9b8a94e8b816867da"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#afe4cf0049bb5fbc9b8a94e8b816867da">CreateOverrideMasterPageItemsCmd</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;spreadsOrPages, <a class="el" href="class_i_callback.html">ICallback</a> *masterItemCollector=nil, int32 drwMgrFlags=<a class="el" href="class_i_shape.html#a6a11299dcbeb8aba75b41a24121663f9a08da4ef529fe5e282843e02b477b8df8">IShape::kSkipChildren</a>+<a class="el" href="class_i_shape.html#a6a11299dcbeb8aba75b41a24121663f9ae21f3c1c407d8801e3e55f9802035817">IShape::kSkipHiddenAndLockedLayers</a>) const =0</td></tr><tr class="separator:afe4cf0049bb5fbc9b8a94e8b816867da"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd4a7c9c3bd710b590a029e0810c321c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_master_spread_utils.html#afd4a7c9c3bd710b590a029e0810c321c">AppendMasterPageItems</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, <a class="el" href="class_i_d_type.html">UID</a> theSpread, const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;onThesePages, const <a class="el" href="class_k2_vector.html">PMRectCollection</a> &amp;pageBounds, <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;masterItems, <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;pages, <a class="el" href="class_k2_vector.html">PMMatrixCollection</a> &amp;offsets, <a class="el" href="class_i_callback.html">ICallback</a> *masterItemCollector=nil, int32 drwMgrFlags=<a class="el" href="class_i_shape.html#a6a11299dcbeb8aba75b41a24121663f9a08da4ef529fe5e282843e02b477b8df8">IShape::kSkipChildren</a>+<a class="el" href="class_i_shape.html#a6a11299dcbeb8aba75b41a24121663f9ae21f3c1c407d8801e3e55f9802035817">IShape::kSkipHiddenAndLockedLayers</a>) const =0</td></tr><tr class="separator:afd4a7c9c3bd710b590a029e0810c321c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac93cb58b8a89bdf1feecfe741fcc8452"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac93cb58b8a89bdf1feecfe741fcc8452"></a> virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>CalculateMasterSpreadToDrawingSpreadMatrix</b> (const <a class="el" href="class_i_master_page.html">IMasterPage</a> *drawingPage, <a class="el" href="class_u_i_d_ref.html">UIDRef</a> masterPage=kInvalidUIDRef) const =0</td></tr><tr class="separator:ac93cb58b8a89bdf1feecfe741fcc8452"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Utility interface to manipulate master spreads; please use the <a class="el" href="class_i_master_spread_utils.html">IMasterSpreadUtils</a> via <a class="el" href="classk_utils_boss.html">kUtilsBoss</a> (see <a class="el" href="_utils_8h_source.html">Utils.h</a>). <pre>Utils&lt;MasterSpreadUtils&gt;()-&gt;IsFrontViewAMaster( ... ) ;</pre><dl class="section see"><dt>See Also<dd><a class="el" href="classk_utils_boss.html">kUtilsBoss</a><dd><a class="el" href="classk_master_pages_boss.html">kMasterPagesBoss</a></dl></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a8aa95ff7a41379d2f5f18aa7a7d5bb12"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMasterSpreadUtils::_IsFrontViewAMaster </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>kFalse - obsolete, do not use </dl></div></div><a class="anchor" id="afd4a7c9c3bd710b590a029e0810c321c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMasterSpreadUtils::AppendMasterPageItems </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>theSpread</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>onThesePages</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_k2_vector.html">PMRectCollection</a> &amp;&nbsp;</td><td class="paramname"><em>pageBounds</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>masterItems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>pages</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">PMMatrixCollection</a> &amp;&nbsp;</td><td class="paramname"><em>offsets</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_callback.html">ICallback</a> *&nbsp;</td><td class="paramname"><em>masterItemCollector</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>drwMgrFlags</em> = <code><a class="el" href="class_i_shape.html#a6a11299dcbeb8aba75b41a24121663f9a08da4ef529fe5e282843e02b477b8df8">IShape::kSkipChildren</a>+<a class="el" href="class_i_shape.html#a6a11299dcbeb8aba75b41a24121663f9ae21f3c1c407d8801e3e55f9802035817">IShape::kSkipHiddenAndLockedLayers</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates a list of master page items, pages, and offsets for the master items that are drawn on the given spread and page bounds. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">db</td><td>the database for the document to operate on </td></tr><tr><td class="paramname">theSpread</td><td>the UID of the spread to collect the items from </td></tr><tr><td class="paramname">onThesePages</td><td>the UIDs of the pages within this spread </td></tr><tr><td class="paramname">pageBounds</td><td>the bounds of the pages (in spread coordinates). May be enlarged by bleed, slug, etc. </td></tr><tr><td class="paramname">masterItems</td><td>OUT the returned list of items drawn on the spread </td></tr><tr><td class="paramname">pages</td><td>OUT the page UID for the master page item (parallel list with masterItems) </td></tr><tr><td class="paramname">offsets</td><td>OUT the offset of each master page item (parallel list with masterItems) </td></tr><tr><td class="paramname">masterItemCollector</td><td>OPTIONAL. Call back object being used for collecting master page items. </td></tr><tr><td class="paramname">drwMgrFlags</td><td>OPTIONAL. Draw flags to use for collecting master page items. </td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_layout_utils.html#a0995e0a7cc5a8d4713aedb6f7c680735">ILayoutUtils::EnlargePagesRectBySlug</a></dl></div></div><a class="anchor" id="a00fb3ffeacf04134149bbdb92959c968"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMasterSpreadUtils::BuildMasterSpreadList </td><td>(</td><td class="paramtype"><a class="el" href="class_i_string_list_control_data.html">IStringListControlData</a> *&nbsp;</td><td class="paramname"><em>stringData</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>masterUIDs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIncludeNone</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>excludeUID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>build a string list of master spread names. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">stringData</td><td>IN an empty <a class="el" href="class_i_string_list_control_data.html">IStringListControlData</a> OUT a list of master names </td></tr><tr><td class="paramname">masterUIDs</td><td>IN an empty <a class="el" href="class_u_i_d_list.html">UIDList</a> created with a valid database OUT a list of UIDs, parallel to stringData (i.e. the n&#39;th UID corresponds to the n&#39;th master name) </td></tr><tr><td class="paramname">bIncludeNone</td><td>IN kTrue means include the string &#39;None&#39; </td></tr><tr><td class="paramname">excludeUID</td><td>IN if valid, skip this UID </td></tr></table></dl></div></div><a class="anchor" id="ab8d5c9f0410d01a54481d5cbea86ca43"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IMasterSpreadUtils::CountPagesWithMaster </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>masterUIDs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>mastersWithMaster</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>pageUIDs</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>count the number of pages in the document that have one of the specified masters applied to it. optionally look at the masters also. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">masterUIDs</td><td>IN list of masters being queried about </td></tr><tr><td class="paramname">mastersWithMaster</td><td>OUT if not NIL, returns the count of master spreads with the specified masters applied </td></tr><tr><td class="paramname">pageUIDs</td><td>OUT if not NIL, returns an array of page UIDs with the specified masters applied </td></tr></table></dl></div></div><a class="anchor" id="afe4cf0049bb5fbc9b8a94e8b816867da"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* IMasterSpreadUtils::CreateOverrideMasterPageItemsCmd </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>spreadsOrPages</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_callback.html">ICallback</a> *&nbsp;</td><td class="paramname"><em>masterItemCollector</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>drwMgrFlags</em> = <code><a class="el" href="class_i_shape.html#a6a11299dcbeb8aba75b41a24121663f9a08da4ef529fe5e282843e02b477b8df8">IShape::kSkipChildren</a>+<a class="el" href="class_i_shape.html#a6a11299dcbeb8aba75b41a24121663f9ae21f3c1c407d8801e3e55f9802035817">IShape::kSkipHiddenAndLockedLayers</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates a OverrideMasterPageItemsCmd and feeds it with items based on the <a class="el" href="class_u_i_d_list.html">UIDList</a> that is being passed in. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spreadsOrPages.</td><td><a class="el" href="class_u_i_d_list.html">UIDList</a> of spreads or pages. </td></tr><tr><td class="paramname">masterItemCollector</td><td>OPTIONAL. Call back object being used for collecting master page items.. </td></tr><tr><td class="paramname">drwMgrFlags</td><td>OPTIONAL. Draw flags being used for collecting master page items.. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>an executable command (<a class="el" href="classk_override_master_page_item_cmd_boss.html">kOverrideMasterPageItemCmdBoss</a>). </dl></div></div><a class="anchor" id="ae9d802e9fb03dc914d81c0e2ac272c43"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMasterSpreadUtils::GetAncestorsOf </td><td>(</td><td class="paramtype"><a class="el" href="class_i_master_spread_list.html">IMasterSpreadList</a> *&nbsp;</td><td class="paramname"><em>masterSpreadList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>masterUID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>ancestors</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>build a list of all masters applied to a given master or its ancestors <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">masterSpreadList</td><td>IN list of masters for a given document </td></tr><tr><td class="paramname">masterUID</td><td>IN master spread whose ancestors are being requested </td></tr><tr><td class="paramname">ancestors</td><td>OUT list of all masters applied to the specified master, or to those masters </td></tr></table></dl></div></div><a class="anchor" id="acc3cdc9c74ba43a5eab45943b75476bf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_list.html">UIDList</a> IMasterSpreadUtils::GetUnusedMasterUIDs </td><td>(</td><td class="paramtype"><a class="el" href="class_i_document.html">IDocument</a> *&nbsp;</td><td class="paramname"><em>doc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>build a UID list of master spreads that are not applied to pages. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">doc</td><td>IN The database to search. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_u_i_d_list.html">UIDList</a> of unused master spread UIDs </dl></div></div><a class="anchor" id="a2c2b6a9ec5fefee61e3a4fd4ff9ad731"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMasterSpreadUtils::IsAnAncestorOf </td><td>(</td><td class="paramtype"><a class="el" href="class_i_master_spread_list.html">IMasterSpreadList</a> *&nbsp;</td><td class="paramname"><em>masterList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>masterA</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>masterB</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return kTrue if masterA is an ancestor of masterB (i.e. if one of the pages of B has masterA applied to it, or if one of master B&#39;s masters has masterA applied to it, and so on recursively) <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">masterList</td><td>IN list of masters (containing masterA and masterB </td></tr><tr><td class="paramname">masterA</td><td>IN potential ancestor master spread masterB IN master being queried about </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if masterA is an ancestor of masterB; kFalse otherwise </dl></div></div><a class="anchor" id="af1d4a61dab4c9c2a5debe139829559f6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMasterSpreadUtils::IsMasterAppliedToPage </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>masterUID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>page</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the specified master is applied to the specified page, or to one of its ancestors <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">masterUID</td><td>IN master being queried about </td></tr><tr><td class="paramname">page</td><td>IN page being queried about </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if page has masterUID applied to it (recursively) </dl></div></div><a class="anchor" id="ac076f884801c36dd3d0542fd3c3806be"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMasterSpreadUtils::IsMasterItemOverriddenOnPage </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>masterItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>startPageUIDRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>determine if the given master page item is already overridden on the given page (may be a crossover and therefore overridden on a page other than the specified one) <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">masterItem</td><td>IN master page page item being queried about </td></tr><tr><td class="paramname">startPageUIDRef</td><td>IN page being queried about </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the given master page page item is overridden on the given page </dl></div></div><a class="anchor" id="a85012457438f5a430824e0cb326c0dd9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMasterSpreadUtils::OverrideMasterPageItem </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>masterItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>pageToOverrideOn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_command.html#a9b7f77ae8c7947d4dcf20b808a2c9f37">ICommand::Undoability</a>&nbsp;</td><td class="paramname"><em>undoability</em> = <code><a class="el" href="class_i_command.html#a9b7f77ae8c7947d4dcf20b808a2c9f37a4d6414d928ccbdb418cfd97c70619d14">ICommand::kAutoUndo</a></code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a> *&nbsp;</td><td class="paramname"><em>overriddenItem</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a master item and a layout page which has that master item drawing on it, override the master item and return the item corresponding to the passed in item. This may be different than the item which was overridden - in the case of a sub-item of a group, the returned item is the item corresponding to the passed in item, not the group (which was overridden). The undoability argument is for uses where the returned item is immediately modified, so the &#39;Override master item&#39; doesn&#39;t need to show up in the Undo stack.<p>Return value is kTrue if everything is OK, kFalse if the item wasn&#39;t overridden (which can happen if the specified master item wasn&#39;t drawing on the specified page, or if the item was already overridden)<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">masterItem</td><td>IN master item to override </td></tr><tr><td class="paramname">pageToOverrideOn</td><td>IN page to override the item on </td></tr><tr><td class="paramname">undoability</td><td>IN how should the override command be undone? default : <a class="el" href="class_i_command.html#a9b7f77ae8c7947d4dcf20b808a2c9f37a4d6414d928ccbdb418cfd97c70619d14">ICommand::kAutoUndo</a></td></tr><tr><td class="paramname">overriddenItem</td><td>OUT new page item corresponding to masterItem </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if success, kFalse otherwise </dl></div></div><a class="anchor" id="a28d5a7801ff04e001700c530a4cd98dc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMasterSpreadUtils::TopoSortMasterSpread </td><td>(</td><td class="paramtype"><a class="el" href="class_i_master_spread_list.html">IMasterSpreadList</a> *&nbsp;</td><td class="paramname"><em>masterSpreadList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>sortedList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>sort the specified <a class="el" href="class_i_master_spread_list.html">IMasterSpreadList</a> such that masters with other masters applied to them are later in the list than the masters they derive from (e.g. if &#39;B-Master&#39; has &#39;C-Master&#39; applied, and &#39;A-Master&#39; and &#39;C-Master&#39; have &#39;None&#39; applied, the sorted order would be &#39;A-Master&#39;, &#39;C-Master&#39;, &#39;B-Master&#39;.). Useful for duplicating a master spread list to a new document.<p>Warning: I think the above comment is wrong. It seems that TopoSortMasterSpread sorts all the masters so that a given master in the list depends only on masters appearing later in the list. That is the root masters are sorted to the end of the list and the most dependent masters are sorted to the beginning.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">masterSpreadList</td><td>IN list of master spreads for a given document </td></tr><tr><td class="paramname">sortedList</td><td>OUT sorted list of masters, base masters first, derived masters later. </td></tr></table></dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_master_spread_utils.html">IMasterSpreadUtils</a><li class="footer">Generated on Sat Sep 22 2018 10:54:20 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
