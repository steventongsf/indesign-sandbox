<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_i_d_x_m_l_d_o_m_node</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_i_d_x_m_l_d_o_m_node.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_i_d_x_m_l_d_o_m_node-members.html">List of all members</a></div><div class="headertitle"><div class="title">IIDXMLDOMNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_i_d_x_m_l_d_o_m_node_8h_source.html">IIDXMLDOMNode.h</a>&gt;</code><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a677cc5b2cf02d80a095609aa4d68e14a"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14a">kNodeTypes</a> { <br /> &nbsp;&nbsp;<a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14aa0639a97d9935b661e0b37902dc2d4bb5">kElement</a>, <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14aa29ffc13091ac2ad71ac70b2dde73fd62">kDocument</a>, <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14aa339c89c49a744ba6290b287302b15eaf">kText</a>, <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14aa4fba2d00fa3bdbf27c64c305b925a5fa">kProcessingInstruction</a>, <br /> &nbsp;&nbsp;<a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14aa81e355c14f8293132a93b991e2f35d3f">kAttribute</a>, <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14aadc2263ef6cca4f0c6cbbd6b3e99c09aa">kComment</a>, <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14aa52478bdc85dfa5598a14ab7fae98767d">kUnknown</a><br /> }</td></tr><tr class="separator:a677cc5b2cf02d80a095609aa4d68e14a"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:ad5a3cf0bb7c920fb080f3138db9e86dd"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#ad5a3cf0bb7c920fb080f3138db9e86dd">CloneNode</a> (bool deepClone)=0</td></tr><tr class="separator:ad5a3cf0bb7c920fb080f3138db9e86dd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae173a86acade328c9109174e6d08f94a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#ae173a86acade328c9109174e6d08f94a">IsValid</a> () const =0</td></tr><tr class="separator:ae173a86acade328c9109174e6d08f94a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a19d00a69c325fa3faca2fbce375ca6fe"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14a">IIDXMLDOMNode::kNodeTypes</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a19d00a69c325fa3faca2fbce375ca6fe">GetNodeType</a> () const =0</td></tr><tr class="separator:a19d00a69c325fa3faca2fbce375ca6fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a548304ef750c74a24362d78f5a575543"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a548304ef750c74a24362d78f5a575543">GetLocalName</a> (<a class="el" href="class_wide_string.html">WideString</a> &amp;localName) const =0</td></tr><tr class="separator:a548304ef750c74a24362d78f5a575543"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a13562b0aff3cfe6e7859ad4c84f97fce"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a13562b0aff3cfe6e7859ad4c84f97fce">GetNamespaceURI</a> (<a class="el" href="class_wide_string.html">WideString</a> &amp;namespaceURI) const =0</td></tr><tr class="separator:a13562b0aff3cfe6e7859ad4c84f97fce"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa76534dfc4e8a5900622808613297572"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#aa76534dfc4e8a5900622808613297572">GetNodeName</a> (<a class="el" href="class_wide_string.html">WideString</a> &amp;name) const =0</td></tr><tr class="separator:aa76534dfc4e8a5900622808613297572"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a219f84a6dc5a7ef5bace136cf443e641"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a219f84a6dc5a7ef5bace136cf443e641">GetNodeValue</a> (<a class="el" href="class_wide_string.html">WideString</a> &amp;value) const =0</td></tr><tr class="separator:a219f84a6dc5a7ef5bace136cf443e641"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5c28aeb2ea78ee223f1285ed5dd8e347"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a5c28aeb2ea78ee223f1285ed5dd8e347">SetNodeValue</a> (const <a class="el" href="class_wide_string.html">WideString</a> &amp;val)=0</td></tr><tr class="separator:a5c28aeb2ea78ee223f1285ed5dd8e347"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6cb482f8f1f6a331a61eed99b960fe7e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a6cb482f8f1f6a331a61eed99b960fe7e">GetPrefix</a> (<a class="el" href="class_wide_string.html">WideString</a> &amp;prefix) const =0</td></tr><tr class="separator:a6cb482f8f1f6a331a61eed99b960fe7e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7aa3795eddc9bb4ba2216cba58c89eed"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a7aa3795eddc9bb4ba2216cba58c89eed">SetPrefix</a> (const <a class="el" href="class_wide_string.html">WideString</a> &amp;prefix)=0</td></tr><tr class="separator:a7aa3795eddc9bb4ba2216cba58c89eed"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab8f5e82cdb7527bed686093173f62962"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_named_node_map.html">IIDXMLDOMNamedNodeMap</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#ab8f5e82cdb7527bed686093173f62962">GetAttributes</a> () const =0</td></tr><tr class="separator:ab8f5e82cdb7527bed686093173f62962"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af7cdf6ebaf7b14c9f149cd70a027eb4f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#af7cdf6ebaf7b14c9f149cd70a027eb4f">HasChildNodes</a> () const =0</td></tr><tr class="separator:af7cdf6ebaf7b14c9f149cd70a027eb4f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a444d924dde0ae23e32fa81662b4191c2"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_n_list.html">IIDXMLDOMNList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a444d924dde0ae23e32fa81662b4191c2">GetChildNodes</a> () const =0</td></tr><tr class="separator:a444d924dde0ae23e32fa81662b4191c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac93c5012acacc74373e874433dc6600a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#ac93c5012acacc74373e874433dc6600a">GetFirstChild</a> () const =0</td></tr><tr class="separator:ac93c5012acacc74373e874433dc6600a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7cd92504d11baaa3e056815797514629"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a7cd92504d11baaa3e056815797514629">GetLastChild</a> () const =0</td></tr><tr class="separator:a7cd92504d11baaa3e056815797514629"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a14b9aa3922e90b69b0432d011735bef3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a14b9aa3922e90b69b0432d011735bef3">GetNextSibling</a> () const =0</td></tr><tr class="separator:a14b9aa3922e90b69b0432d011735bef3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abf311684999b797cfb1d1a79aa552caf"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#abf311684999b797cfb1d1a79aa552caf">GetPreviousSibling</a> () const =0</td></tr><tr class="separator:abf311684999b797cfb1d1a79aa552caf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a62c0e830e92fa05d58d9572ad7a8149a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a62c0e830e92fa05d58d9572ad7a8149a">GetParentNode</a> () const =0</td></tr><tr class="separator:a62c0e830e92fa05d58d9572ad7a8149a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad6a856435d8e2abc5b3cbe6798fbc708"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad6a856435d8e2abc5b3cbe6798fbc708"></a> virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_document.html">IIDXMLDOMDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetOwnerDocument</b> () const =0</td></tr><tr class="separator:ad6a856435d8e2abc5b3cbe6798fbc708"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad15fedd68d870347ca2b193035e69960"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#ad15fedd68d870347ca2b193035e69960">InsertBefore</a> (<a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *newNode, <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *whichNode)=0</td></tr><tr class="separator:ad15fedd68d870347ca2b193035e69960"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a920399f2a8b195a060209642bf8cd9d1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a920399f2a8b195a060209642bf8cd9d1">AppendChild</a> (<a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *newChild)=0</td></tr><tr class="separator:a920399f2a8b195a060209642bf8cd9d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acb385b0e3ef1eff7a1e40d184c43a0a4"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#acb385b0e3ef1eff7a1e40d184c43a0a4">ReplaceChild</a> (<a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *newChild, <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *oldChild)=0</td></tr><tr class="separator:acb385b0e3ef1eff7a1e40d184c43a0a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a09e006c3948a26774cba2f2c6f0fc104"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a09e006c3948a26774cba2f2c6f0fc104"></a> virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoveChild</b> (<a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *oldChild)=0</td></tr><tr class="separator:a09e006c3948a26774cba2f2c6f0fc104"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a99f19709973ffaf02a673dc9aebdc1e4"><td align="right" class="memItemLeft" valign="top">virtual BIB_NAMESPACE::CAXENodeDOM&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a99f19709973ffaf02a673dc9aebdc1e4">GetAXEObject</a> ()=0</td></tr><tr class="separator:a99f19709973ffaf02a673dc9aebdc1e4"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>DOM Node<p>Conceptually, a DOM Node is any type of object in a DOM Tree rather than just an element. This includes (elements, attributes, processing instructions, comments, text, etc)<p><b>Memory Management</b><p>Unless otherwise stated pointers returned by methods in this class are owned by the class and not the client. Exceptions to this rule will be stated clearly where they apply.<p><b>Invalid Parameters</b><p>Unless otherwise indicated, it is an error to use an invalid container (<a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#ae173a86acade328c9109174e6d08f94a">IsValid()</a> == false), or a NULL pointer, as a parameter to any function. In some instances, the requirement that a specific parameter must be valid is repeated in the commentary for the specific function. The lack of any indication in the commentary for the specific function should still be taken to mean that an invalid container or NULL pointer will result in a kAXEErrClientFault exception. </div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a677cc5b2cf02d80a095609aa4d68e14a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14a">IIDXMLDOMNode::kNodeTypes</a></td></tr></table></div><div class="memdoc"><p>Supported Node Types <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a677cc5b2cf02d80a095609aa4d68e14aa0639a97d9935b661e0b37902dc2d4bb5"></a>kElement</em>&nbsp;</td><td class="fielddoc"><p>Element type </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a677cc5b2cf02d80a095609aa4d68e14aa29ffc13091ac2ad71ac70b2dde73fd62"></a>kDocument</em>&nbsp;</td><td class="fielddoc"><p>Document type </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a677cc5b2cf02d80a095609aa4d68e14aa339c89c49a744ba6290b287302b15eaf"></a>kText</em>&nbsp;</td><td class="fielddoc"><p>Simple Characters </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a677cc5b2cf02d80a095609aa4d68e14aa4fba2d00fa3bdbf27c64c305b925a5fa"></a>kProcessingInstruction</em>&nbsp;</td><td class="fielddoc"><p>Processing Instruction </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a677cc5b2cf02d80a095609aa4d68e14aa81e355c14f8293132a93b991e2f35d3f"></a>kAttribute</em>&nbsp;</td><td class="fielddoc"><p>Attribute </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a677cc5b2cf02d80a095609aa4d68e14aadc2263ef6cca4f0c6cbbd6b3e99c09aa"></a>kComment</em>&nbsp;</td><td class="fielddoc"><p>Comment </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a677cc5b2cf02d80a095609aa4d68e14aa52478bdc85dfa5598a14ab7fae98767d"></a>kUnknown</em>&nbsp;</td><td class="fielddoc"><p>Type not supported </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a920399f2a8b195a060209642bf8cd9d1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IIDXMLDOMNode::AppendChild </td><td>(</td><td class="paramtype"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="paramname"><em>newChild</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Append child node<p>Adds the node &#39;newChild&#39; to the end of the list of children of this node.<p>If the &#39;newChild&#39; is already in the tree, it is first removed.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newChild</td><td>The node to add. It must be a node owned by the same document as this node.</td></tr></table></dl><dl class="section see"><dt>See Also<dd>#insertBefore <dd> IIDXMLDOMCDocument::ImportNode </dl></div></div><a class="anchor" id="ad5a3cf0bb7c920fb080f3138db9e86dd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a>* IIDXMLDOMNode::CloneNode </td><td>(</td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>deepClone</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clone a node and optionally clone its descendants<p>The returned node has no parent (parentNode is null), with the expectation that the client will insert it somewhere in the current document&#39;s tree. The source node is not altered or removed from the document; this method creates a new copy of the source node. For all nodes, cloning a node creates a node object owned by the owning document, with DOM IDL attribute values identical to the source node&#39;s nodeName and nodeType, plus the DOM IDL attributes related to namespaces (prefix and namespaces <a class="el" href="class_u_r_i.html">URI</a>).<p>See the W3C DOM specification for the details on how each of the node types is handled during import.<p>Note: You own the pointer to this node and must either insert it into the document or delete it yourself.<p><b>DOM Level 2</b><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">deepClone</td><td>If &#39;kTrue&#39;, recursively clone the subtree under the specified node; if kFalse, clone only the node itself, as explained above. See the W3C DOM specification for a detailed discussion of the clone and relevance of the &#39;deepClone&#39; parameter on various node types.</td></tr></table></dl><dl class="section return"><dt>Returns<dd>The cloned node that belongs to the same document as this node. </dl></div></div><a class="anchor" id="ab8f5e82cdb7527bed686093173f62962"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_named_node_map.html">IIDXMLDOMNamedNodeMap</a>* IIDXMLDOMNode::GetAttributes </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get attributes<p>Get attributes from a kElement node. For any other type of node this function returns nil.<dl class="section return"><dt>Returns<dd>The map of attributes for this element. If there are no attributes on this element, the length will be 0. If this is not an element node, return will be nil. </dl></div></div><a class="anchor" id="a99f19709973ffaf02a673dc9aebdc1e4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual BIB_NAMESPACE::CAXENodeDOM IIDXMLDOMNode::GetAXEObject </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For internal use only. </div></div><a class="anchor" id="a444d924dde0ae23e32fa81662b4191c2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_n_list.html">IIDXMLDOMNList</a>* IIDXMLDOMNode::GetChildNodes </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>List of child nodes<p>If there are no children, this is a node list containing no nodes. The content of the returned node list is &quot;live&quot; in the sense that, for instance, changes to the children of the node object that it was created from are immediately reflected in the nodes returned by the node list accessors; it is not a static snapshot of the content of the node.<p>For node types that do not have children, a list of zero length is returned. Note that a zero length node list will not keep the DOM tree alive if all other references to that tree are destroyed.<dl class="section return"><dt>Returns<dd>Node list of children, which may have a length of 0. </dl></div></div><a class="anchor" id="ac93c5012acacc74373e874433dc6600a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a>* IIDXMLDOMNode::GetFirstChild </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>First child node<p>Get the first child node. Not all node types have children.<dl class="section return"><dt>Returns<dd>The first child under this node if there is one. Otherwise nil. </dl></div></div><a class="anchor" id="a7cd92504d11baaa3e056815797514629"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a>* IIDXMLDOMNode::GetLastChild </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Last child node<p>Get the last child node. Not all node types have children.<dl class="section return"><dt>Returns<dd>The last child under this node if there is one. Otherwise nil. </dl></div></div><a class="anchor" id="a548304ef750c74a24362d78f5a575543"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IIDXMLDOMNode::GetLocalName </td><td>(</td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>localName</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Local part of qualified name<p>Get the local part of the qualified name given to this node. Not all node types can have a qualified name. If no qualification was ever specified, this function returns false. The prefix and local part of a qualified name are always stored separately, though the combined qualified name is available through GetNodeName.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">localName</td><td>An output parameter that is assigned with the local part of the qualified name if it exists, otherwise it is left unchanged.</td></tr></table></dl><dl class="section return"><dt>Returns<dd>&#39;kTrue&#39; if a local part was specified, &#39;kFalse&#39; otherwise, also &#39;kFalse&#39; if this node type cannot have a qualified name.</dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a13562b0aff3cfe6e7859ad4c84f97fce">GetNamespaceURI</a><dd><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a6cb482f8f1f6a331a61eed99b960fe7e">GetPrefix</a></dl></div></div><a class="anchor" id="a13562b0aff3cfe6e7859ad4c84f97fce"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IIDXMLDOMNode::GetNamespaceURI </td><td>(</td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>namespaceURI</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Namespace <a class="el" href="class_u_r_i.html">URI</a><p><b>WARNING:</b> This is not a computed value that is the result of a namespace lookup based on an examination of the namespace declarations in scope. It is merely the namespace <a class="el" href="class_u_r_i.html">URI</a> given at creation time.<p>For nodes of any type other than kElement and kAttribute and nodes created with a DOM Level 1 method, such as CreateElement from the <a class="el" href="class_i_i_d_x_m_l_d_o_m_document.html">IIDXMLDOMDocument</a> interface, this always returns false.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">namespaceURI</td><td>An output parameter that is assigned with the namespace <a class="el" href="class_u_r_i.html">URI</a> if it exists, otherwise it is left unchanged.</td></tr></table></dl><dl class="section return"><dt>Returns<dd>&#39;kTrue&#39; if a namespace <a class="el" href="class_u_r_i.html">URI</a> was defined, &#39;kFalse&#39; otherwise. </dl></div></div><a class="anchor" id="a14b9aa3922e90b69b0432d011735bef3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a>* IIDXMLDOMNode::GetNextSibling </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Next sibling node<p>Get the sibling that follows this one in document order. Not all node types have siblings.<dl class="section return"><dt>Returns<dd>The first child after this node if there is one. Otherwise nil. </dl></div></div><a class="anchor" id="aa76534dfc4e8a5900622808613297572"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IIDXMLDOMNode::GetNodeName </td><td>(</td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>name</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Node name<p>Get the node name. Not all node types have names. Comments will have names and the target of a PI is given by the name property<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">name</td><td>An output parameter that is assigned the node name if this function returns &#39;true&#39;, left unchanged otherwise.</td></tr></table></dl><dl class="section return"><dt>Returns<dd>&#39;true&#39; if this node type has a name, &#39;false&#39; otherwise. </dl></div></div><a class="anchor" id="a19d00a69c325fa3faca2fbce375ca6fe"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14a">IIDXMLDOMNode::kNodeTypes</a> IIDXMLDOMNode::GetNodeType </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Node type<p>Get the node type. To allow for possible additions in the future, the type is an integer value, selected from the constants enumerated as kNodeTypes.<dl class="section return"><dt>Returns<dd>Node type code.</dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a677cc5b2cf02d80a095609aa4d68e14a">kNodeTypes</a></dl></div></div><a class="anchor" id="a219f84a6dc5a7ef5bace136cf443e641"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IIDXMLDOMNode::GetNodeValue </td><td>(</td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Node value<p>Get the node value. Not all node types have values. Comments will have their data stored in the value.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">val</td><td>An output parameter that is assigned the node value if this function returns &#39;true&#39;, left unchanged otherwise.</td></tr></table></dl><dl class="section return"><dt>Returns<dd>&#39;true&#39; if this node type has a value, &#39;false&#39; otherwise. </dl></div></div><a class="anchor" id="a62c0e830e92fa05d58d9572ad7a8149a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a>* IIDXMLDOMNode::GetParentNode </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Parent node<p>All nodes, except kDocument and kAttribute may have a parent. However, if a node has just been created and not yet added to the tree, or if it has been removed from the tree, nil is returned.<dl class="section return"><dt>Returns<dd>The parent node if there is one. Otherwise nil. </dl></div></div><a class="anchor" id="a6cb482f8f1f6a331a61eed99b960fe7e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IIDXMLDOMNode::GetPrefix </td><td>(</td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>prefix</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Prefix of qualified name<p>Get the prefix of the qualified name given to this node. Not all node types can have a qualified name. If no qualification was ever specified, this function returns false. The prefix and local part of a qualified name are always stored separately, though the combined qualified name is available through GetNodeName.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">prefix</td><td>An output parameter that is assigned with the prefix of the qualified name if it exists, otherwise it is left unchanged.</td></tr></table></dl><dl class="section return"><dt>Returns<dd>&#39;kTrue&#39; if a prefix was specified, &#39;kFalse&#39; otherwise, also &#39;kFalse&#39; if this node type cannot have a qualified name.</dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a548304ef750c74a24362d78f5a575543">GetLocalName</a><dd><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a13562b0aff3cfe6e7859ad4c84f97fce">GetNamespaceURI</a></dl></div></div><a class="anchor" id="abf311684999b797cfb1d1a79aa552caf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a>* IIDXMLDOMNode::GetPreviousSibling </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Previous sibling node<p>Get the sibling that preceeds this one in document order. Not all node types have siblings.<dl class="section return"><dt>Returns<dd>The first child before this node if there is one. Otherwise nil. </dl></div></div><a class="anchor" id="af7cdf6ebaf7b14c9f149cd70a027eb4f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IIDXMLDOMNode::HasChildNodes </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Node has children?<p>This is a convenience method to allow easy determination of whether a node has any children.<dl class="section return"><dt>Returns<dd>true if the node has any children, false if the node has no children.</dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a444d924dde0ae23e32fa81662b4191c2">GetChildNodes</a></dl></div></div><a class="anchor" id="ad15fedd68d870347ca2b193035e69960"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IIDXMLDOMNode::InsertBefore </td><td>(</td><td class="paramtype"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="paramname"><em>newNode</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="paramname"><em>whichNode</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Insert node before<p>Inserts the node &#39;newChild&#39; before the existing child node &#39;refChild&#39;, or at the end of the list of children if refChild is nil.<p>If newChild is already in the tree, it is first removed.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newChild</td><td>The node to insert. It must be a node owned by the same document as this node.</td></tr><tr><td class="paramname">refChild</td><td>The reference node, i.e., the node before which the new node must be inserted. May be invalid. If not invalid, must be a current child of this node. </td></tr></table></dl></div></div><a class="anchor" id="ae173a86acade328c9109174e6d08f94a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IIDXMLDOMNode::IsValid </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is Valid Is this node in a valid state<dl class="section return"><dt>Returns<dd>kTrue - Valid, kFalse - Invalid </dl></div></div><a class="anchor" id="acb385b0e3ef1eff7a1e40d184c43a0a4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IIDXMLDOMNode::ReplaceChild </td><td>(</td><td class="paramtype"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="paramname"><em>newChild</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a> *&nbsp;</td><td class="paramname"><em>oldChild</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Replace child node<p>Replaces the child node &#39;oldChild&#39; with &#39;newChild&#39; in the list of children.<p>If the newChild is already in the tree, it is first removed.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newChild</td><td>The new node to put in the child list. It must be a node owned by the same document as this node.</td></tr><tr><td class="paramname">oldChild</td><td>The node being replaced in the list. Must be a current child of this node. </td></tr></table></dl></div></div><a class="anchor" id="a5c28aeb2ea78ee223f1285ed5dd8e347"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IIDXMLDOMNode::SetNodeValue </td><td>(</td><td class="paramtype">const <a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>val</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set node value<p>Any node which can have a nodeValue (<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html#a219f84a6dc5a7ef5bace136cf443e641">GetNodeValue</a>) will also accept requests to set it to a string. The exact response to this varies from node to node.</dl><p>For most types of node, value is null and attempting to set it will result in an error. This will also be the result if the node is read-only.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">val</td><td>The value to set the node to. </td></tr></table></dl></div></div><a class="anchor" id="a7aa3795eddc9bb4ba2216cba58c89eed"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IIDXMLDOMNode::SetPrefix </td><td>(</td><td class="paramtype">const <a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>prefix</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set prefix of qualified name<p>Note that setting this attribute, when permitted, changes the nodeName attribute, which holds the qualified name, as well as the tagName and name attributes of the an element or attribute interface, when applicable.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">prefix</td><td>The prefix to set. </td></tr></table></dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_i_d_x_m_l_d_o_m_node.html">IIDXMLDOMNode</a><li class="footer">Generated on Sat Sep 22 2018 10:54:17 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
