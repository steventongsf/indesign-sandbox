<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_table_commands</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_table_commands.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="class_i_table_commands-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITableCommands Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_table_commands_8h_source.html">ITableCommands.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ITableCommands:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_table_commands.png" usemap="#ITableCommands_map" /><map id="ITableCommands_map" name="ITableCommands_map"><area alt="IPMUnknown" coords="0,0,107,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a2c532efb14dc73871b5fea49fa6cf6a0"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITABLECOMMANDS }</td></tr><tr class="separator:a2c532efb14dc73871b5fea49fa6cf6a0"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr><td colspan="2"><div class="groupHeader">Structure</div></td></tr><tr class="memitem:a6ca21365fc0b272a2c02e3210534d8be"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a6ca21365fc0b272a2c02e3210534d8be">InsertRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows, const Tables::ERelativePosition pos, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height, const Tables::EContinuation continuation=Tables::eStructureAllAttrs)=0</td></tr><tr class="separator:a6ca21365fc0b272a2c02e3210534d8be"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5cb7a80b807ec64899712eaf84c81ff5"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a5cb7a80b807ec64899712eaf84c81ff5">MoveRows</a> (<a class="el" href="class_i_table_model.html">ITableModel</a> *sourceTable, <a class="el" href="class_grid_area.html">GridArea</a> fromArea, int32 toRow, Tables::ERelativePosition pos, bool16 duplicateFlag)=0</td></tr><tr class="separator:a5cb7a80b807ec64899712eaf84c81ff5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aca6e2defec87c0df344f00998164fa97"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#aca6e2defec87c0df344f00998164fa97">MoveColumns</a> (<a class="el" href="class_i_table_model.html">ITableModel</a> *sourceTable, <a class="el" href="class_grid_area.html">GridArea</a> fromArea, int32 toColumn, Tables::ERelativePosition pos, bool16 duplicateFlag)=0</td></tr><tr class="separator:aca6e2defec87c0df344f00998164fa97"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a077d8d3b3796eb8aeb0d44a614582655"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a077d8d3b3796eb8aeb0d44a614582655">InsertColumns</a> (const <a class="el" href="class_col_range.html">ColRange</a> &amp;cols, const Tables::ERelativePosition pos, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width, const Tables::EContinuation continuation=Tables::eStructureAllAttrs)=0</td></tr><tr class="separator:a077d8d3b3796eb8aeb0d44a614582655"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a94f1cc9bff449c4ba32a3972236631ad"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a94f1cc9bff449c4ba32a3972236631ad">DeleteRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:a94f1cc9bff449c4ba32a3972236631ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0fafcbe0b7388d7b78da42b4f7f157a8"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a0fafcbe0b7388d7b78da42b4f7f157a8">DeleteRowsButNotAnchors</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:a0fafcbe0b7388d7b78da42b4f7f157a8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaff46be0d4d106f6282b9cb7eda067fd"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#aaff46be0d4d106f6282b9cb7eda067fd">DeleteColumns</a> (const <a class="el" href="class_col_range.html">ColRange</a> &amp;cols)=0</td></tr><tr class="separator:aaff46be0d4d106f6282b9cb7eda067fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a07762570caed418593c6b1e1bbfbb73b"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a07762570caed418593c6b1e1bbfbb73b">MergeCells</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells)=0</td></tr><tr class="separator:a07762570caed418593c6b1e1bbfbb73b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0782415b7a7044a361ee35bcd9e2ca10"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a0782415b7a7044a361ee35bcd9e2ca10">UnmergeCell</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor)=0</td></tr><tr class="separator:a0782415b7a7044a361ee35bcd9e2ca10"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a31b7cc1924a53f0835316c387a8a1be3"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a31b7cc1924a53f0835316c387a8a1be3">SplitCells</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, const ITableModel::ESplitDirection splitDirection)=0</td></tr><tr class="separator:a31b7cc1924a53f0835316c387a8a1be3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6b2cc491a7b1a470604db02c467ebef5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6b2cc491a7b1a470604db02c467ebef5"></a> virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><b>ChangeTableDirection</b> (Tables::EDirection directionRTL)=0</td></tr><tr class="separator:a6b2cc491a7b1a470604db02c467ebef5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Attributes</div></td></tr><tr class="memitem:a43d34ac305fc3a3bcc0fe58003b97bd2"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a43d34ac305fc3a3bcc0fe58003b97bd2">ResizeRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;newHeight)=0</td></tr><tr class="separator:a43d34ac305fc3a3bcc0fe58003b97bd2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abcb8166073b90923a5238007bee8ae4f"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#abcb8166073b90923a5238007bee8ae4f">ResizeCols</a> (const <a class="el" href="class_col_range.html">ColRange</a> &amp;cols, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;newWidth)=0</td></tr><tr class="separator:abcb8166073b90923a5238007bee8ae4f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab3bb8fe1e6e9d671b38c6c0f454d668b"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#ab3bb8fe1e6e9d671b38c6c0f454d668b">ApplyRowOverrides</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:ab3bb8fe1e6e9d671b38c6c0f454d668b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8d64d27d578e3d815876526bdf5db8b2"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a8d64d27d578e3d815876526bdf5db8b2">ApplyColOverrides</a> (const <a class="el" href="class_col_range.html">ColRange</a> &amp;cols, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:a8d64d27d578e3d815876526bdf5db8b2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa97b8da3ba29fcfc2f860a1e8369c2a0"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#aa97b8da3ba29fcfc2f860a1e8369c2a0">ApplyCellStrokes</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data)=0</td></tr><tr class="separator:aa97b8da3ba29fcfc2f860a1e8369c2a0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8e8378fa00e39f26b82b614c6b9def8d"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a8e8378fa00e39f26b82b614c6b9def8d">ClearCellStrokes</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data)=0</td></tr><tr class="separator:a8e8378fa00e39f26b82b614c6b9def8d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac808787ff774f7ef7021d675a2f6ee68"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#ac808787ff774f7ef7021d675a2f6ee68">ClearCellStrokesUISafe</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data)=0</td></tr><tr class="separator:ac808787ff774f7ef7021d675a2f6ee68"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1c25d8bd6921925eba55236868c3da81"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a1c25d8bd6921925eba55236868c3da81">SwapCellStrokeFill</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells)=0</td></tr><tr class="separator:a1c25d8bd6921925eba55236868c3da81"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae01fc9f3e3131b28f3f0a25d36a771a2"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#ae01fc9f3e3131b28f3f0a25d36a771a2">ApplyCellOverrides</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:ae01fc9f3e3131b28f3f0a25d36a771a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a16285dd3a55620b587913a6975ae157b"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a16285dd3a55620b587913a6975ae157b">ClearCellOverrides</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:a16285dd3a55620b587913a6975ae157b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac66f2d7ccad9212c593e9a4f06e1682a"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#ac66f2d7ccad9212c593e9a4f06e1682a">ApplyTableOverrides</a> (const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:ac66f2d7ccad9212c593e9a4f06e1682a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a006405063d41401b66c313ecea5c65c9"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a006405063d41401b66c313ecea5c65c9">SetTableStyle</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;styleRef)=0</td></tr><tr class="separator:a006405063d41401b66c313ecea5c65c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a62093421dacb70aac69c18841e89fc59"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a62093421dacb70aac69c18841e89fc59">ClearBorderOverrides</a> (Tables::ECellEdge edge, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:a62093421dacb70aac69c18841e89fc59"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a48736e47dc8f3a9a5c07d2f3628cada7"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a48736e47dc8f3a9a5c07d2f3628cada7">ClearCellOverridesUISafe</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:a48736e47dc8f3a9a5c07d2f3628cada7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Queries</div></td></tr><tr class="memitem:ac9835d80e05b1371234f19cabc5f4f4e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#ac9835d80e05b1371234f19cabc5f4f4e">QueryApplyCellStrokesCmd</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data)=0</td></tr><tr class="separator:ac9835d80e05b1371234f19cabc5f4f4e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd82bd2b8e31503f4c84619a2acf7f98"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#afd82bd2b8e31503f4c84619a2acf7f98">QueryClearCellStrokesCmd</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data)=0</td></tr><tr class="separator:afd82bd2b8e31503f4c84619a2acf7f98"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2b5fc962bad902274dfc765b75bccac2"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a2b5fc962bad902274dfc765b75bccac2">QueryClearCellStrokesUISafeCmd</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data)=0</td></tr><tr class="separator:a2b5fc962bad902274dfc765b75bccac2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a022d888813c8e817dc9303721d1820dd"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a022d888813c8e817dc9303721d1820dd">QueryApplyCellOverridesCmd</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:a022d888813c8e817dc9303721d1820dd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Content</div></td></tr><tr class="memitem:a2510547db4b24c5bb35f12767132e58e"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a2510547db4b24c5bb35f12767132e58e">SetCellText</a> (const <a class="el" href="class_wide_string.html">WideString</a> &amp;cellText, const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor)=0</td></tr><tr class="separator:a2510547db4b24c5bb35f12767132e58e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5f661e9f2733e239611fccb4e1441d78"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a5f661e9f2733e239611fccb4e1441d78">ClearContent</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells)=0</td></tr><tr class="separator:a5f661e9f2733e239611fccb4e1441d78"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Internal use</div></td></tr><tr class="memitem:a4c747e7101ec16a0836c452651e32c0b"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a4c747e7101ec16a0836c452651e32c0b">RegisterStrand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;strandRef)=0</td></tr><tr class="separator:a4c747e7101ec16a0836c452651e32c0b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3f4bd7b32d02b1bc6c280cc326b7e7b8"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a3f4bd7b32d02b1bc6c280cc326b7e7b8">RegisterContentMgr</a> (<a class="el" href="class_i_d_type.html">CellType</a> contentMgrType, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;contenMgr)=0</td></tr><tr class="separator:a3f4bd7b32d02b1bc6c280cc326b7e7b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Create Segments</div></td></tr><tr class="memitem:a98c6ed0e566b3a9cc20c366789ca4eca"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a98c6ed0e566b3a9cc20c366789ca4eca">CreateRowSegment</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;distanceFromEdge, const <a class="el" href="class_col_range.html">ColRange</a> &amp;segmentRange)=0</td></tr><tr class="separator:a98c6ed0e566b3a9cc20c366789ca4eca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa2c826b84f637c6589a183e2e8793b52"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#aa2c826b84f637c6589a183e2e8793b52">CreateColSegment</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;distanceFromEdge, const <a class="el" href="class_row_range.html">RowRange</a> &amp;segmentRange)=0</td></tr><tr class="separator:aa2c826b84f637c6589a183e2e8793b52"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Convert to header and footer</div></td></tr><tr class="memitem:a22fad353f8c9a5a14d1a02af0eb6ab16"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a22fad353f8c9a5a14d1a02af0eb6ab16">ConvertToHeaderRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:a22fad353f8c9a5a14d1a02af0eb6ab16"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a431ccf44444979f6c77909fabf71b6ba"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a431ccf44444979f6c77909fabf71b6ba">ConvertToFooterRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:a431ccf44444979f6c77909fabf71b6ba"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab004ff103b16208833c9e504e97db89e"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#ab004ff103b16208833c9e504e97db89e">ConvertToBodyRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:ab004ff103b16208833c9e504e97db89e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Convert table to text</div></td></tr><tr class="memitem:a45d3481956234905a18117f4cda201d8"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a45d3481956234905a18117f4cda201d8">ConvertTableToText</a> (const <a class="el" href="class_p_m_string.html">PMString</a> colSeparator=&quot;\t&quot;, const <a class="el" href="class_p_m_string.html">PMString</a> rowSeparator=&quot;\r&quot;)=0</td></tr><tr class="separator:a45d3481956234905a18117f4cda201d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6b935e0d2c2adade608fe84dd605f0d2"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a6b935e0d2c2adade608fe84dd605f0d2">QueryDeleteTableCmd</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;tableRef)=0</td></tr><tr class="separator:a6b935e0d2c2adade608fe84dd605f0d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa1f3b419c282d11c56e746a48b261804"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#aa1f3b419c282d11c56e746a48b261804">ConvertCellsType</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, <a class="el" href="class_i_d_type.html">CellType</a> destType, bool16 tryToPreserveData=kFalse)=0</td></tr><tr class="separator:aa1f3b419c282d11c56e746a48b261804"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3983b1fcf53269778f8f8f661d3a4320"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_commands.html#a3983b1fcf53269778f8f8f661d3a4320">PastePageItem</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor, <a class="el" href="class_u_i_d_ref.html">UIDRef</a> pageItemUID, bool16 preventCopy=kFalse)=0</td></tr><tr class="separator:a3983b1fcf53269778f8f8f661d3a4320"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Provides command based interface to the table model. Changes made to the table model should be made through this interface rather than through <a class="el" href="class_i_table_attr_modifier.html">ITableAttrModifier</a> or <a class="el" href="class_i_table_model.html">ITableModel</a> to support undo capability. </div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="ae01fc9f3e3131b28f3f0a25d36a771a2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ApplyCellOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to apply overrides to cells within given area. These attributes are represented by boss classes that are distinctively identified by aggregating an <a class="el" href="class_i_table_attr_report.html">ITableAttrReport</a> interface and have a ClassID such as kCellAttr&lt;whatever&gt;Boss.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>the cells within the given <a class="el" href="class_grid_area.html">GridArea</a> to operate upon </td></tr><tr><td class="paramname">attrs</td><td>list of boss objects specifying by their ClassID the attribute to override and new values </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="aa97b8da3ba29fcfc2f860a1e8369c2a0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ApplyCellStrokes </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Method to apply stroke-overrides to cells within given area.

These attributes are represented by boss classes that are distinctively identified by 

aggregating an ITableAttrReport interface and have a ClassID such as kRowAttr&amp;lt;whatever&amp;gt;Boss.



Encapsulates execution of command of class kModifyCellStrokesCmdBoss. This in turn delegates

to the table model&#39;s attribute modifier (ITableAttrModifier) to clear the strokes specified.



For instance, to apply a stroke-weight to the top of all cells in given area, an ICellStrokeData::Data struct

would be initialised as follows:

</pre> <pre>

<a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> data;

data.attrs.Set(ICellStrokeAttrData::eWeight);

data.attrs.Add(ICellStrokeAttrData::eTint);

data.sides  = Tables::eTopSide;

data.weight = newWeight; &amp;#47;&amp;#47; a <a class="el" href="class_p_m_real.html">PMReal</a> specifying new weight in points

data.tintPercent  = newTintPercent; &amp;#47;&amp;#47; a <a class="el" href="class_p_m_real.html">PMReal</a> specifying tint in percent 

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>the cells within the given <a class="el" href="class_grid_area.html">GridArea</a> to operate upon </td></tr><tr><td class="paramname">data</td><td>this is used to specify the sides and/or other attribute(s) for which the stroke-properties should be set. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl><dl class="section pre"><dt>Precondition<dd>the area should be valid within the table model, i.e. have at least one cell within it </dl></div></div><a class="anchor" id="a8d64d27d578e3d815876526bdf5db8b2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ApplyColOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_col_range.html">ColRange</a> &amp;&nbsp;</td><td class="paramname"><em>cols</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to apply attribute-overrides to the given column range.<p>This encapsulates the execution of a command of class kApplyColOverridesCmdBoss. This command in turn delegates to the table model&#39;s attribute modifier (<a class="el" href="class_i_table_attr_modifier.html">ITableAttrModifier</a>) to change the specified overrides.<dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="ab3bb8fe1e6e9d671b38c6c0f454d668b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ApplyRowOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to apply attribute-overrides to the given row range.<p>This encapsulates the execution of a command of class kApplyRowOverridesCmdBoss. This command in turn delegates to the table model&#39;s attribute modifier (<a class="el" href="class_i_table_attr_modifier.html">ITableAttrModifier</a>) to change the specified overrides.<dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="ac66f2d7ccad9212c593e9a4f06e1682a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ApplyTableOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Applies table-level overrides to model. These attributes are represented by boss classes that are distinctively identified by aggregating an <a class="el" href="class_i_table_attr_report.html">ITableAttrReport</a> interface and have a ClassID such as kTableAttr&lt;whatever&gt;Boss.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>the cells within the given <a class="el" href="class_grid_area.html">GridArea</a> to operate upon </td></tr><tr><td class="paramname">attrs</td><td>list of boss objects specifying by their ClassID the attribute to override and new values </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a62093421dacb70aac69c18841e89fc59"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ClearBorderOverrides </td><td>(</td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Removes cell-border overrides<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">edge</td><td>the side which border we are dealing with </td></tr><tr><td class="paramname">attrs</td><td>list of boss objects specifying by their ClassID the override to remove</td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a16285dd3a55620b587913a6975ae157b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ClearCellOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Removes cell-attribute overrides within specified area. These attributes are represented by boss classes that are distinctively identified by aggregating an <a class="el" href="class_i_table_attr_report.html">ITableAttrReport</a> interface and have a ClassID such as kCellAttr&lt;whatever&gt;Boss.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>the cells within the given <a class="el" href="class_grid_area.html">GridArea</a> to operate upon </td></tr><tr><td class="paramname">attrs</td><td>list of boss objects specifying by their ClassID the override to remove</td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a48736e47dc8f3a9a5c07d2f3628cada7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ClearCellOverridesUISafe </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Removes cell-attribute overrides within specified area.<p>These attributes are represented by boss classes that are distinctively identified by aggregating an <a class="el" href="class_i_table_attr_report.html">ITableAttrReport</a> interface and have a ClassID such as kCellAttr&lt;whatever&gt;Boss.<p>The difference between this command and the one above is that this one checks the <a class="el" href="class_grid_area.html">GridArea</a> we are applying to and makes sure it still exists in the table. You can run into this problem through the preview dialogs. If the apply table dimensions command is fired before the Clear Cell Attributes command then you end up clearing attributes on a new table structure which if using the above command would crash<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>the cells within the given <a class="el" href="class_grid_area.html">GridArea</a> to operate upon </td></tr><tr><td class="paramname">attrs</td><td>list of boss objects specifying by their ClassID the override to remove</td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a8e8378fa00e39f26b82b614c6b9def8d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ClearCellStrokes </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Method to remove stroke-overrides from specified sides of cells in given area.



Encapsulates execution of command of class kModifyCellStrokesCmdBoss. This in turn delegates

to the table model&#39;s attribute modifier (ITableAttrModifier) to clear the strokes specified.



For instance, to clear all the stroke-weight attributes set on all sides of the cells in the

area, initialise a ICellStrokeAttrData::Data struct with the following:

</pre> <pre>

<a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> data;

data.sides = Tables::eAllSides; &amp;#47;&amp;#47; or other constant from ESelectionSides

data.attrs.Set(ICellStrokeAttrData::eWeight);

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>cells within this area will have the cell stroke overrides removed </td></tr><tr><td class="paramname">data</td><td>this is used to specify the sides and/or other attribute(s) for which the stroke-properties should be cleared. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl><dl class="section pre"><dt>Precondition<dd>the area should be valid within the table model, i.e. have at least one cell within it </dl></div></div><a class="anchor" id="ac808787ff774f7ef7021d675a2f6ee68"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ClearCellStrokesUISafe </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_table_commands.html#a8e8378fa00e39f26b82b614c6b9def8d">ClearCellStrokes</a> The difference between this command and the one above is that this one checks the <a class="el" href="class_grid_area.html">GridArea</a> we are applying to and makes sure it still exists in the table. You can run into this problem through the preview dialogs. If the apply table dimensions command is fired before the Clear Cell Attributes command then you end up clearing attributes on a new table structure which if using the above command would crash </dl></div></div><a class="anchor" id="a5f661e9f2733e239611fccb4e1441d78"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ClearContent </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to remove the content from cells within given region <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>delimits region within which cell contents are to be cleared </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="aa1f3b419c282d11c56e746a48b261804"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ConvertCellsType </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="paramname"><em>destType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>tryToPreserveData</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to convert the type of cells<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td><a class="el" href="class_grid_area.html">GridArea</a> of cells to be converted </td></tr><tr><td class="paramname">destType</td><td>cell type to be converted into </td></tr><tr><td class="paramname">tryToPreserveData</td><td>if true, the data is preserved into the cell after conversion, if possible. </td></tr></table></dl></div></div><a class="anchor" id="a45d3481956234905a18117f4cda201d8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ConvertTableToText </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>colSeparator</em> = <code>&quot;\t&quot;</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>rowSeparator</em> = <code>&quot;\r&quot;</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">colSeparator</td><td>delimiter for parsing columns </td></tr><tr><td class="paramname">rowSeparator</td><td>delimiter for parsing rows </td></tr></table></dl></div></div><a class="anchor" id="ab004ff103b16208833c9e504e97db89e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ConvertToBodyRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>Rows to convert to body. See <a class="el" href="class_i_table_model.html#a1f968eca62c74a47fbf4c2e928069c80">ITableModel::ConvertToBodyRows</a> for more info. </td></tr></table></dl></div></div><a class="anchor" id="a431ccf44444979f6c77909fabf71b6ba"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ConvertToFooterRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>Rows to convert to footer. See <a class="el" href="class_i_table_model.html#af84af88977857892f2e77f3476ea95fd">ITableModel::ConvertToFooterRows</a> for more info. </td></tr></table></dl></div></div><a class="anchor" id="a22fad353f8c9a5a14d1a02af0eb6ab16"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ConvertToHeaderRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>Rows to convert to headers. See <a class="el" href="class_i_table_model.html#a7e3747d63e9e20ffef2dad5ce39a0f4f">ITableModel::ConvertToHeaderRows</a> for more info. </td></tr></table></dl></div></div><a class="anchor" id="aa2c826b84f637c6589a183e2e8793b52"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::CreateColSegment </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>distanceFromEdge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>segmentRange</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to create a row segment at the distance from the left <a class="el" href="class_p_m_real.html">PMReal</a> specified and spanning the cells in the range <a class="el" href="class_grid_area.html">GridArea</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">distanceFromEdge</td><td></td></tr><tr><td class="paramname">segment</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a98c6ed0e566b3a9cc20c366789ca4eca"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::CreateRowSegment </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>distanceFromEdge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_col_range.html">ColRange</a> &amp;&nbsp;</td><td class="paramname"><em>segmentRange</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to create a row segment at the distance from the top <a class="el" href="class_p_m_real.html">PMReal</a> specified and spanning the cells in the range <a class="el" href="class_grid_area.html">GridArea</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">distanceFromEdge</td><td></td></tr><tr><td class="paramname">segment</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="aaff46be0d4d106f6282b9cb7eda067fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::DeleteColumns </td><td>(</td><td class="paramtype">const <a class="el" href="class_col_range.html">ColRange</a> &amp;&nbsp;</td><td class="paramname"><em>cols</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to remove a specified range of columns from the table.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cols</td><td>specifies the range of columns to remove from the table </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl><dl class="section pre"><dt>Precondition<dd>the start of the range should be within the range of columns in the table <dd> the count of columns to be deleted should be greater than 0 <dd> table.GetTotalCols().Contains(cols) (GetTotalCols) </dl></div></div><a class="anchor" id="a94f1cc9bff449c4ba32a3972236631ad"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::DeleteRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to remove a specified row range from the table model. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies a range of rows to be removed from the table model </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl><dl class="section pre"><dt>Precondition<dd>the start of the range should be within the range of rows in the table <dd> the count of rows to be deleted should be greater than 0 <dd> table.GetTotalRows().Contains(rows) (GetTotalRows) </dl></div></div><a class="anchor" id="a0fafcbe0b7388d7b78da42b4f7f157a8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::DeleteRowsButNotAnchors </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method that can remove all rows from table model, leaving behind the anchor characters.<p>This method is meant to be called when deleting a table via a text deletion. In this case it is undesirable for the table to delete the anchor characters.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies a range of rows to be removed from the table model which should cover the whole table </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl><dl class="section pre"><dt>Precondition<dd>the start of the range should be within the range of rows in the table <dd> table.GetTotalRows() == rows (GetTotalRows) </dl></div></div><a class="anchor" id="a077d8d3b3796eb8aeb0d44a614582655"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::InsertColumns </td><td>(</td><td class="paramtype">const <a class="el" href="class_col_range.html">ColRange</a> &amp;&nbsp;</td><td class="paramname"><em>cols</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>width</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::EContinuation&nbsp;</td><td class="paramname"><em>continuation</em> = <code>Tables::eStructureAllAttrs</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to insert new, unfilled columns in a table.<p>Width for the newly-created columns should be specified in points.<p>If colWidth is 0.0 then the new width is determined from the column relative to which the insertion is being made. A non zero value of width will result in all inserted columns having that width.<p>See the comments on InsertRows for detail on how attributes are propagated from the reference column to the newly created columns, mutatis mutandis.<p>Encapsulates the execution of command that is instance of class <a class="el" href="classk_insert_columns_cmd_boss.html">kInsertColumnsCmdBoss</a>; this acts on the table model to insert columns.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cols</td><td>the start of the <a class="el" href="class_col_range.html">ColRange</a> specifies the insertion location, and the count of the <a class="el" href="class_col_range.html">ColRange</a> columns gives the number of columns to add </td></tr><tr><td class="paramname">pos</td><td>eBefore or eAfter to specify whether to insert before or after the current insertion point </td></tr><tr><td class="paramname">width</td><td></td></tr><tr><td class="paramname">continuation</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command could be executed successully, kFailure otherwise </dl></div></div><a class="anchor" id="a6ca21365fc0b272a2c02e3210534d8be"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::InsertRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>height</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::EContinuation&nbsp;</td><td class="paramname"><em>continuation</em> = <code>Tables::eStructureAllAttrs</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to insert new, unfilled rows in a table.<p>Height should be specified in points. If the given rowHeight is 0.0 then the new row height is determined from the row relative to which the insertion is being made. A non zero value of height will result in all inserted rows having that minimum height.<p>The structure and attributes of the row that is the reference for the insertion will be propagated to the newly created rows; for instance, if the relative position is &#39;eAfter&#39; and the row above the insertion location has a minimum row height of 2 picas and the row height is specified as 0, then the newly created rows will inherit the minimum row size of 2 picas from the rows above the insertion point even if this is not the default for other cells in the table. Similarly, if the relative position is &#39;eBefore&#39;, then the attributes and structure of the row below the insertion point will be propagated to the newly created rows.<p>Encapsulates the execution of command that is instance of class <a class="el" href="classk_insert_rows_cmd_boss.html">kInsertRowsCmdBoss</a>. This command in turn acts on the table model to insert rows.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the location as the start of the range, and how many rows to add, as the count </td></tr><tr><td class="paramname">pos</td><td>eBefore or eAfter to specify whether to insert before or after the current insertion point </td></tr><tr><td class="paramname">height</td><td>height of the row specified in points; a non-zero value means inserted rows will have that minimum height, whereas a zero value will result in a calculated value based as described above </td></tr><tr><td class="paramname">continuation</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command could be executed successully, kFailure otherwise</dl><dl class="section pre"><dt>Precondition<dd>the row range specified has a start within the bounds of the table rows <dd> the count of rows to be added in the row-range given is &gt; 0 <dd> the minimimum height specified is &gt;= 0.0 </dl></div></div><a class="anchor" id="a07762570caed418593c6b1e1bbfbb73b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::MergeCells </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to merge the area specified into a single cell covering a <a class="el" href="class_grid_span.html">GridSpan</a> that is the union of all the cells within this area.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>specifies a grid area that contains the cells to merge </td></tr></table></dl></div></div><a class="anchor" id="aca6e2defec87c0df344f00998164fa97"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::MoveColumns </td><td>(</td><td class="paramtype"><a class="el" href="class_i_table_model.html">ITableModel</a> *&nbsp;</td><td class="paramname"><em>sourceTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="paramname"><em>fromArea</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>toColumn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>duplicateFlag</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to move column(s) in a table<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sourceTable</td><td>specifies the table within which columns are to be moved </td></tr><tr><td class="paramname">fromArea</td><td>specifies the grid area which is to be moved </td></tr><tr><td class="paramname">toColumn</td><td>specifies the column where the selected columns are to be moved </td></tr><tr><td class="paramname">pos</td><td>specifies the relative position with respect to toColumn </td></tr><tr><td class="paramname">duplicateFlag</td><td>specifies whether the moved columns are to be duplicated or not</td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command could be executed successully, kFailure otherwise </dl></div></div><a class="anchor" id="a5cb7a80b807ec64899712eaf84c81ff5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::MoveRows </td><td>(</td><td class="paramtype"><a class="el" href="class_i_table_model.html">ITableModel</a> *&nbsp;</td><td class="paramname"><em>sourceTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="paramname"><em>fromArea</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>toRow</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>duplicateFlag</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to move row(s) in a table<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sourceTable</td><td>specifies the table within which rows are to be moved </td></tr><tr><td class="paramname">fromArea</td><td>specifies the grid area which is to be moved </td></tr><tr><td class="paramname">toRow</td><td>specifies the row where the selected rows are to be moved </td></tr><tr><td class="paramname">pos</td><td>specifies the position of moved rows with respect to destination row, i.e. toRow </td></tr><tr><td class="paramname">duplicateFlag</td><td>specifies whether the moved rows are to be duplicated or not</td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command could be executed successully, kFailure otherwise </dl></div></div><a class="anchor" id="a3983b1fcf53269778f8f8f661d3a4320"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::PastePageItem </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>pageItemUID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>preventCopy</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to paste a page item into the graphic cell.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td><a class="el" href="class_grid_address.html">GridAddress</a> of destination cell </td></tr><tr><td class="paramname">pageItemUID</td><td><a class="el" href="class_u_i_d_ref.html">UIDRef</a> of object to be pasted into the cell </td></tr><tr><td class="paramname">preventCopy</td><td>The object would not be copied, just removed from the source and pasted here. This is not cut-paste. It should be used, only if object is already in the scrap database. </td></tr></table></dl></div></div><a class="anchor" id="a022d888813c8e817dc9303721d1820dd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITableCommands::QueryApplyCellOverridesCmd </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to acquire command that can be processed to apply overrides to cell attributes within given area <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>delimits cells that are target of this operation </td></tr><tr><td class="paramname">attrs</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>interface ptr that has had reference-count incremented </dl></div></div><a class="anchor" id="ac9835d80e05b1371234f19cabc5f4f4e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITableCommands::QueryApplyCellStrokesCmd </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to acquire command that can be processed to apply changes to stroke-properties within given area <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>delimits cells that are target of this operation </td></tr><tr><td class="paramname">data</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>interface ptr that has had reference-count incremented </dl></div></div><a class="anchor" id="afd82bd2b8e31503f4c84619a2acf7f98"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITableCommands::QueryClearCellStrokesCmd </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to acquire command that can be processed to clear stroke-properties within given area <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>delimits cells that are target of this operation </td></tr><tr><td class="paramname">data</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>interface ptr that has had reference-count incremented </dl></div></div><a class="anchor" id="a2b5fc962bad902274dfc765b75bccac2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITableCommands::QueryClearCellStrokesUISafeCmd </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to acquire command that can be processed to clear stroke-properties within given area<p>The difference between this command and the one above is that this one checks the <a class="el" href="class_grid_area.html">GridArea</a> we are applying to and makes sure it still exists in the table. You can run into this problem through the preview dialogs. If the apply table dimensions command is fired before the Clear Cell Attributes command then you end up clearing attributes on a new table structure which if using the above command would crash<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>delimits cells that are target of this operation </td></tr><tr><td class="paramname">data</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>interface ptr that has had reference-count incremented </dl></div></div><a class="anchor" id="a6b935e0d2c2adade608fe84dd605f0d2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITableCommands::QueryDeleteTableCmd </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>tableRef</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to acquire command that can be processed to delete an entire table <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">table</td><td>model ref </td></tr></table></dl><dl class="section return"><dt>Returns<dd>interface ptr that has had reference-count incremented </dl></div></div><a class="anchor" id="a3f4bd7b32d02b1bc6c280cc326b7e7b8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::RegisterContentMgr </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="paramname"><em>contentMgrType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>contenMgr</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only. See the documentation on <a class="el" href="class_i_cell_content_mgr.html">ICellContentMgr</a> for more information. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">contentMgrType</td><td></td></tr><tr><td class="paramname">contenMgr</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a4c747e7101ec16a0836c452651e32c0b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::RegisterStrand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>strandRef</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">strandRef</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="abcb8166073b90923a5238007bee8ae4f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ResizeCols </td><td>(</td><td class="paramtype">const <a class="el" href="class_col_range.html">ColRange</a> &amp;&nbsp;</td><td class="paramname"><em>cols</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>newWidth</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to apply change in width to columns. This will set the column width for the target column range; this does not affect the minimum column width for the target columns.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cols</td><td>specifies the target range of columsn for this operation </td></tr><tr><td class="paramname">newWidth</td><td>specifies the </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a43d34ac305fc3a3bcc0fe58003b97bd2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::ResizeRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>newHeight</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to apply change in height to rows.<p>The result of this method is to set the row-height and the minimum row height for the target rows to newHeight. If some cells in target rows have content that extends below this in depth, then these cells can become overset.<p>This encapsulates executing the command <a class="el" href="classk_resize_rows_cmd_boss.html">kResizeRowsCmdBoss</a>. This command delegates to the table model&#39;s attribute modifier (<a class="el" href="class_i_table_attr_modifier.html">ITableAttrModifier</a>) to change the model attributes.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the range of rows to operate upon </td></tr><tr><td class="paramname">newHeight</td><td>specifies the new minimum and current row-height to set for the target range of rows </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a2510547db4b24c5bb35f12767132e58e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::SetCellText </td><td>(</td><td class="paramtype">const <a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>cellText</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to set the text contents of cell with given anchor (top-left) location. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cellText</td><td>specifies text contents for cell </td></tr><tr><td class="paramname">anchor</td><td>location of top-left of cell that is target for this operation</td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a006405063d41401b66c313ecea5c65c9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::SetTableStyle </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>styleRef</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to associate new table style with table model. Note that InDesign 2.0 does not support named table styles, so this is a method for future use.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">styleRef</td><td>reference to the new table-style to associate with this table model</td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a31b7cc1924a53f0835316c387a8a1be3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::SplitCells </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const ITableModel::ESplitDirection&nbsp;</td><td class="paramname"><em>splitDirection</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is obsolete. Please use SplitCells. Method to split a cell at specified location in given direction. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td></td></tr><tr><td class="paramname">splitDirection</td><td>one of eVerticalSplit, eHorizontalSplit </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwiseMethod to split cells with anchors in the specified area in given direction. </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>area of cells to split, does not need to contain complete cells </td></tr><tr><td class="paramname">splitDirection</td><td>one of eVerticalSplit, eHorizontalSplit </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl></div></div><a class="anchor" id="a1c25d8bd6921925eba55236868c3da81"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::SwapCellStrokeFill </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to swap over stroke-fill of the cells in given area. That is, the fill colour, tint and overprint will be swapped one-to-one with the stroke colour, tint and overprint.<p>This encapsulates execution of a command of class <a class="el" href="classk_swap_cell_stroke_fill_cmd_boss.html">kSwapCellStrokeFillCmdBoss</a>.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>the cells within the given <a class="el" href="class_grid_area.html">GridArea</a> to operate upon </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl><dl class="section pre"><dt>Precondition<dd>the area should be valid within the table model, i.e. have at least one cell within it </dl></div></div><a class="anchor" id="a0782415b7a7044a361ee35bcd9e2ca10"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITableCommands::UnmergeCell </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to unmerge the cells at the specified location, breaking apart the cell into grid elements. These elements will have the trivial or unit GridSpan(1,1).<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>specifies the location of the cell that is to be unmerged </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kSuccess if the command executed successfully, kFailure otherwise </dl><dl class="section pre"><dt>Precondition<dd>the grid address should be valid within the table <dd> the address should refer to an anchor (top-left) of a cell </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_table_commands.html">ITableCommands</a><li class="footer">Generated on Sat Sep 22 2018 10:54:29 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
