<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_hid_txt_parcel_list_data</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_hid_txt_parcel_list_data.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-methods">Public Member Functions</a> | <a href="class_hid_txt_parcel_list_data-members.html">List of all members</a></div><div class="headertitle"><div class="title">HidTxtParcelListData Class Reference<div class="ingroups"><a class="el" href="group__hiddentext.html">HiddenText</a></div></div></div></div><div class="contents"><div class="dynheader"> Inheritance diagram for HidTxtParcelListData:</div><div class="dyncontent"><div class="center"><img alt="" src="class_hid_txt_parcel_list_data.png" usemap="#HidTxtParcelListData_map" /><map id="HidTxtParcelListData_map" name="HidTxtParcelListData_map"><area alt="CPMUnknown&lt; ITextParcelListData &gt;" coords="0,112,223,136" href="class_c_p_m_unknown.html" shape="rect" /><area alt="ITextParcelListData" coords="0,56,223,80" href="class_i_text_parcel_list_data.html" shape="rect" /><area alt="IPMUnknown" coords="0,0,223,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a0ec66a7e190dc9bd31d3e72fb634a5be"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a0ec66a7e190dc9bd31d3e72fb634a5be">HidTxtParcelListData</a> (<a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *boss)</td></tr><tr class="separator:a0ec66a7e190dc9bd31d3e72fb634a5be"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adf5dbfc7313a7650a291492cd91e9cd4"><td align="right" class="memItemLeft" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#adf5dbfc7313a7650a291492cd91e9cd4">~HidTxtParcelListData</a> ()</td></tr><tr class="separator:adf5dbfc7313a7650a291492cd91e9cd4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0ded43f2fa0f36819e659d75887ca98d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0ded43f2fa0f36819e659d75887ca98d"></a> virtual <a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetDataBase</b> () const </td></tr><tr class="separator:a0ded43f2fa0f36819e659d75887ca98d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9e53cbd1453b84660c3dcf218ffc4409"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9e53cbd1453b84660c3dcf218ffc4409"></a> virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTextModelUID</b> () const </td></tr><tr class="separator:a9e53cbd1453b84660c3dcf218ffc4409"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9f3a1f79f538989c8020f17550292ffb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9f3a1f79f538989c8020f17550292ffb"></a> virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetFrameListUID</b> () const </td></tr><tr class="separator:a9f3a1f79f538989c8020f17550292ffb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3e3f1e397e2e1c46f514ecbbcb552580"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3e3f1e397e2e1c46f514ecbbcb552580"></a> virtual <a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryStoryThread</b> () const </td></tr><tr class="separator:a3e3f1e397e2e1c46f514ecbbcb552580"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2456e596207a6ec09fcba527464d1a14"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a2456e596207a6ec09fcba527464d1a14">GetParcelIsDamaged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a2456e596207a6ec09fcba527464d1a14"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c1232d496deba64b14432d58b53f0a2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9c1232d496deba64b14432d58b53f0a2"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelDamaged</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)</td></tr><tr class="separator:a9c1232d496deba64b14432d58b53f0a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aca8a7c34d1bf807425c17cb0826224d2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aca8a7c34d1bf807425c17cb0826224d2"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClearParcelDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)</td></tr><tr class="separator:aca8a7c34d1bf807425c17cb0826224d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aac6fbce1cc380fb12b6b624c0bc01065"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#aac6fbce1cc380fb12b6b624c0bc01065">GetParcelNeedsWrapCheck</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:aac6fbce1cc380fb12b6b624c0bc01065"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b2d3184f50136c8bd4829e6170f1fc0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a1b2d3184f50136c8bd4829e6170f1fc0">SetParcelNeedsWrapCheck</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)</td></tr><tr class="separator:a1b2d3184f50136c8bd4829e6170f1fc0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a58d6631f27e464197f5e2b7ca86413c5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a58d6631f27e464197f5e2b7ca86413c5">ClearParcelNeedsWrapCheck</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)</td></tr><tr class="separator:a58d6631f27e464197f5e2b7ca86413c5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4d2095a4deabe861b046e881775afc5d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4d2095a4deabe861b046e881775afc5d"></a> virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelTextStart</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a4d2095a4deabe861b046e881775afc5d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3e32b0a8ae97e2781d084d902224caaf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3e32b0a8ae97e2781d084d902224caaf"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelTextSpan</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a3e32b0a8ae97e2781d084d902224caaf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a801fa5d597d3faa1d2092143a221a4a2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a801fa5d597d3faa1d2092143a221a4a2"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelTextSpan</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, TextIndex span)</td></tr><tr class="separator:a801fa5d597d3faa1d2092143a221a4a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5b6fbd70c826e651adf6922192608100"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5b6fbd70c826e651adf6922192608100"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelContaining</b> (TextIndex at) const </td></tr><tr class="separator:a5b6fbd70c826e651adf6922192608100"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b508430eda12a3c655c4cabeb8fc620"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1b508430eda12a3c655c4cabeb8fc620"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelVContentBounds</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_p_m_real.html">PMReal</a> *pTop, <a class="el" href="class_p_m_real.html">PMReal</a> *pBottom) const </td></tr><tr class="separator:a1b508430eda12a3c655c4cabeb8fc620"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8ae5c8637adc3b30ae1022ad289a9b06"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8ae5c8637adc3b30ae1022ad289a9b06"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelVContentBounds</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_p_m_real.html">PMReal</a> top, <a class="el" href="class_p_m_real.html">PMReal</a> bottom)</td></tr><tr class="separator:a8ae5c8637adc3b30ae1022ad289a9b06"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1254ff28615ca39047df73005b1e9f03"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a1254ff28615ca39047df73005b1e9f03">GetParcelHasPositionDependentContent</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a1254ff28615ca39047df73005b1e9f03"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1fd9cbf814c3c3efa12705facadb392a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1fd9cbf814c3c3efa12705facadb392a"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasPositionDependentContent</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 v)</td></tr><tr class="separator:a1fd9cbf814c3c3efa12705facadb392a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa7fce26fc1acdd8d3e5e9978a00b09f9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#aa7fce26fc1acdd8d3e5e9978a00b09f9">GetParcelHasKeepsOn</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:aa7fce26fc1acdd8d3e5e9978a00b09f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a441557e04d0e4b691a3733af1e8b0bb0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a441557e04d0e4b691a3733af1e8b0bb0"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasKeepsOn</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 v)</td></tr><tr class="separator:a441557e04d0e4b691a3733af1e8b0bb0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af729442be0c1f9cacf9011a760a3dc9c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af729442be0c1f9cacf9011a760a3dc9c"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelHasBeenVJed</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:af729442be0c1f9cacf9011a760a3dc9c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a18fafe440b9dea000a564856874dc3b7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a18fafe440b9dea000a564856874dc3b7"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasBeenVJed</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 vj)</td></tr><tr class="separator:a18fafe440b9dea000a564856874dc3b7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8dc15971ca8327949f7f0479baa26a65"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8dc15971ca8327949f7f0479baa26a65"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelHasGridAlignedWax</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a8dc15971ca8327949f7f0479baa26a65"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8faf8b39f9fef68360b3508f5b567cd2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8faf8b39f9fef68360b3508f5b567cd2"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasGridAlignedWax</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 v)</td></tr><tr class="separator:a8faf8b39f9fef68360b3508f5b567cd2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a38c78eaea99fa07d56c9df7921196ad5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a38c78eaea99fa07d56c9df7921196ad5"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelHasNeedsPostProcessWax</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a38c78eaea99fa07d56c9df7921196ad5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a57a6762e828401db8a205da3e628756b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a57a6762e828401db8a205da3e628756b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasNeedsPostProcessWax</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 v)</td></tr><tr class="separator:a57a6762e828401db8a205da3e628756b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1ac5ce09c043ba120be338c98da1ce3f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a1ac5ce09c043ba120be338c98da1ce3f">GetFirstLogicalParcelKey</a> (int32 *pIndex) const </td></tr><tr class="separator:a1ac5ce09c043ba120be338c98da1ce3f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a39936cd94cf7a53828b9c78bbd153ddc"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a39936cd94cf7a53828b9c78bbd153ddc">GetNextLogicalParcelKey</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, int32 *pIndex) const </td></tr><tr class="separator:a39936cd94cf7a53828b9c78bbd153ddc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9cfe96a1cd274feced08ebf1a3e6d66e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a9cfe96a1cd274feced08ebf1a3e6d66e">GetNextLogicalParcelKeyByType</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, ITextParcelListData::nextParcelType pType, int32 *pIndex) const </td></tr><tr class="separator:a9cfe96a1cd274feced08ebf1a3e6d66e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5cb51802e4814b5270080c381fad9547"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a5cb51802e4814b5270080c381fad9547">GetPreviousLogicalParcelKey</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, int32 *pIndex) const </td></tr><tr class="separator:a5cb51802e4814b5270080c381fad9547"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5c12269144d5cea8685fe0d801b8e191"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a5c12269144d5cea8685fe0d801b8e191">GetLastLogicalParcelKey</a> (int32 *pIndex) const </td></tr><tr class="separator:a5c12269144d5cea8685fe0d801b8e191"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aea659edc56055968df87a125febdbe29"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#aea659edc56055968df87a125febdbe29">GetLastLogicalNonOversetParcelKey</a> (int32 *pIndex) const </td></tr><tr class="separator:aea659edc56055968df87a125febdbe29"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af0cf9f0ffe920edd5ddfbcbdf6a28a8e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af0cf9f0ffe920edd5ddfbcbdf6a28a8e"></a> virtual Text::FirstLineOffsetMetric&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelFirstLineOffsetMetric</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:af0cf9f0ffe920edd5ddfbcbdf6a28a8e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1c03889e6344920823ce80407ba9344d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1c03889e6344920823ce80407ba9344d"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelMinFirstLineOffset</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a1c03889e6344920823ce80407ba9344d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1745b78b054ffb7c9a48ecbde5c862b8"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1745b78b054ffb7c9a48ecbde5c862b8"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsVertical</b> () const </td></tr><tr class="separator:a1745b78b054ffb7c9a48ecbde5c862b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a59a1beafa01cafd0a2b8ec1536e9b824"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a59a1beafa01cafd0a2b8ec1536e9b824"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsRightToLeft</b> () const </td></tr><tr class="separator:a59a1beafa01cafd0a2b8ec1536e9b824"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab6b096ad3874bde521eb5359ff176c28"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab6b096ad3874bde521eb5359ff176c28"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelMaxSoftBottomHeight</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:ab6b096ad3874bde521eb5359ff176c28"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a144ad26d753e0692af7c75b4b2a18431"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a144ad26d753e0692af7c75b4b2a18431"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelMaxSoftBottomHeight</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_p_m_real.html">PMReal</a> maxHeight)</td></tr><tr class="separator:a144ad26d753e0692af7c75b4b2a18431"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aacf06cc95eeb929fc0eb14025c7aa7e2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aacf06cc95eeb929fc0eb14025c7aa7e2"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelIsValidStartBreakLocation</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, Text::StartBreakLocation mode) const </td></tr><tr class="separator:aacf06cc95eeb929fc0eb14025c7aa7e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae2f73c59563b60ef1c0e576a4a0da1f1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae2f73c59563b60ef1c0e576a4a0da1f1"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetHasAnyValidStartBreakLocation</b> () const </td></tr><tr class="separator:ae2f73c59563b60ef1c0e576a4a0da1f1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3abc2865da16e7b84a0ca20d91ae8a90"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a3abc2865da16e7b84a0ca20d91ae8a90">GetParcelSupportsWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a3abc2865da16e7b84a0ca20d91ae8a90"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af70252988a7941099f3e5f685a35e1ca"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#af70252988a7941099f3e5f685a35e1ca">GetParcelIgnoringWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:af70252988a7941099f3e5f685a35e1ca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6a62852b5019f98982cfd82111e071c0"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a6a62852b5019f98982cfd82111e071c0">GetWaxAnchoredElementCount</a> () const </td></tr><tr class="separator:a6a62852b5019f98982cfd82111e071c0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5b624969e8342ddec15bba7651775a55"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a5b624969e8342ddec15bba7651775a55">GetWaxAnchoredElementIndex</a> (<a class="el" href="class_i_d_type.html">UID</a> uid) const </td></tr><tr class="separator:a5b624969e8342ddec15bba7651775a55"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a510b8ec28b9d22fb7376f817f555470d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a510b8ec28b9d22fb7376f817f555470d">InsertNthWaxAnchoredElement</a> (int32 n, <a class="el" href="class_i_d_type.html">UID</a> uid)</td></tr><tr class="separator:a510b8ec28b9d22fb7376f817f555470d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae90353444b2934f1a485188667759bba"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#ae90353444b2934f1a485188667759bba">RemoveNthWaxAnchoredElement</a> (int32 n)</td></tr><tr class="separator:ae90353444b2934f1a485188667759bba"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2af5e60c4cd54adb842be7185fe9d20f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a2af5e60c4cd54adb842be7185fe9d20f">GetNthWaxAnchoredElementUID</a> (int32 n) const </td></tr><tr class="separator:a2af5e60c4cd54adb842be7185fe9d20f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6359bd209105cfe69491a897ee342c65"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a6359bd209105cfe69491a897ee342c65">GetNthWaxAnchoredElementParcelKey</a> (int32 n) const </td></tr><tr class="separator:a6359bd209105cfe69491a897ee342c65"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8454968c6e6c9c4a2a85fb777431fb90"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a8454968c6e6c9c4a2a85fb777431fb90">SetNthWaxAnchoredElementParcelKey</a> (int32 n, <a class="el" href="class_parcel_key.html">ParcelKey</a> key)</td></tr><tr class="separator:a8454968c6e6c9c4a2a85fb777431fb90"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abc4d75b95986a138d3f99eb27b0cd903"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#abc4d75b95986a138d3f99eb27b0cd903">GetWaxAnchoredElementsIn</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_u_i_d_list.html">UIDList</a> *list) const </td></tr><tr class="separator:abc4d75b95986a138d3f99eb27b0cd903"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a37076c05bbc8f37e6a05bd3985fe5bae"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a37076c05bbc8f37e6a05bd3985fe5bae">GetFirstDamagedParcel</a> () const </td></tr><tr class="separator:a37076c05bbc8f37e6a05bd3985fe5bae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a71e092115e301b18240d57abd543acbb"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a71e092115e301b18240d57abd543acbb">GetFirstKeyIndexes</a> (int32 &amp;damagedKeyIndex, int32 &amp;needWrapCheckKeyIndex) const </td></tr><tr class="separator:a71e092115e301b18240d57abd543acbb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a820b5158c7b95719c52881efc7a5328a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a820b5158c7b95719c52881efc7a5328a"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>ShouldFakeTabAlignToChar</b> () const </td></tr><tr class="separator:a820b5158c7b95719c52881efc7a5328a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a61a5902856f80309d28162afff5709e4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a61a5902856f80309d28162afff5709e4"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InvalidateParcelComposedState</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)</td></tr><tr class="separator:a61a5902856f80309d28162afff5709e4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab2ea9d6e5a80d2b68e312072f66c2f40"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab2ea9d6e5a80d2b68e312072f66c2f40"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>NotifyParcelParentInkBoundsChanged</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)</td></tr><tr class="separator:ab2ea9d6e5a80d2b68e312072f66c2f40"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0bb16702c203476a2a518f32af168f3e"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a0bb16702c203476a2a518f32af168f3e">GetParcelsOnSpread</a> (const <a class="el" href="class_i_spread.html">ISpread</a> *spread, <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_parcel_key.html">ParcelKey</a> &gt; &amp;keyList) const </td></tr><tr class="separator:a0bb16702c203476a2a518f32af168f3e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a95eeecccf9da276eebf0a7ae58fded23"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a95eeecccf9da276eebf0a7ae58fded23">GetNonInlineWrapsForParcel</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList) const </td></tr><tr class="separator:a95eeecccf9da276eebf0a7ae58fded23"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae2f37a1249d2b35f79b8eb30a9aca551"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#ae2f37a1249d2b35f79b8eb30a9aca551">AddParcelWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef, bool16 isActive, bool16 isNonInline, bool16 isInlineToParcel)</td></tr><tr class="separator:ae2f37a1249d2b35f79b8eb30a9aca551"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a23989d61a3dc84fb52578a4f7d42e32a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a23989d61a3dc84fb52578a4f7d42e32a">GetParcelWrapActive</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a>, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef) const </td></tr><tr class="separator:a23989d61a3dc84fb52578a4f7d42e32a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa616b0c2a379040b5b5b8d922f3eb452"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#aa616b0c2a379040b5b5b8d922f3eb452">SetParcelWrapActive</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)</td></tr><tr class="separator:aa616b0c2a379040b5b5b8d922f3eb452"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a60723827425eb02ed9767980aa6017f2"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a60723827425eb02ed9767980aa6017f2">ClearParcelWrapActive</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)</td></tr><tr class="separator:a60723827425eb02ed9767980aa6017f2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac75c74203c2b76849a5eadfc3f3baf0e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#ac75c74203c2b76849a5eadfc3f3baf0e">GetParcelWrapIsNonInline</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a>, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef) const </td></tr><tr class="separator:ac75c74203c2b76849a5eadfc3f3baf0e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a24f5eb4691002327ebd74762807f0aa8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a24f5eb4691002327ebd74762807f0aa8">GetParcelWrapIsInlineToParcel</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a>, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef) const </td></tr><tr class="separator:a24f5eb4691002327ebd74762807f0aa8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4a09c51fdb921e3cd28b2beae90d56a8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a4a09c51fdb921e3cd28b2beae90d56a8">GetParcelWrapHasOverlappedRange</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef) const </td></tr><tr class="separator:a4a09c51fdb921e3cd28b2beae90d56a8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a34574efb57b41570c5b1f9065d3fea02"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a34574efb57b41570c5b1f9065d3fea02">GetParcelWrapOverlappedRange</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYTop, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYBottom) const </td></tr><tr class="separator:a34574efb57b41570c5b1f9065d3fea02"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0d99295d273eea313b078717e7c6312f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a0d99295d273eea313b078717e7c6312f">SetParcelWrapOverlappedRange</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYTop, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYBottom)</td></tr><tr class="separator:a0d99295d273eea313b078717e7c6312f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a34636e3aac04883c64f0e03cce6d7302"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a34636e3aac04883c64f0e03cce6d7302">GetParcelHasWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a34636e3aac04883c64f0e03cce6d7302"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6ba4fc3ef53b62153eb0546879915a3a"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a6ba4fc3ef53b62153eb0546879915a3a">GetParcelWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList) const </td></tr><tr class="separator:a6ba4fc3ef53b62153eb0546879915a3a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a079ec5bfa64660fedc3c263abebea934"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a079ec5bfa64660fedc3c263abebea934">GetParcelHasActiveNonInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a079ec5bfa64660fedc3c263abebea934"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4b0c3a6b84855a150614a34cdd1a081d"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a4b0c3a6b84855a150614a34cdd1a081d">GetParcelActiveNonInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList) const </td></tr><tr class="separator:a4b0c3a6b84855a150614a34cdd1a081d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a80a84c5167ef90e54c50b4fe335beb55"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a80a84c5167ef90e54c50b4fe335beb55">GetParcelHasActiveInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const </td></tr><tr class="separator:a80a84c5167ef90e54c50b4fe335beb55"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4471e227b1b41e3b4169f7b69e1e0aac"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#a4471e227b1b41e3b4169f7b69e1e0aac">GetParcelActiveInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList) const </td></tr><tr class="separator:a4471e227b1b41e3b4169f7b69e1e0aac"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af5414f58644775ea998dfb5861286f8f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#af5414f58644775ea998dfb5861286f8f">RemoveParcelWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)</td></tr><tr class="separator:af5414f58644775ea998dfb5861286f8f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af729000d6a8d1b467dd85d6334c164c2"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_hid_txt_parcel_list_data.html#af729000d6a8d1b467dd85d6334c164c2">GetSupportsColumnSpanType</a> (<a class="el" href="class_i_composition_style.html#ab343b6d3bfdd9dc869daf2ef87bbbf9e">ICompositionStyle::SpanColumnsTypeOptions</a> spanType) const </td></tr><tr class="separator:af729000d6a8d1b467dd85d6334c164c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_c_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_c_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_c_p_m_unknown.html">CPMUnknown&lt; ITextParcelListData &gt;</a></td></tr><tr class="memitem:a10105e4db64f8f2875b5c2cb28a596ad inherit pub_methods_class_c_p_m_unknown"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m_unknown.html#a10105e4db64f8f2875b5c2cb28a596ad">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const</td></tr><tr class="separator:a10105e4db64f8f2875b5c2cb28a596ad inherit pub_methods_class_c_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa7986187496d822587f61c6b52f50f3a inherit pub_methods_class_c_p_m_unknown"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m_unknown.html#aa7986187496d822587f61c6b52f50f3a">AddRef</a> () const</td></tr><tr class="separator:aa7986187496d822587f61c6b52f50f3a inherit pub_methods_class_c_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adfd22e41fda51af2ca00b768bbad664c inherit pub_methods_class_c_p_m_unknown"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_p_m_unknown.html#adfd22e41fda51af2ca00b768bbad664c">Release</a> () const</td></tr><tr class="separator:adfd22e41fda51af2ca00b768bbad664c inherit pub_methods_class_c_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5e824ccfd2035d666a4869fba3007684 inherit pub_methods_class_c_p_m_unknown"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5e824ccfd2035d666a4869fba3007684"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PreDirty</b> (<a class="el" href="class_i_d_type.html">ImplementationID</a> prop=kInvalidImpl, bool16 allowModification=kTrue)</td></tr><tr class="separator:a5e824ccfd2035d666a4869fba3007684 inherit pub_methods_class_c_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaca1ae0b866699065dd7edcc9b991643 inherit pub_methods_class_c_p_m_unknown"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aaca1ae0b866699065dd7edcc9b991643"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PreDirtyNoMessage</b> (<a class="el" href="class_i_d_type.html">ImplementationID</a> prop=kInvalidImpl, bool16 allowModification=kTrue)</td></tr><tr class="separator:aaca1ae0b866699065dd7edcc9b991643 inherit pub_methods_class_c_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a> Additional Inherited Members</h2></td></tr><tr class="inherit_header pub_types_class_i_text_parcel_list_data"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_types_class_i_text_parcel_list_data&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Types inherited from <a class="el" href="class_i_text_parcel_list_data.html">ITextParcelListData</a></td></tr><tr class="memitem:aeeb62c6738a16276233e25c8e5a1b1d1 inherit pub_types_class_i_text_parcel_list_data"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITEXTPARCELLISTDATA }</td></tr><tr class="separator:aeeb62c6738a16276233e25c8e5a1b1d1 inherit pub_types_class_i_text_parcel_list_data"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3728794498f72098318ba84889780a28 inherit pub_types_class_i_text_parcel_list_data"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>nextParcelType</b> { <b>npt_box</b>, <b>npt_anypage</b>, <b>npt_oddpage</b>, <b>npt_evenpage</b> }</td></tr><tr class="separator:a3728794498f72098318ba84889780a28 inherit pub_types_class_i_text_parcel_list_data"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pro_methods_class_c_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pro_methods_class_c_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Protected Member Functions inherited from <a class="el" href="class_c_p_m_unknown.html">CPMUnknown&lt; ITextParcelListData &gt;</a></td></tr><tr class="memitem:a5d02eb07cb727b1babc7b85799c23a5e inherit pro_methods_class_c_p_m_unknown"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5d02eb07cb727b1babc7b85799c23a5e"></a> &nbsp;</td><td class="memItemRight" valign="bottom"><b>CPMUnknown</b> (<a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *boss)</td></tr><tr class="separator:a5d02eb07cb727b1babc7b85799c23a5e inherit pro_methods_class_c_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pro_attribs_class_c_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pro_attribs_class_c_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Protected Attributes inherited from <a class="el" href="class_c_p_m_unknown.html">CPMUnknown&lt; ITextParcelListData &gt;</a></td></tr><tr class="memitem:add059c09a7b16520e59586606e177ea6 inherit pro_attribs_class_c_p_m_unknown"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="add059c09a7b16520e59586606e177ea6"></a> <a class="el" href="class_helper_interface.html">HelperInterface</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fHelperInterface</b></td></tr><tr class="separator:add059c09a7b16520e59586606e177ea6 inherit pro_attribs_class_c_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Stub <a class="el" href="class_i_text_parcel_list_data.html">ITextParcelListData</a> implementation, display of composed hidden text is not supported.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_text_parcel_list_data.html">ITextParcelListData</a></dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2><a class="anchor" id="a0ec66a7e190dc9bd31d3e72fb634a5be"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">HidTxtParcelListData::HidTxtParcelListData </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>boss</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Constructor <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">boss</td><td>refers to boss class on which this interface is aggregated </td></tr></table></dl></div></div><a class="anchor" id="adf5dbfc7313a7650a291492cd91e9cd4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">HidTxtParcelListData::~HidTxtParcelListData </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Destructor. </div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="ae2f37a1249d2b35f79b8eb30a9aca551"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::AddParcelWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isActive</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isNonInline</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isInlineToParcel</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_parcel_key.html">ParcelKey</a></td><td></td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss with active <a class="el" href="class_i_stand_off.html">IStandOff</a></td></tr><tr><td class="paramname">isActive</td><td>kTrue if the Wrap can be tiled against </td></tr><tr><td class="paramname">isNonInline</td><td>kTrue if the Wrap is not the child of an Inline </td></tr><tr><td class="paramname">isInlineToParcel</td><td>kTrue if the Wrap is the child of an Inline that is anchored in the Parcel. If kTrue, then sodRef.fX/YOffset are expected to be zero. </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#af870a324279a8fd2adafad5f4a4c6abb">ITextParcelListData</a>.</div></div><a class="anchor" id="a58d6631f27e464197f5e2b7ca86413c5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::ClearParcelNeedsWrapCheck </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clears the wrap check from the specified Parcel. During composition the TextParcelList will cause this to be cleared when it processes a Parcel following the one currently being composed. It is the responsiblity of the implementation to process the Parcel in which composition begins. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a9a7a30585bc772d243e9d691cbe2a28b">ITextParcelListData</a>.</div></div><a class="anchor" id="a60723827425eb02ed9767980aa6017f2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::ClearParcelWrapActive </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodUID</td><td>UID of wrap boss with active <a class="el" href="class_i_stand_off_data.html">IStandOffData</a> interface </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a6fd2018803513f9a537f58ffca7622ab">ITextParcelListData</a>.</div></div><a class="anchor" id="a37076c05bbc8f37e6a05bd3985fe5bae"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_parcel_key.html">ParcelKey</a> HidTxtParcelListData::GetFirstDamagedParcel </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the first Parcel in the ParcelList which is is damaged. If no Parcel is damaged then an invalid <a class="el" href="class_parcel_key.html">ParcelKey</a> returned. Note that this only refers to Parcels which are damaged, NOT those that need wrap check. <dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#aefdd7d6af9c26b74b7b48569e1c0f912">ITextParcelListData</a>.</div></div><a class="anchor" id="a71e092115e301b18240d57abd543acbb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::GetFirstKeyIndexes </td><td>(</td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>damagedKeyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>needWrapCheckKeyIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method returns information about the first Parcel which is damaged and the first Parcel which needs wrap check. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">damagedKeyIndex</td><td>Reference to int32 which will be filled in with the index of the first Parcel which is damaged, or -1 if none </td></tr><tr><td class="paramname">needWrapCheckKeyIndex</td><td>Reference to int32 which will be filled in with the index of the first Parcel which needs wrap check, or -1 if none </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a8c5657fa7531fc46c822d09ba0683e87">ITextParcelListData</a>.</div></div><a class="anchor" id="a1ac5ce09c043ba120be338c98da1ce3f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_parcel_key.html">ParcelKey</a> HidTxtParcelListData::GetFirstLogicalParcelKey </td><td>(</td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel logicaly first. In terms of this API, a logical Parcel is one that text can be composed in. Typical implementations have these as one-to-one with all the Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a> but implementations such as Table Header and Footer cells have only the first Parcel as logically composable and the rest have no Text content at all. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be set to -1. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the first logical Parcel. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a4b1bd4999288a53f70814d3382231459">ITextParcelListData</a>.</div></div><a class="anchor" id="aea659edc56055968df87a125febdbe29"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_parcel_key.html">ParcelKey</a> HidTxtParcelListData::GetLastLogicalNonOversetParcelKey </td><td>(</td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method allows the implementation to control the meaning of overset. Implementations which do not support overmatter Parcels will return the same value for this method as <a class="el" href="class_hid_txt_parcel_list_data.html#a5c12269144d5cea8685fe0d801b8e191">GetLastLogicalParcelKey()</a>. Those that do support overmatter Parcel should return the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the last Parcel before the first overmatter Parcel. <a class="el" href="class_i_text_parcel_list.html#aee736e63fa9aa6271e4090cd64d10a94">ITextParcelList::GetIsOverset()</a> will use the returned <a class="el" href="class_parcel_key.html">ParcelKey</a> as the measure of overset content. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be filled in with the count of Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of last logical non-overset Parcel </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#aa0c5675829b073180dd2169cb46d2c96">ITextParcelListData</a>.</div></div><a class="anchor" id="a5c12269144d5cea8685fe0d801b8e191"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_parcel_key.html">ParcelKey</a> HidTxtParcelListData::GetLastLogicalParcelKey </td><td>(</td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel logicaly last. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be set to the count of Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the last logical Parcel. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a1c866162eab0f8169b46a1fa7993cf34">ITextParcelListData</a>.</div></div><a class="anchor" id="a39936cd94cf7a53828b9c78bbd153ddc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_parcel_key.html">ParcelKey</a> HidTxtParcelListData::GetNextLogicalParcelKey </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel logically after the specified key. If the key is invalid, an invalid key will be returned. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be filled in with the count of Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the next logical Parcel. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a760f0c26fb240bed67840ffe85134a48">ITextParcelListData</a>.</div></div><a class="anchor" id="a9cfe96a1cd274feced08ebf1a3e6d66e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_parcel_key.html">ParcelKey</a> HidTxtParcelListData::GetNextLogicalParcelKeyByType </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">ITextParcelListData::nextParcelType&nbsp;</td><td class="paramname"><em>pType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the specified Parcel Type logically after the specified key. If the specified Key is already the type of Parcel desired then the key returned will be unchanged. If the key is invalid, an invalid key will be returned. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">pType</td><td>Type of Parcel the caller wishes to move to. If the </td></tr><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be filled in with the count of Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the next logical Parcel. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#aff04d5f65096fa5a54431f7be720ca80">ITextParcelListData</a>.</div></div><a class="anchor" id="a95eeecccf9da276eebf0a7ae58fded23"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">int32 HidTxtParcelListData::GetNonInlineWrapsForParcel </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specfied list with all the non-Inline Wraps which the implementation determines are possible overlaps for the specified Parcel. Note that this is expected to be the same as or superset of the Wraps currently known to the Parcel as returned by <a class="el" href="class_hid_txt_parcel_list_data.html#a6ba4fc3ef53b62153eb0546879915a3a">GetParcelWraps()</a>. The TextParcelList will be responsible for adding these Wraps to the Parcel in a separate step. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodList</td><td>Reference to TextWrapRefList to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of Wraps added to the list </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#aa29183d374f61f71e9c3abc76d0dec79">ITextParcelListData</a>.</div></div><a class="anchor" id="a6359bd209105cfe69491a897ee342c65"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_parcel_key.html">ParcelKey</a> HidTxtParcelListData::GetNthWaxAnchoredElementParcelKey </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Nth element. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>An index into the internal list. Must be greater than or equal to zero and less then the value returned by <a class="el" href="class_hid_txt_parcel_list_data.html#a6a62852b5019f98982cfd82111e071c0">GetWaxAnchoredElementCount()</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a11e0216919f674b6a59adff44012815a">ITextParcelListData</a>.</div></div><a class="anchor" id="a2af5e60c4cd54adb842be7185fe9d20f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_i_d_type.html">UID</a> HidTxtParcelListData::GetNthWaxAnchoredElementUID </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the UID of the Nth element. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>An index into the internal list. Must be greater than or equal to zero and less then the value returned by <a class="el" href="class_hid_txt_parcel_list_data.html#a6a62852b5019f98982cfd82111e071c0">GetWaxAnchoredElementCount()</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The UID </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a9a640754fcbb9c254a1781e9840012cf">ITextParcelListData</a>.</div></div><a class="anchor" id="a4471e227b1b41e3b4169f7b69e1e0aac"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">int32 HidTxtParcelListData::GetParcelActiveInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specfied list with all the Wraps currently added to the Parcel which report being active and are a child of an Inline. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodList</td><td>Reference to TextWrapRefList to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of Wraps added to the list </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a4b0edc1991bb0f38a6e9966efb5a310d">ITextParcelListData</a>.</div></div><a class="anchor" id="a4b0c3a6b84855a150614a34cdd1a081d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">int32 HidTxtParcelListData::GetParcelActiveNonInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specfied list with all the Wraps currently added to the Parcel which report being active and are not the child of an Inline. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodList</td><td>Reference to TextWrapRefList to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of Wraps added to the list </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#af4fc98435af9d88b283982a7065a3753">ITextParcelListData</a>.</div></div><a class="anchor" id="a80a84c5167ef90e54c50b4fe335beb55"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelHasActiveInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the specified Parcel has any active Wraps which are a child of an Inline. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel has any Wraps added to it. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a9204a400330584040254c3f9da78e584">ITextParcelListData</a>.</div></div><a class="anchor" id="a079ec5bfa64660fedc3c263abebea934"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelHasActiveNonInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the specified Parcel has any active Wraps which are not a child of an Inline. added to it. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel has any Wraps added to it. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#aef736194419d26a706ad991213296c32">ITextParcelListData</a>.</div></div><a class="anchor" id="aa7fce26fc1acdd8d3e5e9978a00b09f9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelHasKeepsOn </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>The TextParcelList will set this value if the contents of the Parcel has any keeps on <p>Implements <a class="el" href="class_i_text_parcel_list_data.html#aaa649f2f8c4f224ab3be2476c33707a1">ITextParcelListData</a>.</div></div><a class="anchor" id="a1254ff28615ca39047df73005b1e9f03"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelHasPositionDependentContent </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>The TextParcelList will set this value if the contents of the Parcel, including Wax, OwnedItems, WaxAnchoredElements and even Wraps require it. <p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a42914c7e584f9e51cab94d118b7fc7f8">ITextParcelListData</a>.</div></div><a class="anchor" id="a34636e3aac04883c64f0e03cce6d7302"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelHasWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the specified Parcel has any Wraps added to it. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel has any Wraps added to it. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#add1502021e05fff9101e720f7dc0720e">ITextParcelListData</a>.</div></div><a class="anchor" id="af70252988a7941099f3e5f685a35e1ca"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelIgnoringWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the Parcel is ignoring the effect of all Wraps. Note that the Wraps will still be added to the Parcel, but they will be handled as invalid due to ZOrder. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel is ignoring the effect of all Wraps. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#ae100ac1e00fa954af4ed05820236abaa">ITextParcelListData</a>.</div></div><a class="anchor" id="a2456e596207a6ec09fcba527464d1a14"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelIsDamaged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>A Parcel with TextDamage needs recomposition. <p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a2c8eb5c0250a1a4f4cd17472cedc14c1">ITextParcelListData</a>.</div></div><a class="anchor" id="aac6fbce1cc380fb12b6b624c0bc01065"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelNeedsWrapCheck </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Parcels which are marked as needing Wrap check are suspected of having new intersecting Wraps available through <a class="el" href="class_hid_txt_parcel_list_data.html#a95eeecccf9da276eebf0a7ae58fded23">GetNonInlineWrapsForParcel()</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel needs to check wrap </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#ae583b95c9efad7ecd78e597f5a773d30">ITextParcelListData</a>.</div></div><a class="anchor" id="a0bb16702c203476a2a518f32af168f3e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">int32 HidTxtParcelListData::GetParcelsOnSpread </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_spread.html">ISpread</a> *&nbsp;</td><td class="paramname"><em>spread</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_parcel_key.html">ParcelKey</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>keyList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the list of Parcels that are on the specified <a class="el" href="class_i_spread.html">ISpread</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spread</td><td>Pointer to <a class="el" href="class_i_spread.html">ISpread</a> interface </td></tr><tr><td class="paramname">keyList</td><td><a class="el" href="class_k2_vector.html">K2Vector</a> of ParcelKeys to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of ParcelKeys added to keyList </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#ada7c49552a8c781a14b34d2fde61d6eb">ITextParcelListData</a>.</div></div><a class="anchor" id="a3abc2865da16e7b84a0ca20d91ae8a90"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelSupportsWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kFalse if the Parcel does not support Wraps. This is different from ignoring in that one can stop ignoring sometime in the future whereas one will not suddenly support Wraps. Examples of implementations which do not support Wraps are TextOnPath. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel supports Wraps. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a5886a9beddc67d5874b254e4050e1ba6">ITextParcelListData</a>.</div></div><a class="anchor" id="a23989d61a3dc84fb52578a4f7d42e32a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelWrapActive </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the active state of the StandOff relative to the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a6268b7168cd0dd0fa7c7f914f566cf8a">ITextParcelListData</a>.</div></div><a class="anchor" id="a4a09c51fdb921e3cd28b2beae90d56a8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelWrapHasOverlappedRange </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a91ede28c843addfa91693fa3683572cd">ITextParcelListData</a>.</div></div><a class="anchor" id="a24f5eb4691002327ebd74762807f0aa8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelWrapIsInlineToParcel </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Wraps which are Inline to the Parcel are those that are anchored in the Parcel. Wraps that are children of Inlines that are NOt inline to the Parcel are anchored at a TextIndex previous to the start of the Parcel. This state is set when the Wrap is added to the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#af41b0ba6a6534c72cac1c612538a6b5d">ITextParcelListData</a>.</div></div><a class="anchor" id="ac75c74203c2b76849a5eadfc3f3baf0e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetParcelWrapIsNonInline </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the non-inline state of the StandOff. Wraps which are non-inline are NOT children of an Inline - typically they are children of the Spread. This state is set when the Wrap is added to the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a5a9ac32ef29a5f89908b8bb237dd49dd">ITextParcelListData</a>.</div></div><a class="anchor" id="a34574efb57b41570c5b1f9065d3fea02"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::GetParcelWrapOverlappedRange </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>waxYTop</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>waxYBottom</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#aca08ae9881af6aa7227b7b8c97e28245">ITextParcelListData</a>.</div></div><a class="anchor" id="a6ba4fc3ef53b62153eb0546879915a3a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">int32 HidTxtParcelListData::GetParcelWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specfied list with all the Wraps currently added to the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodList</td><td>Reference to TextWrapRefList to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of Wraps added to the list </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#aa2687fb2cd311d4c8631bf395d9db1b7">ITextParcelListData</a>.</div></div><a class="anchor" id="a5cb51802e4814b5270080c381fad9547"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_parcel_key.html">ParcelKey</a> HidTxtParcelListData::GetPreviousLogicalParcelKey </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel logically previous to the specified key. If the key is invalid, an invalid key will be returned. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be set to -1. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the next logical Parcel. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#af89ceb15f6a8a5e553b16fb5210d087e">ITextParcelListData</a>.</div></div><a class="anchor" id="af729000d6a8d1b467dd85d6334c164c2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 HidTxtParcelListData::GetSupportsColumnSpanType </td><td>(</td><td class="paramtype"><a class="el" href="class_i_composition_style.html#ab343b6d3bfdd9dc869daf2ef87bbbf9e">ICompositionStyle::SpanColumnsTypeOptions</a>&nbsp;</td><td class="paramname"><em>spanType</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>All implementations must support ICompositionStyle::kSingleColumn. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spanType</td><td>Span type to check </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the implementation supports the specified span type. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a9466682de1f186d4c8b19a341fda8f8a">ITextParcelListData</a>.</div></div><a class="anchor" id="a6a62852b5019f98982cfd82111e071c0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">int32 HidTxtParcelListData::GetWaxAnchoredElementCount </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>The number of WaxAnchoredElement known to the implementation. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a983208261f721dd4e7da3d49c7a8d78d">ITextParcelListData</a>.</div></div><a class="anchor" id="a5b624969e8342ddec15bba7651775a55"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">int32 HidTxtParcelListData::GetWaxAnchoredElementIndex </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>uid</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the index of the specified WaxAnchoredElement. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">uid</td><td>The UID of the desired WaxAnchoredElement boss. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The index of the specified WaxAnchoredElement or -1 if it is not known to the implementation. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a9a7778e0e26d86edbaa2e17f21cc2059">ITextParcelListData</a>.</div></div><a class="anchor" id="abc4d75b95986a138d3f99eb27b0cd903"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">int32 HidTxtParcelListData::GetWaxAnchoredElementsIn </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>list</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specified <a class="el" href="class_u_i_d_list.html">UIDList</a> with UIDs of the WaxAnchoredElements in the specified Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">list</td><td>Optional <a class="el" href="class_u_i_d_list.html">UIDList</a> to append to. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of WaxAnchoredElements returned. </dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a92eeb50a8d366f50508da3620742bd6e">ITextParcelListData</a>.</div></div><a class="anchor" id="a510b8ec28b9d22fb7376f817f555470d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::InsertNthWaxAnchoredElement </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>uid</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>A new WaxAnchoredElement is inserted into the list. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>An index into the internal list. Must be greater than or equal to zero and less than OR equal to the value returned by <a class="el" href="class_hid_txt_parcel_list_data.html#a6a62852b5019f98982cfd82111e071c0">GetWaxAnchoredElementCount()</a>. </td></tr><tr><td class="paramname">uid</td><td>The UID of the WaxAnchoredElement. Must not already be known to the implementation. </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a00d7bb967f85226dddddf12de8b6a326">ITextParcelListData</a>.</div></div><a class="anchor" id="ae90353444b2934f1a485188667759bba"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::RemoveNthWaxAnchoredElement </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>The specified WaxAnchoredElement is removed from the list. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>An index into the internal list. Must be greater than or equal to zero and less then the value returned by <a class="el" href="class_hid_txt_parcel_list_data.html#a6a62852b5019f98982cfd82111e071c0">GetWaxAnchoredElementCount()</a>. </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a14ee82c9184fa2a709932569cbac0fca">ITextParcelListData</a>.</div></div><a class="anchor" id="af5414f58644775ea998dfb5861286f8f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::RemoveParcelWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a4178fed678a996ac0ff8cabaa502927c">ITextParcelListData</a>.</div></div><a class="anchor" id="a8454968c6e6c9c4a2a85fb777431fb90"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::SetNthWaxAnchoredElementParcelKey </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>Key</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Nth element. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td><a class="el" href="class_parcel_key.html">ParcelKey</a>. </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a63a1b93ac3e71f26295ba41d9be9050a">ITextParcelListData</a>.</div></div><a class="anchor" id="a1b2d3184f50136c8bd4829e6170f1fc0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::SetParcelNeedsWrapCheck </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>It is the responsibility of the container implementation to mark Parcels as needing Wrap check through this method when it knowns that Wraps which are not Inline to the Parcel might affect it.<p>Typically this means that the implementation has to wait until the Parcel has finished its movement to determine the effect - it is not necessarily correct to simply mark all moving or resizing Parcels as needing Wrap check.<p>Furthermore, the implementation is also responsible for determing what appropriate &quot;damage&quot; is required in order to trigger evaluation of the Wrap. Parcels which are beyond the end of the composed Thread do not necessarily have to be composed<p>The TextParcelList ONLY calls this method when processing Wraps from Inlines via AddParcelInlineWraps(). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a8bdd15ce832267ca1f920fdb0d38ad1a">ITextParcelListData</a>.</div></div><a class="anchor" id="aa616b0c2a379040b5b5b8d922f3eb452"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::SetParcelWrapActive </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname">, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#ad35e2a5d917634cf9ed29b4395ed81e7">ITextParcelListData</a>.</div></div><a class="anchor" id="a0d99295d273eea313b078717e7c6312f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void HidTxtParcelListData::SetParcelWrapOverlappedRange </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>waxYTop</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>waxYBottom</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implements <a class="el" href="class_i_text_parcel_list_data.html#a73fdaf82900bee14329ab427451787c9">ITextParcelListData</a>.</div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_hid_txt_parcel_list_data.html">HidTxtParcelListData</a><li class="footer">Generated on Sat Sep 22 2018 10:53:43 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
