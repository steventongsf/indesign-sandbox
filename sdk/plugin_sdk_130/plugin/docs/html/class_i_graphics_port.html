<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_graphics_port</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_graphics_port.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_graphics_port-members.html">List of all members</a></div><div class="headertitle"><div class="title">IGraphicsPort Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_graphics_port_8h_source.html">IGraphicsPort.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IGraphicsPort:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_graphics_port.png" usemap="#IGraphicsPort_map" /><map id="IGraphicsPort_map" name="IGraphicsPort_map"><area alt="IPMUnknown" coords="0,0,89,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a01ade008593fc84cc9b9d6a35733c76c"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IGRAPHICSPORT }</td></tr><tr class="separator:a01ade008593fc84cc9b9d6a35733c76c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a851612cde3dc39331a626597ac5e96b1"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>TextGraphicsFlags</b> { <b>kFillText</b> = 1, <b>kStrokeText</b> = 2, <b>kClipText</b> = 4 }</td></tr><tr class="separator:a851612cde3dc39331a626597ac5e96b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acef8b102fc078866dc54471438bdb031"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#acef8b102fc078866dc54471438bdb031">RenderingIntent</a> { <b>kPerceptual</b>, <b>kSaturation</b>, <b>kRelative</b>, <b>kAbsolute</b> }</td></tr><tr class="separator:acef8b102fc078866dc54471438bdb031"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a89ba2c36c7a2dda321fc4c6aa61d96fe"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a89ba2c36c7a2dda321fc4c6aa61d96fe"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Setup</b> ()=0</td></tr><tr class="separator:a89ba2c36c7a2dda321fc4c6aa61d96fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8752d1d72e0ccc739835fd1f1cc8fd01"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a8752d1d72e0ccc739835fd1f1cc8fd01">newpath</a> ()=0</td></tr><tr class="separator:a8752d1d72e0ccc739835fd1f1cc8fd01"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4534e532778f1c060ecda9682cb29ac2"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a4534e532778f1c060ecda9682cb29ac2">moveto</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y)=0</td></tr><tr class="separator:a4534e532778f1c060ecda9682cb29ac2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa3e276036adc9581679913b436d57e71"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#aa3e276036adc9581679913b436d57e71">rmoveto</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y)=0</td></tr><tr class="separator:aa3e276036adc9581679913b436d57e71"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a97cab650d6155c91fe82ff7fe90f7eb2"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a97cab650d6155c91fe82ff7fe90f7eb2">lineto</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y)=0</td></tr><tr class="separator:a97cab650d6155c91fe82ff7fe90f7eb2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3244f9f0996d87d53b5314d5be509245"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a3244f9f0996d87d53b5314d5be509245">curveto</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x1, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y1, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x2, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y2, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x3, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y3)=0</td></tr><tr class="separator:a3244f9f0996d87d53b5314d5be509245"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3c950f8a5542af029c6076c250d35948"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a3c950f8a5542af029c6076c250d35948">curvetov</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x2, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y2, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x3, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y3)=0</td></tr><tr class="separator:a3c950f8a5542af029c6076c250d35948"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad0852cbc253acab99b145e05a4a79350"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#ad0852cbc253acab99b145e05a4a79350">closepath</a> ()=0</td></tr><tr class="separator:ad0852cbc253acab99b145e05a4a79350"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3764f1bf8f80d8e61cbd49f4a02b53af"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a3764f1bf8f80d8e61cbd49f4a02b53af">gsave</a> ()=0</td></tr><tr class="separator:a3764f1bf8f80d8e61cbd49f4a02b53af"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3a6f5ed188b108c4ead3575f3ea7136e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a3a6f5ed188b108c4ead3575f3ea7136e">grestore</a> ()=0</td></tr><tr class="separator:a3a6f5ed188b108c4ead3575f3ea7136e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a011049222f80a1a57217898b9274fce3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a011049222f80a1a57217898b9274fce3">translate</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y)=0</td></tr><tr class="separator:a011049222f80a1a57217898b9274fce3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7884b7058c973cab9b419c9c8e3e5ce9"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a7884b7058c973cab9b419c9c8e3e5ce9">scale</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y)=0</td></tr><tr class="separator:a7884b7058c973cab9b419c9c8e3e5ce9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab238a41e1a80e2855141b1db7e01248e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#ab238a41e1a80e2855141b1db7e01248e">rotate</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;theta)=0</td></tr><tr class="separator:ab238a41e1a80e2855141b1db7e01248e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6081265aa1d14616c7a8a838bbd506ab"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a6081265aa1d14616c7a8a838bbd506ab">concat</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)=0</td></tr><tr class="separator:a6081265aa1d14616c7a8a838bbd506ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae452cb9d78e027174c921cb39b7ce596"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#ae452cb9d78e027174c921cb39b7ce596">setlinewidth</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width)=0</td></tr><tr class="separator:ae452cb9d78e027174c921cb39b7ce596"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa7581fc201c6b8ca9e09950a63854fcc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#aa7581fc201c6b8ca9e09950a63854fcc">setdash</a> (int32 numDash, float *dashArray, float offset)=0</td></tr><tr class="separator:aa7581fc201c6b8ca9e09950a63854fcc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c5880d04e107a167e98f6dc9354b510"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a9c5880d04e107a167e98f6dc9354b510">setblendingmode</a> (PMBlendingMode pmBlendingMode)=0</td></tr><tr class="separator:a9c5880d04e107a167e98f6dc9354b510"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6cd9e394b038ebc907f6b6b18f259810"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a6cd9e394b038ebc907f6b6b18f259810">starttransparencygroup</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;bounds, AGMColorSpace *cs, bool16 isolationgroup=kTrue, bool16 knockoutgroup=kFalse)=0</td></tr><tr class="separator:a6cd9e394b038ebc907f6b6b18f259810"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a65b9f24e7e5c7bf37284bced95da1f9e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a65b9f24e7e5c7bf37284bced95da1f9e">endtransparencygroup</a> ()=0</td></tr><tr class="separator:a65b9f24e7e5c7bf37284bced95da1f9e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a32ff3153a9b8041f76cd50113ef077cc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a32ff3153a9b8041f76cd50113ef077cc">BeginGroup</a> (const <a class="el" href="class_p_m_string.html">PMString</a> name, const_AIMDictionaryContainer *attrib)=0</td></tr><tr class="separator:a32ff3153a9b8041f76cd50113ef077cc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9ae248cf70cd81e0c99a6e5f98917651"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a9ae248cf70cd81e0c99a6e5f98917651">EndGroup</a> (const <a class="el" href="class_p_m_string.html">PMString</a> name)=0</td></tr><tr class="separator:a9ae248cf70cd81e0c99a6e5f98917651"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a125e113fbb15ca1b7bb01be3c931067a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a125e113fbb15ca1b7bb01be3c931067a">setopacity</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;opacity, bool16 bIsAlphaShape)=0</td></tr><tr class="separator:a125e113fbb15ca1b7bb01be3c931067a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa29a8e33a83e104271a863e7bc4bd1d8"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#aa29a8e33a83e104271a863e7bc4bd1d8">setlinecap</a> (int32 type)=0</td></tr><tr class="separator:aa29a8e33a83e104271a863e7bc4bd1d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2102b442d86a2461f3b389f9a53fa45b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a2102b442d86a2461f3b389f9a53fa45b">setlinejoin</a> (int32 type)=0</td></tr><tr class="separator:a2102b442d86a2461f3b389f9a53fa45b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4198e50815c73ccf50bd285fd4d635b4"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a4198e50815c73ccf50bd285fd4d635b4">setmiterlimit</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;limit)=0</td></tr><tr class="separator:a4198e50815c73ccf50bd285fd4d635b4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a91b6e7a8f9f78fa7fc24fa05cbee414f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a91b6e7a8f9f78fa7fc24fa05cbee414f">setstrokeadjust</a> (bool16 strokeAdjust)=0</td></tr><tr class="separator:a91b6e7a8f9f78fa7fc24fa05cbee414f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a72df80cb564bcb030e07fa727354ee3c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a72df80cb564bcb030e07fa727354ee3c"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setgray</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;gray)=0</td></tr><tr class="separator:a72df80cb564bcb030e07fa727354ee3c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac186d713a26dc1d153a1c417f5a17328"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac186d713a26dc1d153a1c417f5a17328"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setrgbcolor</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;r, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;g, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;b)=0</td></tr><tr class="separator:ac186d713a26dc1d153a1c417f5a17328"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1caf8f3378761e051d85a0f3ae972918"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1caf8f3378761e051d85a0f3ae972918"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setcmykcolor</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;c, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;m, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;k)=0</td></tr><tr class="separator:a1caf8f3378761e051d85a0f3ae972918"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae16f4150cda7daf81b93583db0e180cd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae16f4150cda7daf81b93583db0e180cd"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setlabcolor</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;l, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;a, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;b)=0</td></tr><tr class="separator:ae16f4150cda7daf81b93583db0e180cd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac8253ab680e7f8dc0d7448eb8687cafd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac8253ab680e7f8dc0d7448eb8687cafd"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setcolorspace</b> (AGMColorSpace *colorSpace)=0</td></tr><tr class="separator:ac8253ab680e7f8dc0d7448eb8687cafd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3bbc5001f3d3c32b3bb2a99f96a4c3c9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3bbc5001f3d3c32b3bb2a99f96a4c3c9"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setcolorvalues</b> (const float *colorVals)=0</td></tr><tr class="separator:a3bbc5001f3d3c32b3bb2a99f96a4c3c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a98016caac91c41351cc49dbd6a1c2658"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a98016caac91c41351cc49dbd6a1c2658"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setgradient</b> (AGMGradient *agmGrad, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;grMatrix, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;xOrig, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;yOrig, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;len, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;ang, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;hiliteLen, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;hiliteAng)=0</td></tr><tr class="separator:a98016caac91c41351cc49dbd6a1c2658"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2c9d739cbf519d3c4af5464f55ffe049"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a2c9d739cbf519d3c4af5464f55ffe049">SetColorServer</a> (AGMPaint *agmPaint, bool16 bIsAlphaShape, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)=0</td></tr><tr class="separator:a2c9d739cbf519d3c4af5464f55ffe049"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a62ae5baa1e119bdb11c90c44c57ab4bc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a62ae5baa1e119bdb11c90c44c57ab4bc">SetAlphaServer</a> (AGMPaint *agmPaint, bool16 bIsAlphaShape, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)=0</td></tr><tr class="separator:a62ae5baa1e119bdb11c90c44c57ab4bc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9a5b7b76c5da175110d1f950fef3860d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a9a5b7b76c5da175110d1f950fef3860d">setoverprint</a> (bool32 overprint)=0</td></tr><tr class="separator:a9a5b7b76c5da175110d1f950fef3860d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9be12e8cd81ad1baebcc6a04f9d07542"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a9be12e8cd81ad1baebcc6a04f9d07542">fill</a> ()=0</td></tr><tr class="separator:a9be12e8cd81ad1baebcc6a04f9d07542"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0b9140365e2a875f09e9aeffde7abb4e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a0b9140365e2a875f09e9aeffde7abb4e">eofill</a> ()=0</td></tr><tr class="separator:a0b9140365e2a875f09e9aeffde7abb4e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3254d1be69314081d7bf80dd26fa9e3e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a3254d1be69314081d7bf80dd26fa9e3e">stroke</a> ()=0</td></tr><tr class="separator:a3254d1be69314081d7bf80dd26fa9e3e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae63a74819143bbe1a5df88840f6fac25"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae63a74819143bbe1a5df88840f6fac25"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>image</b> (<a class="el" href="struct__t___a_g_m_image_record.html">_t_AGMImageRecord</a> *imageRec, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;imMatrix, int32 flags)=0</td></tr><tr class="separator:ae63a74819143bbe1a5df88840f6fac25"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8046aaaf8d5ba20acbe4f5141b9278b1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8046aaaf8d5ba20acbe4f5141b9278b1"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>image</b> (<a class="el" href="struct__t___a_g_m_image_record.html">_t_AGMImageRecord</a> *imageRec, AGMColorSpace *cs, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m, int32 flags)=0</td></tr><tr class="separator:a8046aaaf8d5ba20acbe4f5141b9278b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aad9c2f13d6ee688d4d97cb01643d940f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aad9c2f13d6ee688d4d97cb01643d940f"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>image</b> (AGMImage *image, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;imMatrix, int32 flags)=0</td></tr><tr class="separator:aad9c2f13d6ee688d4d97cb01643d940f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae4b000ea7593242315eb3421c706b46a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae4b000ea7593242315eb3421c706b46a"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>show</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y, uint32 numUTF16s, const textchar *text, TextGraphicsFlags graphicsflags=kFillText, bool16 verticalGlyphs=kFalse, bool16 wmodePositioning=kFalse)=0</td></tr><tr class="separator:ae4b000ea7593242315eb3421c706b46a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9de98733439ae25e343bece9e294935f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9de98733439ae25e343bece9e294935f"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>xshow</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y, uint32 numGlyphs, const int32 *glyphArray, const Fixed *widths, const Fixed *yoffsets=nil, TextGraphicsFlags graphicsflags=kFillText, bool16 verticalGlyphs=kFalse, bool16 wmodePositioning=kFalse, uint32 numChars=0, const textchar *text=nil, <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="struct_one_o_t_feature.html">OneOTFeature</a> &gt; *otFeatureArray=nil)=0</td></tr><tr class="separator:a9de98733439ae25e343bece9e294935f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab7412cae40220582082d80a982436f32"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab7412cae40220582082d80a982436f32"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>xshow</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y, uint32 numGlyphs, const int32 *glyphArray, const float *widths, const float *yoffsets=nil, TextGraphicsFlags graphicsflags=kFillText, bool16 verticalGlyphs=kFalse, bool16 wmodePositioning=kFalse, uint32 numChars=0, const textchar *text=nil, <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="struct_one_o_t_feature.html">OneOTFeature</a> &gt; *otFeatureArray=nil)=0</td></tr><tr class="separator:ab7412cae40220582082d80a982436f32"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a61b50660d1581885b2c56c901e0efe24"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a61b50660d1581885b2c56c901e0efe24"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ctshow</b> (<a class="el" href="class_i_font_instance.html">IFontInstance</a> *fontInstance, <a class="el" href="class_p_m_real_glyph_point.html">PMRealGlyphPoint</a> *glyphPoints, uint32 numGlyphPoints, TextGraphicsFlags graphicsflags=kFillText, bool16 verticalGlyphs=kFalse)=0</td></tr><tr class="separator:a61b50660d1581885b2c56c901e0efe24"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab8898ddb22e3edef01d51320c27b770e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab8898ddb22e3edef01d51320c27b770e"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>selectfont</b> (<a class="el" href="class_i_p_m_font.html">IPMFont</a> *font, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)=0</td></tr><tr class="separator:ab8898ddb22e3edef01d51320c27b770e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aecc5076f7d2f4ef2141552b10ea4f232"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aecc5076f7d2f4ef2141552b10ea4f232"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>selectfont</b> (<a class="el" href="class_i_p_m_font.html">IPMFont</a> *font, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;ptSize)=0</td></tr><tr class="separator:aecc5076f7d2f4ef2141552b10ea4f232"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a184b029e0223266ffbd41ea35f3c1cf3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a184b029e0223266ffbd41ea35f3c1cf3">clip</a> ()=0</td></tr><tr class="separator:a184b029e0223266ffbd41ea35f3c1cf3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a898b2aae7e5760f9532a088124c344da"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a898b2aae7e5760f9532a088124c344da">eoclip</a> ()=0</td></tr><tr class="separator:a898b2aae7e5760f9532a088124c344da"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad217b94addf594bdea4f1bf8ebcde400"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad217b94addf594bdea4f1bf8ebcde400"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>strokepath_clip</b> ()=0</td></tr><tr class="separator:ad217b94addf594bdea4f1bf8ebcde400"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2267e10dafb8e68c03088d979db90fcc"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2267e10dafb8e68c03088d979db90fcc"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rectclip</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height)=0</td></tr><tr class="separator:a2267e10dafb8e68c03088d979db90fcc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a91d61d1c768609d2d970f9fb33448232"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a91d61d1c768609d2d970f9fb33448232"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rectclip</b> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;r)=0</td></tr><tr class="separator:a91d61d1c768609d2d970f9fb33448232"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac402e95c6e77d126639d39dc8ba3407e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac402e95c6e77d126639d39dc8ba3407e"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rectfill</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height)=0</td></tr><tr class="separator:ac402e95c6e77d126639d39dc8ba3407e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a26c1c1666393cda536ec177ca2338daa"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a26c1c1666393cda536ec177ca2338daa"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rectfill</b> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;r)=0</td></tr><tr class="separator:a26c1c1666393cda536ec177ca2338daa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac8e94e456013c8558ec63e17d0a36d1f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac8e94e456013c8558ec63e17d0a36d1f"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rectstroke</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height)=0</td></tr><tr class="separator:ac8e94e456013c8558ec63e17d0a36d1f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7b8ed3c8f0ea939c8193f1957cf614a2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7b8ed3c8f0ea939c8193f1957cf614a2"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rectstroke</b> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;r)=0</td></tr><tr class="separator:a7b8ed3c8f0ea939c8193f1957cf614a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab92613847d89c84eaf9c59a6d1cbe955"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab92613847d89c84eaf9c59a6d1cbe955"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rectpath</b> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height)=0</td></tr><tr class="separator:ab92613847d89c84eaf9c59a6d1cbe955"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aff417c9ccee5281003890fcbf167d5cd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aff417c9ccee5281003890fcbf167d5cd"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rectpath</b> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;r)=0</td></tr><tr class="separator:aff417c9ccee5281003890fcbf167d5cd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a25756b7ad43010a56af5838879069513"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a25756b7ad43010a56af5838879069513">shadingfill</a> (AGMPaint *paint)=0</td></tr><tr class="separator:a25756b7ad43010a56af5838879069513"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8f584adcbc5af044fe3a7d2866951ca1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8f584adcbc5af044fe3a7d2866951ca1"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddComment</b> (int32 comment, void *commentData, int32 length)=0</td></tr><tr class="separator:a8f584adcbc5af044fe3a7d2866951ca1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a85177287a154a0f40d9a7cd4fbd6534d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a85177287a154a0f40d9a7cd4fbd6534d"></a> virtual <a class="el" href="class_i_draw_mgr.html">IDrawMgr</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>PortDrawMgr</b> ()=0</td></tr><tr class="separator:a85177287a154a0f40d9a7cd4fbd6534d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a67ca901793c10402044a90014b2b36ba"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a67ca901793c10402044a90014b2b36ba"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>BeginAuxInfoContext</b> (<a class="el" href="class_g_port_aux_info_param.html">GPortAuxInfoParam</a> *auxInfoParam)=0</td></tr><tr class="separator:a67ca901793c10402044a90014b2b36ba"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3a784325c6b2b31a738a7b2d7323434c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3a784325c6b2b31a738a7b2d7323434c"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>EndAuxInfoContext</b> (<a class="el" href="class_g_port_aux_info_param.html">GPortAuxInfoParam</a> *auxInfoParam)=0</td></tr><tr class="separator:a3a784325c6b2b31a738a7b2d7323434c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6c2e40ccc2ae5dba5a46557370e11ab4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6c2e40ccc2ae5dba5a46557370e11ab4"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>show</b> (const CCTTextList &amp;textList, int32 flags, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *matrix=0) const =0</td></tr><tr class="separator:a6c2e40ccc2ae5dba5a46557370e11ab4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afdd686f89ae302947a701b69317228e0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#afdd686f89ae302947a701b69317228e0">SetRenderingIntent</a> (<a class="el" href="class_i_graphics_port.html#acef8b102fc078866dc54471438bdb031">RenderingIntent</a> intent)=0</td></tr><tr class="separator:afdd686f89ae302947a701b69317228e0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a333ffec19457ee7122bdc6cdc897cdd3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a333ffec19457ee7122bdc6cdc897cdd3">SetOverPrintMode</a> (bool32 mode)=0</td></tr><tr class="separator:a333ffec19457ee7122bdc6cdc897cdd3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6f7255c7a02c9d694696871a185d2a76"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#a6f7255c7a02c9d694696871a185d2a76">FillPath</a> (AGMPath *path)=0</td></tr><tr class="separator:a6f7255c7a02c9d694696871a185d2a76"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af0472847773570b4ccced163972297ba"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#af0472847773570b4ccced163972297ba">StrokePath</a> (AGMPath *path)=0</td></tr><tr class="separator:af0472847773570b4ccced163972297ba"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adcc6cda7110c1fcae24118268c2b540b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_graphics_port.html#adcc6cda7110c1fcae24118268c2b540b">ClipPath</a> (AGMPath *path)=0</td></tr><tr class="separator:adcc6cda7110c1fcae24118268c2b540b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> is THE drawing API for InDesign. It is a shell around the AGM API.<p>The methods behave exactly, or very much like the equivalent PostScript operators. See the PostScript language reference manual for complete documentation.<p>IMPORTANT: if you expect something to print, this is the ONLY interface you can use to do drawing. </div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="acef8b102fc078866dc54471438bdb031"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_graphics_port.html#acef8b102fc078866dc54471438bdb031">IGraphicsPort::RenderingIntent</a></td></tr></table></div><div class="memdoc"><p>Note that these values are defined the same as those in <a class="el" href="class_i_c_m_s_settings.html">ICMSSettings</a>; but <a class="el" href="class_i_c_m_s_settings.html">ICMSSettings</a> includes &#39;virtual&#39; rendering intents that are not allowed in SetRenderingIntent.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_graphics_port.html#afdd686f89ae302947a701b69317228e0">SetRenderingIntent</a></dl></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a32ff3153a9b8041f76cd50113ef077cc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::BeginGroup </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>name</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const_AIMDictionaryContainer *&nbsp;</td><td class="paramname"><em>attrib</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Starts a named group. Groups surround an arbitrary, and possibly empty, set of drawing operations. The may be nested. Begin/End pairs must be matched within a given context which is identified by the name.<p>&#39;name&#39; allows for protocols based nesting of multiple different group types &#39;attrib&#39; dictionary of attributes associated with the group itself rather than each of the enclosed elements.<dl class="section see"><dt>See Also<dd><a class="el" href="class_p_m_string.html">PMString</a> const_CAIMDictionary </dl></div></div><a class="anchor" id="a184b029e0223266ffbd41ea35f3c1cf3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::clip </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the clip to the intersection of the current clip and the inside of the current path. Insideness is determined by the winding fill rule (see EOClip to use the even-odd fill rule).<p><b>Note:</b> This method does NOT modify the port&#39;s current path.<p>Equivalent to PostScript&#39;s &#39;clip&#39; operator.<dl class="section see"><dt>See Also<dd>IGraphicsPort::EOClip </dl></div></div><a class="anchor" id="adcc6cda7110c1fcae24118268c2b540b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::ClipPath </td><td>(</td><td class="paramtype">AGMPath *&nbsp;</td><td class="paramname"><em>path</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Adds the specified path to the clip in the gstate. Any path currently in the gstate is ignored. In addition, the specified path does <em>not</em> get added to the gstate. However, this will perform an implicit newpath.<p>Note: The winding rule for the clip is taken from the path itself.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">path</td><td>The AGM path to clip </td></tr></table></dl></div></div><a class="anchor" id="ad0852cbc253acab99b145e05a4a79350"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::closepath </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Closes the current subpath. It appends a straight line segment connecting the current point to the subpath&#39;s starting point &ndash; generally, the point most recently specified by MoveTo.<p>Equivalent to PostScript&#39;s &#39;closepath&#39; operator. </div></div><a class="anchor" id="a6081265aa1d14616c7a8a838bbd506ab"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::concat </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Makes the port&#39;s current transformation matrix the product of the current matrix and the given one.<p>Equivalent to PostScript&#39;s &#39;concat&#39; operator. </div></div><a class="anchor" id="a3244f9f0996d87d53b5314d5be509245"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::curveto </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x1</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y1</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x2</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y2</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x3</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y3</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Adds a bezier curve segment to the path. The curve is defined by the path&#39;s current point as the first anchor point, (x1,y1) as the first control point, (x2,y2) as the second control point, and (x3,y3) as the second anchor point. (x3,y3) becomes the path&#39;s new current point. The path cannot be empty when this call is made.<p>Equivalent to PostScript&#39;s &#39;curveto&#39; operator. </div></div><a class="anchor" id="a3c950f8a5542af029c6076c250d35948"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::curvetov </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x2</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y2</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x3</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y3</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Adds a bezier curve segment to the path. This method is identical to the CurveTo method except that the path&#39;s current point is treated as both the first anchor point as well as the first control point.<p>The method originated in the Adobe Illustrator file format which used a &#39;v&#39; operator to represent this abbreviated form of curve. </div></div><a class="anchor" id="a9ae248cf70cd81e0c99a6e5f98917651"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::EndGroup </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>name</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Ends a named group.<dl class="section see"><dt>See Also<dd><a class="el" href="class_p_m_string.html">PMString</a></dl></div></div><a class="anchor" id="a65b9f24e7e5c7bf37284bced95da1f9e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::endtransparencygroup </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Ends a transparency group. EndTransparencyGroup does an automatic GRestore. </div></div><a class="anchor" id="a898b2aae7e5760f9532a088124c344da"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::eoclip </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the clip to the intersection of the current clip and the inside of the current path. Insideness is determined by the even-odd fill rule (see Clip to use the winding fill rule).<p><b>Note:</b> This method does NOT modify the port&#39;s current path.<p>Equivalent to PostScript&#39;s &#39;eoclip&#39; operator.<dl class="section see"><dt>See Also<dd>IGraphicsPort::Clip </dl></div></div><a class="anchor" id="a0b9140365e2a875f09e9aeffde7abb4e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::eofill </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Paints the inside of the current path. It uses the port&#39;s current color and opacity. Insideness is determined by the even-odd fill rule. Use Fill for the winding fill rule.<p><b>Note:</b> This method clears the port&#39;s current path.<p>Equivalent to PostScript&#39;s &#39;eofill&#39; operator.<dl class="section see"><dt>See Also<dd>IGraphicsPort::Fill </dl></div></div><a class="anchor" id="a9be12e8cd81ad1baebcc6a04f9d07542"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::fill </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Paints the inside of the current path. It uses the port&#39;s current color and opacity. Insideness is determined by the winding fill rule. Use EOFill for the even-odd fill rule.<p><b>Note:</b> This method clears the port&#39;s current path.<p>Equivalent to PostScript&#39;s &#39;fill&#39; operator.<dl class="section see"><dt>See Also<dd>IGraphicsPort::EOFill </dl></div></div><a class="anchor" id="a6f7255c7a02c9d694696871a185d2a76"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::FillPath </td><td>(</td><td class="paramtype">AGMPath *&nbsp;</td><td class="paramname"><em>path</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills the specified path using the current color server. Any path currently in the gstate is ignored. In addition, the specified path is <em>not</em> added to the gstate. However, this will perform an implicit newpath.<p>Note: The winding rule for the fill is taken from the path itself.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">path</td><td>The AGM path to fill </td></tr></table></dl></div></div><a class="anchor" id="a3a6f5ed188b108c4ead3575f3ea7136e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::grestore </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Resets the port&#39;s current graphics state. It is set to the state that was saved in the previous call to GSave.<p>Equivalent to PostScript&#39;s &#39;grestore&#39; operator. </div></div><a class="anchor" id="a3764f1bf8f80d8e61cbd49f4a02b53af"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::gsave </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">    Makes a copy of the port&#39;s current graphics state.

    The new copy becomes the port&#39;s new current state.

    The graphics state contains:

</pre> <pre>

  current clip

  current color

  current path

  current stroke settings

  current transformation matrix

</pre><p> Equivalent to PostScript&#39;s &#39;gsave&#39; operator. </div></div><a class="anchor" id="a97cab650d6155c91fe82ff7fe90f7eb2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::lineto </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Adds a line segment to the path. The segment is from the path&#39;s current point to the given point. The given point becomes the path&#39;s new current point. The path cannot be empty when this call is made.<p>Equivalent to PostScript&#39;s &#39;lineto&#39; operator. </div></div><a class="anchor" id="a4534e532778f1c060ecda9682cb29ac2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::moveto </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Begins a new subpath within the current path. It also sets the path&#39;s current point to the given point.<p><b>Note:</b> All valid paths must begin with a call to MoveTo, or HintedMoveTo.<p>Equivalent to the PostScript &#39;moveto&#39; operator. </div></div><a class="anchor" id="a8752d1d72e0ccc739835fd1f1cc8fd01"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::newpath </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clears the port&#39;s current path (makes it empty).<p>Equivalent to the PostScript &#39;newpath&#39; operator. </div></div><a class="anchor" id="aa3e276036adc9581679913b436d57e71"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::rmoveto </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Begins a new subpath within the current path. It also sets the path&#39;s current point to the path&#39;s existing current point offset by the given coordinates. The &#39;R&#39; stands for &#39;relative&#39;. The path cannot be empty when this call is made.<p>Equivalent to PostScript&#39;s &#39;rmoveto&#39; operator. </div></div><a class="anchor" id="ab238a41e1a80e2855141b1db7e01248e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::rotate </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>theta</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Rotates the port&#39;s current transformation matrix by the given number of degrees and replaces it.<p>Equivalent to PostScript&#39;s &#39;rotate&#39; operator. </div></div><a class="anchor" id="a7884b7058c973cab9b419c9c8e3e5ce9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::scale </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Scales the port&#39;s current transformation matrix. It uses the given values, which are first mapped by the current transformation matrix so that they are interpreted as being &#39;user space&#39; values.<p>Equivalent to PostScript&#39;s &#39;scale&#39; operator. </div></div><a class="anchor" id="a62ae5baa1e119bdb11c90c44c57ab4bc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::SetAlphaServer </td><td>(</td><td class="paramtype">AGMPaint *&nbsp;</td><td class="paramname"><em>agmPaint</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIsAlphaShape</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Installs a paint server as an alpha server.<p>A subsequent port call to paint, such as Fill or Stroke, will call the paint servers to paint whatever graphic has been drawn with the alpha value(s).<p>There may be both a color and an alpha paint server installed in the graphic state at the same time.<p>The alpha server must have a gray colorspace. &#39;alphaIsShape&#39; defines the alpha values as a shape (NOT opacity).<p>This server is in effect in addition to fixed alpha.<p>The optional &#39;matrix&#39; will be concatenated with current CTM.<p>TotalMatrix = paint server matrix * SetServer matrix * CTM.<p>Clients may specify an invalid CAGMPaint. In this case the alpha server is invalid, so none is defined. This is the same as RemoveAlphaServer.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_graphics_port.html#a2c9d739cbf519d3c4af5464f55ffe049">IGraphicsPort::SetColorServer</a> IGraphicsPort::RemoveAlphaServer </dl></div></div><a class="anchor" id="a9c5880d04e107a167e98f6dc9354b510"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setblendingmode </td><td>(</td><td class="paramtype">PMBlendingMode&nbsp;</td><td class="paramname"><em>pmBlendingMode</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets current blending mode in GState.<p>Blending modes are defined in <a class="el" href="_graphic_types_8h_source.html">GraphicTypes.h</a></div></div><a class="anchor" id="a2c9d739cbf519d3c4af5464f55ffe049"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::SetColorServer </td><td>(</td><td class="paramtype">AGMPaint *&nbsp;</td><td class="paramname"><em>agmPaint</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIsAlphaShape</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Installs a paint server as a color server.<p>A subsequent port call to paint, such as Fill or Stroke, will call the paint servers to paint whatever graphic has been drawn with the color value(s).<p>There may be both a color and an alpha paint server installed in the graphic state at the same time.<p>alphaIsShape defines the alpha values as a shape (NOT opacity).<p>Optional matrix will be concatenated with current CTM.<p>TotalMatrix = paint server matrix * SetServer matrix * CTM.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_graphics_port.html#a62ae5baa1e119bdb11c90c44c57ab4bc">IGraphicsPort::SetAlphaServer</a></dl></div></div><a class="anchor" id="aa7581fc201c6b8ca9e09950a63854fcc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setdash </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>numDash</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">float *&nbsp;</td><td class="paramname"><em>dashArray</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">float&nbsp;</td><td class="paramname"><em>offset</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the port&#39;s current dash pattern. This pattern is used in any later call to Stroke or StrokePathClip.<p>Equivalent to PostScript&#39;s &#39;setdash&#39; operator.<dl class="section see"><dt>See Also<dd>CAGMPort::Stroke CAGMPort::StrokePathClip </dl></div></div><a class="anchor" id="aa29a8e33a83e104271a863e7bc4bd1d8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setlinecap </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>type</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">    Sets the port&#39;s current line cap type.  This type

    is used in any later call to Stroke or StrokePathClip.

    These are the different types:

</pre> <pre>

  Butt cap

  Round cap

  Square cap

</pre><p> Equivalent to PostScript&#39;s &#39;setlinecap&#39; operator.<dl class="section see"><dt>See Also<dd><a class="el" href="_graphic_types_8h_source.html">GraphicTypes.h</a> for possible values of &#39;type&#39; </dl></div></div><a class="anchor" id="a2102b442d86a2461f3b389f9a53fa45b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setlinejoin </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>type</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">    Sets the port&#39;s current line join type.  This type

    is used in any later call to Stroke or StrokePathClip.

    Possible types are:

</pre> <pre>

  Miter join

  Round join

  Bevel join

</pre><p> Equivalent to PostScript&#39;s &#39;setlinejoin&#39; operator.<dl class="section see"><dt>See Also<dd><a class="el" href="_graphic_types_8h_source.html">GraphicTypes.h</a> for possible values of &#39;type&#39; <dd> IGraphicsPort::Stroke IGraphicsPort::StrokePathClip </dl></div></div><a class="anchor" id="ae452cb9d78e027174c921cb39b7ce596"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setlinewidth </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>width</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the port&#39;s current line width. This width is used in any later call to Stroke or StrokePathClip.<p>A stroke adjusted linewidth can be incremented in steps of .25, giving better and smoother visual results for small linewidths when antialiasing is enabled.<p>Equivalent to PostScript&#39;s &#39;setlinewidth&#39; operator.<dl class="section see"><dt>See Also<dd>IGraphicsPort::Stroke IGraphicsPort::StrokePathClip IGraphicsPort::StrokeAdjust </dl></div></div><a class="anchor" id="a4198e50815c73ccf50bd285fd4d635b4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setmiterlimit </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>limit</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the port&#39;s current miter limit. This limit is used iff the port&#39;s current join type is miter join in any later call to Stroke or StrokePathClip.<p>Equivalent to PostScript&#39;s &#39;setmiterlimit&#39; operator.<dl class="section see"><dt>See Also<dd>CAGMPort::Stroke CAGMPort::StrokePathClip </dl></div></div><a class="anchor" id="a125e113fbb15ca1b7bb01be3c931067a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setopacity </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>opacity</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIsAlphaShape</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets a constant opacity value. opacity should be between 0.0 (transparent) and (1.0) opaque. AlphaIsShape = true defines the alpha value as shape alpha. This value is in effect in addition to AlphaServer. </div></div><a class="anchor" id="a9a5b7b76c5da175110d1f950fef3860d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setoverprint </td><td>(</td><td class="paramtype">bool32&nbsp;</td><td class="paramname"><em>overprint</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets Overprint state in GState. </div></div><a class="anchor" id="a333ffec19457ee7122bdc6cdc897cdd3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::SetOverPrintMode </td><td>(</td><td class="paramtype">bool32&nbsp;</td><td class="paramname"><em>mode</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the overprint mode for the port. This setting is part of gstate so is saved by gsave and restored by grestore. By default the overprint mode is true (NZO).<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">opm,:</td><td>True for non-zero overprint; false for full overprint. </td></tr></table></dl></div></div><a class="anchor" id="afdd686f89ae302947a701b69317228e0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::SetRenderingIntent </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_port.html#acef8b102fc078866dc54471438bdb031">RenderingIntent</a>&nbsp;</td><td class="paramname"><em>intent</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the default rendering intent for any drawing that doesn&#39;t specify a particular rendering intent. This default is part of gstate so is saved by gsave and restored by grestore. By default the gstate intent is set to the document vector intent.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_color_space_mgr.html">IColorSpaceMgr</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">intent,:</td><td>The new intent to use. </td></tr></table></dl></div></div><a class="anchor" id="a91b6e7a8f9f78fa7fc24fa05cbee414f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::setstrokeadjust </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>strokeAdjust</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Defines the StrokeAdjust state in the graphics state.<p>Equivalent to PostScript&#39;s &#39;setstrokeadjust&#39; operator. </div></div><a class="anchor" id="a25756b7ad43010a56af5838879069513"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::shadingfill </td><td>(</td><td class="paramtype">AGMPaint *&nbsp;</td><td class="paramname"><em>paint</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is similar to PostScript&#39;s shfill but using a shading paint server.<p>This method is new for InDesign 3.0<dl class="section see"><dt>See Also<dd>CAGMPaint </dl></div></div><a class="anchor" id="a6cd9e394b038ebc907f6b6b18f259810"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::starttransparencygroup </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>bounds</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">AGMColorSpace *&nbsp;</td><td class="paramname"><em>cs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isolationgroup</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>knockoutgroup</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">    Starts a new transparency group.

    &#39;bounds&#39; is in user space and defines the area of the

    transparency group.

    If &#39;isIsolated&#39; is set, &#39;colorSpace&#39; defines the colorspace

    of the group. If the group is defaulted or non-isolated,

    the parent&#39;s colorspace is used.



    StartTransparencyGroup does an automatic GSave.  It inherits

    all of the current GState except for 3 parameters that are

    reset:

</pre> <pre>

SetAlpha(1.0);

RemoveAlphaServer();

SetBlendingMode(kAGMBlendNormal);

</pre><dl class="section see"><dt>See Also<dd>IGraphicsPort::SetAlpha IGraphicsPort::RemoveAlphaServer IGraphicsPort::SetBlendingMode </dl></div></div><a class="anchor" id="a3254d1be69314081d7bf80dd26fa9e3e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::stroke </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Paints a line following the port&#39;s current path with the current color and opacity. The line thickness, dash pattern, joins, and caps are determined by the port&#39;s current settings for those (see SetLineWidth, SetLineDash, SetLineJoin, and SetLineCap).<p>Equivalent to PostScript&#39;s &#39;stroke&#39; operator.<dl class="section see"><dt>See Also<dd>IGraphicsPort::SetLineWidth IGraphicsPort::SetLineDash IGraphicsPort::SetLineJoin IGraphicsPort::SetLineCap </dl></div></div><a class="anchor" id="af0472847773570b4ccced163972297ba"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::StrokePath </td><td>(</td><td class="paramtype">AGMPath *&nbsp;</td><td class="paramname"><em>path</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Strokes the specified path using the current color server. Any path currently in the gstate is ignored. In addition, the specified path is <em>not</em> added to the gstate. However, this will perform an implicit newpath.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">path</td><td>The AGM path to stroke </td></tr></table></dl></div></div><a class="anchor" id="a011049222f80a1a57217898b9274fce3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IGraphicsPort::translate </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Offsets the port&#39;s current transformation matrix. It uses the given values, which are first mapped by the current transformation matrix so that they are interpreted as being &#39;user space&#39; values.<p>Equivalent to PostScript&#39;s &#39;translate&#39; operator. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a><li class="footer">Generated on Sat Sep 22 2018 10:54:17 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
