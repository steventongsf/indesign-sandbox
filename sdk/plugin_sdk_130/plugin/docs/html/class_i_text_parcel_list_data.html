<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_text_parcel_list_data</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_text_parcel_list_data.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_text_parcel_list_data-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITextParcelListData Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><div class="dynheader"> Inheritance diagram for ITextParcelListData:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_text_parcel_list_data.png" usemap="#ITextParcelListData_map" /><map id="ITextParcelListData_map" name="ITextParcelListData_map"><area alt="IPMUnknown" coords="0,0,223,24" href="class_i_p_m_unknown.html" shape="rect" /><area alt="CPMUnknown&lt; ITextParcelListData &gt;" coords="0,112,223,136" href="class_c_p_m_unknown.html" shape="rect" /><area alt="HidTxtParcelListData" coords="0,168,223,192" href="class_hid_txt_parcel_list_data.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:aeeb62c6738a16276233e25c8e5a1b1d1"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITEXTPARCELLISTDATA }</td></tr><tr class="separator:aeeb62c6738a16276233e25c8e5a1b1d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3728794498f72098318ba84889780a28"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>nextParcelType</b> { <b>npt_box</b>, <b>npt_anypage</b>, <b>npt_oddpage</b>, <b>npt_evenpage</b> }</td></tr><tr class="separator:a3728794498f72098318ba84889780a28"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a76dcf62eb5673feb0accc61c986491dd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a76dcf62eb5673feb0accc61c986491dd"></a> virtual <a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetDataBase</b> () const =0</td></tr><tr class="separator:a76dcf62eb5673feb0accc61c986491dd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad8b3ea77d3a263cc819a5dab8e6cd595"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad8b3ea77d3a263cc819a5dab8e6cd595"></a> virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTextModelUID</b> () const =0</td></tr><tr class="separator:ad8b3ea77d3a263cc819a5dab8e6cd595"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aad60928eec9eec8767f2188afe10aa2d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aad60928eec9eec8767f2188afe10aa2d"></a> virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetFrameListUID</b> () const =0</td></tr><tr class="separator:aad60928eec9eec8767f2188afe10aa2d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae9ce39c169a2d5cdf9f8f8f1dcf3372a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae9ce39c169a2d5cdf9f8f8f1dcf3372a"></a> virtual <a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryStoryThread</b> () const =0</td></tr><tr class="separator:ae9ce39c169a2d5cdf9f8f8f1dcf3372a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2c8eb5c0250a1a4f4cd17472cedc14c1"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a2c8eb5c0250a1a4f4cd17472cedc14c1">GetParcelIsDamaged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a2c8eb5c0250a1a4f4cd17472cedc14c1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4dc8387cb2a138d372776d6007ec8eb7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4dc8387cb2a138d372776d6007ec8eb7"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelDamaged</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a4dc8387cb2a138d372776d6007ec8eb7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7dd751d782eb3637a14cfd8c4cb20893"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7dd751d782eb3637a14cfd8c4cb20893"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClearParcelDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a7dd751d782eb3637a14cfd8c4cb20893"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae583b95c9efad7ecd78e597f5a773d30"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#ae583b95c9efad7ecd78e597f5a773d30">GetParcelNeedsWrapCheck</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:ae583b95c9efad7ecd78e597f5a773d30"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8bdd15ce832267ca1f920fdb0d38ad1a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a8bdd15ce832267ca1f920fdb0d38ad1a">SetParcelNeedsWrapCheck</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a8bdd15ce832267ca1f920fdb0d38ad1a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9a7a30585bc772d243e9d691cbe2a28b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a9a7a30585bc772d243e9d691cbe2a28b">ClearParcelNeedsWrapCheck</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a9a7a30585bc772d243e9d691cbe2a28b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a442a74cd22c089ac8fb36310e7fa3d9d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a442a74cd22c089ac8fb36310e7fa3d9d"></a> virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelTextStart</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a442a74cd22c089ac8fb36310e7fa3d9d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a93c64c86b2ce087f046cf0f35cd3f433"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a93c64c86b2ce087f046cf0f35cd3f433"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelTextSpan</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a93c64c86b2ce087f046cf0f35cd3f433"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6c7456acaf92b452043efe24d3951905"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6c7456acaf92b452043efe24d3951905"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelTextSpan</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, TextIndex span)=0</td></tr><tr class="separator:a6c7456acaf92b452043efe24d3951905"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a46ddd4bb89f2b603abfdd2852de84003"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a46ddd4bb89f2b603abfdd2852de84003"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelContaining</b> (TextIndex at) const =0</td></tr><tr class="separator:a46ddd4bb89f2b603abfdd2852de84003"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6bc4d73bcdc4db78d96cda02c5e78e24"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6bc4d73bcdc4db78d96cda02c5e78e24"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelVContentBounds</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_p_m_real.html">PMReal</a> *pTop, <a class="el" href="class_p_m_real.html">PMReal</a> *pBottom) const =0</td></tr><tr class="separator:a6bc4d73bcdc4db78d96cda02c5e78e24"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aec8dc26a211ab63897c1a9417cd0072e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aec8dc26a211ab63897c1a9417cd0072e"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelVContentBounds</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_p_m_real.html">PMReal</a> top, <a class="el" href="class_p_m_real.html">PMReal</a> bottom)=0</td></tr><tr class="separator:aec8dc26a211ab63897c1a9417cd0072e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a42914c7e584f9e51cab94d118b7fc7f8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a42914c7e584f9e51cab94d118b7fc7f8">GetParcelHasPositionDependentContent</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a42914c7e584f9e51cab94d118b7fc7f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5cda0dd4dca813f01769df5b9f0c9eb3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5cda0dd4dca813f01769df5b9f0c9eb3"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasPositionDependentContent</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 v)=0</td></tr><tr class="separator:a5cda0dd4dca813f01769df5b9f0c9eb3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaa649f2f8c4f224ab3be2476c33707a1"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#aaa649f2f8c4f224ab3be2476c33707a1">GetParcelHasKeepsOn</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:aaa649f2f8c4f224ab3be2476c33707a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab9c31bd1cd29b9b431751671a368da47"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab9c31bd1cd29b9b431751671a368da47"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasKeepsOn</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 v)=0</td></tr><tr class="separator:ab9c31bd1cd29b9b431751671a368da47"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a317ec95ddd86feb681ef030ce9683bd1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a317ec95ddd86feb681ef030ce9683bd1"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelHasBeenVJed</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a317ec95ddd86feb681ef030ce9683bd1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abb65222c6cc07fe7ac3bb0078f117b06"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abb65222c6cc07fe7ac3bb0078f117b06"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasBeenVJed</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 vj)=0</td></tr><tr class="separator:abb65222c6cc07fe7ac3bb0078f117b06"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3269ddb9b1efd6c5023dd15a97d779ea"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3269ddb9b1efd6c5023dd15a97d779ea"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelHasGridAlignedWax</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a3269ddb9b1efd6c5023dd15a97d779ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a860e483f94b5aaad72ae561ee4be68e4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a860e483f94b5aaad72ae561ee4be68e4"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasGridAlignedWax</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 v)=0</td></tr><tr class="separator:a860e483f94b5aaad72ae561ee4be68e4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad1cf216edd4d0145c4e6331e13383141"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad1cf216edd4d0145c4e6331e13383141"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelHasNeedsPostProcessWax</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:ad1cf216edd4d0145c4e6331e13383141"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa1516d860e794bc8545ac711d852ee0e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa1516d860e794bc8545ac711d852ee0e"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHasNeedsPostProcessWax</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 v)=0</td></tr><tr class="separator:aa1516d860e794bc8545ac711d852ee0e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4b1bd4999288a53f70814d3382231459"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a4b1bd4999288a53f70814d3382231459">GetFirstLogicalParcelKey</a> (int32 *pIndex=nil) const =0</td></tr><tr class="separator:a4b1bd4999288a53f70814d3382231459"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a760f0c26fb240bed67840ffe85134a48"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a760f0c26fb240bed67840ffe85134a48">GetNextLogicalParcelKey</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, int32 *pIndex=nil) const =0</td></tr><tr class="separator:a760f0c26fb240bed67840ffe85134a48"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aff04d5f65096fa5a54431f7be720ca80"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#aff04d5f65096fa5a54431f7be720ca80">GetNextLogicalParcelKeyByType</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, nextParcelType pType, int32 *pIndex=nil) const =0</td></tr><tr class="separator:aff04d5f65096fa5a54431f7be720ca80"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af89ceb15f6a8a5e553b16fb5210d087e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#af89ceb15f6a8a5e553b16fb5210d087e">GetPreviousLogicalParcelKey</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, int32 *pIndex=nil) const =0</td></tr><tr class="separator:af89ceb15f6a8a5e553b16fb5210d087e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1c866162eab0f8169b46a1fa7993cf34"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a1c866162eab0f8169b46a1fa7993cf34">GetLastLogicalParcelKey</a> (int32 *pIndex=nil) const =0</td></tr><tr class="separator:a1c866162eab0f8169b46a1fa7993cf34"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa0c5675829b073180dd2169cb46d2c96"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#aa0c5675829b073180dd2169cb46d2c96">GetLastLogicalNonOversetParcelKey</a> (int32 *pIndex=nil) const =0</td></tr><tr class="separator:aa0c5675829b073180dd2169cb46d2c96"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a37b496268cb2347be80c0ff6fff6954d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a37b496268cb2347be80c0ff6fff6954d"></a> virtual Text::FirstLineOffsetMetric&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelFirstLineOffsetMetric</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a37b496268cb2347be80c0ff6fff6954d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a784fe4a9e8e14e55cabbf5523e5409b3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a784fe4a9e8e14e55cabbf5523e5409b3"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelMinFirstLineOffset</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a784fe4a9e8e14e55cabbf5523e5409b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4d4361b4db4301fac5c8fcd9b6b8577d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4d4361b4db4301fac5c8fcd9b6b8577d"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsVertical</b> () const =0</td></tr><tr class="separator:a4d4361b4db4301fac5c8fcd9b6b8577d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9129ed5ffd7d4a9866932946963f0e04"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9129ed5ffd7d4a9866932946963f0e04"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsRightToLeft</b> () const =0</td></tr><tr class="separator:a9129ed5ffd7d4a9866932946963f0e04"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adec63cbf17197639d5820e6b68ebedd1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="adec63cbf17197639d5820e6b68ebedd1"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelMaxSoftBottomHeight</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:adec63cbf17197639d5820e6b68ebedd1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae1a6ded52494ce02465c3077af065f4d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae1a6ded52494ce02465c3077af065f4d"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelMaxSoftBottomHeight</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_p_m_real.html">PMReal</a> maxHeight)=0</td></tr><tr class="separator:ae1a6ded52494ce02465c3077af065f4d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a41a23199b8f2d0cea2657a70d804e009"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a41a23199b8f2d0cea2657a70d804e009"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelIsValidStartBreakLocation</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, Text::StartBreakLocation mode) const =0</td></tr><tr class="separator:a41a23199b8f2d0cea2657a70d804e009"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0e426378065cdca576626d912197dc05"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0e426378065cdca576626d912197dc05"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetHasAnyValidStartBreakLocation</b> () const =0</td></tr><tr class="separator:a0e426378065cdca576626d912197dc05"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5886a9beddc67d5874b254e4050e1ba6"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a5886a9beddc67d5874b254e4050e1ba6">GetParcelSupportsWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a5886a9beddc67d5874b254e4050e1ba6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae100ac1e00fa954af4ed05820236abaa"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#ae100ac1e00fa954af4ed05820236abaa">GetParcelIgnoringWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:ae100ac1e00fa954af4ed05820236abaa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a983208261f721dd4e7da3d49c7a8d78d"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a983208261f721dd4e7da3d49c7a8d78d">GetWaxAnchoredElementCount</a> () const =0</td></tr><tr class="separator:a983208261f721dd4e7da3d49c7a8d78d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9a7778e0e26d86edbaa2e17f21cc2059"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a9a7778e0e26d86edbaa2e17f21cc2059">GetWaxAnchoredElementIndex</a> (<a class="el" href="class_i_d_type.html">UID</a> uid) const =0</td></tr><tr class="separator:a9a7778e0e26d86edbaa2e17f21cc2059"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a00d7bb967f85226dddddf12de8b6a326"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a00d7bb967f85226dddddf12de8b6a326">InsertNthWaxAnchoredElement</a> (int32 n, <a class="el" href="class_i_d_type.html">UID</a> uid)=0</td></tr><tr class="separator:a00d7bb967f85226dddddf12de8b6a326"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a14ee82c9184fa2a709932569cbac0fca"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a14ee82c9184fa2a709932569cbac0fca">RemoveNthWaxAnchoredElement</a> (int32 n)=0</td></tr><tr class="separator:a14ee82c9184fa2a709932569cbac0fca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9a640754fcbb9c254a1781e9840012cf"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a9a640754fcbb9c254a1781e9840012cf">GetNthWaxAnchoredElementUID</a> (int32 n) const =0</td></tr><tr class="separator:a9a640754fcbb9c254a1781e9840012cf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a11e0216919f674b6a59adff44012815a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a11e0216919f674b6a59adff44012815a">GetNthWaxAnchoredElementParcelKey</a> (int32 n) const =0</td></tr><tr class="separator:a11e0216919f674b6a59adff44012815a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a63a1b93ac3e71f26295ba41d9be9050a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a63a1b93ac3e71f26295ba41d9be9050a">SetNthWaxAnchoredElementParcelKey</a> (int32 n, <a class="el" href="class_parcel_key.html">ParcelKey</a> Key)=0</td></tr><tr class="separator:a63a1b93ac3e71f26295ba41d9be9050a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a92eeb50a8d366f50508da3620742bd6e"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a92eeb50a8d366f50508da3620742bd6e">GetWaxAnchoredElementsIn</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_u_i_d_list.html">UIDList</a> *list=nil) const =0</td></tr><tr class="separator:a92eeb50a8d366f50508da3620742bd6e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aefdd7d6af9c26b74b7b48569e1c0f912"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#aefdd7d6af9c26b74b7b48569e1c0f912">GetFirstDamagedParcel</a> () const =0</td></tr><tr class="separator:aefdd7d6af9c26b74b7b48569e1c0f912"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c5657fa7531fc46c822d09ba0683e87"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a8c5657fa7531fc46c822d09ba0683e87">GetFirstKeyIndexes</a> (int32 &amp;damagedKeyIndex, int32 &amp;needWrapCheckKeyIndex) const =0</td></tr><tr class="separator:a8c5657fa7531fc46c822d09ba0683e87"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5b530dade5276d8c376f64e9809b602b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5b530dade5276d8c376f64e9809b602b"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>ShouldFakeTabAlignToChar</b> () const =0</td></tr><tr class="separator:a5b530dade5276d8c376f64e9809b602b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5ffc2d7676497cbce58b43590e3632fc"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5ffc2d7676497cbce58b43590e3632fc"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InvalidateParcelComposedState</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a5ffc2d7676497cbce58b43590e3632fc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af94fb45f5c9b425ca3c57fe2aa8c1c3a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af94fb45f5c9b425ca3c57fe2aa8c1c3a"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>NotifyParcelParentInkBoundsChanged</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:af94fb45f5c9b425ca3c57fe2aa8c1c3a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ada7c49552a8c781a14b34d2fde61d6eb"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#ada7c49552a8c781a14b34d2fde61d6eb">GetParcelsOnSpread</a> (const <a class="el" href="class_i_spread.html">ISpread</a> *spread, <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_parcel_key.html">ParcelKey</a> &gt; &amp;keyList) const =0</td></tr><tr class="separator:ada7c49552a8c781a14b34d2fde61d6eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa29183d374f61f71e9c3abc76d0dec79"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#aa29183d374f61f71e9c3abc76d0dec79">GetNonInlineWrapsForParcel</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList) const =0</td></tr><tr class="separator:aa29183d374f61f71e9c3abc76d0dec79"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af870a324279a8fd2adafad5f4a4c6abb"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#af870a324279a8fd2adafad5f4a4c6abb">AddParcelWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef, bool16 isActive, bool16 isNonInline, bool16 isInlineToParcel)=0</td></tr><tr class="separator:af870a324279a8fd2adafad5f4a4c6abb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6268b7168cd0dd0fa7c7f914f566cf8a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a6268b7168cd0dd0fa7c7f914f566cf8a">GetParcelWrapActive</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef) const =0</td></tr><tr class="separator:a6268b7168cd0dd0fa7c7f914f566cf8a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad35e2a5d917634cf9ed29b4395ed81e7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#ad35e2a5d917634cf9ed29b4395ed81e7">SetParcelWrapActive</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a>, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)=0</td></tr><tr class="separator:ad35e2a5d917634cf9ed29b4395ed81e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6fd2018803513f9a537f58ffca7622ab"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a6fd2018803513f9a537f58ffca7622ab">ClearParcelWrapActive</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)=0</td></tr><tr class="separator:a6fd2018803513f9a537f58ffca7622ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a9ac32ef29a5f89908b8bb237dd49dd"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a5a9ac32ef29a5f89908b8bb237dd49dd">GetParcelWrapIsNonInline</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef) const =0</td></tr><tr class="separator:a5a9ac32ef29a5f89908b8bb237dd49dd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af41b0ba6a6534c72cac1c612538a6b5d"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#af41b0ba6a6534c72cac1c612538a6b5d">GetParcelWrapIsInlineToParcel</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef) const =0</td></tr><tr class="separator:af41b0ba6a6534c72cac1c612538a6b5d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a91ede28c843addfa91693fa3683572cd"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a91ede28c843addfa91693fa3683572cd">GetParcelWrapHasOverlappedRange</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef) const =0</td></tr><tr class="separator:a91ede28c843addfa91693fa3683572cd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aca08ae9881af6aa7227b7b8c97e28245"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#aca08ae9881af6aa7227b7b8c97e28245">GetParcelWrapOverlappedRange</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYTop, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYBottom) const =0</td></tr><tr class="separator:aca08ae9881af6aa7227b7b8c97e28245"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a73fdaf82900bee14329ab427451787c9"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a73fdaf82900bee14329ab427451787c9">SetParcelWrapOverlappedRange</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYTop, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYBottom)=0</td></tr><tr class="separator:a73fdaf82900bee14329ab427451787c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:add1502021e05fff9101e720f7dc0720e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#add1502021e05fff9101e720f7dc0720e">GetParcelHasWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:add1502021e05fff9101e720f7dc0720e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa2687fb2cd311d4c8631bf395d9db1b7"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#aa2687fb2cd311d4c8631bf395d9db1b7">GetParcelWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList) const =0</td></tr><tr class="separator:aa2687fb2cd311d4c8631bf395d9db1b7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aef736194419d26a706ad991213296c32"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#aef736194419d26a706ad991213296c32">GetParcelHasActiveNonInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:aef736194419d26a706ad991213296c32"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af4fc98435af9d88b283982a7065a3753"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#af4fc98435af9d88b283982a7065a3753">GetParcelActiveNonInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList) const =0</td></tr><tr class="separator:af4fc98435af9d88b283982a7065a3753"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9204a400330584040254c3f9da78e584"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a9204a400330584040254c3f9da78e584">GetParcelHasActiveInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a9204a400330584040254c3f9da78e584"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4b0edc1991bb0f38a6e9966efb5a310d"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a4b0edc1991bb0f38a6e9966efb5a310d">GetParcelActiveInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList) const =0</td></tr><tr class="separator:a4b0edc1991bb0f38a6e9966efb5a310d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4178fed678a996ac0ff8cabaa502927c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a4178fed678a996ac0ff8cabaa502927c">RemoveParcelWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)=0</td></tr><tr class="separator:a4178fed678a996ac0ff8cabaa502927c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9466682de1f186d4c8b19a341fda8f8a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_data.html#a9466682de1f186d4c8b19a341fda8f8a">GetSupportsColumnSpanType</a> (<a class="el" href="class_i_composition_style.html#ab343b6d3bfdd9dc869daf2ef87bbbf9e">ICompositionStyle::SpanColumnsTypeOptions</a> spanType) const =0</td></tr><tr class="separator:a9466682de1f186d4c8b19a341fda8f8a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="af870a324279a8fd2adafad5f4a4c6abb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::AddParcelWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isActive</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isNonInline</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isInlineToParcel</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_parcel_key.html">ParcelKey</a></td><td></td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss with active <a class="el" href="class_i_stand_off.html">IStandOff</a></td></tr><tr><td class="paramname">isActive</td><td>kTrue if the Wrap can be tiled against </td></tr><tr><td class="paramname">isNonInline</td><td>kTrue if the Wrap is not the child of an Inline </td></tr><tr><td class="paramname">isInlineToParcel</td><td>kTrue if the Wrap is the child of an Inline that is anchored in the Parcel. If kTrue, then sodRef.fX/YOffset are expected to be zero. </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#ae2f37a1249d2b35f79b8eb30a9aca551">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a9a7a30585bc772d243e9d691cbe2a28b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::ClearParcelNeedsWrapCheck </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clears the wrap check from the specified Parcel. During composition the TextParcelList will cause this to be cleared when it processes a Parcel following the one currently being composed. It is the responsiblity of the implementation to process the Parcel in which composition begins. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a58d6631f27e464197f5e2b7ca86413c5">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a6fd2018803513f9a537f58ffca7622ab"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::ClearParcelWrapActive </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodUID</td><td>UID of wrap boss with active <a class="el" href="class_i_stand_off_data.html">IStandOffData</a> interface </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a60723827425eb02ed9767980aa6017f2">HidTxtParcelListData</a>.</div></div><a class="anchor" id="aefdd7d6af9c26b74b7b48569e1c0f912"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelListData::GetFirstDamagedParcel </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the first Parcel in the ParcelList which is is damaged. If no Parcel is damaged then an invalid <a class="el" href="class_parcel_key.html">ParcelKey</a> returned. Note that this only refers to Parcels which are damaged, NOT those that need wrap check. <dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a37076c05bbc8f37e6a05bd3985fe5bae">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a8c5657fa7531fc46c822d09ba0683e87"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::GetFirstKeyIndexes </td><td>(</td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>damagedKeyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>needWrapCheckKeyIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method returns information about the first Parcel which is damaged and the first Parcel which needs wrap check. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">damagedKeyIndex</td><td>Reference to int32 which will be filled in with the index of the first Parcel which is damaged, or -1 if none </td></tr><tr><td class="paramname">needWrapCheckKeyIndex</td><td>Reference to int32 which will be filled in with the index of the first Parcel which needs wrap check, or -1 if none </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a71e092115e301b18240d57abd543acbb">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a4b1bd4999288a53f70814d3382231459"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelListData::GetFirstLogicalParcelKey </td><td>(</td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em> = <code>nil</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel logicaly first. In terms of this API, a logical Parcel is one that text can be composed in. Typical implementations have these as one-to-one with all the Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a> but implementations such as Table Header and Footer cells have only the first Parcel as logically composable and the rest have no Text content at all. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be set to -1. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the first logical Parcel. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a1ac5ce09c043ba120be338c98da1ce3f">HidTxtParcelListData</a>.</div></div><a class="anchor" id="aa0c5675829b073180dd2169cb46d2c96"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelListData::GetLastLogicalNonOversetParcelKey </td><td>(</td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em> = <code>nil</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method allows the implementation to control the meaning of overset. Implementations which do not support overmatter Parcels will return the same value for this method as <a class="el" href="class_i_text_parcel_list_data.html#a1c866162eab0f8169b46a1fa7993cf34">GetLastLogicalParcelKey()</a>. Those that do support overmatter Parcel should return the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the last Parcel before the first overmatter Parcel. <a class="el" href="class_i_text_parcel_list.html#aee736e63fa9aa6271e4090cd64d10a94">ITextParcelList::GetIsOverset()</a> will use the returned <a class="el" href="class_parcel_key.html">ParcelKey</a> as the measure of overset content. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be filled in with the count of Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of last logical non-overset Parcel </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#aea659edc56055968df87a125febdbe29">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a1c866162eab0f8169b46a1fa7993cf34"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelListData::GetLastLogicalParcelKey </td><td>(</td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em> = <code>nil</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel logicaly last. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be set to the count of Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the last logical Parcel. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a5c12269144d5cea8685fe0d801b8e191">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a760f0c26fb240bed67840ffe85134a48"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelListData::GetNextLogicalParcelKey </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel logically after the specified key. If the key is invalid, an invalid key will be returned. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be filled in with the count of Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the next logical Parcel. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a39936cd94cf7a53828b9c78bbd153ddc">HidTxtParcelListData</a>.</div></div><a class="anchor" id="aff04d5f65096fa5a54431f7be720ca80"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelListData::GetNextLogicalParcelKeyByType </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">nextParcelType&nbsp;</td><td class="paramname"><em>pType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the specified Parcel Type logically after the specified key. If the specified Key is already the type of Parcel desired then the key returned will be unchanged. If the key is invalid, an invalid key will be returned. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">pType</td><td>Type of Parcel the caller wishes to move to. If the </td></tr><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be filled in with the count of Parcels in the <a class="el" href="class_i_parcel_list.html">IParcelList</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the next logical Parcel. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a9cfe96a1cd274feced08ebf1a3e6d66e">HidTxtParcelListData</a>.</div></div><a class="anchor" id="aa29183d374f61f71e9c3abc76d0dec79"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextParcelListData::GetNonInlineWrapsForParcel </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specfied list with all the non-Inline Wraps which the implementation determines are possible overlaps for the specified Parcel. Note that this is expected to be the same as or superset of the Wraps currently known to the Parcel as returned by <a class="el" href="class_i_text_parcel_list_data.html#aa2687fb2cd311d4c8631bf395d9db1b7">GetParcelWraps()</a>. The TextParcelList will be responsible for adding these Wraps to the Parcel in a separate step. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodList</td><td>Reference to TextWrapRefList to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of Wraps added to the list </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a95eeecccf9da276eebf0a7ae58fded23">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a11e0216919f674b6a59adff44012815a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelListData::GetNthWaxAnchoredElementParcelKey </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Nth element. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>An index into the internal list. Must be greater than or equal to zero and less then the value returned by <a class="el" href="class_i_text_parcel_list_data.html#a983208261f721dd4e7da3d49c7a8d78d">GetWaxAnchoredElementCount()</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a6359bd209105cfe69491a897ee342c65">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a9a640754fcbb9c254a1781e9840012cf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITextParcelListData::GetNthWaxAnchoredElementUID </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the UID of the Nth element. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>An index into the internal list. Must be greater than or equal to zero and less then the value returned by <a class="el" href="class_i_text_parcel_list_data.html#a983208261f721dd4e7da3d49c7a8d78d">GetWaxAnchoredElementCount()</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The UID </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a2af5e60c4cd54adb842be7185fe9d20f">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a4b0edc1991bb0f38a6e9966efb5a310d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextParcelListData::GetParcelActiveInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specfied list with all the Wraps currently added to the Parcel which report being active and are a child of an Inline. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodList</td><td>Reference to TextWrapRefList to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of Wraps added to the list </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a4471e227b1b41e3b4169f7b69e1e0aac">HidTxtParcelListData</a>.</div></div><a class="anchor" id="af4fc98435af9d88b283982a7065a3753"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextParcelListData::GetParcelActiveNonInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specfied list with all the Wraps currently added to the Parcel which report being active and are not the child of an Inline. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodList</td><td>Reference to TextWrapRefList to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of Wraps added to the list </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a4b0c3a6b84855a150614a34cdd1a081d">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a9204a400330584040254c3f9da78e584"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelHasActiveInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the specified Parcel has any active Wraps which are a child of an Inline. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel has any Wraps added to it. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a80a84c5167ef90e54c50b4fe335beb55">HidTxtParcelListData</a>.</div></div><a class="anchor" id="aef736194419d26a706ad991213296c32"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelHasActiveNonInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the specified Parcel has any active Wraps which are not a child of an Inline. added to it. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel has any Wraps added to it. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a079ec5bfa64660fedc3c263abebea934">HidTxtParcelListData</a>.</div></div><a class="anchor" id="aaa649f2f8c4f224ab3be2476c33707a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelHasKeepsOn </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The TextParcelList will set this value if the contents of the Parcel has any keeps on <p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#aa7fce26fc1acdd8d3e5e9978a00b09f9">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a42914c7e584f9e51cab94d118b7fc7f8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelHasPositionDependentContent </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The TextParcelList will set this value if the contents of the Parcel, including Wax, OwnedItems, WaxAnchoredElements and even Wraps require it. <p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a1254ff28615ca39047df73005b1e9f03">HidTxtParcelListData</a>.</div></div><a class="anchor" id="add1502021e05fff9101e720f7dc0720e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelHasWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the specified Parcel has any Wraps added to it. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel has any Wraps added to it. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a34636e3aac04883c64f0e03cce6d7302">HidTxtParcelListData</a>.</div></div><a class="anchor" id="ae100ac1e00fa954af4ed05820236abaa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelIgnoringWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the Parcel is ignoring the effect of all Wraps. Note that the Wraps will still be added to the Parcel, but they will be handled as invalid due to ZOrder. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel is ignoring the effect of all Wraps. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#af70252988a7941099f3e5f685a35e1ca">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a2c8eb5c0250a1a4f4cd17472cedc14c1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelIsDamaged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>A Parcel with TextDamage needs recomposition. <p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a2456e596207a6ec09fcba527464d1a14">HidTxtParcelListData</a>.</div></div><a class="anchor" id="ae583b95c9efad7ecd78e597f5a773d30"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelNeedsWrapCheck </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Parcels which are marked as needing Wrap check are suspected of having new intersecting Wraps available through <a class="el" href="class_i_text_parcel_list_data.html#aa29183d374f61f71e9c3abc76d0dec79">GetNonInlineWrapsForParcel()</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel needs to check wrap </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#aac6fbce1cc380fb12b6b624c0bc01065">HidTxtParcelListData</a>.</div></div><a class="anchor" id="ada7c49552a8c781a14b34d2fde61d6eb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextParcelListData::GetParcelsOnSpread </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_spread.html">ISpread</a> *&nbsp;</td><td class="paramname"><em>spread</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_parcel_key.html">ParcelKey</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>keyList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the list of Parcels that are on the specified <a class="el" href="class_i_spread.html">ISpread</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spread</td><td>Pointer to <a class="el" href="class_i_spread.html">ISpread</a> interface </td></tr><tr><td class="paramname">keyList</td><td><a class="el" href="class_k2_vector.html">K2Vector</a> of ParcelKeys to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of ParcelKeys added to keyList </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a0bb16702c203476a2a518f32af168f3e">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a5886a9beddc67d5874b254e4050e1ba6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelSupportsWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kFalse if the Parcel does not support Wraps. This is different from ignoring in that one can stop ignoring sometime in the future whereas one will not suddenly support Wraps. Examples of implementations which do not support Wraps are TextOnPath. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel supports Wraps. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a3abc2865da16e7b84a0ca20d91ae8a90">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a6268b7168cd0dd0fa7c7f914f566cf8a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelWrapActive </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the active state of the StandOff relative to the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a23989d61a3dc84fb52578a4f7d42e32a">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a91ede28c843addfa91693fa3683572cd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelWrapHasOverlappedRange </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a4a09c51fdb921e3cd28b2beae90d56a8">HidTxtParcelListData</a>.</div></div><a class="anchor" id="af41b0ba6a6534c72cac1c612538a6b5d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelWrapIsInlineToParcel </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Wraps which are Inline to the Parcel are those that are anchored in the Parcel. Wraps that are children of Inlines that are NOt inline to the Parcel are anchored at a TextIndex previous to the start of the Parcel. This state is set when the Wrap is added to the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a24f5eb4691002327ebd74762807f0aa8">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a5a9ac32ef29a5f89908b8bb237dd49dd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetParcelWrapIsNonInline </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the non-inline state of the StandOff. Wraps which are non-inline are NOT children of an Inline - typically they are children of the Spread. This state is set when the Wrap is added to the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#ac75c74203c2b76849a5eadfc3f3baf0e">HidTxtParcelListData</a>.</div></div><a class="anchor" id="aca08ae9881af6aa7227b7b8c97e28245"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::GetParcelWrapOverlappedRange </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>waxYTop</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>waxYBottom</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a34574efb57b41570c5b1f9065d3fea02">HidTxtParcelListData</a>.</div></div><a class="anchor" id="aa2687fb2cd311d4c8631bf395d9db1b7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextParcelListData::GetParcelWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specfied list with all the Wraps currently added to the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodList</td><td>Reference to TextWrapRefList to be filled in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of Wraps added to the list </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a6ba4fc3ef53b62153eb0546879915a3a">HidTxtParcelListData</a>.</div></div><a class="anchor" id="af89ceb15f6a8a5e553b16fb5210d087e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelListData::GetPreviousLogicalParcelKey </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pIndex</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel logically previous to the specified key. If the key is invalid, an invalid key will be returned. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">pIndex</td><td>Optional pointer which will be filled in with the index of the returned <a class="el" href="class_parcel_key.html">ParcelKey</a>. If the returned Parcel is invalid then pIndex will be set to -1. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the next logical Parcel. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a5cb51802e4814b5270080c381fad9547">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a9466682de1f186d4c8b19a341fda8f8a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelListData::GetSupportsColumnSpanType </td><td>(</td><td class="paramtype"><a class="el" href="class_i_composition_style.html#ab343b6d3bfdd9dc869daf2ef87bbbf9e">ICompositionStyle::SpanColumnsTypeOptions</a>&nbsp;</td><td class="paramname"><em>spanType</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>All implementations must support ICompositionStyle::kSingleColumn. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spanType</td><td>Span type to check </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the implementation supports the specified span type. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#af729000d6a8d1b467dd85d6334c164c2">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a983208261f721dd4e7da3d49c7a8d78d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextParcelListData::GetWaxAnchoredElementCount </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>The number of WaxAnchoredElement known to the implementation. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a6a62852b5019f98982cfd82111e071c0">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a9a7778e0e26d86edbaa2e17f21cc2059"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextParcelListData::GetWaxAnchoredElementIndex </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>uid</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the index of the specified WaxAnchoredElement. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">uid</td><td>The UID of the desired WaxAnchoredElement boss. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The index of the specified WaxAnchoredElement or -1 if it is not known to the implementation. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a5b624969e8342ddec15bba7651775a55">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a92eeb50a8d366f50508da3620742bd6e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextParcelListData::GetWaxAnchoredElementsIn </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>list</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the specified <a class="el" href="class_u_i_d_list.html">UIDList</a> with UIDs of the WaxAnchoredElements in the specified Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">list</td><td>Optional <a class="el" href="class_u_i_d_list.html">UIDList</a> to append to. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>count of WaxAnchoredElements returned. </dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#abc4d75b95986a138d3f99eb27b0cd903">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a00d7bb967f85226dddddf12de8b6a326"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::InsertNthWaxAnchoredElement </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>uid</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>A new WaxAnchoredElement is inserted into the list. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>An index into the internal list. Must be greater than or equal to zero and less than OR equal to the value returned by <a class="el" href="class_i_text_parcel_list_data.html#a983208261f721dd4e7da3d49c7a8d78d">GetWaxAnchoredElementCount()</a>. </td></tr><tr><td class="paramname">uid</td><td>The UID of the WaxAnchoredElement. Must not already be known to the implementation. </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a510b8ec28b9d22fb7376f817f555470d">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a14ee82c9184fa2a709932569cbac0fca"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::RemoveNthWaxAnchoredElement </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The specified WaxAnchoredElement is removed from the list. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>An index into the internal list. Must be greater than or equal to zero and less then the value returned by <a class="el" href="class_i_text_parcel_list_data.html#a983208261f721dd4e7da3d49c7a8d78d">GetWaxAnchoredElementCount()</a>. </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#ae90353444b2934f1a485188667759bba">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a4178fed678a996ac0ff8cabaa502927c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::RemoveParcelWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#af5414f58644775ea998dfb5861286f8f">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a63a1b93ac3e71f26295ba41d9be9050a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::SetNthWaxAnchoredElementParcelKey </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>Key</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Nth element. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td><a class="el" href="class_parcel_key.html">ParcelKey</a>. </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a8454968c6e6c9c4a2a85fb777431fb90">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a8bdd15ce832267ca1f920fdb0d38ad1a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::SetParcelNeedsWrapCheck </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>It is the responsibility of the container implementation to mark Parcels as needing Wrap check through this method when it knowns that Wraps which are not Inline to the Parcel might affect it.<p>Typically this means that the implementation has to wait until the Parcel has finished its movement to determine the effect - it is not necessarily correct to simply mark all moving or resizing Parcels as needing Wrap check.<p>Furthermore, the implementation is also responsible for determing what appropriate &quot;damage&quot; is required in order to trigger evaluation of the Wrap. Parcels which are beyond the end of the composed Thread do not necessarily have to be composed<p>The TextParcelList ONLY calls this method when processing Wraps from Inlines via AddParcelInlineWraps(). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a1b2d3184f50136c8bd4829e6170f1fc0">HidTxtParcelListData</a>.</div></div><a class="anchor" id="ad35e2a5d917634cf9ed29b4395ed81e7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::SetParcelWrapActive </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname">, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#aa616b0c2a379040b5b5b8d922f3eb452">HidTxtParcelListData</a>.</div></div><a class="anchor" id="a73fdaf82900bee14329ab427451787c9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelListData::SetParcelWrapOverlappedRange </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>waxYTop</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>waxYBottom</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel to search in. </td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> to wrap boss </td></tr></table></dl><p>Implemented in <a class="el" href="class_hid_txt_parcel_list_data.html#a0d99295d273eea313b078717e7c6312f">HidTxtParcelListData</a>.</div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_text_parcel_list_data.html">ITextParcelListData</a><li class="footer">Generated on Sat Sep 22 2018 10:54:31 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
