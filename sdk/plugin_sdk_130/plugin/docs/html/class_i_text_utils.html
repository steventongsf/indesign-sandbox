<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_text_utils</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_text_utils.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#nested-classes">Classes</a> | <a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_text_utils-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITextUtils Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_text_utils_8h_source.html">ITextUtils.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ITextUtils:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_text_utils.png" usemap="#ITextUtils_map" /><map id="ITextUtils_map" name="ITextUtils_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> Classes</h2></td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_text_utils_1_1_text_attrs.html">TextAttrs</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_text_utils_1_1_which_text_attrs.html">WhichTextAttrs</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a606c5b68a8c9a0a343b15f3ef3c696c8"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITEXTUTILS }</td></tr><tr class="separator:a606c5b68a8c9a0a343b15f3ef3c696c8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3acb640ea65f12df87390446686b591e"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591e">DisplayNamesFlag</a> { <a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591ea4311d22ed451e85153feeff25e535ce1">kCombineSingleStyleIntoFamilyName</a>, <a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591ea4911065de57f4c867190cc99baf4275a">kSeparateFamilyAndStyleName</a>, <a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591eabc96dac08691c3449937d005d741d795">kStyleNameOnly</a>, <a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591eab1cff394a8c29387bac6f4a42ce153e8">kFamilyNameOnly</a> }</td></tr><tr class="separator:a3acb640ea65f12df87390446686b591e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adf5b3f26a4fd3c9f278d925be7cc6fe3"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#adf5b3f26a4fd3c9f278d925be7cc6fe3">WordCountUpdateAction</a> { <b>kUpdateAll</b> = 0, <b>kUpdateLine</b>, <b>kNoAction</b> }</td></tr><tr class="separator:adf5b3f26a4fd3c9f278d925be7cc6fe3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a140afe1e016089c192144f6d9907167e"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>WordCountUpdateState</b> { <br /> &nbsp;&nbsp;<b>kStartCounting</b> = 0, <b>kCustomizeStartCounting</b>, <b>kContinueCounting</b>, <b>kContinueCountingForComposedFrame</b>, <br /> &nbsp;&nbsp;<b>kEndCounting</b><br /> }</td></tr><tr class="separator:a140afe1e016089c192144f6d9907167e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa8b9124764a96c9f4b3883c41ae08797"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aa8b9124764a96c9f4b3883c41ae08797">PageCountScopes</a> { <b>kSection</b> = 0, <b>kDocument</b> }</td></tr><tr class="separator:aa8b9124764a96c9f4b3883c41ae08797"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0365501976e8bb6dcd4ffb708280a69e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0365501976e8bb6dcd4ffb708280a69e"></a> typedef <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_interface_ptr.html">InterfacePtr</a><br class="typebreak" /> &lt; <a class="el" href="class_i_visitor_helper.html">IVisitorHelper</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>VisitableItems</b></td></tr><tr class="separator:a0365501976e8bb6dcd4ffb708280a69e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abf2ad7286d046609079e0d2e6e86a466"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abf2ad7286d046609079e0d2e6e86a466"></a> typedef <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; TextIndex &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>HIndexList</b></td></tr><tr class="separator:abf2ad7286d046609079e0d2e6e86a466"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1d61d01978f05b27e5616fba3c5955c2"><td align="right" class="memItemLeft" valign="top">typedef bool16(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a1d61d01978f05b27e5616fba3c5955c2">StripMatchingCharactersFunction</a> )(const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;n)</td></tr><tr class="separator:a1d61d01978f05b27e5616fba3c5955c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a8b4a388f1ee39a829b2e06919bd4c4e2"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a8b4a388f1ee39a829b2e06919bd4c4e2">QueryCopyStoryCommand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;source, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dest, const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;sourceRange, const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;destRange, const bool16 ignoreAttributes=kFalse)=0</td></tr><tr class="separator:a8b4a388f1ee39a829b2e06919bd4c4e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9648ba26764772a8d18f1393d0b59f1f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a9648ba26764772a8d18f1393d0b59f1f">QueryCopyStoryToEndCommand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;source, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dest, const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;sourceRange, const bool16 ignoreAttributes=kFalse)=0</td></tr><tr class="separator:a9648ba26764772a8d18f1393d0b59f1f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afe6b3d2e53ba1d4c8f1498d8a8ba027c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#afe6b3d2e53ba1d4c8f1498d8a8ba027c">QueryCopyStoryFromAllToAllCommand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;source, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dest, const bool16 ignoreAttributes=kFalse)=0</td></tr><tr class="separator:afe6b3d2e53ba1d4c8f1498d8a8ba027c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a56f376effb6c1bd867082db3919813ce"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a56f376effb6c1bd867082db3919813ce">QueryCopyStoryFromAllToEndCommand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;source, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dest, const bool16 ignoreAttributes=kFalse)=0</td></tr><tr class="separator:a56f376effb6c1bd867082db3919813ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7a34d61ad6a73e24af3d31f47e2298fd"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7a34d61ad6a73e24af3d31f47e2298fd">QueryMoveStoryCommand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;source, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dest, const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;sourceRange, const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;destRange, const bool16 ignoreAttributes=kFalse)=0</td></tr><tr class="separator:a7a34d61ad6a73e24af3d31f47e2298fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac09a38bde225062c2860b88c4625fc86"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ac09a38bde225062c2860b88c4625fc86">QueryMoveStoryFromAllCommand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;source, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dest, const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;destRange, const bool16 ignoreAttributes=kFalse)=0</td></tr><tr class="separator:ac09a38bde225062c2860b88c4625fc86"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aabaa994d3d0b00669b4f19e81fbd7b27"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aabaa994d3d0b00669b4f19e81fbd7b27">QueryMoveStoryFromAllToAllCommand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;source, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dest, const bool16 ignoreAttributes=kFalse)=0</td></tr><tr class="separator:aabaa994d3d0b00669b4f19e81fbd7b27"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac9a1d9cc30fb7499e9e6da0d63f8b7c1"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ac9a1d9cc30fb7499e9e6da0d63f8b7c1">QueryMoveStoryFromAllToEndCommand</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;source, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dest, const bool16 ignoreAttributes=kFalse)=0</td></tr><tr class="separator:ac9a1d9cc30fb7499e9e6da0d63f8b7c1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac38913709f4fac24b4ff9fcd3884b13f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ac38913709f4fac24b4ff9fcd3884b13f">CreateNewMCFrameCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, bool16 noGraphicAttr, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundary, bool16 isHorizontal=kTrue, bool16 isFrameGrid=kFalse, bool16 isLeftToRight=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>, bool16 isEndnoteStory=kFalse)=0</td></tr><tr class="separator:ac38913709f4fac24b4ff9fcd3884b13f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac11903406f740c9bfb3f48c1ea4fe2ee"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ac11903406f740c9bfb3f48c1ea4fe2ee">CreateNewMCFrameCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, bool16 noGraphicAttr, const <a class="el" href="class_k2_vector.html">PMPointList</a> &amp;opposingCorners, bool16 isHorizontal=kTrue, bool16 isFrameGrid=kFalse, bool16 isLeftToRight=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:ac11903406f740c9bfb3f48c1ea4fe2ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ade20798fea7f13b0304e27f910a5ceea"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ade20798fea7f13b0304e27f910a5ceea">CreateNewMCFrameForStoryCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, bool16 noGraphicAttr, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundary, <a class="el" href="class_i_text_model.html">ITextModel</a> *story, bool16 isHorizontal=kTrue, bool16 isFrameGrid=kFalse, bool16 isLeftToRight=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:ade20798fea7f13b0304e27f910a5ceea"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aea59ce8f4a8f2f7eb43f32753a8b8359"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aea59ce8f4a8f2f7eb43f32753a8b8359">CreateNewMCFrameForFrameListCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, bool16 noGraphicAttr, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundary, <a class="el" href="class_i_frame_list.html">IFrameList</a> *frameList, bool16 atEnd=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:aea59ce8f4a8f2f7eb43f32753a8b8359"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:addfa0b30bb11bfccf7fc8184cd28cd09"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#addfa0b30bb11bfccf7fc8184cd28cd09">CreateNewMCFrameForFrameListCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, bool16 noGraphicAttr, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundary, <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *mcFrame, bool16 insertAfter=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:addfa0b30bb11bfccf7fc8184cd28cd09"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2995af32f471f147e04773db43518606"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a2995af32f471f147e04773db43518606">CreateNewMCFrameForFrameListCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, bool16 noGraphicAttr, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundary, <a class="el" href="class_i_frame_list.html">IFrameList</a> *frameList, int32 insertIndex, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:a2995af32f471f147e04773db43518606"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aed374c1b8c81f5116802bc89e31e5b78"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aed374c1b8c81f5116802bc89e31e5b78">CreateConvertToMCFrameCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, bool16 isHorizontal=kTrue, bool16 isFrameGrid=kFalse, bool16 isLeftToRight=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:aed374c1b8c81f5116802bc89e31e5b78"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0543c8a130815229cb7c87ad5e1e713c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a0543c8a130815229cb7c87ad5e1e713c">CreateConvertToMCFrameForStoryCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, <a class="el" href="class_i_text_model.html">ITextModel</a> *story, bool16 isHorizontal=kTrue, bool16 isFrameGrid=kFalse, bool16 isLeftToRight=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:a0543c8a130815229cb7c87ad5e1e713c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aeee352d8351c7a2c483cf8e3b92e749b"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aeee352d8351c7a2c483cf8e3b92e749b">CreateConvertToMCFrameForFrameListCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, <a class="el" href="class_i_frame_list.html">IFrameList</a> *frameList, bool16 atEnd=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:aeee352d8351c7a2c483cf8e3b92e749b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a83b78c2e97d4c0d4ca9cc286cce6a858"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a83b78c2e97d4c0d4ca9cc286cce6a858">CreateConvertToMCFrameForFrameListCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *mcFrame, bool16 insertAfter=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:a83b78c2e97d4c0d4ca9cc286cce6a858"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4b485286a1431966ce6c49d3a945cca5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a4b485286a1431966ce6c49d3a945cca5">CreateConvertToMCFrameForFrameListCommand</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> parent, <a class="el" href="class_i_frame_list.html">IFrameList</a> *frameList, int32 insertIndex, <a class="el" href="class_i_d_type.html">ClassID</a> frameItem=<a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>)=0</td></tr><tr class="separator:a4b485286a1431966ce6c49d3a945cca5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad509949986a1ed033c1a995d37fd8511"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ad509949986a1ed033c1a995d37fd8511">ConvertTextModelText</a> (const <a class="el" href="class_wide_string.html">WideString</a> &amp;rText, <a class="el" href="class_wide_string.html">WideString</a> *pStripped, bool16 stripHardHyphens=kTrue, bool16 stripDiscretionaryHyphens=kTrue, bool16 convertApostrophes=kTrue, bool16 stripNobreakNonspace=kTrue, bool16 convertHyphens=kTrue, bool16 stripLeadingSpaces=kTrue, bool16 convertForGrammarCheck=kFalse)=0</td></tr><tr class="separator:ad509949986a1ed033c1a995d37fd8511"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6a4e93aa9ac77046b96657ce662b8a8c"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a6a4e93aa9ac77046b96657ce662b8a8c">CollectPageItemsFromFocus</a> (const <a class="el" href="class_i_text_focus.html">ITextFocus</a> *pFocus, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;iid, <a class="el" href="class_u_i_d_list.html">UIDList</a> *pList)=0</td></tr><tr class="separator:a6a4e93aa9ac77046b96657ce662b8a8c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3ad7d68a0b5fc6c82ddbd972c5fd79c1"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a3ad7d68a0b5fc6c82ddbd972c5fd79c1">FocusSpansMultiplePageItems</a> (const <a class="el" href="class_i_text_focus.html">ITextFocus</a> *pFocus)=0</td></tr><tr class="separator:a3ad7d68a0b5fc6c82ddbd972c5fd79c1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a19937958afb2d2beaf74af50a8475bc2"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a19937958afb2d2beaf74af50a8475bc2">GetMultiColFrameIndex</a> (const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *mcf)=0</td></tr><tr class="separator:a19937958afb2d2beaf74af50a8475bc2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad9893be0394a989695db39fff7d7e108"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ad9893be0394a989695db39fff7d7e108">FindSurroundingWord</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *pModel, TextIndex nPosition, int32 *pLength, FuncIsWordChar aFunction)=0</td></tr><tr class="separator:ad9893be0394a989695db39fff7d7e108"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2a8fc2be951f9c5888a339e73c42c227"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a2a8fc2be951f9c5888a339e73c42c227">FindSurroundingWordUsingWordCharFuncOnly</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *pModel, TextIndex nPosition, int32 *pLength, const FuncIsWordChar aFunction)=0</td></tr><tr class="separator:a2a8fc2be951f9c5888a339e73c42c227"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a099114b66b75224fb66a47443fbe1c80"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a099114b66b75224fb66a47443fbe1c80">IsPlainStyleName</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;styleName)=0</td></tr><tr class="separator:a099114b66b75224fb66a47443fbe1c80"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1e2fa4d5c59563a4fab69c1558039a7c"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a1e2fa4d5c59563a4fab69c1558039a7c">IsItalicStyleName</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;styleName)=0</td></tr><tr class="separator:a1e2fa4d5c59563a4fab69c1558039a7c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a59fea82a2d995a76e31d021f7e4b38bf"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a59fea82a2d995a76e31d021f7e4b38bf">IsBoldStyleName</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;styleName)=0</td></tr><tr class="separator:a59fea82a2d995a76e31d021f7e4b38bf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac9a8afe9bad3cd0327267f162d5cd89c"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ac9a8afe9bad3cd0327267f162d5cd89c">IsBoldItalicStyleName</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;styleName)=0</td></tr><tr class="separator:ac9a8afe9bad3cd0327267f162d5cd89c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88edaa0205663b83e4d6ac265c784aa4"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a88edaa0205663b83e4d6ac265c784aa4">GetFontStyleName</a> (<a class="el" href="class_i_text_attr_font.html">ITextAttrFont</a> *fromFont, <a class="el" href="class_i_text_attr_font.html">ITextAttrFont</a> *toFont, <a class="el" href="class_p_m_string.html">PMString</a> *styleName)=0</td></tr><tr class="separator:a88edaa0205663b83e4d6ac265c784aa4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4f8e33e94a783f1b48bb69fdfd6db4c0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a4f8e33e94a783f1b48bb69fdfd6db4c0">RemapFontStyles</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *dataBase, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &amp;stateOverrides, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &amp;newOverrides, <a class="el" href="class_p_m_string.html">PMString</a> *styleName, <a class="el" href="class_i_d_type.html">ClassID</a> textAttrFontUIDBoss=<a class="el" href="classk_text_attr_font_u_i_d_boss.html">kTextAttrFontUIDBoss</a>, <a class="el" href="class_i_d_type.html">ClassID</a> textAttrFontStyleBoss=<a class="el" href="classk_text_attr_font_style_boss.html">kTextAttrFontStyleBoss</a>, bool16 remapExactFontStylesOnly=kFalse)=0</td></tr><tr class="separator:a4f8e33e94a783f1b48bb69fdfd6db4c0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0ffd7da19e7ff663901f6e8d886a485c"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a0ffd7da19e7ff663901f6e8d886a485c">IsOpenTypeFont</a> (const <a class="el" href="class_i_p_m_font.html">IPMFont</a> *font)=0</td></tr><tr class="separator:a0ffd7da19e7ff663901f6e8d886a485c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2039dc31bb8e6ee6629573fd9cc963f8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a2039dc31bb8e6ee6629573fd9cc963f8">IsOpenTypeFamily</a> (<a class="el" href="class_i_font_family.html">IFontFamily</a> *fontFamily)=0</td></tr><tr class="separator:a2039dc31bb8e6ee6629573fd9cc963f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a323519df19dec1e15cfd59e4efe98fca"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a323519df19dec1e15cfd59e4efe98fca">IsAdobeFont</a> (<a class="el" href="class_i_p_m_font.html">IPMFont</a> const *font)=0</td></tr><tr class="separator:a323519df19dec1e15cfd59e4efe98fca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac7acc3738afb11f5ccece3128dcb582b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac7acc3738afb11f5ccece3128dcb582b"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>IsWordBreak</b> (const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;curChar)=0</td></tr><tr class="separator:ac7acc3738afb11f5ccece3128dcb582b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:add895082a3058e3c462a213dc9804395"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#add895082a3058e3c462a213dc9804395">GetDisplayFontNames</a> (<a class="el" href="class_i_font_group.html">IFontGroup</a> *fontGroup, <a class="el" href="class_i_p_m_font.html">IPMFont</a> *font, <a class="el" href="class_p_m_string.html">PMString</a> &amp;familyName, <a class="el" href="class_p_m_string.html">PMString</a> &amp;styleName, <a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591e">DisplayNamesFlag</a> namesFlag)=0</td></tr><tr class="separator:add895082a3058e3c462a213dc9804395"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae5dee4ea410ceab41d7891f64b574bd0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ae5dee4ea410ceab41d7891f64b574bd0">GetDisplayFontNames</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *dataBase, const <a class="el" href="class_i_text_attr_u_i_d.html">ITextAttrUID</a> *fontUID, const <a class="el" href="class_i_text_attr_font.html">ITextAttrFont</a> *fontStyle, <a class="el" href="class_p_m_string.html">PMString</a> &amp;familyName, <a class="el" href="class_p_m_string.html">PMString</a> &amp;styleName, <a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591e">DisplayNamesFlag</a> namesFlag)=0</td></tr><tr class="separator:ae5dee4ea410ceab41d7891f64b574bd0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa9150f4fce64ab81cc92d87c2a626cee"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aa9150f4fce64ab81cc92d87c2a626cee">CollectOwnedItems</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *model, TextIndex start, int32 len, <a class="el" href="class_k2_vector.html">OwnedItemDataList</a> *resultList, bool16 nested=kFalse)=0</td></tr><tr class="separator:aa9150f4fce64ab81cc92d87c2a626cee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a262535d41476ea44d951c8f23893fbe7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a262535d41476ea44d951c8f23893fbe7">CollectVisitableItems</a> (<a class="el" href="class_i_text_model.html">ITextModel</a> *model, TextIndex start, int32 len, <a class="el" href="class_k2_vector.html">VisitableItems</a> *resultList)=0</td></tr><tr class="separator:a262535d41476ea44d951c8f23893fbe7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab2a0293b8e4b71c12a8d99482bbfd8fc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ab2a0293b8e4b71c12a8d99482bbfd8fc">GetUIDListOfInlines</a> (<a class="el" href="class_i_parcel.html">IParcel</a> *parcel, bool16 bWithDropCaps, <a class="el" href="class_u_i_d_list.html">UIDList</a> *resultList)=0</td></tr><tr class="separator:ab2a0293b8e4b71c12a8d99482bbfd8fc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adcbeb50193a3026b0f6b3d7c519bb06b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#adcbeb50193a3026b0f6b3d7c519bb06b">CollectStoryRanges</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *model, TextIndex start, int32 len, StoryRangeList *resultList, TextIndex hIndex=kInvalidTextIndex, <a class="el" href="class_k2_vector.html">ITextUtils::HIndexList</a> *hIndexList=nil, bool16 bIncludeAnchorSpan=kTrue)=0</td></tr><tr class="separator:adcbeb50193a3026b0f6b3d7c519bb06b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad22611a8f4685aec82389f30514f34d1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ad22611a8f4685aec82389f30514f34d1">BuildLogicalStoryRangeList</a> (<a class="el" href="class_i_text_model.html">ITextModel</a> *model, TextIndex start, StoryRangeList *resultList)=0</td></tr><tr class="separator:ad22611a8f4685aec82389f30514f34d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6c661012578ba71ea4479e7fc1703ad2"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a6c661012578ba71ea4479e7fc1703ad2">GetWaxToFrameMatrix</a> (const <a class="el" href="class_i_parcel.html">IParcel</a> *parcel)=0</td></tr><tr class="separator:a6c661012578ba71ea4479e7fc1703ad2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a15cb61f4f3f8c36e7d8d01569008a285"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a15cb61f4f3f8c36e7d8d01569008a285">GetParcelContentBounds</a> (<a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> *tpl, TextIndex at, <a class="el" href="class_p_m_rect.html">PMRect</a> *pCBounds)=0</td></tr><tr class="separator:a15cb61f4f3f8c36e7d8d01569008a285"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7062f79aac31991e66ed9f7b3b1ba3d5"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7062f79aac31991e66ed9f7b3b1ba3d5">IsOverset</a> (const <a class="el" href="class_i_frame_list.html">IFrameList</a> *fl)=0</td></tr><tr class="separator:a7062f79aac31991e66ed9f7b3b1ba3d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abefc48252c7380b8320490b975a2d015"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#abefc48252c7380b8320490b975a2d015">IsScriptOfText</a> (const char *anyText, int32 writingScript)=0</td></tr><tr class="separator:abefc48252c7380b8320490b975a2d015"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a99a7d9881eb20dea3821c3c17b4da41c"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a99a7d9881eb20dea3821c3c17b4da41c">GuessScriptOfText</a> (const char *anyText, int32 preferredWritingScript=kDontKnowScript)=0</td></tr><tr class="separator:a99a7d9881eb20dea3821c3c17b4da41c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ace2eaedf756722752c9a0eb25b19b71a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ace2eaedf756722752c9a0eb25b19b71a">SkipTextCharForRemapping</a> (const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;textChar)=0</td></tr><tr class="separator:ace2eaedf756722752c9a0eb25b19b71a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2d60a6adf8d6f3607034a16d1838dba6"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a2d60a6adf8d6f3607034a16d1838dba6">SkipTextCharForFontLocking</a> (const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;textChar)=0</td></tr><tr class="separator:a2d60a6adf8d6f3607034a16d1838dba6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aba35b91a88a829f0cdb5e4e98a3b3357"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aba35b91a88a829f0cdb5e4e98a3b3357">RemapCharacterValue</a> (<a class="el" href="class_i_p_m_font.html">IPMFont</a> *oldFont, <a class="el" href="class_i_p_m_font.html">IPMFont</a> *newFont, const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;textChar)=0</td></tr><tr class="separator:aba35b91a88a829f0cdb5e4e98a3b3357"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5ad1014d9f1056bf80b6f5fa35bc1d75"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a5ad1014d9f1056bf80b6f5fa35bc1d75">CreateNewStory</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, bool16 defaults=kTrue, <a class="el" href="class_i_d_type.html">ClassID</a> clsID=<a class="el" href="classk_text_story_boss.html">kTextStoryBoss</a>)=0</td></tr><tr class="separator:a5ad1014d9f1056bf80b6f5fa35bc1d75"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a585e0b5f5c8f9e54b991a75bbcebe4e3"><td align="right" class="memItemLeft" valign="top">virtual LanguageID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a585e0b5f5c8f9e54b991a75bbcebe4e3">ScriptToLanguageID</a> (int32 writingScript)=0</td></tr><tr class="separator:a585e0b5f5c8f9e54b991a75bbcebe4e3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad571263b5e8bb0d1b5c74e46d4e49af1"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ad571263b5e8bb0d1b5c74e46d4e49af1">CreateRecomposeThruNthParcelCmd</a> (const <a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> *tpl, int32 parcelIndex)=0</td></tr><tr class="separator:ad571263b5e8bb0d1b5c74e46d4e49af1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2acbf3407aef08d61c3033f623224b6a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a2acbf3407aef08d61c3033f623224b6a">CreateRecomposeThruTextIndexCmd</a> (const <a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> *tpl, TextIndex textIndex)=0</td></tr><tr class="separator:a2acbf3407aef08d61c3033f623224b6a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2668a84abc826abe85913765ae9f98b9"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a2668a84abc826abe85913765ae9f98b9">DeterminePairKern</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *model, TextIndex index, <a class="el" href="class_i_d_type.html">ClassID</a> kernService, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;result)=0</td></tr><tr class="separator:a2668a84abc826abe85913765ae9f98b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aecb67ce96baf86c439f1007cb881a97a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aecb67ce96baf86c439f1007cb881a97a">GetDefaultTextAttrPreferences</a> (const <a class="el" href="struct_i_text_utils_1_1_which_text_attrs.html">WhichTextAttrs</a> which, <a class="el" href="struct_i_text_utils_1_1_text_attrs.html">TextAttrs</a> &amp;out, <a class="el" href="class_i_document.html">IDocument</a> *prefsFromDocument)=0</td></tr><tr class="separator:aecb67ce96baf86c439f1007cb881a97a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a36f987e66e954b5a9e5e4f340cffc03e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a36f987e66e954b5a9e5e4f340cffc03e">AdjustForTableRange</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;story, TextIndex *pStart, TextIndex *pEnd, TextIndex *nextLine)=0</td></tr><tr class="separator:a36f987e66e954b5a9e5e4f340cffc03e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7598a340520b5172dd6e4a5379718cc3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7598a340520b5172dd6e4a5379718cc3">AlignToBaselineGrid</a> (<a class="el" href="class_i_geometry.html">IGeometry</a> *pageItem, <a class="el" href="class_i_parcel.html">IParcel</a> *parcel, const <a class="el" href="class_i_baseline_grid_prefs.html">IBaselineGridPrefs</a> *gridPrefs, <a class="el" href="class_p_m_real.html">PMReal</a> *pYTop, <a class="el" href="class_p_m_real.html">PMReal</a> *pYBottom, Text::GridAlignmentMetric alignment, <a class="el" href="class_p_m_real.html">PMReal</a> alignmentMetricOffset) const =0</td></tr><tr class="separator:a7598a340520b5172dd6e4a5379718cc3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a13cc1ed06db84c631fe0a270cf9dce19"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a13cc1ed06db84c631fe0a270cf9dce19">FindResetOwnedItemUID</a> (<a class="el" href="class_i_item_strand.html">IItemStrand</a> *itemStrand, const <a class="el" href="class_i_d_type.html">ClassID</a> objectType, const <a class="el" href="class_i_d_type.html">UID</a> findOldItemUID, const TextIndex start, const <a class="el" href="class_i_d_type.html">UID</a> newItemUID)=0</td></tr><tr class="separator:a13cc1ed06db84c631fe0a270cf9dce19"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae2c036a105d0189804957790140cdd05"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ae2c036a105d0189804957790140cdd05">RemapCharacterValues</a> (<a class="el" href="class_i_p_m_font.html">IPMFont</a> *oldFont, <a class="el" href="class_i_p_m_font.html">IPMFont</a> *newFont, const textchar *buffer, int32 bufferLength, <a class="el" href="class_wide_string.html">WideString</a> *replacedChars)=0</td></tr><tr class="separator:ae2c036a105d0189804957790140cdd05"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a500e3cfd1a94341b1584a988ac1c2892"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a500e3cfd1a94341b1584a988ac1c2892">CountChars</a> (const UTF16TextChar *buffer, int32 length) const =0</td></tr><tr class="separator:a500e3cfd1a94341b1584a988ac1c2892"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a86e47fc43a07e30cba7aa8b497aca6cc"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a86e47fc43a07e30cba7aa8b497aca6cc">CharOffsetToUTF16Offset</a> (const UTF16TextChar *buffer, int32 length, int32 charOffset) const =0</td></tr><tr class="separator:a86e47fc43a07e30cba7aa8b497aca6cc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abb64d339cc32f77875253bed103dcd7b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#abb64d339cc32f77875253bed103dcd7b">GetSelectedTextItemsFromTextTarget</a> (const <a class="el" href="class_i_text_target.html">ITextTarget</a> *textTarget, <a class="el" href="class_u_i_d_list.html">UIDList</a> *textframes, <a class="el" href="class_u_i_d_list.html">UIDList</a> *mcfs, <a class="el" href="class_u_i_d_list.html">UIDList</a> *splineItems)=0</td></tr><tr class="separator:abb64d339cc32f77875253bed103dcd7b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1183319b711cc5a68dba0eb18a64ece5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a1183319b711cc5a68dba0eb18a64ece5">GetSelectedTextItemsFromLayoutTarget</a> (const <a class="el" href="class_i_layout_target.html">ILayoutTarget</a> *layoutTarget, <a class="el" href="class_u_i_d_list.html">UIDList</a> *textframes, <a class="el" href="class_u_i_d_list.html">UIDList</a> *mcfs, <a class="el" href="class_u_i_d_list.html">UIDList</a> *splineItems)=0</td></tr><tr class="separator:a1183319b711cc5a68dba0eb18a64ece5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1398d52b2560173c879eafbd3f47d66f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a1398d52b2560173c879eafbd3f47d66f">GetSelectedTextItemsFromUIDList</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;pageITems, <a class="el" href="class_u_i_d_list.html">UIDList</a> *textframes, <a class="el" href="class_u_i_d_list.html">UIDList</a> *mcfs, <a class="el" href="class_u_i_d_list.html">UIDList</a> *splineItems)=0</td></tr><tr class="separator:a1398d52b2560173c879eafbd3f47d66f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7a2ccacb06f03e4dbbed602e10bfecca"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7a2ccacb06f03e4dbbed602e10bfecca">GetTextFramesContaining</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *textModel, const <a class="el" href="class_range_data.html">RangeData</a> &amp;range, int32 *pFirstFrameIndex, int32 *pLastFrameIndex)=0</td></tr><tr class="separator:a7a2ccacb06f03e4dbbed602e10bfecca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aefcd4f9d8300d97a24f11d68b16bc7b7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aefcd4f9d8300d97a24f11d68b16bc7b7"></a> virtual <a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>CreateOppositeDirectionFrameList</b> (<a class="el" href="class_u_i_d_list.html">UIDList</a> *pStoryList, ITextOptions::WritingDirection dir)=0</td></tr><tr class="separator:aefcd4f9d8300d97a24f11d68b16bc7b7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd4b4244547c0c27a07c25a71c599ba8"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#afd4b4244547c0c27a07c25a71c599ba8">GetUIDListOfTextFramesFromRange</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *textModel, const <a class="el" href="class_range_data.html">RangeData</a> &amp;range, <a class="el" href="class_u_i_d_list.html">UIDList</a> *resultList)=0</td></tr><tr class="separator:afd4b4244547c0c27a07c25a71c599ba8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2432305cf9d6675db518cfb42c404056"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a2432305cf9d6675db518cfb42c404056">GetUsedInks</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *textModel, TextIndex threadEnd, TextIndex start, int32 len, <a class="el" href="class_i_ink_resource_data.html">IInkResourceData</a> *inkResourceData)=0</td></tr><tr class="separator:a2432305cf9d6675db518cfb42c404056"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa9259d8ab41c0aa29ec288af28d985fc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aa9259d8ab41c0aa29ec288af28d985fc">NotifyOversetChanged</a> (const <a class="el" href="class_i_frame_list.html">IFrameList</a> *frameList)=0</td></tr><tr class="separator:aa9259d8ab41c0aa29ec288af28d985fc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a39dc310c748b3c3d2073fe1718616ade"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a39dc310c748b3c3d2073fe1718616ade">IsMultiColumnFrame</a> (const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *obj) const </td></tr><tr class="separator:a39dc310c748b3c3d2073fe1718616ade"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2dc457e1610f3e8fa1cdcdea04c4f5c2"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a2dc457e1610f3e8fa1cdcdea04c4f5c2">QueryMultiColumnFrame</a> (<a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *tfc) const =0</td></tr><tr class="separator:a2dc457e1610f3e8fa1cdcdea04c4f5c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c3bb466402580c32c8d8e7479efc847"><td align="right" class="memItemLeft" valign="top">virtual const <br class="typebreak" /><a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a9c3bb466402580c32c8d8e7479efc847">QueryMultiColumnFrame</a> (const <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *tfc) const =0</td></tr><tr class="separator:a9c3bb466402580c32c8d8e7479efc847"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3dd0f8f4252aa2bd5556644bc59f4940"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a3dd0f8f4252aa2bd5556644bc59f4940">QueryMultiColumnFrameUID</a> (const <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *tfc) const =0</td></tr><tr class="separator:a3dd0f8f4252aa2bd5556644bc59f4940"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af13a6cd2f2d49659539217601461a579"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#af13a6cd2f2d49659539217601461a579">QueryMCFOrTOPFromSpline</a> (const <a class="el" href="class_i_graphic_frame_data.html">IGraphicFrameData</a> *gfd) const =0</td></tr><tr class="separator:af13a6cd2f2d49659539217601461a579"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9ad4e5b0c6e3706e8f6fb47ca086fa08"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9ad4e5b0c6e3706e8f6fb47ca086fa08"></a> virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetMCFOrTOPFromSpline</b> (const <a class="el" href="class_i_graphic_frame_data.html">IGraphicFrameData</a> *gfd) const =0</td></tr><tr class="separator:a9ad4e5b0c6e3706e8f6fb47ca086fa08"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a13bf7ca15161aa902ae889fa8571c35e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a13bf7ca15161aa902ae889fa8571c35e"></a> virtual <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryTextModelFromSpline</b> (const <a class="el" href="class_i_graphic_frame_data.html">IGraphicFrameData</a> *gfd) const =0</td></tr><tr class="separator:a13bf7ca15161aa902ae889fa8571c35e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1ee7474b9dec582b2cf34253d946dfb5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_hierarchy.html">IHierarchy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a1ee7474b9dec582b2cf34253d946dfb5">QuerySplineFromTextFrame</a> (const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *mcf) const =0</td></tr><tr class="separator:a1ee7474b9dec582b2cf34253d946dfb5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad91a322570dd6918ee992150d6200e8f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_hierarchy.html">IHierarchy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ad91a322570dd6918ee992150d6200e8f">QuerySplineFromTextFrame</a> (const <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *tfc) const =0</td></tr><tr class="separator:ad91a322570dd6918ee992150d6200e8f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6c01664177cef01bae7be1a4dc5023c7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6c01664177cef01bae7be1a4dc5023c7"></a> virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><b>ProcessScaleParcelContent</b> (const <a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> *tpl, <a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;xScale, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;yScale, <a class="el" href="class_i_scale_object_1_1_scale_context.html">IScaleObject::ScaleContext</a> &amp;context) const =0</td></tr><tr class="separator:a6c01664177cef01bae7be1a4dc5023c7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af70ae5c23b12cf4c497e73f67f717620"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#af70ae5c23b12cf4c497e73f67f717620">GetTextFramesPageItemUID</a> (<a class="el" href="class_i_geometry.html">IGeometry</a> *pageItem) const =0</td></tr><tr class="separator:af70ae5c23b12cf4c497e73f67f717620"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad70ab6268c29575d449d1e5b0ceadaa9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad70ab6268c29575d449d1e5b0ceadaa9"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetWordCountInfo</b> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *iTextModel, const uint32 &amp;startIndex, const int32 &amp;lengthToCount, const <a class="el" href="class_i_text_utils.html#adf5b3f26a4fd3c9f278d925be7cc6fe3">ITextUtils::WordCountUpdateAction</a> &amp;action, const ITextUtils::WordCountUpdateState &amp;state, bool16 &amp;wordStarted, uint32 &amp;characters, uint32 &amp;words, uint32 &amp;paragraphs, uint32 &amp;lines, uint32 &amp;oversetCharacters, uint32 &amp;oversetWords, uint32 &amp;oversetParagraphs, uint32 &amp;oversetLines, bool16 &amp;bWordAcrossOverset, <a class="el" href="class_text_story_thread_helper.html">TextStoryThreadHelper</a> &amp;helper)=0</td></tr><tr class="separator:ad70ab6268c29575d449d1e5b0ceadaa9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a31eda33a9f3fe0de3d6675dec241fa46"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a31eda33a9f3fe0de3d6675dec241fa46">GetWordCountInfo</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *iTextModel, const uint32 &amp;startIndex, const int32 &amp;lengthToCount, const <a class="el" href="class_i_text_utils.html#adf5b3f26a4fd3c9f278d925be7cc6fe3">ITextUtils::WordCountUpdateAction</a> &amp;action, const ITextUtils::WordCountUpdateState &amp;state, bool16 &amp;wordStarted, uint32 &amp;fullWidthChars, uint32 &amp;oversetFullWidthChars, uint32 &amp;halfWidthChars, uint32 &amp;oversetHalfWidthChars, uint32 &amp;japaneseChars, uint32 &amp;oversetJapaneseChars, uint32 &amp;kanjis, uint32 &amp;oversetKanjis, uint32 &amp;words, uint32 &amp;oversetWords, uint32 &amp;lines, uint32 &amp;oversetLines, uint32 &amp;paragraphs, uint32 &amp;oversetParagraphs, uint32 &amp;allChars, uint32 &amp;oversetAllChars, bool16 &amp;bWordAcrossOverset, <a class="el" href="class_text_story_thread_helper.html">TextStoryThreadHelper</a> &amp;helper)=0</td></tr><tr class="separator:a31eda33a9f3fe0de3d6675dec241fa46"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a484fa8f873a206fe70fbbb01f861cc44"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a484fa8f873a206fe70fbbb01f861cc44">CountOversetLines</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textModelUIDRef)=0</td></tr><tr class="separator:a484fa8f873a206fe70fbbb01f861cc44"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7fcd886ec324d267b9bda2f67ee15f3b"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7fcd886ec324d267b9bda2f67ee15f3b">IsFocusAFootnote</a> (const <a class="el" href="class_i_text_focus.html">ITextFocus</a> *pFocus, <a class="el" href="class_u_i_d_ref.html">UIDRef</a> *pFootnoteUIDRef=nil)=0</td></tr><tr class="separator:a7fcd886ec324d267b9bda2f67ee15f3b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a963d5f97fd45950484f6f8a5bb7f8028"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a963d5f97fd45950484f6f8a5bb7f8028">IsFootnote</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *model, TextIndex position, <a class="el" href="class_u_i_d_ref.html">UIDRef</a> *pFootnoteUIDRef=nil)=0</td></tr><tr class="separator:a963d5f97fd45950484f6f8a5bb7f8028"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4b600408977871eb93ea3b74c0169a2d"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a4b600408977871eb93ea3b74c0169a2d">AnyFootnotes</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *model, const <a class="el" href="class_range_data.html">RangeData</a> &amp;range)=0</td></tr><tr class="separator:a4b600408977871eb93ea3b74c0169a2d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7895d6cc8b635a24d908561ff8998250"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7895d6cc8b635a24d908561ff8998250">GenerateListsOfAttributesThatCanBeCleared</a> (<a class="el" href="class_i_workspace.html">IWorkspace</a> *workspace, <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *characterAttributes, <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *paragraphAttributes)=0</td></tr><tr class="separator:a7895d6cc8b635a24d908561ff8998250"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa0db7278cb9c072982a077902eabc217"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aa0db7278cb9c072982a077902eabc217">GetPrimaryStoryAnchor</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;storyRef, <a class="el" href="class_range_data.html">RangeData</a> &amp;range) const =0</td></tr><tr class="separator:aa0db7278cb9c072982a077902eabc217"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac7dc37aaee9d3656934947ce2bc4c20f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac7dc37aaee9d3656934947ce2bc4c20f"></a> virtual boost::shared_ptr<br class="typebreak" /> &lt; <a class="el" href="class_wide_string.html">WideString</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>FilterInsertString</b> (const <a class="el" href="class_wide_string.html">WideString</a> *data, <a class="el" href="class_i_text_utils.html#a1d61d01978f05b27e5616fba3c5955c2">StripMatchingCharactersFunction</a> func) const =0</td></tr><tr class="separator:ac7dc37aaee9d3656934947ce2bc4c20f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1d24eafb26bdc25e4b08c93a1ad3c932"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a1d24eafb26bdc25e4b08c93a1ad3c932">GetPrimaryThreadAnchor</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *model, <a class="el" href="class_range_data.html">RangeData</a> &amp;range) const =0</td></tr><tr class="separator:a1d24eafb26bdc25e4b08c93a1ad3c932"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a758846fca28a85fa9e1d45d7b8f0e014"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a758846fca28a85fa9e1d45d7b8f0e014">LinkTextFrames</a> (const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *textFrameA, const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *textFrameB, bool16 prepend)=0</td></tr><tr class="separator:a758846fca28a85fa9e1d45d7b8f0e014"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaad1557df85e50775239f49810a4067f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_hierarchy.html">IHierarchy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aaad1557df85e50775239f49810a4067f">QueryForHierarchyMember</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, const <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *textFrame) const =0</td></tr><tr class="separator:aaad1557df85e50775239f49810a4067f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9fe254bc1168528f1bd1c222f3565845"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a9fe254bc1168528f1bd1c222f3565845">GetPageUIDRef</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textFrameRef) const =0</td></tr><tr class="separator:a9fe254bc1168528f1bd1c222f3565845"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a127fa4159eef7bbb324af061c9421e0f"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a127fa4159eef7bbb324af061c9421e0f">GetPageNumber</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textFrameRef) const =0</td></tr><tr class="separator:a127fa4159eef7bbb324af061c9421e0f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a828928eaec8795ccdc5ae74643be0beb"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a828928eaec8795ccdc5ae74643be0beb">GetPageNumberFormatter</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textFrameRef) const =0</td></tr><tr class="separator:a828928eaec8795ccdc5ae74643be0beb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a566955fe0c8437d6859d3ee68f031c5b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a566955fe0c8437d6859d3ee68f031c5b">GetFormattedPageNumberString</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textFrameRef, <a class="el" href="class_p_m_string.html">PMString</a> *s, <a class="el" href="class_i_drawing_style.html#a88497f2df0fee98b16f61c3c3da66d93">IDrawingStyle::PositionIndicator</a> whichPage=IDrawingStyle::kDataPosition_ThisPage) const =0</td></tr><tr class="separator:a566955fe0c8437d6859d3ee68f031c5b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c5c06fc54defaa788b7c56b9493296a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a8c5c06fc54defaa788b7c56b9493296a">GetFormattedSectionNameString</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textFrameRef, <a class="el" href="class_p_m_string.html">PMString</a> *s) const =0</td></tr><tr class="separator:a8c5c06fc54defaa788b7c56b9493296a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af0cfa4c9bda0095f42497d0f626e0777"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#af0cfa4c9bda0095f42497d0f626e0777">GetChapterNumber</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db) const =0</td></tr><tr class="separator:af0cfa4c9bda0095f42497d0f626e0777"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0780fcf189c7dbe0fe9bdffe95b49932"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a0780fcf189c7dbe0fe9bdffe95b49932">GetFormattedChapterNumberString</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, <a class="el" href="class_p_m_string.html">PMString</a> *s, int32 v=kInvalidChapterNumber) const =0</td></tr><tr class="separator:a0780fcf189c7dbe0fe9bdffe95b49932"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9035982a7aef03658f3ddddcafb618d6"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a9035982a7aef03658f3ddddcafb618d6">GetPageCount</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;target, enum <a class="el" href="class_i_text_utils.html#aa8b9124764a96c9f4b3883c41ae08797">PageCountScopes</a> scope) const =0</td></tr><tr class="separator:a9035982a7aef03658f3ddddcafb618d6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae6da0215ea22d8a7710711caaebca8c5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ae6da0215ea22d8a7710711caaebca8c5">GetPreviousPageNumberFrameRef</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textFrameRef) const =0</td></tr><tr class="separator:ae6da0215ea22d8a7710711caaebca8c5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0760fd1ccdc28ac198042e72740b70e2"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a0760fd1ccdc28ac198042e72740b70e2">GetNextPageNumberFrameRef</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textFrameRef) const =0</td></tr><tr class="separator:a0760fd1ccdc28ac198042e72740b70e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ace181f35364cc8402a9543689b7d43f8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#ace181f35364cc8402a9543689b7d43f8">GetTargetIsInContinuedContainer</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;target) const =0</td></tr><tr class="separator:ace181f35364cc8402a9543689b7d43f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a15bea23cdd960571b5bd8cc5ef738ffd"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a15bea23cdd960571b5bd8cc5ef738ffd">GetTargetContainerContinues</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;target) const =0</td></tr><tr class="separator:a15bea23cdd960571b5bd8cc5ef738ffd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaffdde5175c975ed5be9e61f83c622a7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aaffdde5175c975ed5be9e61f83c622a7"></a> virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTextIndexForTrackedParagraph</b> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;paraStrandDiskPageRef, <a class="el" href="class_i_d_type.html">UID</a> trackerUID, uint32 trackerData) const =0</td></tr><tr class="separator:aaffdde5175c975ed5be9e61f83c622a7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6648c38aafb4adf0f9ecfde5326cc5f6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a6648c38aafb4adf0f9ecfde5326cc5f6">GetLocaleFromTextIndex</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;modelRef, const TextIndex position, bool16 &amp;noLang, void *locale) const =0</td></tr><tr class="separator:a6648c38aafb4adf0f9ecfde5326cc5f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acd4dbc2039827564578d5461ff8e4820"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_document.html">IDocument</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#acd4dbc2039827564578d5461ff8e4820">GetLastDocInBook</a> (bool16 &amp;docWasAlreadyOpen, int32 &amp;startPageNum) const =0</td></tr><tr class="separator:acd4dbc2039827564578d5461ff8e4820"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aee23bbc3ac7963629ca9485b4fa86033"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aee23bbc3ac7963629ca9485b4fa86033">GetSpreadTextFrameColumns</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;spreadRef, <a class="el" href="class_u_i_d_list.html">UIDList</a> *pList) const =0</td></tr><tr class="separator:aee23bbc3ac7963629ca9485b4fa86033"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1d84123117c4e50b361aa216a5eeed89"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a1d84123117c4e50b361aa216a5eeed89">GetSpreadMultiColumnTextFrames</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;spreadRef, <a class="el" href="class_u_i_d_list.html">UIDList</a> *pList) const =0</td></tr><tr class="separator:a1d84123117c4e50b361aa216a5eeed89"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a21f5f852473c5ffc450d214e89dfc643"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a21f5f852473c5ffc450d214e89dfc643">EditTargetStyle</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *targetDB, const <a class="el" href="class_i_d_type.html">UID</a> &amp;targetStyle, <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attributesToApply, const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;uidList) const =0</td></tr><tr class="separator:a21f5f852473c5ffc450d214e89dfc643"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7589fe26ab9cfa727a2b6ff7949b8ce0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7589fe26ab9cfa727a2b6ff7949b8ce0">ApplySourceStyleAttrsToTargetStyle</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *sourceDB, const <a class="el" href="class_i_d_type.html">UID</a> &amp;sourceStyle, <a class="el" href="class_i_data_base.html">IDataBase</a> *targetDB, const <a class="el" href="class_i_d_type.html">UID</a> &amp;targetStyle, const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;uidList) const =0</td></tr><tr class="separator:a7589fe26ab9cfa727a2b6ff7949b8ce0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa1f57c26741c4dd2eaee8c0e9b7cb7df"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aa1f57c26741c4dd2eaee8c0e9b7cb7df">IsTextValidForInsertion</a> (<a class="el" href="class_wide_string.html">WideString</a> const &amp;text) const =0</td></tr><tr class="separator:aa1f57c26741c4dd2eaee8c0e9b7cb7df"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7fab9a7d5d1443a33d747e8697304b65"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7fab9a7d5d1443a33d747e8697304b65">RepairGenericDataLink</a> (<a class="el" href="class_u_i_d_ref.html">UIDRef</a> oldStoryRef, <a class="el" href="class_u_i_d_ref.html">UIDRef</a> newStoryRef)=0</td></tr><tr class="separator:a7fab9a7d5d1443a33d747e8697304b65"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aede959a18b839c214f97375dbb0079b3"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aede959a18b839c214f97375dbb0079b3">GetXRefPageNumberVariableName</a> ()=0</td></tr><tr class="separator:aede959a18b839c214f97375dbb0079b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a032b93fd79bab2ed53495ebb69b6b97a"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a032b93fd79bab2ed53495ebb69b6b97a">GetXRefChapterNumberVariableName</a> ()=0</td></tr><tr class="separator:a032b93fd79bab2ed53495ebb69b6b97a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7ef62197b07d03b1262ced71f525c452"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_wide_string.html">WideString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a7ef62197b07d03b1262ced71f525c452">GetFullVisibleParagraphString</a> (<a class="el" href="class_i_compose_scanner.html">IComposeScanner</a> *scanner, TextIndex textIndex, int32 &amp;paragraphSpan)=0</td></tr><tr class="separator:a7ef62197b07d03b1262ced71f525c452"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3969f61dc8f0ab7149964a5f64ecf925"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a3969f61dc8f0ab7149964a5f64ecf925">IsLeftToRightRun</a> (const <a class="el" href="class_i_wax_line.html">IWaxLine</a> *waxLine, TextIndex ti) const =0</td></tr><tr class="separator:a3969f61dc8f0ab7149964a5f64ecf925"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a83e4dbd4dd270cde4a0e92e23ab995c5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a83e4dbd4dd270cde4a0e92e23ab995c5">GetFirstFrameOfStory</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;story) const =0</td></tr><tr class="separator:a83e4dbd4dd270cde4a0e92e23ab995c5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4e66ccf2e4af0418d74af2536618724e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a4e66ccf2e4af0418d74af2536618724e">ConvertSmartQuotes</a> (<a class="el" href="class_i_text_model.html">ITextModel</a> *model, TextIndex position, int32 length) const =0</td></tr><tr class="separator:a4e66ccf2e4af0418d74af2536618724e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaa3f48588d18dd5630e0bbb49c6f4425"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#aaa3f48588d18dd5630e0bbb49c6f4425">GetGlyphsForOverrides</a> (<a class="el" href="class_i_text_model.html">ITextModel</a> *model, const <a class="el" href="class_range_data.html">RangeData</a> &amp;range, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *overrides, std::vector&lt; std::pair&lt; Text::GlyphID, TextIndex &gt;&gt; *newGlyphPoints, bool16 clearOverrides=kFalse) const =0</td></tr><tr class="separator:aaa3f48588d18dd5630e0bbb49c6f4425"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9f1c1b68b3b11d85a3a078684825276e"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#a9f1c1b68b3b11d85a3a078684825276e">GetPageNumberFromPageUID</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;page) const =0</td></tr><tr class="separator:a9f1c1b68b3b11d85a3a078684825276e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afce8717750701f7a87b4ea92ef8f397f"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /><a class="el" href="class_i_text_story_thread_dict_hier.html#a35aa2f44b7fa1d139c6a581ffc4b88a9">ITextStoryThreadDictHier::CompareResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_utils.html#afce8717750701f7a87b4ea92ef8f397f">CompareItemPosition</a> (const <a class="el" href="class_i_text_model.html">ITextModel</a> *txtModel, const TextIndex item1Position, const TextIndex item2Position) const =0</td></tr><tr class="separator:afce8717750701f7a87b4ea92ef8f397f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Utility functions for creating text-related commands and for gather text information. e.g. <pre><a class="el" href="class_utils.html">Utils</a>&lt;<a class="el" href="class_i_text_utils.html">ITextUtils</a>&gt;()-&gt;QueryCopyStoryCommand( ... ) ;</pre></div><h2 class="groupheader">Member Typedef Documentation</h2><a class="anchor" id="a1d61d01978f05b27e5616fba3c5955c2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef bool16(* ITextUtils::StripMatchingCharactersFunction)(const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;n)</td></tr></table></div><div class="memdoc"><p>Filter illegal control characters from the string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">data</td><td>is the string to filter </td></tr><tr><td class="paramname">func</td><td>is a function that returns kTrue if it is passed a character that should be stripped </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the filtered string or nil if no filtering was required </dl></div></div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a3acb640ea65f12df87390446686b591e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591e">ITextUtils::DisplayNamesFlag</a></td></tr></table></div><div class="memdoc"><p>How should the names be displayed? <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a3acb640ea65f12df87390446686b591ea4311d22ed451e85153feeff25e535ce1"></a>kCombineSingleStyleIntoFamilyName</em>&nbsp;</td><td class="fielddoc"><p>If only one style for the font group familyName will have style name included. styleName will always be blank (Type-&gt;Font menu uses this) </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a3acb640ea65f12df87390446686b591ea4911065de57f4c867190cc99baf4275a"></a>kSeparateFamilyAndStyleName</em>&nbsp;</td><td class="fielddoc"><p>Used in style sheet description field </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a3acb640ea65f12df87390446686b591eabc96dac08691c3449937d005d741d795"></a>kStyleNameOnly</em>&nbsp;</td><td class="fielddoc"><p>familyName is blank, only styleName filled out. Character palette Style Menu uses this. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a3acb640ea65f12df87390446686b591eab1cff394a8c29387bac6f4a42ce153e8"></a>kFamilyNameOnly</em>&nbsp;</td><td class="fielddoc"><p>styleName is blank, only Family filled out. Character palette Famiy Menu uses this. </td></tr></table></div></div><a class="anchor" id="aa8b9124764a96c9f4b3883c41ae08797"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_text_utils.html#aa8b9124764a96c9f4b3883c41ae08797">ITextUtils::PageCountScopes</a></td></tr></table></div><div class="memdoc"><p>Enum defining the scope of the Page Count </div></div><a class="anchor" id="adf5b3f26a4fd3c9f278d925be7cc6fe3"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_text_utils.html#adf5b3f26a4fd3c9f278d925be7cc6fe3">ITextUtils::WordCountUpdateAction</a></td></tr></table></div><div class="memdoc"><p>Do character, word, paragraph and line count<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">startIndex</td><td>&mdash; start index for counting </td></tr><tr><td class="paramname">lengthToCount</td><td>&mdash; how far should count stop. </td></tr><tr><td class="paramname">action</td><td>&mdash; just update line or update all. </td></tr><tr><td class="paramname">state</td><td>&mdash; start or continue counting. </td></tr><tr><td class="paramname">wordStarted</td><td>&mdash; left over state(word is started or not) of last time. </td></tr><tr><td class="paramname">characters</td><td>&mdash; count of characters. (passed out parameter) </td></tr><tr><td class="paramname">words</td><td>&mdash; count of words. (passed out parameter) </td></tr><tr><td class="paramname">paragraphs</td><td>&mdash; count of paragraphs. (passed out parameter) </td></tr><tr><td class="paramname">lines</td><td>&mdash; count of lines. (passed out parameter) </td></tr><tr><td class="paramname">oversetCharacters</td><td>&mdash; count of characters in overset. (passed out parameter) </td></tr><tr><td class="paramname">oversetWords</td><td>&mdash; count of words in overset. (passed out parameter) </td></tr><tr><td class="paramname">oversetParagraphs</td><td>&mdash; count of paragraphs in overset. (passed out parameter) </td></tr><tr><td class="paramname">oversetLines</td><td>&mdash; (Deprecated, won`t return actual overset lines) count of lines in overset. (passed out parameter) </td></tr></table></dl></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a36f987e66e954b5a9e5e4f340cffc03e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::AdjustForTableRange </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>story</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>pStart</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>pEnd</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>nextLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>2.0: Tables use one or more characters to &quot;anchor&quot; the table to the text flow. Inserting within these ranges is considered bad form and will lead to crashes. You may use this method to launder the ranges to encompass all of the table instead of just part. </div></div><a class="anchor" id="a7598a340520b5172dd6e4a5379718cc3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::AlignToBaselineGrid </td><td>(</td><td class="paramtype"><a class="el" href="class_i_geometry.html">IGeometry</a> *&nbsp;</td><td class="paramname"><em>pageItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_parcel.html">IParcel</a> *&nbsp;</td><td class="paramname"><em>parcel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_baseline_grid_prefs.html">IBaselineGridPrefs</a> *&nbsp;</td><td class="paramname"><em>gridPrefs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>pYTop</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>pYBottom</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Text::GridAlignmentMetric&nbsp;</td><td class="paramname"><em>alignment</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>alignmentMetricOffset</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Align text in the primary story thread in the specified text frame. This is NOT suitable for alignment in any other TextStoryThread. </div></div><a class="anchor" id="a4b600408977871eb93ea3b74c0169a2d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::AnyFootnotes </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>range</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns whether the range in the model contains a footnote <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">model</td><td>&mdash; The model in question </td></tr><tr><td class="paramname">range</td><td>&mdash; The range in the given model </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Whether that model-range contains a footnote. </dl></div></div><a class="anchor" id="a7589fe26ab9cfa727a2b6ff7949b8ce0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::ApplySourceStyleAttrsToTargetStyle </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>sourceDB</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">UID</a> &amp;&nbsp;</td><td class="paramname"><em>sourceStyle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>targetDB</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">UID</a> &amp;&nbsp;</td><td class="paramname"><em>targetStyle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>uidList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Description: Convert the attributes from the source database to target database first and

</pre><p> then apply the converted attributes to target style. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sourceDB</td><td>[IN] source database </td></tr><tr><td class="paramname">sourceStyle</td><td>[IN] source style </td></tr><tr><td class="paramname">targetDB</td><td>[IN] target database </td></tr><tr><td class="paramname">targetStyle</td><td>[IN] target style </td></tr><tr><td class="paramname">uidList</td><td>[IN] itemList to apply </td></tr></table></dl></div></div><a class="anchor" id="ad22611a8f4685aec82389f30514f34d1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::BuildLogicalStoryRangeList </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">StoryRangeList *&nbsp;</td><td class="paramname"><em>resultList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Builds a list of text ranges for the specified story that are in logical order. The first range will begin at &#39;start&#39; and the rest of the ranges will wrap around the end of the story to end at &#39;start - 1&#39;. </div></div><a class="anchor" id="a86e47fc43a07e30cba7aa8b497aca6cc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::CharOffsetToUTF16Offset </td><td>(</td><td class="paramtype">const UTF16TextChar *&nbsp;</td><td class="paramname"><em>buffer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>length</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>charOffset</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Translates character (can be multiple UTF16s) offset into UTF16 offset in UTF16TextChar buffer </div></div><a class="anchor" id="aa9150f4fce64ab81cc92d87c2a626cee"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::CollectOwnedItems </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>len</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">OwnedItemDataList</a> *&nbsp;</td><td class="paramname"><em>resultList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>nested</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the list of owned items associated with a TextRange <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">model</td><td>The TextModel </td></tr><tr><td class="paramname">start</td><td>The starting TextIndex of Text range to collect from. </td></tr><tr><td class="paramname">len</td><td>The length of the Text range to collect from. </td></tr><tr><td class="paramname">resultList</td><td></td></tr><tr><td class="paramname">nested</td><td>If kFalse, only the OwnedItems in the specified Text range are returned. If kTrue, then all nested OwnedItems, that is OwnedItems that are contained in StoryRanges managed by found OwnedItems, are also returned. See <a class="el" href="class_i_text_utils.html#adcbeb50193a3026b0f6b3d7c519bb06b">CollectStoryRanges()</a> for more information on nesting. </td></tr></table></dl></div></div><a class="anchor" id="a6a4e93aa9ac77046b96657ce662b8a8c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::CollectPageItemsFromFocus </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_focus.html">ITextFocus</a> *&nbsp;</td><td class="paramname"><em>pFocus</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>iid</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>pList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Collects UIDs of items with specified interface from the text focus. e.g. IID_IGRAPHICFRAMEDATA, IID_ITOPFRAMEDATA Can be a costly function with a text selection that spans many pages. See FocusSpansMultiplePageItems. </div></div><a class="anchor" id="adcbeb50193a3026b0f6b3d7c519bb06b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::CollectStoryRanges </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>len</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">StoryRangeList *&nbsp;</td><td class="paramname"><em>resultList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>hIndex</em> = <code>kInvalidTextIndex</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">ITextUtils::HIndexList</a> *&nbsp;</td><td class="paramname"><em>hIndexList</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIncludeAnchorSpan</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the list of <em>logically</em> sequential story ranges that derive from the specified span of the text model. For a typical model span with no special content this will simply return a single StoryRange as (start, start + len). If a table, or other type of owned item which contains nested text is within the specified span then the specified span will be returned as two ranges with the appropriate nested text range(s) inserted between them. The hIndex and hIndexList are optional parameters which allows the caller to identify the starting TextIndex of the hierarchical element that &quot;owns&quot; the equivalent range in the resultList. Ranges from the main story thread (which starts at TextIndex 0) will have the hIndex of kInvalidTextIndex. Hierarchical elements that are found in the main story thread will have hIndex values within the main story thread and if those elements have sub elements then those will be in other story threads. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">bIncludeAnchorSpan</td><td>is optional parameter which provides flexibility to client if they want to include anchor when calculating net span. For example, we don&#39;t want to include anchor span(such as table) when when do line count, e.g., for a 4x4 table, we want the line count as 16 instead of 17. </td></tr></table></dl></div></div><a class="anchor" id="a262535d41476ea44d951c8f23893fbe7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::CollectVisitableItems </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>len</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">VisitableItems</a> *&nbsp;</td><td class="paramname"><em>resultList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns the list of owned items associated with a TextRange that have an <a class="el" href="class_i_visitor_helper.html">IVisitorHelper</a> interface. </div></div><a class="anchor" id="afce8717750701f7a87b4ea92ef8f397f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_text_story_thread_dict_hier.html#a35aa2f44b7fa1d139c6a581ffc4b88a9">ITextStoryThreadDictHier::CompareResult</a> ITextUtils::CompareItemPosition </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>txtModel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const TextIndex&nbsp;</td><td class="paramname"><em>item1Position</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const TextIndex&nbsp;</td><td class="paramname"><em>item2Position</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Compare two items in the same text model by their text index to determine if an item appears visually before or after the other item. 

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">txtModel</td><td>The text model for both the items to be compared </td></tr><tr><td class="paramname">item1Position</td><td>Text index of the first item </td></tr><tr><td class="paramname">item2Position</td><td>Text index of the second item </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kIsBefore if item1 appears before item2, kIsEqual if both indexes are equal, kIsAfter if item1 appears after item2 </dl></div></div><a class="anchor" id="a4e66ccf2e4af0418d74af2536618724e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::ConvertSmartQuotes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>position</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>length</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Map quotes to smart quotes

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">story</td><td>to convert quotes </td></tr><tr><td class="paramname">position</td><td>where to start converting quotes </td></tr><tr><td class="paramname">length</td><td>to convert quotes </td></tr></table></dl></div></div><a class="anchor" id="ad509949986a1ed033c1a995d37fd8511"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_wide_string.html">WideString</a>&amp; ITextUtils::ConvertTextModelText </td><td>(</td><td class="paramtype">const <a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>rText</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> *&nbsp;</td><td class="paramname"><em>pStripped</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>stripHardHyphens</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>stripDiscretionaryHyphens</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>convertApostrophes</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>stripNobreakNonspace</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>convertHyphens</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>stripLeadingSpaces</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>convertForGrammarCheck</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Strip various types of characters from some text. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rText</td><td>is the source text. </td></tr><tr><td class="paramname">pStripped</td><td>will be the converted text. If nil, nothing occurs and we return rText. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Returns the converted text (pStripped) unless nil, then return rText. </dl></div></div><a class="anchor" id="a500e3cfd1a94341b1584a988ac1c2892"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::CountChars </td><td>(</td><td class="paramtype">const UTF16TextChar *&nbsp;</td><td class="paramname"><em>buffer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>length</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Counts number of Unicode characters in a UTF16TextChar buffer </div></div><a class="anchor" id="a484fa8f873a206fe70fbbb01f861cc44"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::CountOversetLines </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textModelUIDRef</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>return the number of overset lines in a given text model </div></div><a class="anchor" id="aed374c1b8c81f5116802bc89e31e5b78"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateConvertToMCFrameCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isHorizontal</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrameGrid</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isLeftToRight</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to convert an existing frame to a multi-column text frame with a new story and a new frame list.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Existing frame which will be converted to multi-column frame. </td></tr><tr><td class="paramname">isHorizontal</td><td>- kTrue if the new Story orientation is horizontal, kFalse if it is vertical. Default is kTrue. </td></tr><tr><td class="paramname">isFrameGrid</td><td>- kTrue if the new Story frame is a frame grid. kFalse if it is a text frame. Default is kFalse. </td></tr><tr><td class="paramname">isLeftToRight</td><td>- kTrue if the new Story direction is left to right. kFalse if it is right to left. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="aeee352d8351c7a2c483cf8e3b92e749b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateConvertToMCFrameForFrameListCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_frame_list.html">IFrameList</a> *&nbsp;</td><td class="paramname"><em>frameList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>atEnd</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to convert an existing frame to a multi-column text frame and insert at the end or beginning of an existing frame list.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Existing frame which will be converted to multi-column frame. </td></tr><tr><td class="paramname">frameList</td><td>- The existing frame list into which the multi-column frame will be inserted. </td></tr><tr><td class="paramname">atEnd</td><td>- kTrue if the multi-column frame will be appened to the end of the frame list, kFalse if it will be inserted to the beginning of the frame list. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="a83b78c2e97d4c0d4ca9cc286cce6a858"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateConvertToMCFrameForFrameListCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="paramname"><em>mcFrame</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>insertAfter</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to convert an existing frame to a multi-column text frame and insert into an existing frame list. The new frame will be inserted before or after the specified <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a>.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Existing frame which will be converted to multi-column frame. </td></tr><tr><td class="paramname">mcFrame</td><td>- The multi-column frame in the existing frame list before or after which the converted frame will be inserted. </td></tr><tr><td class="paramname">insertAfter</td><td>- kTrue if the converted frame will be inserted after mcFrame, kFalse if it will be inserted before mcFrame. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="a4b485286a1431966ce6c49d3a945cca5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateConvertToMCFrameForFrameListCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_frame_list.html">IFrameList</a> *&nbsp;</td><td class="paramname"><em>frameList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>insertIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to convert an existing frame to a multi-column text frame and insert into an existing frame list.<p>The other 2 versions of ConvertToTextFrameForFrameList are recommended. This version is just for use in case if you want to insert the frame to the middle of the frame list and don&#39;t have the corresponding <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a>. But this case is rare.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Existing frame which will be converted to multi-column frame. </td></tr><tr><td class="paramname">frameList</td><td>- The existing frame list into which the multi-column frame will be inserted. </td></tr><tr><td class="paramname">insertIndex</td><td>- Index in the frame list where the multi-column frame will be inserted. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="a0543c8a130815229cb7c87ad5e1e713c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateConvertToMCFrameForStoryCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>story</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isHorizontal</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrameGrid</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isLeftToRight</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to convert an existing frame to a multi-column text frame, attaches to an existing story and starts a new frame list.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Existing frame which will be converted to multi-column frame. </td></tr><tr><td class="paramname">story</td><td>- The existing story to which the multi-column frame will attach. </td></tr><tr><td class="paramname">isHorizontal</td><td>- kTrue if Story orientation set to horizontal, kFalse if it is vertical. Default is kTrue. </td></tr><tr><td class="paramname">isFrameGrid</td><td>- kTrue if the Story frame set to a frame grid. kFalse if it is a text frame. Default is kFalse. </td></tr><tr><td class="paramname">isLeftToRight</td><td>- kTrue if the Story direction set to left to right. kFalse if it is right to left. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="ac38913709f4fac24b4ff9fcd3884b13f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateNewMCFrameCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>noGraphicAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>boundary</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isHorizontal</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrameGrid</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isLeftToRight</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isEndnoteStory</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to create a new multi-column text frame with a new story and a new frame list.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Parent page item under which to create the new frame. </td></tr><tr><td class="paramname">noGraphicAttr</td><td>- kTrue if not to set object styles for the new frame. kFalse otherwise. Usually set to kTrue. </td></tr><tr><td class="paramname">boundary</td><td>- Boundary (in pasteboard coordinates) of the spline where multi-column frame will be created. </td></tr><tr><td class="paramname">isHorizontal</td><td>- kTrue if the new story orientation is horizontal, kFalse if it is vertical. Default is kTrue. </td></tr><tr><td class="paramname">isFrameGrid</td><td>- kTrue if the new story is a frame grid. kFalse if it is a text frame. Default is kFalse. </td></tr><tr><td class="paramname">isLeftToRight</td><td>- kTrue if the new story direction is left to right. kFalse if it is right to left. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>. </td></tr><tr><td class="paramname">isEndnoteStory</td><td>- Is the new text frame going to be part of an endnote story? Default is kFalse.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="ac11903406f740c9bfb3f48c1ea4fe2ee"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateNewMCFrameCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>noGraphicAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_k2_vector.html">PMPointList</a> &amp;&nbsp;</td><td class="paramname"><em>opposingCorners</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isHorizontal</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrameGrid</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isLeftToRight</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to create a new multi-column text frame with a new story and a new frame list.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Parent page item under which to create the new frame. </td></tr><tr><td class="paramname">noGraphicAttr</td><td>- kTrue if not to set object styles for the new frame. kFalse otherwise. Usually set to kTrue. </td></tr><tr><td class="paramname">opposingCorners</td><td>- Opposing corners (in pasteboard coordinates) of the spline where multi-column frame will be created. </td></tr><tr><td class="paramname">isHorizontal</td><td>- kTrue if the new story orientation is horizontal, kFalse if it is vertical. Default is kTrue. </td></tr><tr><td class="paramname">isFrameGrid</td><td>- kTrue if the new story is a frame grid. kFalse if it is a text frame. Default is kFalse. </td></tr><tr><td class="paramname">isLeftToRight</td><td>- kTrue if the new story direction is left to right. kFalse if it is right to left. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="aea59ce8f4a8f2f7eb43f32753a8b8359"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateNewMCFrameForFrameListCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>noGraphicAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>boundary</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_frame_list.html">IFrameList</a> *&nbsp;</td><td class="paramname"><em>frameList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>atEnd</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to create a new multi-column text frame and insert to the end or beginning of the specified frame list.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Parent page item under which to create the new frame. </td></tr><tr><td class="paramname">noGraphicAttr</td><td>- kTrue if not to set object styles for the new frame. kFalse otherwise. Usually set to kTrue. </td></tr><tr><td class="paramname">boundary</td><td>- Boundary of the spline where multi-column frame will be created. </td></tr><tr><td class="paramname">frameList</td><td>- The existing frame list into which the new frame will be inserted. </td></tr><tr><td class="paramname">atEnd</td><td>- kTrue if the new frame will be appended to the end of the frame list, kFalse if it will be inserted to the beginning of the frame list. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="addfa0b30bb11bfccf7fc8184cd28cd09"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateNewMCFrameForFrameListCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>noGraphicAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>boundary</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="paramname"><em>mcFrame</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>insertAfter</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to create a new multi-column text frame and insert into an existing frame list. The new frame will be inserted before or after the specified <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a>.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Parent page item under which to create the new frame. </td></tr><tr><td class="paramname">noGraphicAttr</td><td>- kTrue if not to set object styles for the new frame. kFalse otherwise. Usually set to kTrue. </td></tr><tr><td class="paramname">boundary</td><td>- Boundary of the spline where multi-column frame will be created. </td></tr><tr><td class="paramname">mcFrame</td><td>- The multi-column frame in the existing frame list before or after which the new frame will be inserted. </td></tr><tr><td class="paramname">insertAfter</td><td>- kTrue if the new frame will be inserted after mcFrame, kFalse if it will be inserted before mcFrame. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="a2995af32f471f147e04773db43518606"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateNewMCFrameForFrameListCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>noGraphicAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>boundary</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_frame_list.html">IFrameList</a> *&nbsp;</td><td class="paramname"><em>frameList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>insertIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to create a new multi-column text frame and insert into an existing frame list.<p>The other 2 versions of QueryNewMCFrameForFrameListCmd are recommended. This version is just for use in case if you want to insert the new frame to the middle of the frame list and don&#39;t have the corresponding <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a>. But this case is rare.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Parent page item under which to create the new frame. </td></tr><tr><td class="paramname">noGraphicAttr</td><td>- kTrue if not to set object styles for the new frame. kFalse otherwise. Default is kTrue. </td></tr><tr><td class="paramname">boundary</td><td>- Boundary of the spline where multi-column frame will be created. </td></tr><tr><td class="paramname">frameList</td><td>- The existing frame list into which the new frame will be inserted. </td></tr><tr><td class="paramname">insertIndex</td><td>- index in the frame list where the new frame will be inserted. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="ade20798fea7f13b0304e27f910a5ceea"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateNewMCFrameForStoryCommand </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>parent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>noGraphicAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>boundary</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>story</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isHorizontal</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrameGrid</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isLeftToRight</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>frameItem</em> = <code><a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates the command to create a new multi-column text frame, attaches to an existing story and starts a new frame list.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">parent</td><td>- Parent page item under which to create the new frame. </td></tr><tr><td class="paramname">noGraphicAttr</td><td>- kTrue if not to set object styles for the new frame. kFalse otherwise. Usually set to kTrue. </td></tr><tr><td class="paramname">boundary</td><td>- Boundary of the spline where multi-column frame will be created. </td></tr><tr><td class="paramname">story</td><td>- The existing story to which the new frame will attach. </td></tr><tr><td class="paramname">isHorizontal</td><td>- kTrue if the story orientation set to horizontal, kFalse if it is vertical. Default is kTrue. </td></tr><tr><td class="paramname">isFrameGrid</td><td>- kTrue if the story set to a frame grid. kFalse if it is a text frame. Default is kFalse. </td></tr><tr><td class="paramname">isLeftToRight</td><td>- kTrue if the story direction set left to right. kFalse if it is right to left. Default is kTrue. </td></tr><tr><td class="paramname">frameItem</td><td>- ID of the frame item. Default is <a class="el" href="classk_frame_item_boss.html">kFrameItemBoss</a>.</td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_command.html">ICommand</a> - <a class="el" href="class_i_command.html">ICommand</a> of <a class="el" href="classk_create_multi_column_item_cmd_boss.html">kCreateMultiColumnItemCmdBoss</a> created. </dl></div></div><a class="anchor" id="a5ad1014d9f1056bf80b6f5fa35bc1d75"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITextUtils::CreateNewStory </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>defaults</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>clsID</em> = <code><a class="el" href="classk_text_story_boss.html">kTextStoryBoss</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Create a new story in the specified database.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">defaults</td><td>specified whether the user&#39;s default attributes should be applied to the new story </td></tr><tr><td class="paramname">clsID</td><td>specifies whether user specified story boss should be created </td></tr></table></dl></div></div><a class="anchor" id="ad571263b5e8bb0d1b5c74e46d4e49af1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateRecomposeThruNthParcelCmd </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> *&nbsp;</td><td class="paramname"><em>tpl</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>parcelIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a command to force recomposition (use to avoid CmdBehaviorMonitor asserts if you need to force recomposition from within another command) </div></div><a class="anchor" id="a2acbf3407aef08d61c3033f623224b6a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::CreateRecomposeThruTextIndexCmd </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> *&nbsp;</td><td class="paramname"><em>tpl</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>textIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a command to force recomposition (use to avoid CmdBehaviorMonitor asserts if you need to force recomposition from within another command) </div></div><a class="anchor" id="a2668a84abc826abe85913765ae9f98b9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::DeterminePairKern </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>index</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>kernService</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>result</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determines the pair kern at a particular text index. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">kernService</td><td>refers to the ClassID of a boss that has the <a class="el" href="class_i_pair_kern_dict.html">IPairKernDict</a> interface to use. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>this method returns an ErrorCode (kSuccess, kFailure, kCancel) </dl></div></div><a class="anchor" id="a21f5f852473c5ffc450d214e89dfc643"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::EditTargetStyle </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>targetDB</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">UID</a> &amp;&nbsp;</td><td class="paramname"><em>targetStyle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attributesToApply</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>uidList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Description: Edit the given target style with the given style attributes.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">targetDB</td><td>[IN] target database </td></tr><tr><td class="paramname">targetStyle</td><td>[IN] target style </td></tr><tr><td class="paramname">attributesToApply</td><td>[IN] the attributes in the target database to apply </td></tr><tr><td class="paramname">uidList</td><td>[IN] itemList to apply </td></tr></table></dl></div></div><a class="anchor" id="a13cc1ed06db84c631fe0a270cf9dce19"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextUtils::FindResetOwnedItemUID </td><td>(</td><td class="paramtype"><a class="el" href="class_i_item_strand.html">IItemStrand</a> *&nbsp;</td><td class="paramname"><em>itemStrand</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>objectType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>findOldItemUID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const TextIndex&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>newItemUID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Looks for findOldItemUI from &quot;start&quot; and replaces it with newItemUID in the item strand. This is typically used by commands that create owned items during import. In case the owned item is contained in a table and there is text after the end of the table (ie after the table in the tables containing text story thread) then the TextIndex stored in the command may not be valid. The returned TextIndex is the new location at which findOldItemUID was found in the item strand. </div></div><a class="anchor" id="ad9893be0394a989695db39fff7d7e108"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextUtils::FindSurroundingWord </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>pModel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>nPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pLength</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">FuncIsWordChar&nbsp;</td><td class="paramname"><em>aFunction</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find the word at a text location. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pModel</td><td>The text model in question. </td></tr><tr><td class="paramname">nPosition</td><td>The text location in question. </td></tr><tr><td class="paramname">pLength</td><td>OUT the length of the word. </td></tr><tr><td class="paramname">aFunction</td><td>a function that determines what characters are considered word breaking. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the beginning location of the surrounding word. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_compose_scanner.html">IComposeScanner</a>. <dd><a class="el" href="class_i_language.html">ILanguage</a>. </dl></div></div><a class="anchor" id="a2a8fc2be951f9c5888a339e73c42c227"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextUtils::FindSurroundingWordUsingWordCharFuncOnly </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>pModel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>nPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pLength</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const FuncIsWordChar&nbsp;</td><td class="paramname"><em>aFunction</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find the word at a text location. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pModel</td><td>The text model in question. </td></tr><tr><td class="paramname">nPosition</td><td>The text location in question. </td></tr><tr><td class="paramname">pLength</td><td>OUT the length of the word. </td></tr><tr><td class="paramname">aFunction</td><td>a function that determines what characters are considered word breaking. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the beginning location of the surrounding word. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_compose_scanner.html">IComposeScanner</a>. <dd><a class="el" href="class_i_language.html">ILanguage</a>. </dl></div></div><a class="anchor" id="a3ad7d68a0b5fc6c82ddbd972c5fd79c1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::FocusSpansMultiplePageItems </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_focus.html">ITextFocus</a> *&nbsp;</td><td class="paramname"><em>pFocus</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Does the focus span more than one page item frames. </div></div><a class="anchor" id="a7895d6cc8b635a24d908561ff8998250"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GenerateListsOfAttributesThatCanBeCleared </td><td>(</td><td class="paramtype"><a class="el" href="class_i_workspace.html">IWorkspace</a> *&nbsp;</td><td class="paramname"><em>workspace</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>characterAttributes</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>paragraphAttributes</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Populates the two passed in attribute boss lists with all the character attributes and paragraph attributes, respectively, that can exist in a style and therefore the attributes that can be &quot;cleared&quot;. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">workspace</td><td>&mdash; Workspace to use as the basis for collecting all possible &quot;style&quot; attributes. </td></tr><tr><td class="paramname">characterAttributes</td><td>&mdash; <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> to populate with the complete list of character attributes that can be cleared (in a style) </td></tr><tr><td class="paramname">paragraphAttributes</td><td>&mdash; <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> to populate with the complete list of paragraph attributes that can be cleared (in a style) </td></tr></table></dl></div></div><a class="anchor" id="af0cfa4c9bda0095f42497d0f626e0777"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::GetChapterNumber </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Return the chapter number

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">target</td><td>The relevant text frame or an owned item </td></tr></table></dl></div></div><a class="anchor" id="aecb67ce96baf86c439f1007cb881a97a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetDefaultTextAttrPreferences </td><td>(</td><td class="paramtype">const <a class="el" href="struct_i_text_utils_1_1_which_text_attrs.html">WhichTextAttrs</a>&nbsp;</td><td class="paramname"><em>which</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="struct_i_text_utils_1_1_text_attrs.html">TextAttrs</a> &amp;&nbsp;</td><td class="paramname"><em>out</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_document.html">IDocument</a> *&nbsp;</td><td class="paramname"><em>prefsFromDocument</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the requested attributes from the preferences of the document specified. prefsFromDocument should be non nil. For paragraph and character overrides only continuing attributes are returned. </div></div><a class="anchor" id="add895082a3058e3c462a213dc9804395"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetDisplayFontNames </td><td>(</td><td class="paramtype"><a class="el" href="class_i_font_group.html">IFontGroup</a> *&nbsp;</td><td class="paramname"><em>fontGroup</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>font</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>familyName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>styleName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591e">DisplayNamesFlag</a>&nbsp;</td><td class="paramname"><em>namesFlag</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the display font names for font <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">*fontGroup</td><td>font group for font </td></tr><tr><td class="paramname">*font</td><td>font to get name from </td></tr><tr><td class="paramname">&amp;familyName</td><td>OUT </td></tr><tr><td class="paramname">&amp;styleName</td><td>OUT </td></tr><tr><td class="paramname">namesFlag</td><td>See enum DisplayNamesFlag. </td></tr></table></dl></div></div><a class="anchor" id="ae5dee4ea410ceab41d7891f64b574bd0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetDisplayFontNames </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>dataBase</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_text_attr_u_i_d.html">ITextAttrUID</a> *&nbsp;</td><td class="paramname"><em>fontUID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_text_attr_font.html">ITextAttrFont</a> *&nbsp;</td><td class="paramname"><em>fontStyle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>familyName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>styleName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_text_utils.html#a3acb640ea65f12df87390446686b591e">DisplayNamesFlag</a>&nbsp;</td><td class="paramname"><em>namesFlag</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the display font names for font <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">*dataBase</td><td>database of family UID </td></tr><tr><td class="paramname">fontUID</td><td>family UID </td></tr><tr><td class="paramname">fontStyle</td><td>style of font </td></tr><tr><td class="paramname">&amp;familyName</td><td>OUT </td></tr><tr><td class="paramname">&amp;styleName</td><td>OUT </td></tr><tr><td class="paramname">namesFlag</td><td>See enum DisplayNamesFlag. </td></tr></table></dl></div></div><a class="anchor" id="a83e4dbd4dd270cde4a0e92e23ab995c5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a> ITextUtils::GetFirstFrameOfStory </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>story</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Returns the Ref of first frame of the story

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">story</td><td>whose first frame we need to find. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>ref of spline of first MCF, otherwise kInvalidUIDRef if not able to find one </dl></div></div><a class="anchor" id="a88edaa0205663b83e4d6ac265c784aa4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::GetFontStyleName </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_attr_font.html">ITextAttrFont</a> *&nbsp;</td><td class="paramname"><em>fromFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_text_attr_font.html">ITextAttrFont</a> *&nbsp;</td><td class="paramname"><em>toFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> *&nbsp;</td><td class="paramname"><em>styleName</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>used by ApplyTextAttrToWorkspaceCmd, UserApplyAttrCmd, and TextState. </div></div><a class="anchor" id="a0780fcf189c7dbe0fe9bdffe95b49932"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetFormattedChapterNumberString </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> *&nbsp;</td><td class="paramname"><em>s</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>v</em> = <code>kInvalidChapterNumber</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Return the chapter number as a string.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">target</td><td>The relevant database </td></tr><tr><td class="paramname">s</td><td>The returned formatted string </td></tr><tr><td class="paramname">v</td><td>The optional value to format. If v==kInvalidChapterNumber, the value is retrieved from GetChapterNumber. </td></tr></table></dl></div></div><a class="anchor" id="a566955fe0c8437d6859d3ee68f031c5b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetFormattedPageNumberString </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textFrameRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> *&nbsp;</td><td class="paramname"><em>s</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_drawing_style.html#a88497f2df0fee98b16f61c3c3da66d93">IDrawingStyle::PositionIndicator</a>&nbsp;</td><td class="paramname"><em>whichPage</em> = <code>IDrawingStyle::kDataPosition_ThisPage</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the formatted string for the current, previous, or next page the given textFrame is on. </div></div><a class="anchor" id="a8c5c06fc54defaa788b7c56b9493296a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetFormattedSectionNameString </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textFrameRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> *&nbsp;</td><td class="paramname"><em>s</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the formatted string for the section the given textFrame is on </div></div><a class="anchor" id="a7ef62197b07d03b1262ced71f525c452"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_wide_string.html">WideString</a> ITextUtils::GetFullVisibleParagraphString </td><td>(</td><td class="paramtype"><a class="el" href="class_i_compose_scanner.html">IComposeScanner</a> *&nbsp;</td><td class="paramname"><em>scanner</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>textIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>paragraphSpan</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Return the text of a paragraph including any paragraph numbers at the beginning. Any non-visible characters are also stripped out.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">scanner</td><td>Compose Scanner for the story with the paragraph. </td></tr><tr><td class="paramname">textIndex</td><td>position in the paragraph. </td></tr><tr><td class="paramname">paragraphSpan</td><td>[OUT]. Length of the paragraph according to the scanner. This will NOT be the length of the returned string. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the paragrah string with non-visible characters stripped out and any numbers prepended if there are any. </dl></div></div><a class="anchor" id="aaa3f48588d18dd5630e0bbb49c6f4425"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetGlyphsForOverrides </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>range</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>overrides</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">std::vector&lt; std::pair&lt; Text::GlyphID, TextIndex &gt;&gt; *&nbsp;</td><td class="paramname"><em>newGlyphPoints</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>clearOverrides</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Creates Glyphs for a given text range in text model with attributes to be overriden. Does not modify composed text frame.

Appends overrides to current style and finds the glyphs.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">model</td><td>on which the whole action isto be taken. Current styles will be picked from this. </td></tr><tr><td class="paramname">range</td><td>of model on which the overrides need to be applied. </td></tr><tr><td class="paramname">overrides</td><td>list of attributes,that need to be applied on range. </td></tr><tr><td class="paramname">newGlyphPoints(out)</td><td>list of Pair (glyphs and corresponding text index) that would be used with override. Does not allocate memory. Please pass reference to valid object. </td></tr><tr><td class="paramname">clearOverrides</td><td>set to true if overrides need to be cleared and not applied. </td></tr></table></dl></div></div><a class="anchor" id="acd4dbc2039827564578d5461ff8e4820"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_document.html">IDocument</a>* ITextUtils::GetLastDocInBook </td><td>(</td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>docWasAlreadyOpen</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>startPageNum</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the last document in the current active book and whether it was already opened or not. </div></div><a class="anchor" id="a6648c38aafb4adf0f9ecfde5326cc5f6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetLocaleFromTextIndex </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>modelRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const TextIndex&nbsp;</td><td class="paramname"><em>position</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>noLang</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">void *&nbsp;</td><td class="paramname"><em>locale</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Return the ICU Locale for the given target and position.

If the target is a TextModel, then if the position is valid, it will return the LanguageID applied to that location.

Otherwise, if target refers to a valid document, the default languageID for the document is returned.

Otherwise, kLanguageNeutral is returned.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">target</td><td>Preferably a document or a TextModel, but can be an empty <a class="el" href="class_u_i_d_ref.html">UIDRef</a> or any reference to the desired document. </td></tr><tr><td class="paramname">position</td><td>The position in the model. Optional. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The ID of the language applied to the given location. </dl></div></div><a class="anchor" id="a19937958afb2d2beaf74af50a8475bc2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::GetMultiColFrameIndex </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="paramname"><em>mcf</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">returns the index of a multicolumn frame in its thread by simply calling

</pre><p><a class="el" href="class_i_multi_column_text_frame.html#ad84c215085d5b10e896b7ee5c1fb75c2">IMultiColumnTextFrame::GetMCFIndex()</a>; Note: This was broken in CS2 and was returning the index first TextFrameColumn within the FrameList. It was fixed in CS5. </div></div><a class="anchor" id="a0760fd1ccdc28ac198042e72740b70e2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a> ITextUtils::GetNextPageNumberFrameRef </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textFrameRef</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> for the page number after to the one the given textFrame is on </div></div><a class="anchor" id="a9035982a7aef03658f3ddddcafb618d6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::GetPageCount </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>target</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">enum <a class="el" href="class_i_text_utils.html#aa8b9124764a96c9f4b3883c41ae08797">PageCountScopes</a>&nbsp;</td><td class="paramname"><em>scope</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Return the page count based on the given scope

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">target</td><td>The relevant text frame or an owned item </td></tr></table></dl></div></div><a class="anchor" id="a127fa4159eef7bbb324af061c9421e0f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::GetPageNumber </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textFrameRef</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the page number for the page the given textFrame is on </div></div><a class="anchor" id="a828928eaec8795ccdc5ae74643be0beb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">ClassID</a> ITextUtils::GetPageNumberFormatter </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textFrameRef</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the number formatter for the page the given textFrame is on. Formatter is also applicable for chapter numbers. </div></div><a class="anchor" id="a9f1c1b68b3b11d85a3a078684825276e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::GetPageNumberFromPageUID </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>page</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the page number for the page with given page uid </div></div><a class="anchor" id="a9fe254bc1168528f1bd1c222f3565845"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a> ITextUtils::GetPageUIDRef </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textFrameRef</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Return the UIDRef for the page the given textFrame is on

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">target</td><td>The textFrame or OwnedItem whose page number is desired. </td></tr></table></dl></div></div><a class="anchor" id="a15cb61f4f3f8c36e7d8d01569008a285"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::GetParcelContentBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> *&nbsp;</td><td class="paramname"><em>tpl</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>pCBounds</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the Content Bounds of the Parcel at the specified TextIndex. If there is no Parcel at that TextIndex then it returns kFalse. Note that if the text at that location isn&#39;t fully composed then the Parcel you get may not be the same Parcel after composition. </div></div><a class="anchor" id="ae6da0215ea22d8a7710711caaebca8c5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a> ITextUtils::GetPreviousPageNumberFrameRef </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textFrameRef</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> for the page number previous to the one the given textFrame is on </div></div><a class="anchor" id="aa0db7278cb9c072982a077902eabc217"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetPrimaryStoryAnchor </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>storyRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>range</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Calculate the range in the main story thread that ultimately owns the given range. e.g. Works to backtrack from a footnote or note or inline to the owning text index. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">point1</td><td>[IN/OUT] storyRef, the story that ultimately &quot;owns&quot; the given range. </td></tr><tr><td class="paramname">point2</td><td>[IN/OUT] range, the &quot;owning&quot; range of the original given range. </td></tr></table></dl></div></div><a class="anchor" id="a1d24eafb26bdc25e4b08c93a1ad3c932"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetPrimaryThreadAnchor </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>range</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Calculate the range in the main story thread that owns the given range. within the same TextModel. Unlike <a class="el" href="class_i_text_utils.html#aa0db7278cb9c072982a077902eabc217">GetPrimaryStoryAnchor()</a> above, this method does NOT attempt to back out of inlines into a different story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">model</td><td>TextModel to work on </td></tr><tr><td class="paramname">range</td><td>[IN/OUT] the &quot;owning&quot; range of the original given range. </td></tr></table></dl></div></div><a class="anchor" id="a1183319b711cc5a68dba0eb18a64ece5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetSelectedTextItemsFromLayoutTarget </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_layout_target.html">ILayoutTarget</a> *&nbsp;</td><td class="paramname"><em>layoutTarget</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>textframes</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>mcfs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>splineItems</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetSelectedTextItemsFromLayoutTarget gathers UIDs for the text frames that are currently selected. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">layoutTarget</td><td>IN The current <a class="el" href="class_i_layout_target.html">ILayoutTarget</a> you want to gather selected text items from. </td></tr><tr><td class="paramname">textframes</td><td>OUT The text frames that are currently selected. </td></tr><tr><td class="paramname">mcfs</td><td>OUT The multi column frames that are currently selected. </td></tr><tr><td class="paramname">splineItems</td><td>OUT The spline items that are currently selected. </td></tr></table></dl></div></div><a class="anchor" id="abb64d339cc32f77875253bed103dcd7b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetSelectedTextItemsFromTextTarget </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_target.html">ITextTarget</a> *&nbsp;</td><td class="paramname"><em>textTarget</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>textframes</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>mcfs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>splineItems</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetSelectedTextItemsFromTextTarget gathers UIDs for the text frames that are currently selected. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textTarget</td><td>IN The current <a class="el" href="class_i_text_target.html">ITextTarget</a> you want to gather selected text items from. </td></tr><tr><td class="paramname">textframes</td><td>OUT The text frames that are currently selected. </td></tr><tr><td class="paramname">mcfs</td><td>OUT The multi column frames that are currently selected. </td></tr><tr><td class="paramname">splineItems</td><td>OUT The spline items that are currently selected. </td></tr></table></dl></div></div><a class="anchor" id="a1398d52b2560173c879eafbd3f47d66f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetSelectedTextItemsFromUIDList </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>pageITems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>textframes</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>mcfs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>splineItems</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetSelectedTextItemsFromLayoutTarget gathers UIDs for the text frames that are currently selected. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_u_i_d_list.html">UIDList</a></td><td>IN The pageitems to look through for text frames </td></tr><tr><td class="paramname">textframes</td><td>OUT The text frames that are currently selected. </td></tr><tr><td class="paramname">mcfs</td><td>OUT The multi column frames that are currently selected. </td></tr><tr><td class="paramname">splineItems</td><td>OUT The spline items that are currently selected. </td></tr></table></dl></div></div><a class="anchor" id="a1d84123117c4e50b361aa216a5eeed89"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::GetSpreadMultiColumnTextFrames </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>spreadRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>pList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Description: Fills in list of IMultiColumnTextFrames known to the

</pre><p> spread. by calling the <a class="el" href="class_i_spread_multi_column_frames.html">ISpreadMultiColumnFrames</a> interface on the specified Spread. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spreadRef</td><td><a class="el" href="class_u_i_d_ref.html">UIDRef</a> to spread to return MCFs from </td></tr><tr><td class="paramname">pList</td><td><a class="el" href="class_u_i_d_list.html">UIDList</a> to fill </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Length of pList </dl></div></div><a class="anchor" id="aee23bbc3ac7963629ca9485b4fa86033"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::GetSpreadTextFrameColumns </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>spreadRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>pList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Description: Fills in list of ITextFrameColumns known to the spread by

</pre><p> calling the <a class="el" href="class_i_spread_multi_column_frames.html">ISpreadMultiColumnFrames</a> interface on the specified Spread. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spreadRef</td><td><a class="el" href="class_u_i_d_ref.html">UIDRef</a> to spread to return TFCs from </td></tr><tr><td class="paramname">pList</td><td><a class="el" href="class_u_i_d_list.html">UIDList</a> to fill </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Length of pList </dl></div></div><a class="anchor" id="a15bea23cdd960571b5bd8cc5ef738ffd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::GetTargetContainerContinues </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>target</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return whether or not the container for the given target continues elsewhere (e.g. a table continues to another frame) </div></div><a class="anchor" id="ace181f35364cc8402a9543689b7d43f8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::GetTargetIsInContinuedContainer </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>target</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return whether or not the container for the given target is continued from elsewhere (e.g. a table is continued from the previous frame) </div></div><a class="anchor" id="a7a2ccacb06f03e4dbbed602e10bfecca"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetTextFramesContaining </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>textModel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>range</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pFirstFrameIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pLastFrameIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetTextFramesContaining returns the range of TextFrames that the Parcels containing the Text Range map to. The Range MUST be within a single StoryThread. pFirstFrameIndex will be -1 if the Text Range does not map to a Text Frame. </div></div><a class="anchor" id="af70ae5c23b12cf4c497e73f67f717620"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITextUtils::GetTextFramesPageItemUID </td><td>(</td><td class="paramtype"><a class="el" href="class_i_geometry.html">IGeometry</a> *&nbsp;</td><td class="paramname"><em>pageItem</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the uid of the page which this text frame is one, can return kInvalidUID <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageItem</td><td>&ndash; pageitem to find page UID of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>UID </dl></div></div><a class="anchor" id="ab2a0293b8e4b71c12a8d99482bbfd8fc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetUIDListOfInlines </td><td>(</td><td class="paramtype"><a class="el" href="class_i_parcel.html">IParcel</a> *&nbsp;</td><td class="paramname"><em>parcel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bWithDropCaps</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>resultList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns the child for each Inline UID in the owned item strand </div></div><a class="anchor" id="afd4b4244547c0c27a07c25a71c599ba8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetUIDListOfTextFramesFromRange </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>textModel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>range</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>resultList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetUIDListOfTextFrames returns a list of TextFrames that the Parcels containing the specified Text Range map to. The Range MAY cross StoryThread boundries. </div></div><a class="anchor" id="a2432305cf9d6675db518cfb42c404056"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetUsedInks </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>textModel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>threadEnd</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>len</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_ink_resource_data.html">IInkResourceData</a> *&nbsp;</td><td class="paramname"><em>inkResourceData</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in inkResourceData with the known inks in the specified Range. It incorporates handling of the last CR in the Story Thread, so callers need not take care of removing it from the range.<p>Notes:<ol type="1"><li>This routine only examines Text attributes from a canned list and is currently not extensible.<li>The caller is responsible for making sure that the specified range is fully composed. </ol></div></div><a class="anchor" id="a6c661012578ba71ea4479e7fc1703ad2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a> ITextUtils::GetWaxToFrameMatrix </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_parcel.html">IParcel</a> *&nbsp;</td><td class="paramname"><em>parcel</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the <a class="el" href="class_p_m_matrix.html">PMMatrix</a> to transform a point in WaxCoordinates in a Parcel to the owning Frame. Useful if you are an inline and you want to find out where you are relative to the Frame. </div></div><a class="anchor" id="a31eda33a9f3fe0de3d6675dec241fa46"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::GetWordCountInfo </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>iTextModel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const uint32 &amp;&nbsp;</td><td class="paramname"><em>startIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32 &amp;&nbsp;</td><td class="paramname"><em>lengthToCount</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_text_utils.html#adf5b3f26a4fd3c9f278d925be7cc6fe3">ITextUtils::WordCountUpdateAction</a> &amp;&nbsp;</td><td class="paramname"><em>action</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const ITextUtils::WordCountUpdateState &amp;&nbsp;</td><td class="paramname"><em>state</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>wordStarted</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>fullWidthChars</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>oversetFullWidthChars</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>halfWidthChars</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>oversetHalfWidthChars</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>japaneseChars</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>oversetJapaneseChars</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>kanjis</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>oversetKanjis</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>words</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>oversetWords</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>lines</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>oversetLines</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>paragraphs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>oversetParagraphs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>allChars</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 &amp;&nbsp;</td><td class="paramname"><em>oversetAllChars</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>bWordAcrossOverset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_text_story_thread_helper.html">TextStoryThreadHelper</a> &amp;&nbsp;</td><td class="paramname"><em>helper</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Do roman character, all character, katakana, hiragana, kanji, paragraph and line count<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">startIndex</td><td>&mdash; start index for counting </td></tr><tr><td class="paramname">lengthToCount</td><td>&mdash; how far should count stop. </td></tr><tr><td class="paramname">action</td><td>&mdash; just update line or update all. </td></tr><tr><td class="paramname">state</td><td>&mdash; start or continue counting. </td></tr><tr><td class="paramname">wordStarted</td><td>&mdash; left over state(word is started or not) of last time. </td></tr><tr><td class="paramname">fullWidthChars</td><td>&mdash; count of full-width chars including full-width numbers, symbols and punctuations. (passed out parameter) </td></tr><tr><td class="paramname">oversetFullWidthChars</td><td>&mdash; count of full-width chars including full-width numbers, symbols and punctuations in overset. (passed out parameter) </td></tr><tr><td class="paramname">halfWidthChars</td><td>&mdash; count of half-width chars including half-width numbers, symbols and punctuations. (passed out parameter) </td></tr><tr><td class="paramname">oversetHalfWidthChars</td><td>&mdash; count of half-width chars including half-width numbers, symbols and punctuations in overset. (passed out parameter) </td></tr><tr><td class="paramname">japaneseChars</td><td>&mdash; count of japanese chars including full and half-width Hiragana and Katakana. (passed out parameter) </td></tr><tr><td class="paramname">oversetJapaneseChars</td><td>&mdash; count of japanese chars including full and half-width Hiragana and Katakana in overset. (passed out parameter) </td></tr><tr><td class="paramname">kanjis</td><td>&mdash; count of kanjis. (passed out parameter) </td></tr><tr><td class="paramname">oversetKanjis</td><td>&mdash; count of kanjis in overset. (passed out parameter) </td></tr><tr><td class="paramname">words</td><td>&mdash; count of words. (passed out parameter) </td></tr><tr><td class="paramname">oversetWords</td><td>&mdash; count of words in overset. (passed out parameter) </td></tr><tr><td class="paramname">lines</td><td>&mdash; count of lines. (passed out parameter) </td></tr><tr><td class="paramname">oversetLines</td><td>&mdash; count of lines in overset. (passed out parameter) </td></tr><tr><td class="paramname">paragraphs</td><td>&mdash; count of paragraphs. (passed out parameter) </td></tr><tr><td class="paramname">oversetParagraphs</td><td>&mdash; count of paragraphs in overset. (passed out parameter) </td></tr><tr><td class="paramname">allChars</td><td>&mdash; count of all characters(passed out parameter) </td></tr><tr><td class="paramname">oversetAllChars</td><td>&mdash; count of all characters in overset. (passed out parameter) </td></tr></table></dl></div></div><a class="anchor" id="a032b93fd79bab2ed53495ebb69b6b97a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_wide_string.html">WideString</a>&amp; ITextUtils::GetXRefChapterNumberVariableName </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a pointer to a <a class="el" href="class_wide_string.html">WideString</a> with the name of the XRefChapterNumberVariable. <dl class="section return"><dt>Returns<dd><a class="el" href="class_wide_string.html">WideString</a></dl></div></div><a class="anchor" id="aede959a18b839c214f97375dbb0079b3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_wide_string.html">WideString</a>&amp; ITextUtils::GetXRefPageNumberVariableName </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a pointer to a <a class="el" href="class_wide_string.html">WideString</a> with the name of the XRefPageNumberVariable. <dl class="section return"><dt>Returns<dd><a class="el" href="class_wide_string.html">WideString</a></dl></div></div><a class="anchor" id="a99a7d9881eb20dea3821c3c17b4da41c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::GuessScriptOfText </td><td>(</td><td class="paramtype">const char *&nbsp;</td><td class="paramname"><em>anyText</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>preferredWritingScript</em> = <code>kDontKnowScript</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns the best guess for the text&#39;s writing script, preferredWritingScript is being used as a hint. </div></div><a class="anchor" id="a323519df19dec1e15cfd59e4efe98fca"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsAdobeFont </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> const *&nbsp;</td><td class="paramname"><em>font</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Does this font carry an Adobe copyright? </div></div><a class="anchor" id="ac9a8afe9bad3cd0327267f162d5cd89c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsBoldItalicStyleName </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>styleName</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is this style name considered bold and italic? </div></div><a class="anchor" id="a59fea82a2d995a76e31d021f7e4b38bf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsBoldStyleName </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>styleName</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is this style name considered bold? (For example, &quot;Bold&quot;, &quot;Heavy&quot;, &quot;Black&quot;) </div></div><a class="anchor" id="a7fcd886ec324d267b9bda2f67ee15f3b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsFocusAFootnote </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_focus.html">ITextFocus</a> *&nbsp;</td><td class="paramname"><em>pFocus</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a> *&nbsp;</td><td class="paramname"><em>pFootnoteUIDRef</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns whether the given <a class="el" href="class_i_text_focus.html">ITextFocus</a> is a footnote and optionally returns the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> for that footnote <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pFocus</td><td>&mdash; The <a class="el" href="class_i_text_focus.html">ITextFocus</a> in question </td></tr><tr><td class="paramname">pFootnoteUIDRef</td><td>&mdash; If non-nil and there is a footnote at that model-position, the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the footnote </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Whether the focus is a footnote. </dl></div></div><a class="anchor" id="a963d5f97fd45950484f6f8a5bb7f8028"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsFootnote </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>position</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a> *&nbsp;</td><td class="paramname"><em>pFootnoteUIDRef</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns whether the position in the model is a footnote and optionally returns the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> for that footnote <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">model</td><td>&mdash; The model in question </td></tr><tr><td class="paramname">position</td><td>&mdash; The position in the given model </td></tr><tr><td class="paramname">pFootnoteUIDRef</td><td>&mdash; If non-nil and there is a footnote at that model-position, the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the footnote </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Whether that model-position is a footnote. </dl></div></div><a class="anchor" id="a1e2fa4d5c59563a4fab69c1558039a7c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsItalicStyleName </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>styleName</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is this style name considered italic? (For example, &quot;Italic&quot;, &quot;Oblique&quot;) </div></div><a class="anchor" id="a3969f61dc8f0ab7149964a5f64ecf925"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsLeftToRightRun </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_wax_line.html">IWaxLine</a> *&nbsp;</td><td class="paramname"><em>waxLine</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>ti</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Returns whether or not the run at the text index within the specified line is left to right direction.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">waxLine</td><td>the line to examine. </td></tr><tr><td class="paramname">textIndex</td><td>position in the line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the run direction is left to right, otherwise kFalse. </dl></div></div><a class="anchor" id="a39dc310c748b3c3d2073fe1718616ade"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsMultiColumnFrame </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>obj</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Return whether or not the given object is a MultiColumn TextFrame

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">obj</td><td>can be any object </td></tr></table></dl></div></div><a class="anchor" id="a2039dc31bb8e6ee6629573fd9cc963f8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsOpenTypeFamily </td><td>(</td><td class="paramtype"><a class="el" href="class_i_font_family.html">IFontFamily</a> *&nbsp;</td><td class="paramname"><em>fontFamily</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is this font family an opentype font family? </div></div><a class="anchor" id="a0ffd7da19e7ff663901f6e8d886a485c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsOpenTypeFont </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>font</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is this font an opentype font? </div></div><a class="anchor" id="a7062f79aac31991e66ed9f7b3b1ba3d5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsOverset </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_frame_list.html">IFrameList</a> *&nbsp;</td><td class="paramname"><em>fl</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Is the text parcel list overset?

</pre><dl class="section return"><dt>Returns<dd>returns kTrue if the specified ParcelList has any characters in addition to the final carriage return not mapped to a Parcel. If it&#39;s ONLY the final carriage return that is overset that it is NOT considered overset. </dl></div></div><a class="anchor" id="a099114b66b75224fb66a47443fbe1c80"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsPlainStyleName </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>styleName</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is this style name considered plain? (For example, &quot;Roman&quot;, &quot;Regular&quot;, &quot;&quot;) </div></div><a class="anchor" id="abefc48252c7380b8320490b975a2d015"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsScriptOfText </td><td>(</td><td class="paramtype">const char *&nbsp;</td><td class="paramname"><em>anyText</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>writingScript</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns false if writingScript and text are contradicting. </div></div><a class="anchor" id="aa1f57c26741c4dd2eaee8c0e9b7cb7df"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::IsTextValidForInsertion </td><td>(</td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> const &amp;&nbsp;</td><td class="paramname"><em>text</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Checks if the specified text is valid for insertion in the text model. Some control characters are not accepted by the text model. <dl class="section see"><dt>See Also<dd><a class="el" href="namespace_text_char.html#ac34f9e78d06d52b8c3e4685f93b10285">TextChar::IsIllegalControlChar()</a>. </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">text</td><td>[IN] text to be checked for validity. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the text is valid. </dl></div></div><a class="anchor" id="a758846fca28a85fa9e1d45d7b8f0e014"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode ITextUtils::LinkTextFrames </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="paramname"><em>textFrameA</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="paramname"><em>textFrameB</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>prepend</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Link two text frames together as follows: If prepend is kFalse, then the textFrameA will be linked to textFrameB. Thus, existing text will flow from textFrameA to textFrameB. If prepend is kTrue, then the textFrameB will be linked to textFrameA. Thus, existing text will flow from textFrameB to textFrameA. In both cases, textFrameB will inherit textFrameA&#39;s attributes (e.g. vertical or horizontal frame). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textFrameA</td><td>- see desc above. </td></tr><tr><td class="paramname">textFrameB</td><td>- see desc above. </td></tr><tr><td class="paramname">prepend</td><td>- see desc above. </td></tr></table></dl></div></div><a class="anchor" id="aa9259d8ab41c0aa29ec288af28d985fc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::NotifyOversetChanged </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_frame_list.html">IFrameList</a> *&nbsp;</td><td class="paramname"><em>frameList</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Notifies the last Frame in the FrameList that its overset state may have changed. This call simply posts the appropriate inval rect for the location of the overset indicator and adds the Frame to the RecomposedFrames list. Note that the caller must ensure that at least one Frame in the FrameList is damaged or else the inval may never be played until the Frame becomes damaged and is recomposed. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">frameList</td><td></td></tr></table></dl></div></div><a class="anchor" id="a8b4a388f1ee39a829b2e06919bd4c4e2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::QueryCopyStoryCommand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;&nbsp;</td><td class="paramname"><em>sourceRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;&nbsp;</td><td class="paramname"><em>destRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>ignoreAttributes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Function for copying text from one story to another.

</pre><p> This replaces the range in the destination story with a copy of the specified text from the source story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the source <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">dest</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the destination <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">ignoreAttributes</td><td>Ignore the attributes on copy, default to kFalse </td></tr></table></dl></div></div><a class="anchor" id="afe6b3d2e53ba1d4c8f1498d8a8ba027c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::QueryCopyStoryFromAllToAllCommand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>ignoreAttributes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Function for copying all of the text from one story to another.

</pre><p> This replaces the destination story with a copy of the source story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the source <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">dest</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the destination <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">ignoreAttributes</td><td>Ignore the attributes on copy, default to kFalse </td></tr></table></dl></div></div><a class="anchor" id="a56f376effb6c1bd867082db3919813ce"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::QueryCopyStoryFromAllToEndCommand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>ignoreAttributes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Function for copying text from one story to another.

</pre><p> This copies the entire source story to the end of the destination story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the source <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">dest</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the destination <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">ignoreAttributes</td><td>Ignore the attributes on copy, default to kFalse </td></tr></table></dl></div></div><a class="anchor" id="a9648ba26764772a8d18f1393d0b59f1f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::QueryCopyStoryToEndCommand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;&nbsp;</td><td class="paramname"><em>sourceRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>ignoreAttributes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Function for copying text from one story to another.

</pre><p> This copies the specified text from the source story to the end of the destination story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the source <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">dest</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the destination <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">ignoreAttributes</td><td>Ignore the attributes on copy, default to kFalse </td></tr></table></dl></div></div><a class="anchor" id="aaad1557df85e50775239f49810a4067f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_hierarchy.html">IHierarchy</a>* ITextUtils::QueryForHierarchyMember </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *&nbsp;</td><td class="paramname"><em>textFrame</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert the textFrame to a member of <a class="el" href="class_i_hierarchy.html">IHierarchy</a> (even if the textFrame is Text-on-a-Path) </div></div><a class="anchor" id="af13a6cd2f2d49659539217601461a579"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a>* ITextUtils::QueryMCFOrTOPFromSpline </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_graphic_frame_data.html">IGraphicFrameData</a> *&nbsp;</td><td class="paramname"><em>gfd</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">If the spline contains text, return the associated multi-column object.

</pre><p> If spline doesn&#39;t contain text and if the spline has TOP, return the multi-column object associated with <a class="el" href="classk_t_o_p_frame_item_boss.html">kTOPFrameItemBoss</a>. return nil, for other conditions. </div></div><a class="anchor" id="a7a34d61ad6a73e24af3d31f47e2298fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::QueryMoveStoryCommand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;&nbsp;</td><td class="paramname"><em>sourceRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;&nbsp;</td><td class="paramname"><em>destRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>ignoreAttributes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Function for moving text from one story to another.

</pre><p> This replaces the range in the destination story with the specified text from the source story. The source range is removed from the source story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the source <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">dest</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the destination <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">ignoreAttributes</td><td>Ignore the attributes on move, default to kFalse </td></tr></table></dl></div></div><a class="anchor" id="ac09a38bde225062c2860b88c4625fc86"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::QueryMoveStoryFromAllCommand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_text_1_1_story_range.html">StoryRange</a> &amp;&nbsp;</td><td class="paramname"><em>destRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>ignoreAttributes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Function for moving text from one story to another.

</pre><p> The entire source story is moved to the destination range. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the source <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">dest</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the destination <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">ignoreAttributes</td><td>Ignore the attributes on move, default to kFalse </td></tr></table></dl></div></div><a class="anchor" id="aabaa994d3d0b00669b4f19e81fbd7b27"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::QueryMoveStoryFromAllToAllCommand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>ignoreAttributes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Function for moving text from one story to another.

</pre><p> This replaces the destination story with the source story. The source range is removed from the source story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the source <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">dest</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the destination <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">ignoreAttributes</td><td>Ignore the attributes on move, default to kFalse </td></tr></table></dl></div></div><a class="anchor" id="ac9a1d9cc30fb7499e9e6da0d63f8b7c1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ITextUtils::QueryMoveStoryFromAllToEndCommand </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>ignoreAttributes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Function for moving text from one story to another.

</pre><p> This moves the entire source story to the end of the destination story. The source range is removed from the source story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the source <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">dest</td><td>The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the destination <a class="el" href="class_i_text_model.html">ITextModel</a>. </td></tr><tr><td class="paramname">ignoreAttributes</td><td>Ignore the attributes on move, default to kFalse </td></tr></table></dl></div></div><a class="anchor" id="a2dc457e1610f3e8fa1cdcdea04c4f5c2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a>* ITextUtils::QueryMultiColumnFrame </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *&nbsp;</td><td class="paramname"><em>tfc</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Given an ITextFrameColumn, return the associated MultiColumn TextFrame.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">tfc</td><td>Pointer to <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a></td></tr></table></dl></div></div><a class="anchor" id="a9c3bb466402580c32c8d8e7479efc847"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a>* ITextUtils::QueryMultiColumnFrame </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *&nbsp;</td><td class="paramname"><em>tfc</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Const version of QueryMultiColumnFrame </div></div><a class="anchor" id="a3dd0f8f4252aa2bd5556644bc59f4940"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITextUtils::QueryMultiColumnFrameUID </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *&nbsp;</td><td class="paramname"><em>tfc</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>UID version of QueryMultiColumnFrame </div></div><a class="anchor" id="a1ee7474b9dec582b2cf34253d946dfb5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_hierarchy.html">IHierarchy</a>* ITextUtils::QuerySplineFromTextFrame </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a> *&nbsp;</td><td class="paramname"><em>mcf</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Given an IMultiColumnTextFrames, return the spline associated with it

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">mcf</td><td>Pointer to <a class="el" href="class_i_multi_column_text_frame.html">IMultiColumnTextFrame</a></td></tr></table></dl><dl class="section return"><dt>Returns<dd>Pointer to <a class="el" href="class_i_hierarchy.html">IHierarchy</a></dl></div></div><a class="anchor" id="ad91a322570dd6918ee992150d6200e8f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_hierarchy.html">IHierarchy</a>* ITextUtils::QuerySplineFromTextFrame </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> *&nbsp;</td><td class="paramname"><em>tfc</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Given an ITextFrameColumn, return the spline associated with the parent MultiColumnTextFrame.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">tfc</td><td>Pointer to <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a></td></tr></table></dl><dl class="section return"><dt>Returns<dd>Pointer to <a class="el" href="class_i_hierarchy.html">IHierarchy</a></dl></div></div><a class="anchor" id="aba35b91a88a829f0cdb5e4e98a3b3357"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> ITextUtils::RemapCharacterValue </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>oldFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>newFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;&nbsp;</td><td class="paramname"><em>textChar</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns the remapped textchar after converting to platform encoding using oldFont and back to newFont. </div></div><a class="anchor" id="ae2c036a105d0189804957790140cdd05"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextUtils::RemapCharacterValues </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>oldFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>newFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const textchar *&nbsp;</td><td class="paramname"><em>buffer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>bufferLength</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> *&nbsp;</td><td class="paramname"><em>replacedChars</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns the position of first remapped textchar in buffer and copies the remapped textchars in replacedChars after converting to platform encoding using oldFont and back to newFont. </div></div><a class="anchor" id="a4f8e33e94a783f1b48bb69fdfd6db4c0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::RemapFontStyles </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>dataBase</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &amp;&nbsp;</td><td class="paramname"><em>stateOverrides</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &amp;&nbsp;</td><td class="paramname"><em>newOverrides</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> *&nbsp;</td><td class="paramname"><em>styleName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>textAttrFontUIDBoss</em> = <code><a class="el" href="classk_text_attr_font_u_i_d_boss.html">kTextAttrFontUIDBoss</a></code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>textAttrFontStyleBoss</em> = <code><a class="el" href="classk_text_attr_font_style_boss.html">kTextAttrFontStyleBoss</a></code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>remapExactFontStylesOnly</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Remap font styles tries to choose the expected family/style and allow roundtripping. </div></div><a class="anchor" id="a7fab9a7d5d1443a33d747e8697304b65"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextUtils::RepairGenericDataLink </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>oldStoryRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>newStoryRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fix up TOC/Index/Third party links when placing a story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">oldStoryRef</td><td>[IN] The destination of the fixing operation. The story being fixed. </td></tr><tr><td class="paramname">newStoryRef</td><td>[IN] The source of the fixing operation. </td></tr></table></dl></div></div><a class="anchor" id="a585e0b5f5c8f9e54b991a75bbcebe4e3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual LanguageID ITextUtils::ScriptToLanguageID </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>writingScript</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Writing script to Language ID conversion. </div></div><a class="anchor" id="a2d60a6adf8d6f3607034a16d1838dba6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::SkipTextCharForFontLocking </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;&nbsp;</td><td class="paramname"><em>textChar</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">returns whether the char needs to be skipped during remapping.

</pre><p> Used by UserApplyAttrCmd, ScriptUserEditCmdResp, and CJKUserEditCmdResp. </div></div><a class="anchor" id="ace2eaedf756722752c9a0eb25b19b71a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextUtils::SkipTextCharForRemapping </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> &amp;&nbsp;</td><td class="paramname"><em>textChar</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">returns whether the char needs to be skipped during remapping.

</pre><p> Used by Text::RemapCharacterValue. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_text_utils.html">ITextUtils</a><li class="footer">Generated on Sat Sep 22 2018 10:54:31 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
