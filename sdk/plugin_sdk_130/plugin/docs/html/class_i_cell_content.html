<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_cell_content</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_cell_content.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_cell_content-members.html">List of all members</a></div><div class="headertitle"><div class="title">ICellContent Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><div class="dynheader"> Inheritance diagram for ICellContent:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_cell_content.png" usemap="#ICellContent_map" /><map id="ICellContent_map" name="ICellContent_map"><area alt="IPMUnknown" coords="0,0,183,24" href="class_i_p_m_unknown.html" shape="rect" /><area alt="CPMUnknown&lt; ICellContent &gt;" coords="0,112,183,136" href="class_c_p_m_unknown.html" shape="rect" /><area alt="CCellContent" coords="0,168,183,192" href="class_c_cell_content.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:aaff0bd5c201e08d5eedd650108406554"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ICELLCONTENT }</td></tr><tr class="separator:aaff0bd5c201e08d5eedd650108406554"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aee7bcb4b7fd73ec1300e48eb6db28174"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>GrowableDirection</b> { <br /> &nbsp;&nbsp;<b>kNone</b> = 0, <b>kLeft</b> = 0x01, <b>kTop</b> = 0x02, <b>kRight</b> = 0x04, <br /> &nbsp;&nbsp;<b>kBottom</b> = 0x08 <br /> }</td></tr><tr class="separator:aee7bcb4b7fd73ec1300e48eb6db28174"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a6c04259ea501aeeaf386409872b8ea1d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6c04259ea501aeeaf386409872b8ea1d"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetTableModel</b> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;tableModelRef)=0</td></tr><tr class="separator:a6c04259ea501aeeaf386409872b8ea1d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adda5c935eceb11e9cae3d7e61cf28445"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="adda5c935eceb11e9cae3d7e61cf28445"></a> virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTableModel</b> () const =0</td></tr><tr class="separator:adda5c935eceb11e9cae3d7e61cf28445"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a30c00967a6c643de3e55fd47fd03ea31"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a30c00967a6c643de3e55fd47fd03ea31"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetGridID</b> (const <a class="el" href="class_grid_i_d.html">GridID</a> &amp;gridID)=0</td></tr><tr class="separator:a30c00967a6c643de3e55fd47fd03ea31"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a19cf37fdeff2cf667482f9a56c575662"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a19cf37fdeff2cf667482f9a56c575662"></a> virtual <a class="el" href="class_grid_i_d.html">GridID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetGridID</b> () const =0</td></tr><tr class="separator:a19cf37fdeff2cf667482f9a56c575662"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a094eaa251bc8194422b8a7efe82c5c51"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a094eaa251bc8194422b8a7efe82c5c51"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetGridAddress</b> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;gridAddress)=0</td></tr><tr class="separator:a094eaa251bc8194422b8a7efe82c5c51"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3ab528a8c2455402db7023eb14bdf107"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3ab528a8c2455402db7023eb14bdf107"></a> virtual <a class="el" href="class_grid_address.html">GridAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetGridAddress</b> () const =0</td></tr><tr class="separator:a3ab528a8c2455402db7023eb14bdf107"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8aa664259ddbf83759d3ed7c8a2dc72d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a8aa664259ddbf83759d3ed7c8a2dc72d">GetCellPathBounds</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a8aa664259ddbf83759d3ed7c8a2dc72d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad3bd79a3f83d38067ec657ce507056a0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad3bd79a3f83d38067ec657ce507056a0"></a> virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelFrameUID</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:ad3bd79a3f83d38067ec657ce507056a0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9022e02119e8b35fef06fdbf65305b58"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9022e02119e8b35fef06fdbf65305b58"></a> virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelToFrameMatrix</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a9022e02119e8b35fef06fdbf65305b58"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a14a6cd58239918784730010179e0f660"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a14a6cd58239918784730010179e0f660"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelAcceptingInvals</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a14a6cd58239918784730010179e0f660"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a87f2888dee9e8c1eae9772b51ca2c57f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a87f2888dee9e8c1eae9772b51ca2c57f"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddParcelPendingInval</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;invalRect)=0</td></tr><tr class="separator:a87f2888dee9e8c1eae9772b51ca2c57f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afe32c10bef2e4ea62da03778b5ae2e3e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#afe32c10bef2e4ea62da03778b5ae2e3e">NotifyLayoutParcelDamageChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 isDamaged)=0</td></tr><tr class="separator:afe32c10bef2e4ea62da03778b5ae2e3e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a09b471e92cb44ca24a85254043de3d39"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a09b471e92cb44ca24a85254043de3d39">NotifyLayoutParcelPosDependentContentSet</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a09b471e92cb44ca24a85254043de3d39"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3a19e4f463fdfdb98485b054258d9d52"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a3a19e4f463fdfdb98485b054258d9d52">NotifyLayoutParcelInkBoundsChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a3a19e4f463fdfdb98485b054258d9d52"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a66473b0a5c7b7d23fb55fb5d2bfcfc69"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a66473b0a5c7b7d23fb55fb5d2bfcfc69">GetCellType</a> () const =0</td></tr><tr class="separator:a66473b0a5c7b7d23fb55fb5d2bfcfc69"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acab72c0580b8b67661162777030e4196"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#acab72c0580b8b67661162777030e4196">NotifyRowTypeChanging</a> (bool16 repeat, int32 lRowCount)=0</td></tr><tr class="separator:acab72c0580b8b67661162777030e4196"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa01622ec2fd61c2d729fbbe817dfb785"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa01622ec2fd61c2d729fbbe817dfb785"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InvalCellContent</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:aa01622ec2fd61c2d729fbbe817dfb785"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a854b7ca4fa0a189d18a9b0694d8b90c2"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a854b7ca4fa0a189d18a9b0694d8b90c2">ResetCompositionState</a> ()=0</td></tr><tr class="separator:a854b7ca4fa0a189d18a9b0694d8b90c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a33bec8358d052c67a86b9848352f9bf5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a33bec8358d052c67a86b9848352f9bf5"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelCount</b> () const =0</td></tr><tr class="separator:a33bec8358d052c67a86b9848352f9bf5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2e3b2fa59a465a20e89acc0e12098852"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2e3b2fa59a465a20e89acc0e12098852"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelIndex</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a2e3b2fa59a465a20e89acc0e12098852"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a53f41142eb62d5d7f5eb831652891cd2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a53f41142eb62d5d7f5eb831652891cd2"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNthParcelKey</b> (int32 n) const =0</td></tr><tr class="separator:a53f41142eb62d5d7f5eb831652891cd2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad89a064eb73eaf633c0aff90c7ff3c0f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#ad89a064eb73eaf633c0aff90c7ff3c0f">CreateParcelAt</a> (int32 index)=0</td></tr><tr class="separator:ad89a064eb73eaf633c0aff90c7ff3c0f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac6b345ff9f4f8906e07fb29d54676ad3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#ac6b345ff9f4f8906e07fb29d54676ad3">RemoveParcel</a> (int32 index)=0</td></tr><tr class="separator:ac6b345ff9f4f8906e07fb29d54676ad3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad5aaaa778e830f8e47df589573cba73a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#ad5aaaa778e830f8e47df589573cba73a">SetParcelGeometry</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;cellPathBounds, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;parcelBounds, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;maxGrowBounds, GrowableDirection growDir, bool16 contentAttributeChanged)=0</td></tr><tr class="separator:ad5aaaa778e830f8e47df589573cba73a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5da4644a43caf723530d38f44814babd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5da4644a43caf723530d38f44814babd"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelGrowDir</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, GrowableDirection growDir)=0</td></tr><tr class="separator:a5da4644a43caf723530d38f44814babd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a77ed3ef9fd9f5eae5e9821f2fda7b63a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a77ed3ef9fd9f5eae5e9821f2fda7b63a"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelHeight</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_p_m_real.html">PMReal</a> height)=0</td></tr><tr class="separator:a77ed3ef9fd9f5eae5e9821f2fda7b63a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a314f3826db5a9a3befeba6cbd8f469fa"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a314f3826db5a9a3befeba6cbd8f469fa">NotifyContentAttributeChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a314f3826db5a9a3befeba6cbd8f469fa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a27ec11280c64dcfeb21afe37322e7837"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a27ec11280c64dcfeb21afe37322e7837">NotifyParcelMoved</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a27ec11280c64dcfeb21afe37322e7837"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a542aa720c97809b33d5e5efa6f63bcb0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a542aa720c97809b33d5e5efa6f63bcb0">GetParcelNeedsComposition</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a542aa720c97809b33d5e5efa6f63bcb0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae946f216e5d6893a8ae5f9123176b949"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae946f216e5d6893a8ae5f9123176b949"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>RecomposeThruParcel</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:ae946f216e5d6893a8ae5f9123176b949"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a34921c921c27777dae45652c292eb1e9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a34921c921c27777dae45652c292eb1e9"></a> virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelContentInkBounds</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a34921c921c27777dae45652c292eb1e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9ccbadc2faf6cf981b6bde7e741113f6"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a9ccbadc2faf6cf981b6bde7e741113f6">GetParcelHasPositionDependentContent</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a9ccbadc2faf6cf981b6bde7e741113f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adfd34800e185a29cd09bee953f271e1a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#adfd34800e185a29cd09bee953f271e1a">GetParcelTopHungComposedBottom</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:adfd34800e185a29cd09bee953f271e1a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae887417dd3f0c4dd36cc7ca9d89f88a6"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae887417dd3f0c4dd36cc7ca9d89f88a6"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelBottomHungComposedTop</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:ae887417dd3f0c4dd36cc7ca9d89f88a6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5be494136eaff477e30b839b41584ede"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5be494136eaff477e30b839b41584ede"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelComposedGrowableHeight</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> parcelKey) const =0</td></tr><tr class="separator:a5be494136eaff477e30b839b41584ede"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a200c77a99e856456d3d7c7669b203e92"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a200c77a99e856456d3d7c7669b203e92">CollectParcelOwnedItems</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">OwnedItemDataList</a> *rList) const =0</td></tr><tr class="separator:a200c77a99e856456d3d7c7669b203e92"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae9a03c07981970fb972efac552d9cbd4"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#ae9a03c07981970fb972efac552d9cbd4">ConvertFromAnna</a> (TableLayout *layout)=0</td></tr><tr class="separator:ae9a03c07981970fb972efac552d9cbd4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a57581118214f6c42419117cad7ca2967"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a57581118214f6c42419117cad7ca2967">IsEmpty</a> () const =0</td></tr><tr class="separator:a57581118214f6c42419117cad7ca2967"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9e6ea11cb49140fcd7e5f58a2357ed95"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_cell_content.html#a9e6ea11cb49140fcd7e5f58a2357ed95">GetParcelPaintedBBox</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a9e6ea11cb49140fcd7e5f58a2357ed95"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a200c77a99e856456d3d7c7669b203e92"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::CollectParcelOwnedItems </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">OwnedItemDataList</a> *&nbsp;</td><td class="paramname"><em>rList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Appends the list of OwnedItems that are associated with the specified Parcel. Only those OwnedItems that are actually composed within the Parcel are added. Note that because of the presence of WaxAnchorPts and WaxAnchoredElements it is not sufficient to use the span of the Parcel to compute this. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">rList</td><td>The results are appended to the list. </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_cell_content.html#af2f2e4d8196c8d9efe4eb8f7ce1d0170">CCellContent</a>.</div></div><a class="anchor" id="ae9a03c07981970fb972efac552d9cbd4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::ConvertFromAnna </td><td>(</td><td class="paramtype">TableLayout *&nbsp;</td><td class="paramname"><em>layout</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal method. Do not call. <p>Implemented in <a class="el" href="class_c_cell_content.html#a8626335910295b48428f4d3f4cdb4723">CCellContent</a>.</div></div><a class="anchor" id="ad89a064eb73eaf633c0aff90c7ff3c0f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ICellContent::CreateParcelAt </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>index</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates a new Parcel at the specified index within the ParcelList. </div></div><a class="anchor" id="a8aa664259ddbf83759d3ed7c8a2dc72d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> ICellContent::GetCellPathBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convenience methods. See <a class="el" href="class_i_table_layout.html">ITableLayout</a> for more information. <p>Implemented in <a class="el" href="class_c_cell_content.html#ab79a4646a90d6c4bc2765be967c1d051">CCellContent</a>.</div></div><a class="anchor" id="a66473b0a5c7b7d23fb55fb5d2bfcfc69"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">CellType</a> ICellContent::GetCellType </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Cell Content Type (eg kTextContentType)<p>This method is used by Table Model to determine which Content Manager should handle the content of the cell during certain model operations. </div></div><a class="anchor" id="a9ccbadc2faf6cf981b6bde7e741113f6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ICellContent::GetParcelHasPositionDependentContent </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Some types of content may be positioned within the Parcel relative to some thing outside the Parcel, say the TextFrame or the Pasteboard. When the Parcel is moved it will require recomposition.<p>Only meaningful if the Parcel is fully composed, if called when it is not composed it will likely return kTrue. </div></div><a class="anchor" id="a542aa720c97809b33d5e5efa6f63bcb0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ICellContent::GetParcelNeedsComposition </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Retrurns kTrue if the specified Parcel OR any Parcel at a lower index needs to be composed. </div></div><a class="anchor" id="a9e6ea11cb49140fcd7e5f58a2357ed95"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> ICellContent::GetParcelPaintedBBox </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>parcel key to be queried for </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_p_m_rect.html">PMRect</a> painted bounding box of the parcel. Refer to <a class="el" href="class_i_shape.html">IShape</a> for more details on paintedBBox </dl></div></div><a class="anchor" id="adfd34800e185a29cd09bee953f271e1a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ICellContent::GetParcelTopHungComposedBottom </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>These bounds are NOT necessarily the bounds of the ink, they reflect the &quot;squishable&quot; size of the content or, in other words, the minimum size of the composed content.<p>For example, consider a TextCell which contains text that has Vertical Justification set to Fully Justified. The ink for this content fills the entire Parcel but the GrowableHeight is far less. As the Parcel is made shorter the spacing between the lines added by the Vertical Justification also shortens until there is no longer any added space. This final height is the GrowableHeight.<p>Growable Height/Width is only valid if the growable direction of the Parcel is compatible with the growable direction of the content. Consider a TextCell which has 90 degree content rotation. If the GrowableDirection of the Parcel is vertical then the value returned for GrowableHeight() will be zero. This prevents Parcels with this type of orientation from &quot;ratcheting&quot; up the height of the row and never allowing it to shrink.<p>TopHungComposedBottom() Returns the Parcel Bottom required to fit the bottom ofthe content without causing the top of the Parcel to change.<p>BottomHungComposedTop() Returns the Parcel Top required to fit the top of the content without causing the bottom of the Parcel to change. </div></div><a class="anchor" id="a57581118214f6c42419117cad7ca2967"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ICellContent::IsEmpty </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>bool16 kTure if the cell is empty. No text in case of text cell and empty graphic frame in case of graphic cell </dl></div></div><a class="anchor" id="a314f3826db5a9a3befeba6cbd8f469fa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::NotifyContentAttributeChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is called by the TableComposer when a Cell attribute which is marked as being a content attribute has been changed. The callee should examine all the content attributes that affect the cell and damage the content appropriately in the normal way. Note that for performance reasons this method should only be called when the composer knows that it does not need to call <a class="el" href="class_i_cell_content.html#ad5aaaa778e830f8e47df589573cba73a">SetParcelGeometry()</a>. </div></div><a class="anchor" id="afe32c10bef2e4ea62da03778b5ae2e3e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::NotifyLayoutParcelDamageChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isDamaged</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Notifies the Table Layout that the Parcel content damage state has changed. <p>Implemented in <a class="el" href="class_c_cell_content.html#a19562f04cd62693310961209f6c1babc">CCellContent</a>.</div></div><a class="anchor" id="a3a19e4f463fdfdb98485b054258d9d52"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::NotifyLayoutParcelInkBoundsChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>If the inkBounds of the Parcel changes outside of composition this method should be called. <p>Implemented in <a class="el" href="class_c_cell_content.html#a58ccf41ef7be13dfd3221da8f5566848">CCellContent</a>.</div></div><a class="anchor" id="a09b471e92cb44ca24a85254043de3d39"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::NotifyLayoutParcelPosDependentContentSet </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method should be calleed when a Parcel which has content which was not previously position dependent is now position dependent. <p>Implemented in <a class="el" href="class_c_cell_content.html#adb9fd63392e43fbf87dd72cdae8f6716">CCellContent</a>.</div></div><a class="anchor" id="a27ec11280c64dcfeb21afe37322e7837"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::NotifyParcelMoved </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by the TableComposer when the specified Parcel has position dependent content (see <a class="el" href="class_i_parcel_list.html">IParcelList</a>) and the Layout Row containing the Parcel is moved without the Parcel being resized. </div></div><a class="anchor" id="acab72c0580b8b67661162777030e4196"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::NotifyRowTypeChanging </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>repeat</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lRowCount</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Cells support two &quot;types&quot;: 1) &#39;regular&#39;, that is for each Layout Row a Parcel is created and the text flows into it as if it was linked, and 2) &#39;repeat&#39; in which the text composes only in the first Parcel and all the other Parcels simply draw the contents of the first Parcel.<p>The latter is used to support Header/Footer and SubHeader. The language here is not that a cell &quot;is a header or footer&quot; but rather what its type is.<p>This method will be called when: 1) a new Header or Footer Row containing the Cell is created, 2) an existing Body Row is about to change type to Header or Footer, and 3) a Body row is set to be a sub-head.<p>No call will be made when a Body Row is created as the default is &#39;regular&#39;.<p>The callee must be careful to not ask the Model what the current type is since this method is sometimes called during pre-notification.<p>lRowCount indicates how many LayoutRows exist for the ModelRow. The cell needs to ensure that it does not have more Parcels than this number. </div></div><a class="anchor" id="ac6b345ff9f4f8906e07fb29d54676ad3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::RemoveParcel </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>index</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The specified Parcel is removed from the ParcelList. </div></div><a class="anchor" id="a854b7ca4fa0a189d18a9b0694d8b90c2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::ResetCompositionState </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method will be called when the Cell has been duplicated or otherwise moved between (or even within the same) story. The callee should simply remove all the Parcels and reset all other state as if the cell had never been composed. The ContentManager for the particular cell is responsible for damaging </div></div><a class="anchor" id="ad5aaaa778e830f8e47df589573cba73a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ICellContent::SetParcelGeometry </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>cellPathBounds</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>parcelBounds</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>maxGrowBounds</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">GrowableDirection&nbsp;</td><td class="paramname"><em>growDir</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>contentAttributeChanged</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is called by the TableComposer to define the size and position of the Parcel. Typically this is only called when the size of the Parcel changes.<p>cellPathBounds This area is the path bounding box of the cell &quot;piece&quot; containing the Parcel and is provided to allow the Parcel to draw indicators (such as overset text) within the boundry of the cell piece but not necessarily within the Parcel itself.<p>bounds The bounds of the Parcel. These bounds differ from the cellPathBounds because of insets and strokes on the cell. The top left corner of will be (0.0, 0.0).<p>maxGrowBounds Specifies the maximum amount that a Parcel&#39;s bounds may grow. This value works in concert with growDir. The cell is allowed to ignore this value AND retain the previous value if growDir is set to kNone.<p>growDir Tells the cell that the Parcel is allowed to grow in the specified direction upto the maximum specified as maxGrowBounds.<p>contentAttributeChanged Setting this value to kTrue is the same as calling <a class="el" href="class_i_cell_content.html#a314f3826db5a9a3befeba6cbd8f469fa">NotifyContentAttributeChanged()</a>. Combining actions in this way improves performace. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_cell_content.html">ICellContent</a><li class="footer">Generated on Sat Sep 22 2018 10:53:55 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
