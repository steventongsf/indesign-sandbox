<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_preflight_process</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_preflight_process.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_preflight_process-members.html">List of all members</a></div><div class="headertitle"><div class="title">IPreflightProcess Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_preflight_process_8h_source.html">IPreflightProcess.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IPreflightProcess:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_preflight_process.png" usemap="#IPreflightProcess_map" /><map id="IPreflightProcess_map" name="IPreflightProcess_map"><area alt="IPMUnknown" coords="0,0,108,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:aefbfc21a386799771df0ff77c1b5d0e7"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IPREFLIGHTPROCESS }</td></tr><tr class="separator:aefbfc21a386799771df0ff77c1b5d0e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a08dafac920e7a16139ea4de1b1cdd525"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525">OperatingState</a> { <br /> &nbsp;&nbsp;<a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525a7d49ccb1d8bc458433592491c047a31f">kNothingToDo</a>, <a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525ad43742e1c55e298195cdd4bf407a200e">kInitializing</a>, <a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525ae805a8fa9742fdce8bc9dfd5402477df">kWaitingForComposition</a>, <a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525a5aba6499a83465bf3385a323cc3a9c3e">kExpandingTree</a>, <br /> &nbsp;&nbsp;<a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525a17c0b0eabd87c0170e8d8e50a9a007ca">kVisitingTree</a>, <a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525a453a2da0656d2bbe91741599d76a4b1a">kResultsComplete</a><br /> }</td></tr><tr class="separator:a08dafac920e7a16139ea4de1b1cdd525"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad5d5fc4e7660e133a944ba815a30bd3f"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3f">PauseState</a> { <a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3fa65191a47e3252694aa0111520df7ecf4">kRunning</a> = 0, <a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3fa076dc78363849f85575761d76acc76a3">kDocumentClosed</a>, <a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3fadd393f3af531631079ffc3c1f9a8f208">kUserPaused</a> }</td></tr><tr class="separator:ad5d5fc4e7660e133a944ba815a30bd3f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5dbf1d2655f6b4719381059e1da0dfb8"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a5dbf1d2655f6b4719381059e1da0dfb8">PriorityType</a> { <a class="el" href="class_i_preflight_process.html#a5dbf1d2655f6b4719381059e1da0dfb8a5527b424f6b3461482a4be7b7813bff3">kInactive</a>, <a class="el" href="class_i_preflight_process.html#a5dbf1d2655f6b4719381059e1da0dfb8a8de701bb5ee2ea9af67fc90816bea1a2">kLowPriority</a>, <a class="el" href="class_i_preflight_process.html#a5dbf1d2655f6b4719381059e1da0dfb8a673af3a05d1d24fcc5c482d2d97a13ac">kHighPriority</a> }</td></tr><tr class="separator:a5dbf1d2655f6b4719381059e1da0dfb8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aba8f33149f27b155450302504a81a262"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262">NodeType</a> { <br /> &nbsp;&nbsp;<a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262a41b5bb62e216ccaa800cc66824d02636">kInvalidNodeType</a>, <a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262a0e56695e314833e9b6e7bc59a08811fd">kRoot</a>, <a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262aa1111d1ea3218cda0d51dea9152720bf">kObject</a>, <a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262a5e7a163aecdd4b9c7a6569e235d190f5">kResult</a>, <br /> &nbsp;&nbsp;<a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262a7891bf850d1512dceb0177375a6d1dc6">kDirectory</a><br /> }</td></tr><tr class="separator:aba8f33149f27b155450302504a81a262"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3afe566ca4db97994e71e387da41c02b"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a3afe566ca4db97994e71e387da41c02b">LinkType</a> { <a class="el" href="class_i_preflight_process.html#a3afe566ca4db97994e71e387da41c02ba200f294954d12701d4c05ac866aa0dcb">kInvalidLinkType</a>, <a class="el" href="class_i_preflight_process.html#a3afe566ca4db97994e71e387da41c02babf26342e82b1030cd8af7eef3dfd7fce">kOwnership</a>, <a class="el" href="class_i_preflight_process.html#a3afe566ca4db97994e71e387da41c02ba9545f3232fbe717e85471ee8d1d9bdd2">kReference</a>, <a class="el" href="class_i_preflight_process.html#a3afe566ca4db97994e71e387da41c02ba3f4c65b68939ba946172e1d40317ec34">kTemporary</a> }</td></tr><tr class="separator:a3afe566ca4db97994e71e387da41c02b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0c5dfa4d7447cae4ed3f8501b62b453c"><td align="right" class="memItemLeft" valign="top">typedef uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a></td></tr><tr class="separator:a0c5dfa4d7447cae4ed3f8501b62b453c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5dac1140d0305b6b1641facb80db1c91"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">NodeIDVector</a></td></tr><tr class="separator:a5dac1140d0305b6b1641facb80db1c91"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a98b49f3a67560f338ce7b2f7cf6590c5"><td align="right" class="memItemLeft" valign="top">typedef uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a></td></tr><tr class="separator:a98b49f3a67560f338ce7b2f7cf6590c5"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a686f109b1f9f1a826ec261f87158dbc6"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a686f109b1f9f1a826ec261f87158dbc6">GetUniqueID</a> () const =0</td></tr><tr class="separator:a686f109b1f9f1a826ec261f87158dbc6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a98ee1d35d2bf8818cd7da3f9fc47a30e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a98ee1d35d2bf8818cd7da3f9fc47a30e">SetUniqueID</a> (uint32 id)=0</td></tr><tr class="separator:a98ee1d35d2bf8818cd7da3f9fc47a30e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4832339592b5a5ed296e55d1e8c5f5aa"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a4832339592b5a5ed296e55d1e8c5f5aa">GetTimeStamp</a> () const =0</td></tr><tr class="separator:a4832339592b5a5ed296e55d1e8c5f5aa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae36c2013e4eee12e6602850205a4f2a4"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ae36c2013e4eee12e6602850205a4f2a4">GetSelector</a> () const =0</td></tr><tr class="separator:ae36c2013e4eee12e6602850205a4f2a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0db9b5eff82fc3a774417d62318190ad"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a0db9b5eff82fc3a774417d62318190ad">SetSelector</a> (<a class="el" href="class_i_d_type.html">ClassID</a> selID)=0</td></tr><tr class="separator:a0db9b5eff82fc3a774417d62318190ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9905af537d9658e76075cb1251307d49"><td align="right" class="memItemLeft" valign="top">virtual PreflightDocumentID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a9905af537d9658e76075cb1251307d49">GetDocumentID</a> () const =0</td></tr><tr class="separator:a9905af537d9658e76075cb1251307d49"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af27220fe7fdc1e4e970f992bbb5887f6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#af27220fe7fdc1e4e970f992bbb5887f6">SetDocumentID</a> (const PreflightDocumentID &amp;newDocID)=0</td></tr><tr class="separator:af27220fe7fdc1e4e970f992bbb5887f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8791850fda8394a84305709cae35c059"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a8791850fda8394a84305709cae35c059">SetIsBookProcess</a> (bool newState)=0</td></tr><tr class="separator:a8791850fda8394a84305709cae35c059"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab278ccbb7cabc70c303ae20e1bc64fb9"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ab278ccbb7cabc70c303ae20e1bc64fb9">IsBookProcess</a> () const =0</td></tr><tr class="separator:ab278ccbb7cabc70c303ae20e1bc64fb9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a96b59b2f9aede91f0f614f758e0667ec"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a96b59b2f9aede91f0f614f758e0667ec">GetAutoDelete</a> () const =0</td></tr><tr class="separator:a96b59b2f9aede91f0f614f758e0667ec"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5ac8b6a6a5bce22607c0c8070c2c2277"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a5ac8b6a6a5bce22607c0c8070c2c2277">SetAutoDelete</a> (bool newState)=0</td></tr><tr class="separator:a5ac8b6a6a5bce22607c0c8070c2c2277"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a567eed2824e46e2660a11a2e309b2c7e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a567eed2824e46e2660a11a2e309b2c7e">Clear</a> ()=0</td></tr><tr class="separator:a567eed2824e46e2660a11a2e309b2c7e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad44cd78ea74f797e48c05ba6354e222c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ad44cd78ea74f797e48c05ba6354e222c">SetOptions</a> (const <a class="el" href="class_i_preflight_options.html">IPreflightOptions</a> *iOptions)=0</td></tr><tr class="separator:ad44cd78ea74f797e48c05ba6354e222c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a169b10943f3e8d48e7526f48a0d45d56"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_preflight_options.html">IPreflightOptions</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a169b10943f3e8d48e7526f48a0d45d56">QueryOptions</a> () const =0</td></tr><tr class="separator:a169b10943f3e8d48e7526f48a0d45d56"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a20ff1ff2a52ee1574a09d1c9f030c9ef"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_preflight_profile.html">IPreflightProfile</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a20ff1ff2a52ee1574a09d1c9f030c9ef">QueryProfile</a> () const =0</td></tr><tr class="separator:a20ff1ff2a52ee1574a09d1c9f030c9ef"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c6403caaf580812dd03c49449e15fa7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a9c6403caaf580812dd03c49449e15fa7">SetProfile</a> (<a class="el" href="class_i_preflight_profile.html">IPreflightProfile</a> *iProfile)=0</td></tr><tr class="separator:a9c6403caaf580812dd03c49449e15fa7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a92e8796891e8e0957615a16dce06777d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525">OperatingState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a92e8796891e8e0957615a16dce06777d">GetState</a> () const =0</td></tr><tr class="separator:a92e8796891e8e0957615a16dce06777d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6cf11e65eeedd921418888884f403754"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3f">PauseState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a6cf11e65eeedd921418888884f403754">GetPaused</a> () const =0</td></tr><tr class="separator:a6cf11e65eeedd921418888884f403754"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acdea6383ecef1d97c4afad4a70678c3d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#acdea6383ecef1d97c4afad4a70678c3d">SetPaused</a> (<a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3f">PauseState</a> newState)=0</td></tr><tr class="separator:acdea6383ecef1d97c4afad4a70678c3d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2a8427868637b715bad8eb7f6a0a2c39"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a2a8427868637b715bad8eb7f6a0a2c39">IsActive</a> () const =0</td></tr><tr class="separator:a2a8427868637b715bad8eb7f6a0a2c39"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ada3884d479ee2214fa69e9aaa7a416a9"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a5dbf1d2655f6b4719381059e1da0dfb8">PriorityType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ada3884d479ee2214fa69e9aaa7a416a9">GetPriority</a> () const =0</td></tr><tr class="separator:ada3884d479ee2214fa69e9aaa7a416a9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a79d9a4d256a54dd3750f30d70145261a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a79d9a4d256a54dd3750f30d70145261a">AdvanceState</a> (<a class="el" href="class_idle_timer.html">IdleTimer</a> *timer, bool synchronous)=0</td></tr><tr class="separator:a79d9a4d256a54dd3750f30d70145261a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac7205e995969518c4a9c6825c0099139"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /><a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ac7205e995969518c4a9c6825c0099139">CreateAggregatedResults</a> () const =0</td></tr><tr class="separator:ac7205e995969518c4a9c6825c0099139"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a018319a31cd5a5ad09295d13bfbb01d1"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a018319a31cd5a5ad09295d13bfbb01d1">GetRootNode</a> () const =0</td></tr><tr class="separator:a018319a31cd5a5ad09295d13bfbb01d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac9fce39716e22c88bbae8234fad9cbe3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ac9fce39716e22c88bbae8234fad9cbe3">GetRootObjectNode</a> () const =0</td></tr><tr class="separator:ac9fce39716e22c88bbae8234fad9cbe3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9d8ef133b07f86225e233ceb3dc5fa72"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262">NodeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a9d8ef133b07f86225e233ceb3dc5fa72">GetNodeType</a> (<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> node) const =0</td></tr><tr class="separator:a9d8ef133b07f86225e233ceb3dc5fa72"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3b85cbae43ab803d34f7fc5e4a8d7e6d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a3afe566ca4db97994e71e387da41c02b">LinkType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a3b85cbae43ab803d34f7fc5e4a8d7e6d">GetLinkType</a> (<a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> link) const =0</td></tr><tr class="separator:a3b85cbae43ab803d34f7fc5e4a8d7e6d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8ec98c66f9c255615366498a144b162a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a8ec98c66f9c255615366498a144b162a">GetParentNodes</a> (<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> node, <a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">NodeIDVector</a> &amp;parents) const =0</td></tr><tr class="separator:a8ec98c66f9c255615366498a144b162a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2d2190e044ac21c4bd40c45f6822ea22"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a2d2190e044ac21c4bd40c45f6822ea22">GetChildNodes</a> (<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> node, <a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">NodeIDVector</a> &amp;children) const =0</td></tr><tr class="separator:a2d2190e044ac21c4bd40c45f6822ea22"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a47fbda5872bf17b87a4fd0cb5cabed82"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a47fbda5872bf17b87a4fd0cb5cabed82">GetFirstParentLink</a> (<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> node) const =0</td></tr><tr class="separator:a47fbda5872bf17b87a4fd0cb5cabed82"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c1bb5d4f9440f63d1241d4f5b8eae4e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a8c1bb5d4f9440f63d1241d4f5b8eae4e">GetNextParentLink</a> (<a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> link) const =0</td></tr><tr class="separator:a8c1bb5d4f9440f63d1241d4f5b8eae4e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af94589f5024d4b02337e62d121718256"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#af94589f5024d4b02337e62d121718256">GetFirstChildLink</a> (<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> node) const =0</td></tr><tr class="separator:af94589f5024d4b02337e62d121718256"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3c382ef5416d29131732285562edf344"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a3c382ef5416d29131732285562edf344">GetNextChildLink</a> (<a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> link) const =0</td></tr><tr class="separator:a3c382ef5416d29131732285562edf344"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a679ba91de55cbcb76e7f210f43532590"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a679ba91de55cbcb76e7f210f43532590">GetLinkParentNode</a> (<a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> link) const =0</td></tr><tr class="separator:a679ba91de55cbcb76e7f210f43532590"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a09186359c3c0f44c3c7070c8e5db468d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a09186359c3c0f44c3c7070c8e5db468d">GetLinkChildNode</a> (<a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> link) const =0</td></tr><tr class="separator:a09186359c3c0f44c3c7070c8e5db468d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab502592284ee6d1a65b45951d4939377"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ab502592284ee6d1a65b45951d4939377">GetObjectNodeObjectID</a> (<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> node, <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;objID) const =0</td></tr><tr class="separator:ab502592284ee6d1a65b45951d4939377"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2cc5035eaed87d3fd2c25933fb980eaa"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a2cc5035eaed87d3fd2c25933fb980eaa">GetResultNodes</a> (<a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">NodeIDVector</a> &amp;results) const =0</td></tr><tr class="separator:a2cc5035eaed87d3fd2c25933fb980eaa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1da6890dd64eec08656385aff6b62441"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_wide_string.html">PreflightRuleID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a1da6890dd64eec08656385aff6b62441">GetResultNodeRuleID</a> (<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> resultNode) const =0</td></tr><tr class="separator:a1da6890dd64eec08656385aff6b62441"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adfe25f87389575513d3d8bedbeabd902"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#adfe25f87389575513d3d8bedbeabd902">QueryResultNodeTable</a> (<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> resultNode) const =0</td></tr><tr class="separator:adfe25f87389575513d3d8bedbeabd902"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7dee246e295e694d2fd1758a23e8c59f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a7dee246e295e694d2fd1758a23e8c59f">InvalidateObject</a> (const <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;objID)=0</td></tr><tr class="separator:a7dee246e295e694d2fd1758a23e8c59f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a48ae76229db6b6c4e0e193e8fcd466d9"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a48ae76229db6b6c4e0e193e8fcd466d9">InvalidateDocument</a> ()=0</td></tr><tr class="separator:a48ae76229db6b6c4e0e193e8fcd466d9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa95b6dbac38e30625d85961ed8fe775e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#aa95b6dbac38e30625d85961ed8fe775e">OnSettingsChange</a> (const IPreflightSettingsChangeInfo *iInfo)=0</td></tr><tr class="separator:aa95b6dbac38e30625d85961ed8fe775e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a21206945545c425ff5c8d6cdb404d3ad"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a21206945545c425ff5c8d6cdb404d3ad">GetDescription</a> () const =0</td></tr><tr class="separator:a21206945545c425ff5c8d6cdb404d3ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a05c5f7e45090da15950858ac5773bbea"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#a05c5f7e45090da15950858ac5773bbea">GetResults</a> () const =0</td></tr><tr class="separator:a05c5f7e45090da15950858ac5773bbea"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab1e7f885d43eaa1975bad89a02631369"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process.html#ab1e7f885d43eaa1975bad89a02631369">GetInventory</a> () const =0</td></tr><tr class="separator:ab1e7f885d43eaa1975bad89a02631369"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>This interface sits on a preflight process boss and tracks the status of a particular preflight operation (either the background process we use in the UI or a synchronous one you create yourself via <a class="el" href="class_i_preflight_process_manager.html">IPreflightProcessManager</a>).<p>In addition to the state/status, it also maintains a database of raw results. This database tracks not only the results but the entire preflight DOM used for the process. Normally you don&#39;t inspect the raw results directly (though you can) but rather use the aggregated results, which are a prettified version with user-facing strings and organization.<p>You normally get this interface from <a class="el" href="class_i_preflight_process_manager.html">IPreflightProcessManager</a>. To find the processes for a given document, for example, use <a class="el" href="class_i_preflight_process_manager.html#a7c250e53b0c42a1215bb70662adefd20">IPreflightProcessManager::GetProcessesForDocument</a> or use <a class="el" href="class_i_preflight_utils.html#a92d29ca116832f6521c54d6ab01130c2">IPreflightUtils::QueryProcessForDocument()</a> if you want the process for the document that the preflight UI is using. </div><h2 class="groupheader">Member Typedef Documentation</h2><a class="anchor" id="a98b49f3a67560f338ce7b2f7cf6590c5"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef uint32 <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">IPreflightProcess::LinkID</a></td></tr></table></div><div class="memdoc"><p>Links are a parent-child data structure that also maintain next- and prev- of same parent node, and next- and prev- of same child node. Ie an arbitrary graph of nodes. Each link also has a type (ownership vs reference). </div></div><a class="anchor" id="a0c5dfa4d7447cae4ed3f8501b62b453c"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef uint32 <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">IPreflightProcess::NodeID</a></td></tr></table></div><div class="memdoc"><p>Nodes in the database. Zero means invalid. </div></div><a class="anchor" id="a5dac1140d0305b6b1641facb80db1c91"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef <a class="el" href="class_k2_vector.html">K2Vector</a>&lt;<a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&gt; <a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">IPreflightProcess::NodeIDVector</a></td></tr></table></div><div class="memdoc"><p>A vector of node IDs, used for various &quot;get all of X&quot; methods. </div></div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a3afe566ca4db97994e71e387da41c02b"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_preflight_process.html#a3afe566ca4db97994e71e387da41c02b">IPreflightProcess::LinkType</a></td></tr></table></div><div class="memdoc"><p>This enum identifies the link type. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a3afe566ca4db97994e71e387da41c02ba200f294954d12701d4c05ac866aa0dcb"></a>kInvalidLinkType</em>&nbsp;</td><td class="fielddoc"><p>General failure/invalid case. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a3afe566ca4db97994e71e387da41c02babf26342e82b1030cd8af7eef3dfd7fce"></a>kOwnership</em>&nbsp;</td><td class="fielddoc"><p>The parent object owns the child. A node can actually have multiple owners. The idea is that if a node runs out of ownership parents, it is deleted. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a3afe566ca4db97994e71e387da41c02ba9545f3232fbe717e85471ee8d1d9bdd2"></a>kReference</em>&nbsp;</td><td class="fielddoc"><p>The parent only references the child, so it won&#39;t protect it from deletion. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a3afe566ca4db97994e71e387da41c02ba3f4c65b68939ba946172e1d40317ec34"></a>kTemporary</em>&nbsp;</td><td class="fielddoc"><p>Temporary links are used for bookkeeping during the object discovery (expansion) phase. </td></tr></table></div></div><a class="anchor" id="aba8f33149f27b155450302504a81a262"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262">IPreflightProcess::NodeType</a></td></tr></table></div><div class="memdoc"><p>This enum identifies the node category. Depending on the category you can ask different questions. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aba8f33149f27b155450302504a81a262a41b5bb62e216ccaa800cc66824d02636"></a>kInvalidNodeType</em>&nbsp;</td><td class="fielddoc"><p>General failure/invalid case. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aba8f33149f27b155450302504a81a262a0e56695e314833e9b6e7bc59a08811fd"></a>kRoot</em>&nbsp;</td><td class="fielddoc"><p>The root of all nodes in the database. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aba8f33149f27b155450302504a81a262aa1111d1ea3218cda0d51dea9152720bf"></a>kObject</em>&nbsp;</td><td class="fielddoc"><p>A preflight object. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aba8f33149f27b155450302504a81a262a5e7a163aecdd4b9c7a6569e235d190f5"></a>kResult</em>&nbsp;</td><td class="fielddoc"><p>A result node. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aba8f33149f27b155450302504a81a262a7891bf850d1512dceb0177375a6d1dc6"></a>kDirectory</em>&nbsp;</td><td class="fielddoc"><p>A directory node, ie children are bird of some kind of feather. </td></tr></table></div></div><a class="anchor" id="a08dafac920e7a16139ea4de1b1cdd525"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525">IPreflightProcess::OperatingState</a></td></tr></table></div><div class="memdoc"><p>States a process can be in at any point in time (see <a class="el" href="class_i_preflight_process.html#a92e8796891e8e0957615a16dce06777d">GetState()</a>). <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a08dafac920e7a16139ea4de1b1cdd525a7d49ccb1d8bc458433592491c047a31f"></a>kNothingToDo</em>&nbsp;</td><td class="fielddoc"><p>The process isn&#39;t set up with any document, or the profile has no rules active. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a08dafac920e7a16139ea4de1b1cdd525ad43742e1c55e298195cdd4bf407a200e"></a>kInitializing</em>&nbsp;</td><td class="fielddoc"><p>Starting up (initially or after a clear-everything change). </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a08dafac920e7a16139ea4de1b1cdd525ae805a8fa9742fdce8bc9dfd5402477df"></a>kWaitingForComposition</em>&nbsp;</td><td class="fielddoc"><p>To avoid thrashing, processes wait until composition is complete. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a08dafac920e7a16139ea4de1b1cdd525a5aba6499a83465bf3385a323cc3a9c3e"></a>kExpandingTree</em>&nbsp;</td><td class="fielddoc"><p>Walking DOM and building graph of object relationships. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a08dafac920e7a16139ea4de1b1cdd525a17c0b0eabd87c0170e8d8e50a9a007ca"></a>kVisitingTree</em>&nbsp;</td><td class="fielddoc"><p>Actually visiting DOM elements. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a08dafac920e7a16139ea4de1b1cdd525a453a2da0656d2bbe91741599d76a4b1a"></a>kResultsComplete</em>&nbsp;</td><td class="fielddoc"><p>Results are up to date. </td></tr></table></div></div><a class="anchor" id="ad5d5fc4e7660e133a944ba815a30bd3f"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3f">IPreflightProcess::PauseState</a></td></tr></table></div><div class="memdoc"><p>Processes can be paused; they still get invalidated but they won&#39;t get validation cycles until they&#39;re unpaused. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad5d5fc4e7660e133a944ba815a30bd3fa65191a47e3252694aa0111520df7ecf4"></a>kRunning</em>&nbsp;</td><td class="fielddoc"><p>Ie not paused. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ad5d5fc4e7660e133a944ba815a30bd3fa076dc78363849f85575761d76acc76a3"></a>kDocumentClosed</em>&nbsp;</td><td class="fielddoc"><p>Document is no longer open. (This applies when book preflighting.) </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ad5d5fc4e7660e133a944ba815a30bd3fadd393f3af531631079ffc3c1f9a8f208"></a>kUserPaused</em>&nbsp;</td><td class="fielddoc"><p>Preflighting is paused because the user paused it. </td></tr></table></div></div><a class="anchor" id="a5dbf1d2655f6b4719381059e1da0dfb8"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_preflight_process.html#a5dbf1d2655f6b4719381059e1da0dfb8">IPreflightProcess::PriorityType</a></td></tr></table></div><div class="memdoc"><p>Processes can have differing priorities depending on their state. See <a class="el" href="class_i_preflight_process.html#ada3884d479ee2214fa69e9aaa7a416a9">GetPriority()</a>. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a5dbf1d2655f6b4719381059e1da0dfb8a5527b424f6b3461482a4be7b7813bff3"></a>kInactive</em>&nbsp;</td><td class="fielddoc"><p>All results are current or there is nothing to do or the process is paused. No point in calling AdvanceState. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a5dbf1d2655f6b4719381059e1da0dfb8a8de701bb5ee2ea9af67fc90816bea1a2"></a>kLowPriority</em>&nbsp;</td><td class="fielddoc"><p>In a holding pattern, waiting for text composition or delayed expansion. Should be called on a regular basis but not with high frequency because it&#39;ll simply return. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a5dbf1d2655f6b4719381059e1da0dfb8a673af3a05d1d24fcc5c482d2d97a13ac"></a>kHighPriority</em>&nbsp;</td><td class="fielddoc"><p>There is work to be done. The higher the callback frequency, the more work will get done in the same amount of time. </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a79d9a4d256a54dd3750f30d70145261a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::AdvanceState </td><td>(</td><td class="paramtype"><a class="el" href="class_idle_timer.html">IdleTimer</a> *&nbsp;</td><td class="paramname"><em>timer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>synchronous</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Give a time slice to do some work. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">timer</td><td>IN The timer which tells the process how much time it can use. Can be nil, indicating the process should work synchronously. </td></tr><tr><td class="paramname">synchronous</td><td>IN Set this to true if you are calling this in a tight loop where (for example) the text composer will not be given any time to work; otherwise the process will never (or only extremely slowly) complete. When true, text composition will be forced synchronously prior to preflight expansion and visitation. Set this parameter to false if you&#39;re calling it from an idle loop where the text composer has a chance to operate efficiently. </td></tr></table></dl></div></div><a class="anchor" id="a567eed2824e46e2660a11a2e309b2c7e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::Clear </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clear all tasks, the database, everything. </div></div><a class="anchor" id="ac7205e995969518c4a9c6825c0099139"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a>* IPreflightProcess::CreateAggregatedResults </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Create an aggregated version of the results. This is the version that drives the UI, and rules are given the opportunity to condense all results into an &quot;aggregated&quot; form.<dl class="section return"><dt>Returns<dd>A refcounted aggregated results, or nil if some kind of error occurs. </dl></div></div><a class="anchor" id="a96b59b2f9aede91f0f614f758e0667ec"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool IPreflightProcess::GetAutoDelete </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the auto-delete property. If true the process will be deleted automatically if the document (or book, if the process is associated with a book) is closed. If false, the process is not automatically deleted.<dl class="section return"><dt>Returns<dd>The auto-delete state. </dl></div></div><a class="anchor" id="a2d2190e044ac21c4bd40c45f6822ea22"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::GetChildNodes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="paramname"><em>node</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">NodeIDVector</a> &amp;&nbsp;</td><td class="paramname"><em>children</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get all the child nodes of a given node. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">node</td><td>IN The node for which you want the children. </td></tr><tr><td class="paramname">parents</td><td>OUT Receives the list of child nodes. </td></tr></table></dl></div></div><a class="anchor" id="a21206945545c425ff5c8d6cdb404d3ad"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightProcess::GetDescription </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is for debugging purposes. <dl class="section return"><dt>Returns<dd>A string describing the state of the process. Not localized. </dl></div></div><a class="anchor" id="a9905af537d9658e76075cb1251307d49"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual PreflightDocumentID IPreflightProcess::GetDocumentID </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>The document this preflight is associated with. Note that this does NOT use <a class="el" href="class_i_document.html">IDocument</a> because the life cycle of the process may or may not correspond to the open document. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_manager.html">IPreflightManager</a> for document ID mapping services. </dl><dl class="section return"><dt>Returns<dd>The ID of the associated document. All preflight processes need a document. </dl></div></div><a class="anchor" id="af94589f5024d4b02337e62d121718256"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> IPreflightProcess::GetFirstChildLink </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="paramname"><em>node</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the first child link of a given node. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">node</td><td>IN The node you want the first child of. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The <a class="el" href="class_node_i_d.html">NodeID</a> of the parent node, or 0 if the node has no children. </dl></div></div><a class="anchor" id="a47fbda5872bf17b87a4fd0cb5cabed82"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> IPreflightProcess::GetFirstParentLink </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="paramname"><em>node</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the first parent link of a given node (note that nodes can have multiple parents). Once you have the link you can look &quot;up&quot; to the parent node, or &quot;over&quot; to the next parent. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">node</td><td>IN The child node whose first parent you want. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The <a class="el" href="class_node_i_d.html">NodeID</a> of the parent node, or 0 if the child has no parent. </dl></div></div><a class="anchor" id="ab1e7f885d43eaa1975bad89a02631369"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightProcess::GetInventory </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is for debugging purposes. <dl class="section return"><dt>Returns<dd>A string containing a dump of the entire database. Not/partially localized. </dl></div></div><a class="anchor" id="a09186359c3c0f44c3c7070c8e5db468d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> IPreflightProcess::GetLinkChildNode </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="paramname"><em>link</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a parent-child link, get the child node. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">link</td><td>IN The link you want the child node for. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The <a class="el" href="class_node_i_d.html">NodeID</a> of the child node. Will only be zero if the link is invalid (valid links always connect valid nodes). </dl></div></div><a class="anchor" id="a679ba91de55cbcb76e7f210f43532590"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> IPreflightProcess::GetLinkParentNode </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="paramname"><em>link</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a parent-child link, get the parent node. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">link</td><td>IN The link you want the parent node for. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The <a class="el" href="class_node_i_d.html">NodeID</a> of the parent node. Will only be zero if the link is invalid (valid links always connect valid nodes). </dl></div></div><a class="anchor" id="a3b85cbae43ab803d34f7fc5e4a8d7e6d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a3afe566ca4db97994e71e387da41c02b">LinkType</a> IPreflightProcess::GetLinkType </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="paramname"><em>link</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a link, get its type. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">link</td><td>IN THe link you&#39;re interested in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The link type, or kInvalidLinkType if link ID is invalid or error occurs. </dl></div></div><a class="anchor" id="a3c382ef5416d29131732285562edf344"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> IPreflightProcess::GetNextChildLink </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="paramname"><em>link</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the next child link (ie same parent, a different child). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">link</td><td>IN The &#39;current&#39; link, the one you want the next sibling of. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The LinkID of the next child link, or 0 if the link has no next sibling. </dl></div></div><a class="anchor" id="a8c1bb5d4f9440f63d1241d4f5b8eae4e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a> IPreflightProcess::GetNextParentLink </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a98b49f3a67560f338ce7b2f7cf6590c5">LinkID</a>&nbsp;</td><td class="paramname"><em>link</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the next parent link of the same child node. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">node</td><td>IN The current parent link. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The LinkID of the next parent link, or 0 if the link has no next parent sibling. </dl></div></div><a class="anchor" id="a9d8ef133b07f86225e233ceb3dc5fa72"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#aba8f33149f27b155450302504a81a262">NodeType</a> IPreflightProcess::GetNodeType </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="paramname"><em>node</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a node, get its type. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">node</td><td>IN THe node you&#39;re interested in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The node type, or kInvalidNodeType if node is invalid or error occurs. </dl></div></div><a class="anchor" id="ab502592284ee6d1a65b45951d4939377"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::GetObjectNodeObjectID </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="paramname"><em>node</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;&nbsp;</td><td class="paramname"><em>objID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For object nodes, get the preflight object ID. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">node</td><td>IN The object node you&#39;re interested in. </td></tr><tr><td class="paramname">objID</td><td>OUT Receives the object ID, or an invalid ID if the node isn&#39;t valid, or isn&#39;t an object node. </td></tr></table></dl></div></div><a class="anchor" id="a8ec98c66f9c255615366498a144b162a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::GetParentNodes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="paramname"><em>node</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">NodeIDVector</a> &amp;&nbsp;</td><td class="paramname"><em>parents</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get all the parent nodes of a given node. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">node</td><td>IN The node for which you want the parents. </td></tr><tr><td class="paramname">parents</td><td>OUT Receives the list of parent nodes. </td></tr></table></dl></div></div><a class="anchor" id="a6cf11e65eeedd921418888884f403754"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3f">PauseState</a> IPreflightProcess::GetPaused </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets whether the process is paused, and if so, why. <dl class="section return"><dt>Returns<dd>The pause state. </dl></div></div><a class="anchor" id="ada3884d479ee2214fa69e9aaa7a416a9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a5dbf1d2655f6b4719381059e1da0dfb8">PriorityType</a> IPreflightProcess::GetPriority </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Checks the current state and returns a performance priority. <dl class="section return"><dt>Returns<dd>The priority code. </dl></div></div><a class="anchor" id="a1da6890dd64eec08656385aff6b62441"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_wide_string.html">PreflightRuleID</a> IPreflightProcess::GetResultNodeRuleID </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="paramname"><em>resultNode</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For a given result node ID, obtain the rule ID of that node. </div></div><a class="anchor" id="a2cc5035eaed87d3fd2c25933fb980eaa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::GetResultNodes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">NodeIDVector</a> &amp;&nbsp;</td><td class="paramname"><em>results</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Obtains a vector of all results nodes. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">results</td><td>OUT Receives the vector of result node IDs. </td></tr></table></dl></div></div><a class="anchor" id="a05c5f7e45090da15950858ac5773bbea"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightProcess::GetResults </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is for debugging purposes. <dl class="section return"><dt>Returns<dd>A string describing the errors found. Not (or only partially) localized. </dl></div></div><a class="anchor" id="a018319a31cd5a5ad09295d13bfbb01d1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> IPreflightProcess::GetRootNode </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the root node in the database &ndash; note that this is NOT the same as the root object node! The root node is a logical root, whereas the root object (ie, the document object) sits under the root. Remember, the database contains more than just object nodes. <dl class="section return"><dt>Returns<dd>The ID of the root node. This is a node of type kRoot. </dl></div></div><a class="anchor" id="ac9fce39716e22c88bbae8234fad9cbe3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a> IPreflightProcess::GetRootObjectNode </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the root OBJECT node in the database &ndash; note that this is NOT the same as the root node! The root node is a logical root, whereas the root object (ie, the document object) sits under the root. Remember, the database contains more than just object nodes. <dl class="section return"><dt>Returns<dd>The ID of the root object node, ie the document object. This is a node of type kObject. </dl></div></div><a class="anchor" id="ae36c2013e4eee12e6602850205a4f2a4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">ClassID</a> IPreflightProcess::GetSelector </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the selector ID for the process. This is simply a way of tagging the owner of the process so the owner can find it later. For example preflight uses the kPreflightContinuousProcessSelectorID selector to indicate the current continous (background) preflighting process, as opposed to some ad-hoc process it might create for other reasons.<p>Note that this is purely a tagging mechanism. The process doesn&#39;t do anything with the selector ID except store it.<dl class="section return"><dt>Returns<dd>The selector. </dl></div></div><a class="anchor" id="a92e8796891e8e0957615a16dce06777d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html#a08dafac920e7a16139ea4de1b1cdd525">OperatingState</a> IPreflightProcess::GetState </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the current state of the process. <dl class="section return"><dt>Returns<dd>The state. </dl></div></div><a class="anchor" id="a4832339592b5a5ed296e55d1e8c5f5aa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IPreflightProcess::GetTimeStamp </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the modification &#39;time stamp&#39; &ndash; not really a time at all, but a change number that indicates whether the state of the database is the same as the last time you checked. Every time there&#39;s a change this number is bumped by one.<dl class="section return"><dt>Returns<dd>The current &quot;time stamp&quot; identifier. </dl></div></div><a class="anchor" id="a686f109b1f9f1a826ec261f87158dbc6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IPreflightProcess::GetUniqueID </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the unique ID of this process. This number is generated automatically by the process manager in all cases where the process is created via the manager.<dl class="section return"><dt>Returns<dd>The process&#39;s unique ID. This is unique within a given ID session. </dl></div></div><a class="anchor" id="a48ae76229db6b6c4e0e193e8fcd466d9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::InvalidateDocument </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Invalidate the root document object. This clears out the document tree and forces a complete rebuild of all results. Same result as if you got the document object ID and called InvalidateObject. </div></div><a class="anchor" id="a7dee246e295e694d2fd1758a23e8c59f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::InvalidateObject </td><td>(</td><td class="paramtype">const <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;&nbsp;</td><td class="paramname"><em>objID</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Invalidate the specified object in the process (if that object exists). This clips the subtree below the node and adds the node to the expansion and visitation list.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">objID</td><td>IN The object to invalidate. </td></tr></table></dl></div></div><a class="anchor" id="a2a8427868637b715bad8eb7f6a0a2c39"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool IPreflightProcess::IsActive </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Same as checking for state != kResultsComplete &amp;&amp; state != kNothingToDo &amp;&amp; paused == kRunning. <dl class="section return"><dt>Returns<dd>True if the process has something to do; False if complete or nothing to do. </dl></div></div><a class="anchor" id="ab278ccbb7cabc70c303ae20e1bc64fb9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool IPreflightProcess::IsBookProcess </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get whether there are books associated with this process. <dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_process.html#a8791850fda8394a84305709cae35c059">SetIsBookProcess</a>.</dl><dl class="section return"><dt>Returns<dd>kTrue if the process is book-affiliated; kFalse otherwise. </dl></div></div><a class="anchor" id="aa95b6dbac38e30625d85961ed8fe775e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::OnSettingsChange </td><td>(</td><td class="paramtype">const IPreflightSettingsChangeInfo *&nbsp;</td><td class="paramname"><em>iInfo</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called on a process via the process manager (usually) to indicate that settings may have changed for the given database. (Profile change, deleted profile, options, etc.) Process needs to double-check settings and/or invalidate as appropriate.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iInfo</td><td>IN The event information to respond to. </td></tr></table></dl></div></div><a class="anchor" id="a169b10943f3e8d48e7526f48a0d45d56"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_preflight_options.html">IPreflightOptions</a>* IPreflightProcess::QueryOptions </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query the current options. Note that you can&#39;t modify these options, just look at them. <dl class="section return"><dt>Returns<dd>The current options, refcounted. </dl></div></div><a class="anchor" id="a20ff1ff2a52ee1574a09d1c9f030c9ef"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_preflight_profile.html">IPreflightProfile</a>* IPreflightProcess::QueryProfile </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the profile used for this preflight process. Const because it may come from someplace that wouldn&#39;t want it to be modified. <dl class="section return"><dt>Returns<dd>A refcounted profile interface. </dl></div></div><a class="anchor" id="adfe25f87389575513d3d8bedbeabd902"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightProcess::QueryResultNodeTable </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#a0c5dfa4d7447cae4ed3f8501b62b453c">NodeID</a>&nbsp;</td><td class="paramname"><em>resultNode</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For a given result node ID, obtain the table of recorded results. </div></div><a class="anchor" id="a5ac8b6a6a5bce22607c0c8070c2c2277"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::SetAutoDelete </td><td>(</td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>newState</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the auto-delete property. If true the process will be deleted automatically if the document (or book, if the process is associated with a book) is closed. If false, the process is not automatically deleted.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newState</td><td>IN The new auto-delete state. </td></tr></table></dl></div></div><a class="anchor" id="af27220fe7fdc1e4e970f992bbb5887f6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::SetDocumentID </td><td>(</td><td class="paramtype">const PreflightDocumentID &amp;&nbsp;</td><td class="paramname"><em>newDocID</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the document this preflight is associated with. This is typically done only when the process is first created. Note that this does NOT use <a class="el" href="class_i_document.html">IDocument</a> because the life cycle of the process may or may not correspond to the open document.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_manager.html">IPreflightManager</a> for document ID mapping services. </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newDocID</td><td>IN The new document ID. </td></tr></table></dl></div></div><a class="anchor" id="a8791850fda8394a84305709cae35c059"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::SetIsBookProcess </td><td>(</td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>newState</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set whether there are books associated with this process. That is, this process&#39;s results are used (either actively or not, in the case of a closed document) to provide the current preflight errors for a document associated with a book. Note that a process can in theory be associated with more than one book (if it happens to match multiple books&#39; settings). Also, note that this boolean doesn&#39;t mean that it isn&#39;t the active preflight for a document as well. The impetus for this flag is that when a process is associated with a book and the document is closed, the process is not automatically destroyed.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newState</td><td>IN kTrue if the process is book-affiliated; kFalse otherwise. </td></tr></table></dl></div></div><a class="anchor" id="ad44cd78ea74f797e48c05ba6354e222c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::SetOptions </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_options.html">IPreflightOptions</a> *&nbsp;</td><td class="paramname"><em>iOptions</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the options to use for this process. This method makes a COPY of the options. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iOptions</td><td>IN The options. Can&#39;t be nil. A copy is made so refcount is unchanged. </td></tr></table></dl></div></div><a class="anchor" id="acdea6383ecef1d97c4afad4a70678c3d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::SetPaused </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html#ad5d5fc4e7660e133a944ba815a30bd3f">PauseState</a>&nbsp;</td><td class="paramname"><em>newState</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets whether the process is paused, and if so, why. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newState</td><td>The new paused state. </td></tr></table></dl></div></div><a class="anchor" id="a9c6403caaf580812dd03c49449e15fa7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::SetProfile </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_profile.html">IPreflightProfile</a> *&nbsp;</td><td class="paramname"><em>iProfile</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the profile used for this preflight process. This references the profile, unless the profile is one associated with a document (as opposed to the application), in which case a copy of the profile is made so that the process (and all its associated data) can still live with the document closed. (This is needed for book preflight, for example.)<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProfile</td><td>IN The profile to use. </td></tr></table></dl></div></div><a class="anchor" id="a0db9b5eff82fc3a774417d62318190ad"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::SetSelector </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>selID</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the selector ID for the process.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_process.html#ae36c2013e4eee12e6602850205a4f2a4">GetSelector</a> for what this is. </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">selID</td><td>IN The new selector ID. </td></tr></table></dl></div></div><a class="anchor" id="a98ee1d35d2bf8818cd7da3f9fc47a30e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcess::SetUniqueID </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>id</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the unique ID of the process. This should not be called for any process that is created by the process manager, as changing it will affect all kinds of caches.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">id</td><td>IN The new unique ID. </td></tr></table></dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_preflight_process.html">IPreflightProcess</a><li class="footer">Generated on Sat Sep 22 2018 10:54:25 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
