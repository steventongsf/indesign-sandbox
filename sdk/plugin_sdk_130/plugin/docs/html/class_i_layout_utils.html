<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_layout_utils</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_layout_utils.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_layout_utils-members.html">List of all members</a></div><div class="headertitle"><div class="title">ILayoutUtils Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_layout_utils_8h_source.html">ILayoutUtils.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ILayoutUtils:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_layout_utils.png" usemap="#ILayoutUtils_map" /><map id="ILayoutUtils_map" name="ILayoutUtils_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:ad6246ba4b9de59fa0858f31c64c4c1c9"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ILAYOUTUTILS }</td></tr><tr class="separator:ad6246ba4b9de59fa0858f31c64c4c1c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:ad154381598c3d3b30e43b4585f840fc8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#ad154381598c3d3b30e43b4585f840fc8">FindDocument</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;docRef)=0</td></tr><tr class="separator:ad154381598c3d3b30e43b4585f840fc8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:affb533c81b0ac75760cda970e419ef7c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#affb533c81b0ac75760cda970e419ef7c">GetOwnerPageUID</a> (const <a class="el" href="class_i_hierarchy.html">IHierarchy</a> *pageItemHier, bool16 enlargeForSlug=kFalse)=0</td></tr><tr class="separator:affb533c81b0ac75760cda970e419ef7c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae3cda476044616307808c45af4f4a6b5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#ae3cda476044616307808c45af4f4a6b5">GetDrawingPageUID</a> (const <a class="el" href="class_i_hierarchy.html">IHierarchy</a> *pageItemHier, bool16 enlargeForSlug=kFalse)=0</td></tr><tr class="separator:ae3cda476044616307808c45af4f4a6b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0995e0a7cc5a8d4713aedb6f7c680735"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a0995e0a7cc5a8d4713aedb6f7c680735">EnlargePagesRectBySlug</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;pageRect, int32 pageIndex, int32 spreadPageCount, PageType pageType, bool16 bPrintingOrExporting=kFalse, int32 trueSpreadPageCount=0)=0</td></tr><tr class="separator:a0995e0a7cc5a8d4713aedb6f7c680735"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2c1b1f63b3e8e4c9b2177e0f4b7601b8"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a2c1b1f63b3e8e4c9b2177e0f4b7601b8">GetIntersectingPageUID</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;spreadRef, const <a class="el" href="class_p_m_rect.html">PBPMRect</a> &amp;itemBounds, bool16 enlargeForSlug=kFalse, const <a class="el" href="struct_transform_1_1_coordinate_space.html">Transform::CoordinateSpace</a> &amp;coordinateSpace=Transform::PasteboardCoordinates())=0</td></tr><tr class="separator:a2c1b1f63b3e8e4c9b2177e0f4b7601b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2e9bac03122a62bb2ab464720d840e1d"><td align="right" class="memItemLeft" valign="top">virtual PageType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a2e9bac03122a62bb2ab464720d840e1d">GetPageType</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;pageRef)=0</td></tr><tr class="separator:a2e9bac03122a62bb2ab464720d840e1d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3c88605682a26859e12e57a93a7ad3fd"><td align="right" class="memItemLeft" valign="top">virtual DocPageBinding&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a3c88605682a26859e12e57a93a7ad3fd">GetDocumentPageBinding</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;docRef)=0</td></tr><tr class="separator:a3c88605682a26859e12e57a93a7ad3fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a19affbd1aa732fb82e33166b98a8d2a6"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a19affbd1aa732fb82e33166b98a8d2a6">QueryParentFor</a> (const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *pUnknown, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;rIID)=0</td></tr><tr class="separator:a19affbd1aa732fb82e33166b98a8d2a6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a66234d41c4ecd0b68567b3980f3234d1"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a66234d41c4ecd0b68567b3980f3234d1">QueryOutermostParentFor</a> (const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *pUnknown, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;rIID)=0</td></tr><tr class="separator:a66234d41c4ecd0b68567b3980f3234d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac594e3f2a6b7dc4c4255012c1b79ae36"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#ac594e3f2a6b7dc4c4255012c1b79ae36">GetMaxSpreadSize</a> (const <a class="el" href="class_i_spread.html">ISpread</a> *theSpread=nil, bool16 bFactorInIslandness=kTrue, bool16 bFactorInFirstOddPage=kTrue, bool16 bFactorInPagesPerSpreadPref=kTrue)=0</td></tr><tr class="separator:ac594e3f2a6b7dc4c4255012c1b79ae36"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a367015aa4b9a8b05f918e3743fea46b9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a367015aa4b9a8b05f918e3743fea46b9">DoesPageHaveContent</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;pageUIDList)=0</td></tr><tr class="separator:a367015aa4b9a8b05f918e3743fea46b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a68a17724e125004ecb656f0d805ddf40"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_margins.html">IMargins</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a68a17724e125004ecb656f0d805ddf40">QueryMargins</a> (int32 whichPage, const <a class="el" href="class_i_spread.html">ISpread</a> *currentSpread)=0</td></tr><tr class="separator:a68a17724e125004ecb656f0d805ddf40"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aef3b517b6c4d96f9db7cae017f41f965"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_columns.html">IColumns</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#aef3b517b6c4d96f9db7cae017f41f965">Query_Columns</a> (int32 whichPage, const <a class="el" href="class_i_spread.html">ISpread</a> *currentSpread)=0</td></tr><tr class="separator:aef3b517b6c4d96f9db7cae017f41f965"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7a260a60a5aac802165fffe8415d692d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_command.html">ICommand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a7a260a60a5aac802165fffe8415d692d">MakeShuffleCmd</a> (<a class="el" href="class_i_document.html">IDocument</a> *doc, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;firstSpread=UIDRef::gNull, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;lastSpread=UIDRef::gNull)=0</td></tr><tr class="separator:a7a260a60a5aac802165fffe8415d692d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2f8fd6f31e9e3c9e9533fde2dc391aab"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a2f8fd6f31e9e3c9e9533fde2dc391aab">IsAMaster</a> (<a class="el" href="class_i_d_type.html">UID</a> spreadOrPageUID, <a class="el" href="class_i_data_base.html">IDataBase</a> *db)=0</td></tr><tr class="separator:a2f8fd6f31e9e3c9e9533fde2dc391aab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2e7ad8a3c9ca295a12594e0da4ae084b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a2e7ad8a3c9ca295a12594e0da4ae084b">InvalidateViews</a> (<a class="el" href="class_i_document.html">IDocument</a> *document)=0</td></tr><tr class="separator:a2e7ad8a3c9ca295a12594e0da4ae084b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af892b724d5399fb1cd89f0c90d4f5c99"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#af892b724d5399fb1cd89f0c90d4f5c99">SpreadQueryHitTestPageItemNew</a> (const <a class="el" href="class_i_spread.html">ISpread</a> *mySpread, const <a class="el" href="class_p_m_point.html">PBPMPoint</a> &amp;where, <a class="el" href="class_i_d_type.html">ClassID</a> handlerClass, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interfaceID, int16 tolerance=kHitTestTolerance)=0</td></tr><tr class="separator:af892b724d5399fb1cd89f0c90d4f5c99"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Page-related min/max values.</div></td></tr><tr class="memitem:a84ff49ec2474367de79dce797021e3a4"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a84ff49ec2474367de79dce797021e3a4">GetMinNumPages</a> ()=0</td></tr><tr class="separator:a84ff49ec2474367de79dce797021e3a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1566d563142887b457b4d933197fc136"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a1566d563142887b457b4d933197fc136">GetMaxNumPages</a> ()=0</td></tr><tr class="separator:a1566d563142887b457b4d933197fc136"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aeaf7a72bac13ff79f6a6536028343852"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#aeaf7a72bac13ff79f6a6536028343852">GetMinPagesPerSpread</a> ()=0</td></tr><tr class="separator:aeaf7a72bac13ff79f6a6536028343852"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a430431bcf31e515f5e15e998463cd70e"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a430431bcf31e515f5e15e998463cd70e">GetMaxPagesPerSpread</a> ()=0</td></tr><tr class="separator:a430431bcf31e515f5e15e998463cd70e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a664df0941d29c3321a107245cb5c7e7e"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a664df0941d29c3321a107245cb5c7e7e">GetMinPageWidth</a> ()=0</td></tr><tr class="separator:a664df0941d29c3321a107245cb5c7e7e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5865074868a636616cccb94a7450b21c"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a5865074868a636616cccb94a7450b21c">GetMaxPageWidth</a> ()=0</td></tr><tr class="separator:a5865074868a636616cccb94a7450b21c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a699545aa3a9a294f2d16b104d651fc35"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a699545aa3a9a294f2d16b104d651fc35">GetMinPageLength</a> ()=0</td></tr><tr class="separator:a699545aa3a9a294f2d16b104d651fc35"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a97c2d715215f39bb644e4bc0ec2a6593"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_layout_utils.html#a97c2d715215f39bb644e4bc0ec2a6593">GetMaxPageLength</a> ()=0</td></tr><tr class="separator:a97c2d715215f39bb644e4bc0ec2a6593"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Layout-related utilities on model side. <dl class="section see"><dt>See Also<dd><a class="el" href="classk_utils_boss.html">kUtilsBoss</a><dd><a class="el" href="class_i_layout_u_i_utils.html">ILayoutUIUtils</a> for view-related methods </dl></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a367015aa4b9a8b05f918e3743fea46b9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ILayoutUtils::DoesPageHaveContent </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>pageUIDList</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Helper function to create a shuffle pages command for all the pages in a document. Be careful to shuffle the correct spreads, or just default to the whole document. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">doc</td><td>[IN] The document to use. If nil, use the front document. </td></tr><tr><td class="paramname">firstSpread</td><td>[IN] If specified, start with this spread. </td></tr><tr><td class="paramname">lastSpread</td><td>[IN] If specified, end with this spread. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>an <a class="el" href="class_i_command.html">ICommand</a> pointer for the command.Determine there is content on any page in a range of pages </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageUIDList</td><td>[IN] <a class="el" href="class_u_i_d_list.html">UIDList</a> of pages to check. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if any of the pages contain content. </dl></div></div><a class="anchor" id="a0995e0a7cc5a8d4713aedb6f7c680735"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ILayoutUtils::EnlargePagesRectBySlug </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>pageRect</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>pageIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>spreadPageCount</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">PageType&nbsp;</td><td class="paramname"><em>pageType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bPrintingOrExporting</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>trueSpreadPageCount</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a <a class="el" href="class_p_m_rect.html">PMRect</a> for a page and some info about the page, enlarge the rect to account for the slug area.<p>Note: Special care must be paid to &quot;middle&quot; pages in a spread &ndash; we don&#39;t allow the rect to enlarge in such a way that it would result in a rect that overlaps a neighboring page on the spread. Thus, while all pages can grow vertically, only first and last pages of a spread can grow in both horizontal directions. Special attention must also be paid to binding direction (meaning of &#39;first&#39; and &#39;last&#39; differs in RtoL cases). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">db</td><td>[IN] <a class="el" href="class_i_data_base.html">IDataBase</a> pointer for the document. </td></tr><tr><td class="paramname">pageRect</td><td>[IN/OUT] Page&#39;s rectangle, potentially modified to account for slug area. </td></tr><tr><td class="paramname">spreadPageCount</td><td>[IN] The number of pages in the spread. </td></tr><tr><td class="paramname">pageType</td><td>[IN] What kind of page is represented by pageRect. </td></tr><tr><td class="paramname">bPrintingOrExporting</td><td>[IN] Whether rect is being computed while printing or exporting. Obsolete, and unused. </td></tr><tr><td class="paramname">trueSpreadPageCount</td><td>[IN] Used in situations where spreadPageCount &quot;lies,&quot; like in cases where the master spread&#39;s pagecount is used instead of the layout spread.</td></tr></table></dl><dl class="section see"><dt>See Also<dd>PageType for allowable page types. </dl></div></div><a class="anchor" id="ad154381598c3d3b30e43b4585f840fc8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ILayoutUtils::FindDocument </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>docRef</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Searches the document list for a particular document. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">docRef</td><td><a class="el" href="class_u_i_d_ref.html">UIDRef</a> identifying the document being sought </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the document is in the document list </dl></div></div><a class="anchor" id="a3c88605682a26859e12e57a93a7ad3fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual DocPageBinding ILayoutUtils::GetDocumentPageBinding </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>docRef</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the binding direction for the specified document <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">docRef</td><td>[IN] <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>DocPageBinding for the binding being used. Note: One of kLeftToRightBinding or kRightToLeftBinding will be returned (default is kLeftToRightBinding; kDefaultBinding will not be returned). </dl></div></div><a class="anchor" id="ae3cda476044616307808c45af4f4a6b5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ILayoutUtils::GetDrawingPageUID </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_hierarchy.html">IHierarchy</a> *&nbsp;</td><td class="paramname"><em>pageItemHier</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>enlargeForSlug</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the UID of the page on which a given page item is currently being drawn. This can be used to get the page UID of the layout page on which a master page item is being drawn&ndash;very useful for determining page number strings. For page items that lie on multiple pages, this routine returns the page on which the majority of the page item area falls. If the page item does not fall on a page at all, the routine returns the UID of the spread. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageItemHier</td><td>[IN] An <a class="el" href="class_i_hierarchy.html">IHierarchy</a> pointer for the page item. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>UID of the page on which the page item is drawn, or the spread if the item is not drawn on a page. </dl></div></div><a class="anchor" id="a2c1b1f63b3e8e4c9b2177e0f4b7601b8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ILayoutUtils::GetIntersectingPageUID </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>spreadRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PBPMRect</a> &amp;&nbsp;</td><td class="paramname"><em>itemBounds</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>enlargeForSlug</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_transform_1_1_coordinate_space.html">Transform::CoordinateSpace</a> &amp;&nbsp;</td><td class="paramname"><em>coordinateSpace</em> = <code>Transform::PasteboardCoordinates()</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a PBPMRect and a <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of a Spread, this helper function returns the UID of the page in the Spread on which the PBPMRect would fall.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_u_i_d_ref.html">UIDRef</a></td><td>[IN] <a class="el" href="class_u_i_d_ref.html">UIDRef</a> for the spread. </td></tr><tr><td class="paramname">itemBounds</td><td>[IN] Rectangle in pasteboard or spread coordinates as specified by coordinateSpace. </td></tr><tr><td class="paramname">coordinateSpace</td><td>[IN] The coordinate system in which itemBounds is specified. The possible values are Transform::PasteboardCoordinates() and Transform::SpreadCoordinates(). </td></tr></table></dl><dl class="section return"><dt>Returns<dd>UID of page where itemBounds rect falls. For a rect that would fall on multiple pages, this routine returns the page on which the majority of the rect area falls. If the rect does not fall on a page at all, the routine returns the UID of the spread. </dl></div></div><a class="anchor" id="a1566d563142887b457b4d933197fc136"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMaxNumPages </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the maximum number of pages in a document. </div></div><a class="anchor" id="a97c2d715215f39bb644e4bc0ec2a6593"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMaxPageLength </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the maximum page height in points. </div></div><a class="anchor" id="a430431bcf31e515f5e15e998463cd70e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMaxPagesPerSpread </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the maximum number of pages in a spread. </div></div><a class="anchor" id="a5865074868a636616cccb94a7450b21c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMaxPageWidth </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the maximum page width in points. </div></div><a class="anchor" id="ac594e3f2a6b7dc4c4255012c1b79ae36"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMaxSpreadSize </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_spread.html">ISpread</a> *&nbsp;</td><td class="paramname"><em>theSpread</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bFactorInIslandness</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bFactorInFirstOddPage</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bFactorInPagesPerSpreadPref</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Figure out how many pages a particular spread (or any spread, if theSpread == nil) can have. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">theSpread</td><td>[IN] <a class="el" href="class_i_spread.html">ISpread</a> interface of spread to calculate. If nil, calculate for all spreads. </td></tr><tr><td class="paramname">bFactorInIslandness</td><td>[IN] Whether to take &quot;island spread&quot; capability into account. </td></tr><tr><td class="paramname">bFactorInFirstOddPage</td><td>[IN] Whether to assume the first page is odd-numbered (and hence a right page). </td></tr><tr><td class="paramname">bFactorInPagesPerSpreadPref</td><td>[IN] Whether to consider preference value for pages per spread. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the calculated number of pages for the spread(s). </dl></div></div><a class="anchor" id="a84ff49ec2474367de79dce797021e3a4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMinNumPages </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the minimum number of pages in a document. </div></div><a class="anchor" id="a699545aa3a9a294f2d16b104d651fc35"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMinPageLength </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the minimum page height in points. </div></div><a class="anchor" id="aeaf7a72bac13ff79f6a6536028343852"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMinPagesPerSpread </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the minimum number of pages in a spread. </div></div><a class="anchor" id="a664df0941d29c3321a107245cb5c7e7e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ILayoutUtils::GetMinPageWidth </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the minimum page width in points. </div></div><a class="anchor" id="affb533c81b0ac75760cda970e419ef7c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ILayoutUtils::GetOwnerPageUID </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_hierarchy.html">IHierarchy</a> *&nbsp;</td><td class="paramname"><em>pageItemHier</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>enlargeForSlug</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the UID of the page on which a given page item falls. For page items that lie on multiple pages, this routine returns the page on which the majority of the page item area falls. If the page item does not fall on a page at all, the routine returns the UID of the spread. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageItemHier</td><td>[IN] An <a class="el" href="class_i_hierarchy.html">IHierarchy</a> pointer for the page item. </td></tr><tr><td class="paramname">enlargeForSlug</td><td>[IN] kTrue to take into consideration the slug area around the page. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>UID of the page on which the page item falls, or the spread if the item does not fall on a page. </dl></div></div><a class="anchor" id="a2e9bac03122a62bb2ab464720d840e1d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual PageType ILayoutUtils::GetPageType </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>pageRef</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Give a ref for a page, return if it is a left, unisex (neither left nor right), or right page. Used for determining what type of page tab to draw in Pages Panel, and has margin implications. For pages that are left pages, their actual left margin will be an outside margin, and their right margin will be an inside margin. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageRef</td><td>[IN] <a class="el" href="class_u_i_d_ref.html">UIDRef</a> for the page. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>PageType for the page. </dl></div></div><a class="anchor" id="a2e7ad8a3c9ca295a12594e0da4ae084b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ILayoutUtils::InvalidateViews </td><td>(</td><td class="paramtype"><a class="el" href="class_i_document.html">IDocument</a> *&nbsp;</td><td class="paramname"><em>document</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>If there are any views, invalidate them, otherwise do nothing. This calls into the UI plug-in Layout UI to actually do the invalidation if there is a UI present. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">document</td><td>[IN] to invalidate views for. </td></tr></table></dl></div></div><a class="anchor" id="a2f8fd6f31e9e3c9e9533fde2dc391aab"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ILayoutUtils::IsAMaster </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>spreadOrPageUID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tell whether a page is a master page or a master spread. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spreadOrPageUID</td><td>[IN] UID of a page or a spread to check. </td></tr><tr><td class="paramname">db</td><td>[IN] <a class="el" href="class_i_data_base.html">IDataBase</a> pointer for the document. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the UID is a page in a master spread or is a master spread. </dl></div></div><a class="anchor" id="a7a260a60a5aac802165fffe8415d692d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_command.html">ICommand</a>* ILayoutUtils::MakeShuffleCmd </td><td>(</td><td class="paramtype"><a class="el" href="class_i_document.html">IDocument</a> *&nbsp;</td><td class="paramname"><em>doc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>firstSpread</em> = <code>UIDRef::gNull</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>lastSpread</em> = <code>UIDRef::gNull</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Helper function to create a shuffle pages command for all the pages in a document. Be careful to shuffle the correct spreads, or just default to the whole document. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">doc</td><td>[IN] The document to use. If nil, use the front document. </td></tr><tr><td class="paramname">firstSpread</td><td>[IN] If specified, start with this spread. </td></tr><tr><td class="paramname">lastSpread</td><td>[IN] If specified, end with this spread. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>an <a class="el" href="class_i_command.html">ICommand</a> pointer for the command. </dl></div></div><a class="anchor" id="aef3b517b6c4d96f9db7cae017f41f965"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_columns.html">IColumns</a>* ILayoutUtils::Query_Columns </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>whichPage</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_spread.html">ISpread</a> *&nbsp;</td><td class="paramname"><em>currentSpread</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the columns of the spread associated with the frontmost layout window, or the indicated spread if the optional argument is used. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichpage</td><td>[IN] Optional zero-based page index for the desired page of the spread (zero is the left page in left-to-right binding documents, the right page in right-to-left documents). </td></tr><tr><td class="paramname">currentSpread</td><td>[IN] Optional <a class="el" href="class_i_spread.html">ISpread</a> pointer for the desired spread. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_columns.html">IColumns</a> pointer for the columns. The reference count is incremented; the caller is responsible for calling <a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release()</a>; </dl></div></div><a class="anchor" id="a68a17724e125004ecb656f0d805ddf40"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_margins.html">IMargins</a>* ILayoutUtils::QueryMargins </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>whichPage</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_spread.html">ISpread</a> *&nbsp;</td><td class="paramname"><em>currentSpread</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the margins of the given spread. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichpage</td><td>[IN] Optional zero-based page index for the desired page of the spread (zero is the left page in left-to-right binding documents, the right page in right-to-left documents). </td></tr><tr><td class="paramname">currentSpread</td><td>[IN] Optional <a class="el" href="class_i_spread.html">ISpread</a> pointer for the desired spread. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_margins.html">IMargins</a> pointer for the margins. The reference count is incremented; the caller is responsible for calling <a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release()</a>; </dl></div></div><a class="anchor" id="a66234d41c4ecd0b68567b3980f3234d1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ILayoutUtils::QueryOutermostParentFor </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>pUnknown</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>rIID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Traverse up the hierarchy to the outermost frame looking for an item supporting the specified interface. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pUnknown</td><td>[IN] Interface pointer to the starting item. </td></tr><tr><td class="paramname">rIID</td><td>[IN] Interface ID for the interface being sought. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> pointer for item found, else nil. If non-nil, the reference count is incremented; the caller is responsible for calling <a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release()</a>. </dl></div></div><a class="anchor" id="a19affbd1aa732fb82e33166b98a8d2a6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ILayoutUtils::QueryParentFor </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>pUnknown</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>rIID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Traverse up the hierarchy looking for an item supporting the specified interface. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pUnknown</td><td>[IN] Interface pointer to the starting item. </td></tr><tr><td class="paramname">rIID</td><td>[IN] Interface ID for the interface being sought. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> pointer for item found, else nil. If non-nil, the reference count is incremented; the caller is responsible for calling <a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release()</a>. </dl></div></div><a class="anchor" id="af892b724d5399fb1cd89f0c90d4f5c99"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ILayoutUtils::SpreadQueryHitTestPageItemNew </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_spread.html">ISpread</a> *&nbsp;</td><td class="paramname"><em>mySpread</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PBPMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>handlerClass</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interfaceID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int16&nbsp;</td><td class="paramname"><em>tolerance</em> = <code>kHitTestTolerance</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>UI independant Hit testing code. If your hit testing can be done with the UI(not ID server), use the calls in <a class="el" href="class_i_layout_u_i_utils.html">ILayoutUIUtils</a> to Hit test. Hit-test a point on the given spread <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">mySpread</td><td>[IN] the spread to hit-test </td></tr><tr><td class="paramname">where</td><td>[IN] point to hit-test in pasteboard coordinates. </td></tr><tr><td class="paramname">handlerClass</td><td>[IN] ClassID of handler boss for particular hit-test behavior desired. </td></tr><tr><td class="paramname">interfaceID</td><td>[IN] the interfaceID of the hit page item you want returned </td></tr><tr><td class="paramname">tolerance</td><td>[IN] The tolerance for how close &#39;where&#39; must be to be considered a hit. Defaults to kHitTestTolerance. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>item that was hit. Interface returned is the one specified with interfaceID parameter </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_layout_utils.html">ILayoutUtils</a><li class="footer">Generated on Sat Sep 22 2018 10:54:19 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
