<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_raster_port</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_raster_port.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_raster_port-members.html">List of all members</a></div><div class="headertitle"><div class="title">IRasterPort Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_raster_port_8h_source.html">IRasterPort.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IRasterPort:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_raster_port.png" usemap="#IRasterPort_map" /><map id="IRasterPort_map" name="IRasterPort_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:adc30aa0a019f23f5d7c0db74e69b420d"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IRASTERPORT }</td></tr><tr class="separator:adc30aa0a019f23f5d7c0db74e69b420d"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a1d4f6d8bcb3ddb7fb8c5fd55db6ee791"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a1d4f6d8bcb3ddb7fb8c5fd55db6ee791">Setup</a> ()=0</td></tr><tr class="separator:a1d4f6d8bcb3ddb7fb8c5fd55db6ee791"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a74b94409c5df3188073effb3662bda91"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a74b94409c5df3188073effb3662bda91">currentgstatelevel</a> ()=0</td></tr><tr class="separator:a74b94409c5df3188073effb3662bda91"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a721384999d0c3dc746355f7f5bc7eff1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a721384999d0c3dc746355f7f5bc7eff1">initdevicescale</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> scale=1.0)=0</td></tr><tr class="separator:a721384999d0c3dc746355f7f5bc7eff1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1ef7e1c9ba859fae25c0124c2234a42b"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a1ef7e1c9ba859fae25c0124c2234a42b">getdevicescale</a> ()=0</td></tr><tr class="separator:a1ef7e1c9ba859fae25c0124c2234a42b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a82ac4ca22a5f5a023241dce9133dc981"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a82ac4ca22a5f5a023241dce9133dc981">setmatrix</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)=0</td></tr><tr class="separator:a82ac4ca22a5f5a023241dce9133dc981"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a95fac61e96e61cd1fa22321b3555245f"><td align="right" class="memItemLeft" valign="top">virtual int8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a95fac61e96e61cd1fa22321b3555245f">currentmatrix</a> (<a class="el" href="class_p_m_matrix.html">PMMatrix</a> *m)=0</td></tr><tr class="separator:a95fac61e96e61cd1fa22321b3555245f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a259ad9118c613a0ea7a7a2aeca4c545d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a259ad9118c613a0ea7a7a2aeca4c545d">currentlinewidth</a> ()=0</td></tr><tr class="separator:a259ad9118c613a0ea7a7a2aeca4c545d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afa7d4adb86118df6d5c2c32f16b4ca84"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#afa7d4adb86118df6d5c2c32f16b4ca84">currentdash</a> (int32 *numDash, Fixed **dashArray, Fixed *offset)=0</td></tr><tr class="separator:afa7d4adb86118df6d5c2c32f16b4ca84"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2a01b96aa17cf1e6182caf1ba30c4f77"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a2a01b96aa17cf1e6182caf1ba30c4f77">currentlinecap</a> ()=0</td></tr><tr class="separator:a2a01b96aa17cf1e6182caf1ba30c4f77"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a258e517f438d47e07b445a53cb51afc1"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a258e517f438d47e07b445a53cb51afc1">currentlinejoin</a> ()=0</td></tr><tr class="separator:a258e517f438d47e07b445a53cb51afc1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab6bf1c8c6b661ecd16da0cc4c61890e6"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#ab6bf1c8c6b661ecd16da0cc4c61890e6">currentmiterlimit</a> ()=0</td></tr><tr class="separator:ab6bf1c8c6b661ecd16da0cc4c61890e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a888425eddd37b3258398520558ab7e94"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a888425eddd37b3258398520558ab7e94">currentfillbounds</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> *bounds)=0</td></tr><tr class="separator:a888425eddd37b3258398520558ab7e94"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a91acc7fbbeaf4ccb8b9562d15732ec40"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a91acc7fbbeaf4ccb8b9562d15732ec40">currentstrokebounds</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> *bounds)=0</td></tr><tr class="separator:a91acc7fbbeaf4ccb8b9562d15732ec40"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a56c0856ae6ea97b3f74da57e60375560"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a56c0856ae6ea97b3f74da57e60375560">currentclipbounds</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> *bounds)=0</td></tr><tr class="separator:a56c0856ae6ea97b3f74da57e60375560"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a11234fcf1460b056c965c7885814fd"><td align="right" class="memItemLeft" valign="top">virtual AGMPaint *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a1a11234fcf1460b056c965c7885814fd">currentsrccolor</a> ()=0</td></tr><tr class="separator:a1a11234fcf1460b056c965c7885814fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a24e6a581d5942c1ea2a7b7a180f8ffc0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a24e6a581d5942c1ea2a7b7a180f8ffc0">currentdstcolor</a> (AGMRasterPort *dstDevice, AGMPaint *agmPaint)=0</td></tr><tr class="separator:a24e6a581d5942c1ea2a7b7a180f8ffc0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a48c2d02d87ffe42a87c53f9d1a41908d"><td align="right" class="memItemLeft" valign="top">virtual int8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a48c2d02d87ffe42a87c53f9d1a41908d">infill</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;devRect)=0</td></tr><tr class="separator:a48c2d02d87ffe42a87c53f9d1a41908d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a594026a59878d6aaf7b6e6b89e52af8a"><td align="right" class="memItemLeft" valign="top">virtual int8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a594026a59878d6aaf7b6e6b89e52af8a">ineofill</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;devRect)=0</td></tr><tr class="separator:a594026a59878d6aaf7b6e6b89e52af8a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5f49dd73a8c0c2b9b53903c6c23a6d32"><td align="right" class="memItemLeft" valign="top">virtual int8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a5f49dd73a8c0c2b9b53903c6c23a6d32">instroke</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;devRect)=0</td></tr><tr class="separator:a5f49dd73a8c0c2b9b53903c6c23a6d32"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1af34b1a0ac0f8a69f87953139370a51"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a1af34b1a0ac0f8a69f87953139370a51">initclip</a> ()=0</td></tr><tr class="separator:a1af34b1a0ac0f8a69f87953139370a51"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a7af0da6f51993ba8c7f5dc2f64ef46"><td align="right" class="memItemLeft" valign="top">virtual int8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a1a7af0da6f51993ba8c7f5dc2f64ef46">clipclass</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;rect)=0</td></tr><tr class="separator:a1a7af0da6f51993ba8c7f5dc2f64ef46"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a913bd0e28a17ec6c50a1db5ba767d5e9"><td align="right" class="memItemLeft" valign="top">virtual bool8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a913bd0e28a17ec6c50a1db5ba767d5e9">transform</a> (<a class="el" href="class_p_m_real.html">PMReal</a> *x, <a class="el" href="class_p_m_real.html">PMReal</a> *y)=0</td></tr><tr class="separator:a913bd0e28a17ec6c50a1db5ba767d5e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aff914d5cbd114ff1d36889636fcac36c"><td align="right" class="memItemLeft" valign="top">virtual bool8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#aff914d5cbd114ff1d36889636fcac36c">itransform</a> (<a class="el" href="class_p_m_real.html">PMReal</a> *x, <a class="el" href="class_p_m_real.html">PMReal</a> *y)=0</td></tr><tr class="separator:aff914d5cbd114ff1d36889636fcac36c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac6ddc1c250657f54b96361a1726b2976"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#ac6ddc1c250657f54b96361a1726b2976">GetPathInfo</a> (<a class="el" href="class_i_outline_info.html">IOutlineInfo</a> *callBack)=0</td></tr><tr class="separator:ac6ddc1c250657f54b96361a1726b2976"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a134542e2e16b5c7596cab295098f54c7"><td align="right" class="memItemLeft" valign="top">virtual bool8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a134542e2e16b5c7596cab295098f54c7">GetError</a> ()=0</td></tr><tr class="separator:a134542e2e16b5c7596cab295098f54c7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac9e288f0d820e319328a07bd8ea05824"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#ac9e288f0d820e319328a07bd8ea05824">SetXORMode</a> (bool32 xorOn)=0</td></tr><tr class="separator:ac9e288f0d820e319328a07bd8ea05824"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ade8079f020da8277abd2718b22501558"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#ade8079f020da8277abd2718b22501558">setantialiaspolicy</a> (int32 *inOutPolicy)=0</td></tr><tr class="separator:ade8079f020da8277abd2718b22501558"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3c8075c1cd75eaebc01796a6904b01cb"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a3c8075c1cd75eaebc01796a6904b01cb">setportoptions</a> (uint32 portOptions)=0</td></tr><tr class="separator:a3c8075c1cd75eaebc01796a6904b01cb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3f784d14e709c709c92bd9fd5e2e943a"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a3f784d14e709c709c92bd9fd5e2e943a">getportoptions</a> ()=0</td></tr><tr class="separator:a3f784d14e709c709c92bd9fd5e2e943a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a91f33c0f964472517719946c571226f0"><td align="right" class="memItemLeft" valign="top">virtual bool8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a91f33c0f964472517719946c571226f0">SetDeviceProfile</a> (AGMColorProfile *profile)=0</td></tr><tr class="separator:a91f33c0f964472517719946c571226f0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4adc22516896327200e0fce30a5192da"><td align="right" class="memItemLeft" valign="top">virtual bool8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_raster_port.html#a4adc22516896327200e0fce30a5192da">IsHiDPI</a> ()=0</td></tr><tr class="separator:a4adc22516896327200e0fce30a5192da"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>This is a viewport interface which is a shell over AGM&#39;s rasterport specific API Most of the methods work exactly or very similar to PostScript operators. See Postscript language reference manual for more info<p>IMPORTANT: You CANNOT use <a class="el" href="class_i_raster_port.html">IRasterPort</a> methods in any drawing code you expect to print<p>Note: Many of the methods exposed by <a class="el" href="class_i_raster_port.html">IRasterPort</a> use internal types and are intended for internal usage only. </div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a1a7af0da6f51993ba8c7f5dc2f64ef46"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int8 IRasterPort::clipclass </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>rect</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Check to see if the provided rectangle is within the current clip path.<p>The rectangle provided is in user space and will be transformed to device space using the current CTM before comparing with device space clip in the gstate.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rect</td><td>IN The rect to test </td></tr></table></dl><dl class="section return"><dt>Returns<dd>0 if the rect is partially clipped, 1 if it&#39;s unclipped, 2 if it&#39;s totally clipped </dl></div></div><a class="anchor" id="a56c0856ae6ea97b3f74da57e60375560"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::currentclipbounds </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>bounds</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current clip bounds in device coordinates (not user-coordinates). Note that even the device scale set by initdevicescale can be seen through currentclipbounds. So if you were to initdevicescale(2.0); then translate user space by (100, 100); then clip to L:0 T:0 R:10 B:10 and then asked for currentclipbounds, you would get L:200 T:200 R:220 B:220 &ndash; an answer in the coordinate system of the deep down unscaled device.<p>Also note that before a clip is ever set, AGM reports a wide open clip of +/- (2^30 - 2^7) of all the strange things. But the first clip will actually intersect the requested clip with the extent of the pixel bounds. For example:<p>gport-&gt;rectclip( -double(1UL&lt;&lt;29), -double(1UL&lt;&lt;29), double(1UL&lt;&lt;30), double(1UL&lt;&lt;30)); rport-&gt;currentclipbounds( &amp;rect); //...we&#39;re now down to the pixel buffer.<p>will reveal the actual size of the pixel buffer (sneaking past the device scale factor set by initdevicescale.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">bounds</td><td>OUT The clip bounds </td></tr></table></dl></div></div><a class="anchor" id="afa7d4adb86118df6d5c2c32f16b4ca84"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::currentdash </td><td>(</td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>numDash</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Fixed **&nbsp;</td><td class="paramname"><em>dashArray</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Fixed *&nbsp;</td><td class="paramname"><em>offset</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current dash pattern<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">numDash</td><td>OUT The number of dashes </td></tr><tr><td class="paramname">dashArray</td><td>OUT The current dash array </td></tr><tr><td class="paramname">offset</td><td>OUT The dash offset </td></tr></table></dl></div></div><a class="anchor" id="a24e6a581d5942c1ea2a7b7a180f8ffc0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::currentdstcolor </td><td>(</td><td class="paramtype">AGMRasterPort *&nbsp;</td><td class="paramname"><em>dstDevice</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">AGMPaint *&nbsp;</td><td class="paramname"><em>agmPaint</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method intentionally uncommented </div></div><a class="anchor" id="a888425eddd37b3258398520558ab7e94"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::currentfillbounds </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>bounds</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current fill bounds<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">bounds</td><td>OUT The fill bounds </td></tr></table></dl></div></div><a class="anchor" id="a74b94409c5df3188073effb3662bda91"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IRasterPort::currentgstatelevel </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the current gsave level in the backing port<dl class="section return"><dt>Returns<dd>the port&#39;s gsave level </dl></div></div><a class="anchor" id="a2a01b96aa17cf1e6182caf1ba30c4f77"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IRasterPort::currentlinecap </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current line cap. See <a class="el" href="_graphic_types_8h_source.html">GraphicTypes.h</a> for possible return values<dl class="section return"><dt>Returns<dd>the current line cap </dl></div></div><a class="anchor" id="a258e517f438d47e07b445a53cb51afc1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IRasterPort::currentlinejoin </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current line join. See <a class="el" href="_graphic_types_8h_source.html">GraphicTypes.h</a> for possible return values<dl class="section return"><dt>Returns<dd>the current line join </dl></div></div><a class="anchor" id="a259ad9118c613a0ea7a7a2aeca4c545d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IRasterPort::currentlinewidth </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current line width<dl class="section return"><dt>Returns<dd>the current line width </dl></div></div><a class="anchor" id="a95fac61e96e61cd1fa22321b3555245f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int8 IRasterPort::currentmatrix </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current user coord CTM if there is a device scale factor, the returned matrix will not include it<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">m</td><td>OUT The current matrix </td></tr></table></dl><dl class="section return"><dt>Returns<dd>non-zero if the call succeeds, else zero </dl></div></div><a class="anchor" id="ab6bf1c8c6b661ecd16da0cc4c61890e6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IRasterPort::currentmiterlimit </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current miter limit<dl class="section return"><dt>Returns<dd>the current miter limit </dl></div></div><a class="anchor" id="a1a11234fcf1460b056c965c7885814fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual AGMPaint* IRasterPort::currentsrccolor </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current source color<dl class="section return"><dt>Returns<dd>the current source color </dl></div></div><a class="anchor" id="a91acc7fbbeaf4ccb8b9562d15732ec40"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::currentstrokebounds </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>bounds</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current stroke bounds<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">bounds</td><td>OUT The stroke bounds </td></tr></table></dl></div></div><a class="anchor" id="a1ef7e1c9ba859fae25c0124c2234a42b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IRasterPort::getdevicescale </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s device coord scale factor<dl class="section return"><dt>Returns<dd>The device coord scale factor </dl></div></div><a class="anchor" id="a134542e2e16b5c7596cab295098f54c7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool8 IRasterPort::GetError </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets backing port&#39;s error state<dl class="section return"><dt>Returns<dd>kTrue if the backing port is in an error state, else kFalse </dl></div></div><a class="anchor" id="ac6ddc1c250657f54b96361a1726b2976"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::GetPathInfo </td><td>(</td><td class="paramtype"><a class="el" href="class_i_outline_info.html">IOutlineInfo</a> *&nbsp;</td><td class="paramname"><em>callBack</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the backing port&#39;s current path<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">callBack</td><td>OUT The outline info to store the path </td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_outline_info.html">IOutlineInfo</a></dl></div></div><a class="anchor" id="a3f784d14e709c709c92bd9fd5e2e943a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IRasterPort::getportoptions </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method intentionally uncommented </div></div><a class="anchor" id="a594026a59878d6aaf7b6e6b89e52af8a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int8 IRasterPort::ineofill </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>devRect</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tests whether the rectangle in device space would be painted by eofill, taking current clip into account<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">devRect</td><td>IN The rect to test, in device coordinates </td></tr></table></dl><dl class="section return"><dt>Returns<dd>0 if doesn&#39;t intersect, 1 if fully intersects, or 2 if partially intersects </dl></div></div><a class="anchor" id="a48c2d02d87ffe42a87c53f9d1a41908d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int8 IRasterPort::infill </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>devRect</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tests whether the rectangle in device space would be painted by fill, taking current clip into account<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">devRect</td><td>IN The rect to test, in device coordinates </td></tr></table></dl><dl class="section return"><dt>Returns<dd>0 if doesn&#39;t intersect, 1 if fully intersects, or 2 if partially intersects </dl></div></div><a class="anchor" id="a1af34b1a0ac0f8a69f87953139370a51"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::initclip </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Initializes the backing port&#39;s clipping </div></div><a class="anchor" id="a721384999d0c3dc746355f7f5bc7eff1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::initdevicescale </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>scale</em> = <code>1.0</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the backing port&#39;s device coord scale factor. Note: For HiDPI offscreens set the device scale before setting the user matrix<p>What this does is make every currentmatrix, setmatrix call pass through this scale factor. With setmatrix, first the scale factor is put into the port, then the passed in matrix. With currentmatrix, the real CTM is post-unscaled before returning. That essentially means that there is a scale-factor stuck on the device that you can&#39;t see (except with currentclipbounds) or get rid of. So for example, if you create a double-size pixelbuffer for AGM and call initdevicescale(2.) on the raster port, all the existing AGM drawing code that uses setmatrix, currentmatrix will be drawing double-resolution pictures without knowing it.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">scale</td><td>IN The device coord scale factor (implicitly 1:1 unless an HiDPI mode is in effect) </td></tr></table></dl></div></div><a class="anchor" id="a5f49dd73a8c0c2b9b53903c6c23a6d32"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int8 IRasterPort::instroke </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>devRect</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tests whether the rectangle in device space would be painted by stroke, taking current clip into account<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">devRect</td><td>IN The rect to test, in device coordinates </td></tr></table></dl><dl class="section return"><dt>Returns<dd>0 if doesn&#39;t intersect, 1 if fully intersects, or 2 if partially intersects </dl></div></div><a class="anchor" id="a4adc22516896327200e0fce30a5192da"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool8 IRasterPort::IsHiDPI </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determines if the backing port is in high DPI mode (device scale == 2.0)<dl class="section return"><dt>Returns<dd>kTrue if the backing port&#39;s device scale is 2.0, else kFalse </dl></div></div><a class="anchor" id="aff914d5cbd114ff1d36889636fcac36c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool8 IRasterPort::itransform </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Transforms the given point by the inverse of the backing port&#39;s CTM (i.e. from device space to CTM space)<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">x</td><td>IN/OUT The x component of the point </td></tr><tr><td class="paramname">y</td><td>IN/OUT The y component of the point </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if succeeds, else kFalse </dl></div></div><a class="anchor" id="ade8079f020da8277abd2718b22501558"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::setantialiaspolicy </td><td>(</td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>inOutPolicy</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">     Sets the anti-aliasing policy for the backing port. 



     Returns previous policy. Allows use like this:



     &lt;pre&gt;

     int32 options = 1;

     rasterport-&gt;setantialiaspolicy(&amp;options);

</pre><p> use the port... rasterport-&gt;setantialiaspolicy(&amp;options); // Restore previous value <p>inOutPolicy is a bit mask that can take one or more of the following: 1 to antialias text 2 to antialias graphics 4 prevents linearized blending for non-AGM alpha<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">inOutPolicy</td><td>IN/OUT The new policy on input, the old policy on output </td></tr></table></dl></div></div><a class="anchor" id="a91f33c0f964472517719946c571226f0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool8 IRasterPort::SetDeviceProfile </td><td>(</td><td class="paramtype">AGMColorProfile *&nbsp;</td><td class="paramname"><em>profile</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the device profile for the current raster port.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">profile</td><td>IN The profile to set </td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_color_space_mgr.html">IColorSpaceMgr</a></dl></div></div><a class="anchor" id="a82ac4ca22a5f5a023241dce9133dc981"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::setmatrix </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the backing port&#39;s user coord CTM to m if there is a device scale factor in effect, the matrix m should not include it<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">m</td><td>IN The new matrix </td></tr></table></dl></div></div><a class="anchor" id="a3c8075c1cd75eaebc01796a6904b01cb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::setportoptions </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>portOptions</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method intentionally uncommented </div></div><a class="anchor" id="a1d4f6d8bcb3ddb7fb8c5fd55db6ee791"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::Setup </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Initializes the port. May be called multiple times to re-initialize the port if the backing port changes<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_a_g_m_port_data.html">IAGMPortData</a></dl></div></div><a class="anchor" id="ac9e288f0d820e319328a07bd8ea05824"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRasterPort::SetXORMode </td><td>(</td><td class="paramtype">bool32&nbsp;</td><td class="paramname"><em>xorOn</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets XOR mode on the backing port<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xorOn</td><td>IN The new xor mode </td></tr></table></dl></div></div><a class="anchor" id="a913bd0e28a17ec6c50a1db5ba767d5e9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool8 IRasterPort::transform </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Transforms the given point by the backing port&#39;s CTM to a point in device space<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">x</td><td>IN/OUT The x component of the point </td></tr><tr><td class="paramname">y</td><td>IN/OUT The y component of the point </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if succeeds, else kFalse </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_raster_port.html">IRasterPort</a><li class="footer">Generated on Sat Sep 22 2018 10:54:26 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
