<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_wax_anchor_pt</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_wax_anchor_pt.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_wax_anchor_pt-members.html">List of all members</a></div><div class="headertitle"><div class="title">IWaxAnchorPt Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><div class="dynheader"> Inheritance diagram for IWaxAnchorPt:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_wax_anchor_pt.png" usemap="#IWaxAnchorPt_map" /><map id="IWaxAnchorPt_map" name="IWaxAnchorPt_map"><area alt="IPMUnknown" coords="0,0,92,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a5987085ba5caa7a72df2c64e3d8fa70e"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IWAXANCHORPT }</td></tr><tr class="separator:a5987085ba5caa7a72df2c64e3d8fa70e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abf152dc8d164fd988a0fff0fa99f3b1e"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#abf152dc8d164fd988a0fff0fa99f3b1e">NextAnchorInfo</a> { <a class="el" href="class_i_wax_anchor_pt.html#abf152dc8d164fd988a0fff0fa99f3b1ea9c828d9baeb5364e6cf863487dec9f4a">nai_notcontinued</a>, <a class="el" href="class_i_wax_anchor_pt.html#abf152dc8d164fd988a0fff0fa99f3b1ead96ad0635918bb905f8143f92b371572">nai_continued</a> }</td></tr><tr class="separator:abf152dc8d164fd988a0fff0fa99f3b1e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8f6c01c2f691f99937c4f5d9696dc13d"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a8f6c01c2f691f99937c4f5d9696dc13d">waxLineDamageType</a> { <b>kWLDT_Other</b> = 0, <b>kWLDT_Keeps</b> = 1, <b>kWLDT_Content</b> = 2 }</td></tr><tr class="separator:a8f6c01c2f691f99937c4f5d9696dc13d"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:ad847e471622236920cff8495af0e6e6e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad847e471622236920cff8495af0e6e6e"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>Recompose</b> (const <a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> *tpl, const <a class="el" href="class_i_paragraph_composer_1_1_tiler.html">IParagraphComposer::Tiler</a> *tiler, TextIndex lineStartIndex, TextIndex anchorPtIndex, <a class="el" href="class_parcel_key.html">ParcelKey</a> parcelKey, <a class="el" href="class_p_m_real.html">PMReal</a> yPosition, <a class="el" href="class_i_wax_anchor_pt.html#a8f6c01c2f691f99937c4f5d9696dc13d">waxLineDamageType</a> waxLineDamage, bool16 firstWaxLineInParcel, bool16 waxLinePartOfKeepsBlock, <a class="el" href="class_parcel_key.html">ParcelKey</a> *pParcelKey, <a class="el" href="class_p_m_rect.html">PMRect</a> *pBBox, <a class="el" href="class_p_m_real.html">PMReal</a> *pSpaceAfter, bool16 *pHasBreak, int32 *pTextSpan, bool16 *pDamagePreviousWaxLine, <a class="el" href="class_i_wax_anchor_pt.html#abf152dc8d164fd988a0fff0fa99f3b1e">NextAnchorInfo</a> *pNextAnchorInfo, int32 *pDamageFollowingNChars, bool16 *pDeferredCompositionDueToKeeps, TextIndex noDamageBackTextIndex=-1)=0</td></tr><tr class="separator:ad847e471622236920cff8495af0e6e6e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a659d5ee08a1cca1c466585c01509f27a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a659d5ee08a1cca1c466585c01509f27a">Move</a> (TextIndex anchorPtIndex, <a class="el" href="class_i_parcel_list.html">IParcelList</a> *pl, <a class="el" href="class_parcel_key.html">ParcelKey</a> parcelKey, <a class="el" href="class_p_m_real.html">PMReal</a> yPosition, <a class="el" href="class_p_m_real.html">PMReal</a> yPosDelta)=0</td></tr><tr class="separator:a659d5ee08a1cca1c466585c01509f27a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a73de11e729c07e44ce43b4773d285ced"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a73de11e729c07e44ce43b4773d285ced">GetBBox</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> *pBBox) const =0</td></tr><tr class="separator:a73de11e729c07e44ce43b4773d285ced"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aea3dfd5f310e979110c89d53933e8eb5"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#aea3dfd5f310e979110c89d53933e8eb5">GetTextSpan</a> () const =0</td></tr><tr class="separator:aea3dfd5f310e979110c89d53933e8eb5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:affb217e9589832caae329823ff9307e6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#affb217e9589832caae329823ff9307e6">GetInkBounds</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> *inkBounds) const =0</td></tr><tr class="separator:affb217e9589832caae329823ff9307e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adc98d5b5b6da72dd282215e2b171a994"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#adc98d5b5b6da72dd282215e2b171a994">GetDrawPassInfo</a> (<a class="el" href="class_k2_vector.html">Text::DrawPassInfoList</a> *passList) const =0</td></tr><tr class="separator:adc98d5b5b6da72dd282215e2b171a994"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a52b576ee4cb8e940e7f37fa262239150"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a52b576ee4cb8e940e7f37fa262239150">IterateWaxAnchorPointDrawOrder</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xform, <a class="el" href="class_i_callback.html">ICallback</a> *callbackInfo, int32 iShapeFlags)=0</td></tr><tr class="separator:a52b576ee4cb8e940e7f37fa262239150"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4be71afafd048b8ae3d586bf11f4eaab"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a4be71afafd048b8ae3d586bf11f4eaab">Draw</a> (<a class="el" href="class_graphics_data.html">GraphicsData</a> *gd, int32 iShapeFlags, Text::DrawPassInfo::Pass pass, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;xOffset, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;yOffset, const <a class="el" href="class_p_m_rect.html">PMRect</a> *areaToDraw)=0</td></tr><tr class="separator:a4be71afafd048b8ae3d586bf11f4eaab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0c781732502d07993574acfec70d97a1"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a0c781732502d07993574acfec70d97a1">GetIsParcelPositionDependent</a> () const =0</td></tr><tr class="separator:a0c781732502d07993574acfec70d97a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88a2f33479f5bfb39ac952ac92828a0f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a88a2f33479f5bfb39ac952ac92828a0f">MarkKeepsDamageFromText</a> ()=0</td></tr><tr class="separator:a88a2f33479f5bfb39ac952ac92828a0f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac1eaef06347eaf6f1841a795cb0b46eb"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#ac1eaef06347eaf6f1841a795cb0b46eb">MarkExtendedDamageFromTextKeeps</a> (bool16 paraHasKeepAllLines)=0</td></tr><tr class="separator:ac1eaef06347eaf6f1841a795cb0b46eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aceaf58e82371942f6966d69c016df607"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#aceaf58e82371942f6966d69c016df607">HitTest</a> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;waxPt, TextIndex *nextLine) const =0</td></tr><tr class="separator:aceaf58e82371942f6966d69c016df607"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adfb06619b92add045026a809911554bb"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#adfb06619b92add045026a809911554bb">CollectOwnedItems</a> (<a class="el" href="class_k2_vector.html">OwnedItemDataList</a> *rList) const =0</td></tr><tr class="separator:adfb06619b92add045026a809911554bb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4317fad8de4f0ac6eab875ca054b24ff"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a4317fad8de4f0ac6eab875ca054b24ff">GetTopKeepsContentBottom</a> (const <a class="el" href="class_i_wax_line.html">IWaxLine</a> *waxLine) const =0</td></tr><tr class="separator:a4317fad8de4f0ac6eab875ca054b24ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aff325c5659d8e58e2eca7a7b266ec1c9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#aff325c5659d8e58e2eca7a7b266ec1c9">NotifyComposedPartOfKeepsBlock</a> (<a class="el" href="class_i_wax_line.html">IWaxLine</a> *waxLine)=0</td></tr><tr class="separator:aff325c5659d8e58e2eca7a7b266ec1c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aea499c905bafc77fd07f2ae7eba51111"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#aea499c905bafc77fd07f2ae7eba51111">MarkCompositionDamage</a> (<a class="el" href="class_i_wax_line.html">IWaxLine</a> *waxLine, <a class="el" href="class_p_m_real.html">PMReal</a> topYIntersect)=0</td></tr><tr class="separator:aea499c905bafc77fd07f2ae7eba51111"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2d9b303100b36ffaa0cd2f4d192319d0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a2d9b303100b36ffaa0cd2f4d192319d0">GetIsDivisible</a> () const =0</td></tr><tr class="separator:a2d9b303100b36ffaa0cd2f4d192319d0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8e6ebb7194b2094396ae7604cd709e4c"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a8e6ebb7194b2094396ae7604cd709e4c">GetIsOnlyOrFirstOfASet</a> (bool16 *pHasTopBreak) const =0</td></tr><tr class="separator:a8e6ebb7194b2094396ae7604cd709e4c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adb5cfd9435bccb6c62391e475db7f069"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#adb5cfd9435bccb6c62391e475db7f069">GetTextKeepsViolation</a> (bool16 paraHasKeepAllLines) const =0</td></tr><tr class="separator:adb5cfd9435bccb6c62391e475db7f069"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a63e28f161375302c02c4cbcebc22304d"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a63e28f161375302c02c4cbcebc22304d">BackupToStartOfKeepsFromTop</a> (bool16 paraHasKeepAllLines, bool16 &amp;topOfKeepsBlockNotTopOfWAPSet, bool16 &amp;keepsBlockAtTopOfContainingWAP, bool16 &amp;keepsBlockHasTopBreak, bool16 &amp;keepsBlockDamaged) const =0</td></tr><tr class="separator:a63e28f161375302c02c4cbcebc22304d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1fd8ef127074d11eb37d579a0f0a1580"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a1fd8ef127074d11eb37d579a0f0a1580">BackupToStartOfKeepsFromBottom</a> (bool16 paraHasKeepAllLines, bool16 &amp;topOfKeepsBlockNotTopOfWAPSet, bool16 &amp;keepsBlockAtTopOfContainingWAP, bool16 &amp;keepsBlockHasTopBreak, bool16 &amp;keepsBlockDamaged) const =0</td></tr><tr class="separator:a1fd8ef127074d11eb37d579a0f0a1580"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3c3211467f25ad377777fe95056d70d4"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a3c3211467f25ad377777fe95056d70d4">GetIsCompositionExtending</a> () const =0</td></tr><tr class="separator:a3c3211467f25ad377777fe95056d70d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acd65b928b27a99bd02d6b804736974b3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#acd65b928b27a99bd02d6b804736974b3">MarkParcelMoveDamage</a> ()=0</td></tr><tr class="separator:acd65b928b27a99bd02d6b804736974b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad71c02b4eed50eb47e30a4971801d206"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#ad71c02b4eed50eb47e30a4971801d206">MarkPreviousParcelMoveDamage</a> ()=0</td></tr><tr class="separator:ad71c02b4eed50eb47e30a4971801d206"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a86ca8efb65195318cc6c2a07a07697d7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a86ca8efb65195318cc6c2a07a07697d7">MarkParcelGridDamage</a> ()=0</td></tr><tr class="separator:a86ca8efb65195318cc6c2a07a07697d7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a491c3a62fa8185711d441dd00f7cb06f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_anchor_pt.html#a491c3a62fa8185711d441dd00f7cb06f">MarkPreviousParcelGridDamage</a> ()=0</td></tr><tr class="separator:a491c3a62fa8185711d441dd00f7cb06f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="abf152dc8d164fd988a0fff0fa99f3b1e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_wax_anchor_pt.html#abf152dc8d164fd988a0fff0fa99f3b1e">IWaxAnchorPt::NextAnchorInfo</a></td></tr></table></div><div class="memdoc"><table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="abf152dc8d164fd988a0fff0fa99f3b1ea9c828d9baeb5364e6cf863487dec9f4a"></a>nai_notcontinued</em>&nbsp;</td><td class="fielddoc"><p>The next WaxLine does NOT contain an Anchor which is related to this Anchor. If the position of this Anchor changes relative to its original location then the next WaxLine will be damaged. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="abf152dc8d164fd988a0fff0fa99f3b1ead96ad0635918bb905f8143f92b371572"></a>nai_continued</em>&nbsp;</td><td class="fielddoc"><p>The next WaxLine contains an Anchor which is related to this Anchor. The next WaxLine will not be damaged. </td></tr></table></div></div><a class="anchor" id="a8f6c01c2f691f99937c4f5d9696dc13d"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_wax_anchor_pt.html#a8f6c01c2f691f99937c4f5d9696dc13d">IWaxAnchorPt::waxLineDamageType</a></td></tr></table></div><div class="memdoc"><p>The owning UID of the Anchored rectangle is being asked to re-compose itself starting in the specified parcel and yPosition. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">tpl</td><td>Pointer to <a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a> being composed </td></tr><tr><td class="paramname">tiler</td><td>Pointer to <a class="el" href="class_i_paragraph_composer_1_1_tiler.html">IParagraphComposer::Tiler</a> managing the geometry </td></tr><tr><td class="paramname">lineStartIndex</td><td></td></tr><tr><td class="paramname">anchorPtIndex</td><td></td></tr><tr><td class="paramname">tiler</td><td></td></tr><tr><td class="paramname">parcelKey</td><td></td></tr><tr><td class="paramname">yPosition</td><td></td></tr><tr><td class="paramname">waxLineDamage</td><td></td></tr><tr><td class="paramname">firstWaxLineInParcel</td><td>Set to kTrue if the new WaxLine will be the first WaxLine in the specified StartingParcel OR it is part of a keeps/dropcap block that has its top WaxLine as the first in the specified StartingParcel. </td></tr><tr><td class="paramname">waxLinePartOfKeepsBlock</td><td>Set to kTrue if the new WaxLine is to be kept with a previous WaxLine due to KeepWithNext or KeepWithFirstN or KeepTogether. This can only be kTrue for the first WaxAnchorPt of a multiple WaxAnchorPt set. The callee is expected to compute a value for <a class="el" href="class_i_wax_anchor_pt.html#a4317fad8de4f0ac6eab875ca054b24ff">GetTopKeepsContentBottom()</a>. If the damage situation is such that the original value is known to be valid then it does not have to recompute it.</td></tr></table></dl><p>If the method returns kTrue then the callee must return ALL the following out parameters except for pDamagePreviousWaxLine: <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pParcelKey</td><td>The parcel key of the Anchor rectangle </td></tr><tr><td class="paramname">pBBox</td><td>The bounding box, in Parcel coordinates. These are not necessarily the inkBounds of the object, just the raw dimensions of the object as if the object was a part of Text. The YPosition of the Anchoring WaxLine will be set to the bottom of the rect, the LineHeight will be set to the height of the rect and the Width will be set to the width of the rect. </td></tr><tr><td class="paramname">pSpaceAfter</td><td>The BBox. Can be negative. The WaxAnchorComposer will adjust the YPosition of the WaxLine by this amount while maintaining the position of the BBox. </td></tr><tr><td class="paramname">pHasBreak</td><td>Set to kTrue if some Break (Column, Frame, Page, etc) in effect for this WaxAnchorPt AND this WaxAnchorPt is the ONLY or the FIRST, in the event it is part of a series of related WaxAnchorPts. </td></tr><tr><td class="paramname">pTextSpan</td><td>The number of Anchor points (span) mapped (&gt;=1). </td></tr><tr><td class="paramname">pDamagePrevousWaxLine</td><td>Set to kTrue if the previous WaxLine should be damaged after completing processing for this Anchor. Requires that the previous WaxLine be related to this Anchor. This value must always be set. </td></tr><tr><td class="paramname">pNextAnchorInfo</td><td>Set to nai_notcontinued if no Anchors related to this one follow this Anchor. </td></tr><tr><td class="paramname">pDamageFollowingNthChars</td><td>Specifies the number of characters after (anchorPtIndex + pTextSpan) that should be content damaged after this Anchor is processed. pNextAnchorInfo must be set to nai_continued and the affected characters must be owned by the Anchor. Only needs to be set if the Anchor composed. </td></tr><tr><td class="paramname">pDeferredCompositionDueToKeeps</td><td>If waxLinePartOfKeepsBlock is kTrue, then this should be set to kTrue if partial composition was done to faciliate keeps computation, kFalse otherwise. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Anchor composed, kFalse otherwise. </dl></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a1fd8ef127074d11eb37d579a0f0a1580"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex IWaxAnchorPt::BackupToStartOfKeepsFromBottom </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>paraHasKeepAllLines</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>topOfKeepsBlockNotTopOfWAPSet</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>keepsBlockAtTopOfContainingWAP</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>keepsBlockHasTopBreak</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>keepsBlockDamaged</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method by the Text Keeps processing when it is backing up to the start of the Text Keeps block and it encounters a WaxAnchorPt that the next WaxLine would like to be kept with.<p>By definition this WaxAnchorPt will be the only, or last of a multi-piece set.<p>The callee needs to indicate how this Text Keep thread flows through the WaxAnchorPt - by definition the WaxLine below the WaxAnchorPt is trying to keep with the bottom edge but if there is internal keeps relationships that stretch from this bottom edge then this is the Keeps block that we are interested in.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">paraHasKeepAllLines</td><td>kTrue if the anchoring Paragraph has Keep All Lines Together set. This will be used by the callee so that it will backup to the very top of the multi-WaxAnchorPt set (topOfKeepsBlockNotTopOfWAPSet will be kFalse, keepBlockAtTopContaining will be kTrue) unless the internal object as an effective text break. </td></tr><tr><td class="paramname">topOfKeepsBlockNotTopOfWAPSet</td><td>Returned kTrue if the object can be considered divisible - that is the top of the keeps block beginning at the bottom of the object ends before the top of the object mapped by one or more WaxAnchorPt, even though the top of the object might be in an earlier WaxAnchorPt. kFalse if the entire object can be considered one whole keeps block, even though the top of the object might be in an earlier WaxAnchorPt. This latter is important because it tells the Text Keeps processing system whether it needs to continue the keeps backup using the WaxLine keeps flags on the top WaxAnchorPt. </td></tr><tr><td class="paramname">keepsBlockAtTopOfContainingWAP</td><td>Returned kTrue if the top of the keeps block is also the top of the WaxAnchorPt that contains it. If topOfKeepsBlockNotTopOfWAPSet is kFalse, then this value must be kTrue. </td></tr><tr><td class="paramname">keepsBlockHasTopBreak</td><td>Returned kTrue if the top of the keeps block has an effective text break. This will only be interesting to the Text Keeps processing if the keeps block starts at the top of the WaxAnchorPt (so topOfKeepsBlockNotTopOfWAPSet is set to kFalse, and keepsBlockAtTopOfContaining set to kTrue). </td></tr><tr><td class="paramname">keepsBlockDamaged</td><td>Returned kTrue if any of the internal abstracted Keeps range between the LAST multi-piece WaxAnchor and the top of the internal Keeps range has already been damaged. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The TextIndex of the WaxAnchoredPt which controls the top of the keeps block, which will either be THIS WaxAnchorPt or an ealier one if a multi-piece WaxAnchorPt. </dl></div></div><a class="anchor" id="a63e28f161375302c02c4cbcebc22304d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex IWaxAnchorPt::BackupToStartOfKeepsFromTop </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>paraHasKeepAllLines</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>topOfKeepsBlockNotTopOfWAPSet</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>keepsBlockAtTopOfContainingWAP</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>keepsBlockHasTopBreak</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>keepsBlockDamaged</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is used by the Text Keeps processing on a WaxAnchorPt which may or may not have been already damaged either internally or by the WaxLine it is on.<p>When undamaged it will be because it just finished composing the Parcel and this is the first non-first WaxAnchorPt of a multi-piece set and it wants to get the top of the keeps block.<p>Through a previous call to <a class="el" href="class_i_wax_anchor_pt.html#adb5cfd9435bccb6c62391e475db7f069">GetTextKeepsViolation()</a> it knows that this WaxAnchorPt is not the first part of a multi-piece set and the top edge of the WaxAnchorPt wants to be kept with the bottom edge of the WaxAnchorPt composed on the previous WaxLine.<p>When damaged it will be because we have geometry damaged the WaxLine containing this WaxAnchorPt and because we know that it is not the first of a set we want to extend the damage through keeps of the WaxAnchorPt ABOVE this WaxAnchorPt.<p>Either way the callee is asked to start with this keep relationship and backup the keeps relationship chain towards the first WaxAnchorPt in the set.<p>Note that in practice we expect that the returned values will indicate the very top, rather than an internal value, of previous WaxAnchorPt because the WaxAnchorPt is expected to be responsible for internal keeps and the only reason it would create a keeps violation between internal edges is if by doing so it was to leave the Parcel empty.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">paraHasKeepAllLines</td><td>kTrue if the anchoring Paragraph has Keep All Lines Together set. This will be used by the callee so that it will backup to the very top of the multi-WaxAnchorPt set (topOfKeepsBlockNotTopOfWAPSet will be kFalse, keepBlockAtTopContaining will be kTrue) unless the internal object as an effective text break. </td></tr><tr><td class="paramname">topOfKeepsBlockNotTopOfWAPSet</td><td>Returned kTrue if the object can be considered divisible - that is the top of the keeps block beginning at the bottom of the object ends before the top of the object mapped by one or more WaxAnchorPt, even though the top of the object might be in an earlier WaxAnchorPt. kFalse if the entire object can be considered one whole keeps block, even though the top of the object might be in an earlier WaxAnchorPt. This latter is important because it tells the Text Keeps processing system whether it needs to continue the keeps backup using the WaxLine keeps flags on the top WaxAnchorPt. </td></tr><tr><td class="paramname">keepsBlockAtTopOfContainingWAP</td><td>Returned kTrue if the top of the keeps block is also the top of the WaxAnchorPt that contains it. If topOfKeepsBlockNotTopOfWAPSet is kFalse, then this value must be kTrue. </td></tr><tr><td class="paramname">keepsBlockHasTopBreak</td><td>Set to kTrue if the top of the keeps block has an effective text break. This will only be interesting to the Text Keeps processing if the keeps block starts at the top of the WaxAnchorPt (so topOfKeepsBlockNotTopOfWAPSet is set to kFalse, and keepsBlockAtTopOfContaining set to kTrue). </td></tr><tr><td class="paramname">keepsBlockDamaged</td><td>Set to kTrue if any of the internal abstracted Keeps range between the PREVIOUS multi-piece WaxAnchor and the top of the internal Keeps range has already been damaged. NOTE: The WaxAnchorPt COULD already be damaged and this damage flag does NOT apply to that damage. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The TextIndex of the WaxAnchoredPt which controls the top of the keeps block, which will either be THIS WaxAnchorPt or an ealier one if a multi-piece WaxAnchorPt. </dl></div></div><a class="anchor" id="adfb06619b92add045026a809911554bb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::CollectOwnedItems </td><td>(</td><td class="paramtype"><a class="el" href="class_k2_vector.html">OwnedItemDataList</a> *&nbsp;</td><td class="paramname"><em>rList</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the list of owned items associated with this WaxAnchorPt. Although this list is being collect from a composition component, it is NOT assumed that the WaxAnchorPt is fully composed. Those OwnedItems that are known to be part of the composition range because they are part of a Parcel that has an existing span, regardless of damage state, should be returned. Do not return overset. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">resultList</td><td>Append to the list. </td></tr></table></dl></div></div><a class="anchor" id="a4be71afafd048b8ae3d586bf11f4eaab"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::Draw </td><td>(</td><td class="paramtype"><a class="el" href="class_graphics_data.html">GraphicsData</a> *&nbsp;</td><td class="paramname"><em>gd</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>iShapeFlags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Text::DrawPassInfo::Pass&nbsp;</td><td class="paramname"><em>pass</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>xOffset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>yOffset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>areaToDraw</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draw the anchor. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gd</td><td></td></tr><tr><td class="paramname">iShapeFlags</td><td></td></tr><tr><td class="paramname">pass</td><td></td></tr><tr><td class="paramname">xOffset</td><td>The left edge of the Anchor BBox in drawing container coordintes. </td></tr><tr><td class="paramname">yOffset</td><td>The bottom edge of the Anchor BBox in drawing container coordintes. </td></tr><tr><td class="paramname">areaToDraw</td><td></td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_wax_run_text.html">IWaxRunText</a></dl></div></div><a class="anchor" id="a73de11e729c07e44ce43b4773d285ced"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::GetBBox </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>pBBox</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the stroke bounding box in Wax coordinates of the Anchor. The value returned should be the same as returned by Recompose(). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pBBox</td><td></td></tr></table></dl></div></div><a class="anchor" id="adc98d5b5b6da72dd282215e2b171a994"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::GetDrawPassInfo </td><td>(</td><td class="paramtype"><a class="el" href="class_k2_vector.html">Text::DrawPassInfoList</a> *&nbsp;</td><td class="paramname"><em>passList</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the DrawPassInfo for the Anchor. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">passList</td><td></td></tr></table></dl></div></div><a class="anchor" id="affb217e9589832caae329823ff9307e6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::GetInkBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>inkBounds</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the ink bounds in Wax coordinates of the Anchor. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">inkBounds</td><td></td></tr></table></dl></div></div><a class="anchor" id="a3c3211467f25ad377777fe95056d70d4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxAnchorPt::GetIsCompositionExtending </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is called during composition of the WaxAnchorPt when Tiling occurs. Returns kTrue if the WaxAnchorPt is composing the &quot;top&quot; of the WaxAnchorPt, False otherwise. </div></div><a class="anchor" id="a2d9b303100b36ffaa0cd2f4d192319d0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxAnchorPt::GetIsDivisible </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if this WaxAnchorPt could be composed into multiple pieces. This method helps the Text Keeps processing system understand if this WaxAnchorPt is or could be part of a contiguous multi-piece set. <dl class="section return"><dt>Returns<dd>kTrue if this WaxAnchorPt is divisible </dl></div></div><a class="anchor" id="a8e6ebb7194b2094396ae7604cd709e4c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxAnchorPt::GetIsOnlyOrFirstOfASet </td><td>(</td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>pHasTopBreak</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Text Keeps processing understands that WaxAnchorPts may represent a single conceptual object managed by one or more contiguous WaxAnchorPts. This represents a challenge when trying to establish what can be treated as a single WaxLine and what cannot.<p>This method allows the Text Keeps Processing to know if the keeps flags on the WaxLine containing the WaxAnchorPt can used.<p>For middle or last WaxAnchorPts of a set those flags can never be used.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pHasTopBreak</td><td>If method returns kTrue, then this pointer will be set to kTrue if the top of the WaxAnchorPt has an effective text break, kFalse otherwise. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if this WaxAnchorPt is the only WaxAnchorPt, or is the top/first WaxAnchorPt of a multi-piece set, kFalse otherwise. </dl></div></div><a class="anchor" id="a0c781732502d07993574acfec70d97a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxAnchorPt::GetIsParcelPositionDependent </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the WaxAnchorPt contains any content which is dependent on the position of the Parcel relative to the Pasteboard. WaxAnchorPts must return kTrue for this method to guarantee that they will be called via MarkMoveDamage() when the containing Parcel is moved. </div></div><a class="anchor" id="adb5cfd9435bccb6c62391e475db7f069"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxAnchorPt::GetTextKeepsViolation </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>paraHasKeepAllLines</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method will be called by the Parcel Composer for the first WaxLine composed off the end of the Parcel which contains a WaxAnchorPt.<p>The Text Keeps processor will first call <a class="el" href="class_i_wax_anchor_pt.html#a8e6ebb7194b2094396ae7604cd709e4c">GetIsOnlyOrFirstOfASet()</a> and if that returns kFalse, then it knows that the keeps flags on the WaxLine cannot be relied upon and therefore it will call this method.<p>This method should return kTrue if for any reason there is any internal keeps relationship between the top of this WaxAnchorPt and the previous WaxAnchorPt, which will be in the same set.<p>If not, or there is a internal effective keeps break, then this method should return kFalse.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">paraHasKeepAllLines</td><td>kTrue if the anchoring Paragraph has Keep All Lines Together set. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if there is an internal keeps relationship between the top of this Wax WaxAnchorPt and the previous one, which will be in the same set, kFalse otherwise. </dl></div></div><a class="anchor" id="aea3dfd5f310e979110c89d53933e8eb5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IWaxAnchorPt::GetTextSpan </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of characters that are controlled by this Anchor. </div></div><a class="anchor" id="a4317fad8de4f0ac6eab875ca054b24ff"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxAnchorPt::GetTopKeepsContentBottom </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_wax_line.html">IWaxLine</a> *&nbsp;</td><td class="paramname"><em>waxLine</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is called during Parcel composition to determine what the minimum content bottom for the WaxAnchorPt is. When the WaxAnchorPt is part of a keeps block then the previous non-WaxAnchorPt WaxLine wants to be kept with the top of whatever minimum sub-divisible part of the WaxAnchorPt can be composed. It is the responsibility of the WaxAnchorPt to compute this value whenever the components which would affect this value change. In addition, when the WaxAnchorPt grows by the inclusion of additional components the value returned must not change. </div></div><a class="anchor" id="aceaf58e82371942f6966d69c016df607"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxAnchorPt::HitTest </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>waxPt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>nextLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a point in Wax coordinates, return the TextIndex of the closest character/glyph in this WaxAnchorPt. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">waxPt</td><td></td></tr><tr><td class="paramname">nextLine</td><td>The TextIndex of the end of the WaxLine (which is the st art of the next WaxLine </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The TextIndex of the closest character/glyph or kInvalidTextIndex if no hit is made. </dl></div></div><a class="anchor" id="a52b576ee4cb8e940e7f37fa262239150"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::IterateWaxAnchorPointDrawOrder </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xform</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_callback.html">ICallback</a> *&nbsp;</td><td class="paramname"><em>callbackInfo</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>iShapeFlags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_i_parcel_shape.html">IParcelShape</a> calls this method as part of a IShape::IterateDrawOrder() sequence. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xform</td><td></td></tr><tr><td class="paramname">callbackInfo</td><td></td></tr><tr><td class="paramname">iShapeFlags</td><td></td></tr></table></dl></div></div><a class="anchor" id="aea499c905bafc77fd07f2ae7eba51111"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxAnchorPt::MarkCompositionDamage </td><td>(</td><td class="paramtype"><a class="el" href="class_i_wax_line.html">IWaxLine</a> *&nbsp;</td><td class="paramname"><em>waxLine</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>topYIntersect</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The WaxAnchorPt should mark the appropriate damage internally and on its anchoring WaxLine to force recomposition, however this damage should not result in damaging a previous WaxAnchorPt (if it is related to the callee) or a previous Parcel. Furthermore, the callee is not responsible for damaging the containing Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">topYIntersect</td><td>The YPosition, in Wax coordinate system, that the WaxAnchorPt should damage relative to. This value will be less than equal to the WaxLine YPosition but it may be higher than the Line Height of the WaxLine. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the &quot;top&quot; of the WaxAnchorPt was damaged by this call. When this occurs the CompositionIter will mark the WaxLine keeps damaged. </dl></div></div><a class="anchor" id="ac1eaef06347eaf6f1841a795cb0b46eb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxAnchorPt::MarkExtendedDamageFromTextKeeps </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>paraHasKeepAllLines</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Damage for backup damage the top of the keeps block in this WaxAnchorPt. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">paraHasKeepAllLines</td><td>kTrue if the anchoring Paragraph has Keep All Lines Together set. This will be used by the callee so that it will backup to the very top of the multi-WaxAnchorPt set (topOfKeepsBlockNotTopOfWAPSet will be kFalse, keepBlockAtTopContaining will be kTrue) unless the internal object as an effective text break. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if damage was marked, kFalse otherwise. </dl></div></div><a class="anchor" id="a88a2f33479f5bfb39ac952ac92828a0f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::MarkKeepsDamageFromText </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Text Keeps has included the bottom edge of this WaxAnchorPt and the top of the effective Text Keeps block ends in this WaxAnchorPt without including the top edge of this WaxAnchorPt.<p>This later criteria is important because this method will not be called if the containing Paragraph has keep all lines together as that will, if effective, force the entire WaxAnchorPt to be out of the Parcel and that will be handled by the Text Keeps processing without calling this method. </div></div><a class="anchor" id="a86ca8efb65195318cc6c2a07a07697d7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::MarkParcelGridDamage </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The WaxAnchorPt is notified that the Parcel it is composed into has been damaged because one or more Text Alignment Grids have changed. This notification needs to be forwarded to any dependent content which may have been aligned to these grids. </div></div><a class="anchor" id="acd65b928b27a99bd02d6b804736974b3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::MarkParcelMoveDamage </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The WaxAnchorPt is notified that the Parcel it is composed into has been moved. If the WaxAnchorPt manages any StoryThreads then this notification must be passed through to any Parcels associated with this <a class="el" href="class_i_wax_anchor_pt.html">IWaxAnchorPt</a>. Note that the <a class="el" href="class_i_wax_line.html">IWaxLine</a> managed by the <a class="el" href="class_i_wax_anchor_pt.html">IWaxAnchorPt</a> is NOT damaged by the caller and that the OwnedItem API of the <a class="el" href="class_i_wax_anchor_pt.html">IWaxAnchorPt</a> is also notified via the <a class="el" href="class_i_owned_item.html#ae456f0a1dfadd0bef8538b99809d37ab">IOwnedItem::ParcelMoved()</a> method. </div></div><a class="anchor" id="a491c3a62fa8185711d441dd00f7cb06f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::MarkPreviousParcelGridDamage </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The WaxAnchorPt is notified that a Parcel Previous to the Parcel it is composed into has been damaged because one or more Text Alignment Grids have changed. This notification needs to be forwarded to any dependent content which may have been aligned to these grids. </div></div><a class="anchor" id="ad71c02b4eed50eb47e30a4971801d206"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::MarkPreviousParcelMoveDamage </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The WaxAnchorPt is notified that a Parcel Previous to the Parcel containing this WaxAnchorPt has been moved AND the WaxLine containing this WaxAnchorPt is the first WaxLine after the Parcel that moved. If the composition of this WaxAnchorPt is dependent on the Page position of the Parcel then it will need to do the appropriate damage to trigger recomposition. </div></div><a class="anchor" id="a659d5ee08a1cca1c466585c01509f27a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxAnchorPt::Move </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>anchorPtIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_parcel_list.html">IParcelList</a> *&nbsp;</td><td class="paramname"><em>pl</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>parcelKey</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>yPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>yPosDelta</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Similar to Recompose() but instead the WaxAnchor is notified that it is being moved within the same Parcel. This is used during Vertical Justification processing of the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchorPtIndex</td><td></td></tr><tr><td class="paramname">tiler</td><td></td></tr><tr><td class="paramname">parcelKey</td><td></td></tr><tr><td class="paramname">yPosition</td><td></td></tr><tr><td class="paramname">yPosDelta</td><td></td></tr></table></dl></div></div><a class="anchor" id="aff325c5659d8e58e2eca7a7b266ec1c9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxAnchorPt::NotifyComposedPartOfKeepsBlock </td><td>(</td><td class="paramtype"><a class="el" href="class_i_wax_line.html">IWaxLine</a> *&nbsp;</td><td class="paramname"><em>waxLine</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>After recomposing the WaxAnchorPt in the context of a deferred keeps situation - that is waxLinePartOfKeepsBlock was set to kTrue, this method will be called by the Parcel Composer to give the WaxAnchorPt the opportunity to damage the WaxAnchorPt appropriately in order to try pull up content in a later WaxAnchorPt thay may have been pushed there due to the need to compute TopKeepsContentBottom. If the WaxAnchorPt does not have multiple composable pieces or it already has composed more than the minimum required for keeps it is free to do nothing and return kFalse. <dl class="section return"><dt>Returns<dd>kTrue if the WaxAnchorPt damaged the anchoring WaxLine. Note that because this method is called during composition the callee should only damage the anchoring WaxLine and should not damage any other WaxLines or Parcels. </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_wax_anchor_pt.html">IWaxAnchorPt</a><li class="footer">Generated on Sat Sep 22 2018 10:54:33 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
