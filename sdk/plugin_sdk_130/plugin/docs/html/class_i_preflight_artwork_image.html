<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_preflight_artwork_image</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_preflight_artwork_image.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_preflight_artwork_image-members.html">List of all members</a></div><div class="headertitle"><div class="title">IPreflightArtworkImage Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_preflight_artwork_image_8h_source.html">IPreflightArtworkImage.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IPreflightArtworkImage:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_preflight_artwork_image.png" usemap="#IPreflightArtworkImage_map" /><map id="IPreflightArtworkImage_map" name="IPreflightArtworkImage_map"><area alt="IPMUnknown" coords="0,0,139,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:af5e105d9bf79d6aa4458cb3241e5cd4e"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="class_i_preflight_artwork_image.html#af5e105d9bf79d6aa4458cb3241e5cd4eac61bb02b6bb254a3d0951ae18c7b2e73">kRF_Default</a> = 0, <a class="el" href="class_i_preflight_artwork_image.html#af5e105d9bf79d6aa4458cb3241e5cd4eaa799c6cf7f87f4f7eb3d6d94e5d4f014">kRF_Alpha</a> = (1L&lt;&lt;0) }</td></tr><tr class="separator:af5e105d9bf79d6aa4458cb3241e5cd4e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a90b16b2e5d8de11811e3480f6875d001"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IPREFLIGHTARTWORKIMAGE }</td></tr><tr class="separator:a90b16b2e5d8de11811e3480f6875d001"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:ac3bc0773daa9a0b99cbdff1a3c63711b"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="struct_int32_rect.html">Int32Rect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#ac3bc0773daa9a0b99cbdff1a3c63711b">GetBounds</a> () const =0</td></tr><tr class="separator:ac3bc0773daa9a0b99cbdff1a3c63711b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a36dce6e0367610b853ed3cf3f1d06d1f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#a36dce6e0367610b853ed3cf3f1d06d1f">QueryColorSpace</a> () const =0</td></tr><tr class="separator:a36dce6e0367610b853ed3cf3f1d06d1f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a73c12a69c10055b09ad8f918d99a8d59"><td align="right" class="memItemLeft" valign="top">virtual const uint8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#a73c12a69c10055b09ad8f918d99a8d59">GetPixelPtr</a> (int32 channel, int32 x, int32 y) const =0</td></tr><tr class="separator:a73c12a69c10055b09ad8f918d99a8d59"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aadd7ab7798bd061aa7630b9a4f06daef"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#aadd7ab7798bd061aa7630b9a4f06daef">GetPixelIncrement</a> (int32 channel) const =0</td></tr><tr class="separator:aadd7ab7798bd061aa7630b9a4f06daef"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7867ffcff08a31c2e05207941b067550"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#a7867ffcff08a31c2e05207941b067550">GetRowIncrement</a> (int32 channel) const =0</td></tr><tr class="separator:a7867ffcff08a31c2e05207941b067550"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af24db8bdf773a7c03e747ea32454e1e9"><td align="right" class="memItemLeft" valign="top">virtual const uint8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#af24db8bdf773a7c03e747ea32454e1e9">QueryChunkyScanline</a> (int32 y) const =0</td></tr><tr class="separator:af24db8bdf773a7c03e747ea32454e1e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6220956368245b5eca90b7f151a5cf97"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#a6220956368245b5eca90b7f151a5cf97">ReleaseChunkyScanline</a> (const uint8 *p) const =0</td></tr><tr class="separator:a6220956368245b5eca90b7f151a5cf97"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aecec0c88f73e1be14b2b8502ea5c4482"><td align="right" class="memItemLeft" valign="top">virtual const int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#aecec0c88f73e1be14b2b8502ea5c4482">GetChunkyPixelSize</a> () const =0</td></tr><tr class="separator:aecec0c88f73e1be14b2b8502ea5c4482"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae4ca032a83550d7e0e3a32b686116f63"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#ae4ca032a83550d7e0e3a32b686116f63">SetColorSpace</a> (const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> &gt; &amp;iCS)=0</td></tr><tr class="separator:ae4ca032a83550d7e0e3a32b686116f63"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adb96063cf6ddf572cf9640e9c94ef8d8"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#adb96063cf6ddf572cf9640e9c94ef8d8">SetBounds</a> (const <a class="el" href="struct_int32_rect.html">Int32Rect</a> &amp;b)=0</td></tr><tr class="separator:adb96063cf6ddf572cf9640e9c94ef8d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c294a87c27388765a580763dbabd115"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#a9c294a87c27388765a580763dbabd115">SetSharedBuffer</a> (void *buf)=0</td></tr><tr class="separator:a9c294a87c27388765a580763dbabd115"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3640d4a28cb4861f00285b9ff505596a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#a3640d4a28cb4861f00285b9ff505596a">SetPixelIncrement</a> (int32 inc)=0</td></tr><tr class="separator:a3640d4a28cb4861f00285b9ff505596a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa48b242a90e75a1a77768e8502bab428"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_image.html#aa48b242a90e75a1a77768e8502bab428">SetRowIncrement</a> (int32 inc)=0</td></tr><tr class="separator:aa48b242a90e75a1a77768e8502bab428"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>This interface provides access to image data provided from mark or group interfaces. In particular, <a class="el" href="class_i_preflight_artwork_mark_info.html#ab17aa3762f5f9b1fee3c0edba06bdd12">IPreflightArtworkMarkInfo::Rasterize()</a>. This interface sits on a boss pretty much all by itself. Typically it&#39;s used to look at a raster version of some object when inspecting the attributes are not sufficient.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_artwork_mark_info.html">IPreflightArtworkMarkInfo</a></dl></div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="af5e105d9bf79d6aa4458cb3241e5cd4e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">anonymous enum</td></tr></table></div><div class="memdoc"><table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af5e105d9bf79d6aa4458cb3241e5cd4eac61bb02b6bb254a3d0951ae18c7b2e73"></a>kRF_Default</em>&nbsp;</td><td class="fielddoc"><p>The default rasterization set: no alpha </td></tr><tr><td class="fieldname"><em><a class="anchor" id="af5e105d9bf79d6aa4458cb3241e5cd4eaa799c6cf7f87f4f7eb3d6d94e5d4f014"></a>kRF_Alpha</em>&nbsp;</td><td class="fielddoc"><p>Include an alpha channel in the rasterized image. </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="ac3bc0773daa9a0b99cbdff1a3c63711b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="struct_int32_rect.html">Int32Rect</a> IPreflightArtworkImage::GetBounds </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the pixel bounds of the image. <dl class="section return"><dt>Returns<dd>The pixel bounds of the image. </dl></div></div><a class="anchor" id="aecec0c88f73e1be14b2b8502ea5c4482"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const int32 IPreflightArtworkImage::GetChunkyPixelSize </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Obtains the byte size of each pixel; ie the increment by which you should increase the pointer to get to the next pixel.<dl class="section return"><dt>Returns<dd>The number of bytes between pixel origins. </dl></div></div><a class="anchor" id="aadd7ab7798bd061aa7630b9a4f06daef"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IPreflightArtworkImage::GetPixelIncrement </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>channel</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the number of bytes between pixels (in a given row). This along with <a class="el" href="class_i_preflight_artwork_image.html#a73c12a69c10055b09ad8f918d99a8d59">GetPixelPtr()</a> allows you to walk the pixel data quickly, but you need to be careful to use it properly. In particular you need to use <a class="el" href="class_i_preflight_artwork_image.html#aadd7ab7798bd061aa7630b9a4f06daef">GetPixelIncrement()</a> to know how far to move in a given row and <a class="el" href="class_i_preflight_artwork_image.html#a7867ffcff08a31c2e05207941b067550">GetRowIncrement()</a> to know how to move to the same pixel in the next/prev row.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>The channel for which you want the increment. In some cases (eg separate alpha) the channel data may be in a completely separate piece of memory with a different row/pixel increment from other channels. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The number of bytes to add to a pixel pointer to get to the next (x+1) pixel in the same row. </dl></div></div><a class="anchor" id="a73c12a69c10055b09ad8f918d99a8d59"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const uint8* IPreflightArtworkImage::GetPixelPtr </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>channel</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a pointer to the image data for a particular pixel.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">channel</td><td>IN Which channel you want a pointer to. </td></tr><tr><td class="paramname">x</td><td>IN The x coordinate in <a class="el" href="class_i_preflight_artwork_image.html#ac3bc0773daa9a0b99cbdff1a3c63711b">GetBounds()</a> space (note that xMin, xMax can be negative) </td></tr><tr><td class="paramname">y</td><td>IN The y coordinate in <a class="el" href="class_i_preflight_artwork_image.html#ac3bc0773daa9a0b99cbdff1a3c63711b">GetBounds()</a> space (note that yMin, yMax can be negative) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A pointer to the pixel/channel, or nil if any of the parameters are out of bounds. </dl></div></div><a class="anchor" id="a7867ffcff08a31c2e05207941b067550"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IPreflightArtworkImage::GetRowIncrement </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>channel</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the number of bytes between rows. This along with <a class="el" href="class_i_preflight_artwork_image.html#a73c12a69c10055b09ad8f918d99a8d59">GetPixelPtr()</a> and <a class="el" href="class_i_preflight_artwork_image.html#aadd7ab7798bd061aa7630b9a4f06daef">GetPixelIncrement()</a> allows you to walk the pixel data quickly, but you need to be careful to use it properly. In particular you need to use <a class="el" href="class_i_preflight_artwork_image.html#aadd7ab7798bd061aa7630b9a4f06daef">GetPixelIncrement()</a> to know how far to move in a given row and <a class="el" href="class_i_preflight_artwork_image.html#a7867ffcff08a31c2e05207941b067550">GetRowIncrement()</a> to know how to move to the same pixel in the next/prev row.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>The channel for which you want the increment. In some cases (eg separate alpha) the channel data may be in a completely separate piece of memory with a different row/pixel increment from other channels. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The number of bytes to add to a pixel pointer to get to the same pixel in the next (y+1) row. </dl></div></div><a class="anchor" id="af24db8bdf773a7c03e747ea32454e1e9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const uint8* IPreflightArtworkImage::QueryChunkyScanline </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>y</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Alternative pixel interface that provides chunky pixels. If you want to look at all of the channels of the data together, chunky is generally easiest, but the generic accessors above support chunky, planar, or a combination, so it&#39;s hard to make a compact and efficient algorithm (the general case involves incrementing N pointers for each pixel). The chunky accessors will rearrange pixel data on a scanline basis <em>if necessary</em> in order to provide chunky data. If the data is already chunky then this is a very fast operation; if it&#39;s not, it&#39;s going to be as least as fast as any chunkifier you would write.<p>This method obtains a pointer to chunky data for the specified scanline. (And only that scanline; you can&#39;t generally go beyond or before this in order to get next/prev rows.)<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">y</td><td>IN The Y coordinate of the scanline in which you&#39;re interested. Must be within the bounds (</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_artwork_image.html#ac3bc0773daa9a0b99cbdff1a3c63711b">GetBounds</a>). </dl><dl class="section return"><dt>Returns<dd>A pointer to the chunky scanline data. You need to release this when you&#39;re done via</dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_artwork_image.html#a6220956368245b5eca90b7f151a5cf97">ReleaseChunkyScanline</a>. </dl></div></div><a class="anchor" id="a36dce6e0367610b853ed3cf3f1d06d1f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a>* IPreflightArtworkImage::QueryColorSpace </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the colorspace information. You&#39;ll need this to get most of the stats about the space, including whether it has alpha, how many channels, which channel is which, etc.<dl class="section return"><dt>Returns<dd>A refcounted colorspace info interface. </dl></div></div><a class="anchor" id="a6220956368245b5eca90b7f151a5cf97"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkImage::ReleaseChunkyScanline </td><td>(</td><td class="paramtype">const uint8 *&nbsp;</td><td class="paramname"><em>p</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Releases the scanline reserved by QueryChunkyScanline.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>IN The scanline you&#39;re releasing. After this you should not attempt to access it. </td></tr></table></dl></div></div><a class="anchor" id="adb96063cf6ddf572cf9640e9c94ef8d8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkImage::SetBounds </td><td>(</td><td class="paramtype">const <a class="el" href="struct_int32_rect.html">Int32Rect</a> &amp;&nbsp;</td><td class="paramname"><em>b</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the bounds. Internal use only. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">b</td><td>IN The bounds. </td></tr></table></dl></div></div><a class="anchor" id="ae4ca032a83550d7e0e3a32b686116f63"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkImage::SetColorSpace </td><td>(</td><td class="paramtype">const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>iCS</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the colorspace. Internal use only. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iCS</td><td>IN The colorspace. </td></tr></table></dl></div></div><a class="anchor" id="a3640d4a28cb4861f00285b9ff505596a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkImage::SetPixelIncrement </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>inc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the pixel increment. Internal use only. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">inc</td><td>IN The increment. </td></tr></table></dl></div></div><a class="anchor" id="aa48b242a90e75a1a77768e8502bab428"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkImage::SetRowIncrement </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>inc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the row increment. Internal use only. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">inc</td><td>IN The increment. </td></tr></table></dl></div></div><a class="anchor" id="a9c294a87c27388765a580763dbabd115"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkImage::SetSharedBuffer </td><td>(</td><td class="paramtype">void *&nbsp;</td><td class="paramname"><em>buf</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the shared buffer. Internal use only. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">buf</td><td>IN The buffer; this is an opaque type, not a memory buffer. </td></tr></table></dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_preflight_artwork_image.html">IPreflightArtworkImage</a><li class="footer">Generated on Sat Sep 22 2018 10:54:24 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
