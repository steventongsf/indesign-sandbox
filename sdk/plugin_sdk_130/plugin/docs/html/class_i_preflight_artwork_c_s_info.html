<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_preflight_artwork_c_s_info</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_preflight_artwork_c_s_info.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_preflight_artwork_c_s_info-members.html">List of all members</a></div><div class="headertitle"><div class="title">IPreflightArtworkCSInfo Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_preflight_artwork_c_s_info_8h_source.html">IPreflightArtworkCSInfo.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IPreflightArtworkCSInfo:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_preflight_artwork_c_s_info.png" usemap="#IPreflightArtworkCSInfo_map" /><map id="IPreflightArtworkCSInfo_map" name="IPreflightArtworkCSInfo_map"><area alt="IPMUnknown" coords="0,0,144,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:aaa5f400606aa48a5ad89ac697039cb08"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IPREFLIGHTARTWORKCSINFO }</td></tr><tr class="separator:aaa5f400606aa48a5ad89ac697039cb08"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aba50158312405b3235980e936ee52aec"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#aba50158312405b3235980e936ee52aec">Type</a> { <br /> &nbsp;&nbsp;<b>kCS_Invalid</b>, <b>kCS_Other</b>, <b>kCS_Gray</b>, <b>kCS_RGB</b>, <br /> &nbsp;&nbsp;<b>kCS_CMYK</b>, <b>kCS_LAB</b>, <a class="el" href="class_i_preflight_artwork_c_s_info.html#aba50158312405b3235980e936ee52aeca870cc5283de81021e34aab3a52060fa0">kCS_NChannel</a>, <a class="el" href="class_i_preflight_artwork_c_s_info.html#aba50158312405b3235980e936ee52aeca2bc8ef8205a36a6e2275257410c3c561">kCS_DeviceN</a>, <br /> &nbsp;&nbsp;<a class="el" href="class_i_preflight_artwork_c_s_info.html#aba50158312405b3235980e936ee52aeca802316522c96636f929dfefde159c754">kCS_Indexed</a>, <a class="el" href="class_i_preflight_artwork_c_s_info.html#aba50158312405b3235980e936ee52aeca8303c2ba69df55910f628ab5ec66f80c">kCS_Pattern</a><br /> }</td></tr><tr class="separator:aba50158312405b3235980e936ee52aec"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7d1298fa5ec053548278f74f064faa95"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95">ChannelType</a> { <br /> &nbsp;&nbsp;<a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95a5f50673bc2b3de5e256d2ad0c9e69582">kChannelTypeProcess</a>, <a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95a76178c5e2da2a3b32bb6f10a47d7d8e6">kChannelTypeSpot</a>, <a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95aaee63804e35906ed7c8d021c65ef181b">kChannelTypeRegistration</a>, <a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95acfa675df26a7d3430c9c5c8fab5b9869">kChannelTypeCMYKInDeviceN</a>, <br /> &nbsp;&nbsp;<a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95af77cdf0bc7f1dd1fe83119144bdc9561">kChannelTypeAlpha</a>, <a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95ac58591bcaa7ab043fb99833396e2a7b6">kChannelTypeInvalid</a><br /> }</td></tr><tr class="separator:a7d1298fa5ec053548278f74f064faa95"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a655ec12c9967775f35041413a94edcd6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a655ec12c9967775f35041413a94edcd6">Initialize</a> (CAGMColorSpace &amp;cs)=0</td></tr><tr class="separator:a655ec12c9967775f35041413a94edcd6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a401a3dce43c10513ced6b0bfe9a49bab"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html#aba50158312405b3235980e936ee52aec">Type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a401a3dce43c10513ced6b0bfe9a49bab">GetType</a> () const =0</td></tr><tr class="separator:a401a3dce43c10513ced6b0bfe9a49bab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5fa9b443e1e8f15e37e5a359d98a6270"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a5fa9b443e1e8f15e37e5a359d98a6270">QueryBase</a> () const =0</td></tr><tr class="separator:a5fa9b443e1e8f15e37e5a359d98a6270"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6fb728b5b4ca0deaeab236eaf5be472f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a6fb728b5b4ca0deaeab236eaf5be472f">QueryProcess</a> () const =0</td></tr><tr class="separator:a6fb728b5b4ca0deaeab236eaf5be472f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae9b87987c9871af88ab0fc3382bfaf84"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#ae9b87987c9871af88ab0fc3382bfaf84">QueryCSWithAlphaState</a> (bool alpha) const =0</td></tr><tr class="separator:ae9b87987c9871af88ab0fc3382bfaf84"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac2ce70e4323dc406e90207352443ad99"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#ac2ce70e4323dc406e90207352443ad99">QueryCSRasterPortSafe</a> (bool alpha) const =0</td></tr><tr class="separator:ac2ce70e4323dc406e90207352443ad99"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6e6183cfe5b6a9d97bfa4d9972b9ad61"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a6e6183cfe5b6a9d97bfa4d9972b9ad61">GetNumChannels</a> () const =0</td></tr><tr class="separator:a6e6183cfe5b6a9d97bfa4d9972b9ad61"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab7cb27fdeb22d9edc7bbe17afbf40a7b"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#ab7cb27fdeb22d9edc7bbe17afbf40a7b">GetColorChannelsMap</a> () const =0</td></tr><tr class="separator:ab7cb27fdeb22d9edc7bbe17afbf40a7b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3705c765d3d13a0d3b600879c9c97532"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a3705c765d3d13a0d3b600879c9c97532">GetProcessChannelsMap</a> () const =0</td></tr><tr class="separator:a3705c765d3d13a0d3b600879c9c97532"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aad23af6284183f0163f860828ba5a2ef"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#aad23af6284183f0163f860828ba5a2ef">GetCMYKChannelsMap</a> () const =0</td></tr><tr class="separator:aad23af6284183f0163f860828ba5a2ef"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a13faeba38a4374ceb26382b7a01068f1"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a13faeba38a4374ceb26382b7a01068f1">GetSpotChannelsMap</a> () const =0</td></tr><tr class="separator:a13faeba38a4374ceb26382b7a01068f1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3eb8deb3d7627810fad8a1db0409a3d0"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a3eb8deb3d7627810fad8a1db0409a3d0">GetRegistrationChannelsMap</a> () const =0</td></tr><tr class="separator:a3eb8deb3d7627810fad8a1db0409a3d0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b0f7660961e1f112b2ebd63913548cd"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95">ChannelType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a1b0f7660961e1f112b2ebd63913548cd">GetNthChannelInfo</a> (uint32 n, int32 *index=nil) const =0</td></tr><tr class="separator:a1b0f7660961e1f112b2ebd63913548cd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a08d19abd08b25dfe6508356340d4cd52"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_wide_string.html">WideString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a08d19abd08b25dfe6508356340d4cd52">GetNthChannelName</a> (uint32 n) const =0</td></tr><tr class="separator:a08d19abd08b25dfe6508356340d4cd52"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aec2a7f6c3fad8b6c7983bcffadb32ae8"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#aec2a7f6c3fad8b6c7983bcffadb32ae8">GetIndexedNumEntries</a> () const =0</td></tr><tr class="separator:aec2a7f6c3fad8b6c7983bcffadb32ae8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad5b26af00c71c6d72cca41f3271b9578"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#ad5b26af00c71c6d72cca41f3271b9578">GetIndexedNthEntry</a> (int32 n, <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_p_m_real.html">PMReal</a> &gt; &amp;vals) const =0</td></tr><tr class="separator:ad5b26af00c71c6d72cca41f3271b9578"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a771e2aa3d2748ad439bf7c3741c02ad5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_artwork_c_s_info.html#a771e2aa3d2748ad439bf7c3741c02ad5">GetColorSpace</a> (CAGMColorSpace &amp;spc) const =0</td></tr><tr class="separator:a771e2aa3d2748ad439bf7c3741c02ad5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>This interface is of use to preflight rule implementations; ie if you&#39;re writing a preflight rule, you may need the data exposed in this interface. Otherwise you&#39;re not going to need this.<p>Furthermore, this interface is related to rules that inspect artwork. Artwork is the term used to refer to marking operations that are captured by the preflight engine and handed to rules for further inspection. To get to this information you ask to visit objects of preflight class kPreflightOM_ArtworkMark in your <a class="el" href="class_i_preflight_rule_visitor.html#ac5832846bd627f37ce595c14ca7285fd">IPreflightRuleVisitor::GetClassesToVisit()</a> implementation.<p>The group of artwork interfaces are nonpersistent interfaces that live on typically very short lived bosses. The root object, kPreflightAtworkMarkBoss, is created by a call to <a class="el" href="class_i_preflight_object_model.html#a235fceb0a4338a8fbf680ae1c6b3601d">IPreflightObjectModel::QueryObject()</a>, typically on your behalf via <a class="el" href="class_i_preflight_visit_info.html#aeb297c3bb6c47af1aaf696fe4c7f9c88">IPreflightVisitInfo::QueryObject()</a>, in your implementation of <a class="el" href="class_i_preflight_rule_visitor.html">IPreflightRuleVisitor</a>. From that root object you can query to get other kinds of objects.<p>Here&#39;s the hierarchy of interfaces that live on an artwork marking boss, or are served up by those interfaces.<p>kPreflightAtworkMarkBoss <a class="el" href="class_i_preflight_object.html">IPreflightObject</a> <a class="el" href="class_i_preflight_artwork_mark_info.html">IPreflightArtworkMarkInfo</a> <a class="el" href="class_i_preflight_artwork_paint_info.html">IPreflightArtworkPaintInfo</a> (via QueryColorPaintInfo, QueryAlphaPaintInfo) <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> (via QueryColorSpace) <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> (via QueryBase, QueryProcess, etc) <a class="el" href="class_i_preflight_artwork_image.html">IPreflightArtworkImage</a> (via Rasterize()) <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a> (via QueryColorSpace) <a class="el" href="class_i_preflight_artwork_shape_context.html">IPreflightArtworkShapeContext</a> <a class="el" href="class_i_preflight_artwork_text_context.html">IPreflightArtworkTextContext</a> <a class="el" href="class_i_preflight_artwork_o_p_i_context.html">IPreflightArtworkOPIContext</a> IPreflightArtworkOPI </div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a7d1298fa5ec053548278f74f064faa95"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95">IPreflightArtworkCSInfo::ChannelType</a></td></tr></table></div><div class="memdoc"><p>The categories in which a given channel corresponds. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7d1298fa5ec053548278f74f064faa95a5f50673bc2b3de5e256d2ad0c9e69582"></a>kChannelTypeProcess</em>&nbsp;</td><td class="fielddoc"><p>A process channel in a fully specified process space (or NChannel space). </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a7d1298fa5ec053548278f74f064faa95a76178c5e2da2a3b32bb6f10a47d7d8e6"></a>kChannelTypeSpot</em>&nbsp;</td><td class="fielddoc"><p>A spot channel (not process or CMYK individual channel). </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a7d1298fa5ec053548278f74f064faa95aaee63804e35906ed7c8d021c65ef181b"></a>kChannelTypeRegistration</em>&nbsp;</td><td class="fielddoc"><p>Registration (ie separation all) </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a7d1298fa5ec053548278f74f064faa95acfa675df26a7d3430c9c5c8fab5b9869"></a>kChannelTypeCMYKInDeviceN</em>&nbsp;</td><td class="fielddoc"><p>An individual CMYK channel floating in a DeviceN space. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a7d1298fa5ec053548278f74f064faa95af77cdf0bc7f1dd1fe83119144bdc9561"></a>kChannelTypeAlpha</em>&nbsp;</td><td class="fielddoc"><p>The alpha channel. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a7d1298fa5ec053548278f74f064faa95ac58591bcaa7ab043fb99833396e2a7b6"></a>kChannelTypeInvalid</em>&nbsp;</td><td class="fielddoc"><p>This can happen in some DeviceN cases such as [none] channels. </td></tr></table></div></div><a class="anchor" id="aba50158312405b3235980e936ee52aec"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_preflight_artwork_c_s_info.html#aba50158312405b3235980e936ee52aec">IPreflightArtworkCSInfo::Type</a></td></tr></table></div><div class="memdoc"><p>Basic Type. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aba50158312405b3235980e936ee52aeca870cc5283de81021e34aab3a52060fa0"></a>kCS_NChannel</em>&nbsp;</td><td class="fielddoc"><p>NChannel is a process space combined with spots. Use QueryBase to access the base process space. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aba50158312405b3235980e936ee52aeca2bc8ef8205a36a6e2275257410c3c561"></a>kCS_DeviceN</em>&nbsp;</td><td class="fielddoc"><p>General DeviceN, meaning an arbitrary combination of spots and possibly individual CMYK inks. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aba50158312405b3235980e936ee52aeca802316522c96636f929dfefde159c754"></a>kCS_Indexed</em>&nbsp;</td><td class="fielddoc"><p>An indexed (single channel) space which points to an array of values in another colorspace. Use <a class="el" href="class_i_preflight_artwork_c_s_info.html#a5fa9b443e1e8f15e37e5a359d98a6270">QueryBase()</a> to obtain information about the underlying space. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aba50158312405b3235980e936ee52aeca8303c2ba69df55910f628ab5ec66f80c"></a>kCS_Pattern</em>&nbsp;</td><td class="fielddoc"><p>A pattern, which is a wrapped-up bit of artwork which itself may have different colorspaces and so on. This is generally opaque; none of the methods below will do much. However, patterns are auto-expanded into artwork so you can ignore this marking operation if you like and wait for the child artwork to arrive later. </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="aad23af6284183f0163f860828ba5a2ef"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt;int32&gt;&amp; IPreflightArtworkCSInfo::GetCMYKChannelsMap </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the map of the channel indices of the CMYK channels. The resulting array will have four color values corresponding to cyan, magenta, yellow, and black. A value of -1 indicates that there is no corresponding channel; otherwise it is the index of the corresponding channel for that colorant.<dl class="section return"><dt>Returns<dd>The vector containing 4 channel indices of CMYK channels; some entries may be -1 if there is no mapping for that CMYK channel. Note that this is a const reference for maximum performance. Be careful of the scope; if you need to hold onto it for a while, be sure to assign it to a properly scoped variable. </dl></div></div><a class="anchor" id="ab7cb27fdeb22d9edc7bbe17afbf40a7b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt;int32&gt;&amp; IPreflightArtworkCSInfo::GetColorChannelsMap </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the alpha channel index, if there is one. <dl class="section return"><dt>Returns<dd>The index of the alpha channel, or -1 if there is no alpha channel.Get the map for the color channels &ndash; that is all the channels <em>except</em> the alpha channel, if there is one.<dd> The vector containing channel indices of color channels. </dl></div></div><a class="anchor" id="a771e2aa3d2748ad439bf7c3741c02ad5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkCSInfo::GetColorSpace </td><td>(</td><td class="paramtype">CAGMColorSpace &amp;&nbsp;</td><td class="paramname"><em>spc</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the internal/private CAGMColorSpace. This is for internal use only. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spc</td><td>OUT The smart pointer to fill with the colorspace. </td></tr></table></dl></div></div><a class="anchor" id="ad5b26af00c71c6d72cca41f3271b9578"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkCSInfo::GetIndexedNthEntry </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_p_m_real.html">PMReal</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>vals</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the Nth index colors. Note that <a class="el" href="class_i_preflight_artwork_c_s_info.html#a5fa9b443e1e8f15e37e5a359d98a6270">QueryBase()</a> will give you the space you need to interpret the array.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>IN The index of the entry you want. </td></tr><tr><td class="paramname">vals</td><td>OUT Receives the array of color values. </td></tr></table></dl></div></div><a class="anchor" id="aec2a7f6c3fad8b6c7983bcffadb32ae8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IPreflightArtworkCSInfo::GetIndexedNumEntries </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the number of entries in an indexed color type space. <dl class="section return"><dt>Returns<dd>The number of entries, or 0 if it&#39;s not an indexed space. </dl></div></div><a class="anchor" id="a1b0f7660961e1f112b2ebd63913548cd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html#a7d1298fa5ec053548278f74f064faa95">ChannelType</a> IPreflightArtworkCSInfo::GetNthChannelInfo </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>n</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>index</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get information on a particular channel.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>The (0 based) index of the channel you want to examine. </td></tr><tr><td class="paramname">index</td><td>If not nil, receives the corresponding index based on the returned type. For kChannelTypeProcess, receives the index into the process space (eg for RGB, 1 = Green). For kChannelTypeCMYKInDeviceN, the index is the CMYK index. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The channel type. </dl></div></div><a class="anchor" id="a08d19abd08b25dfe6508356340d4cd52"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_wide_string.html">WideString</a> IPreflightArtworkCSInfo::GetNthChannelName </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For DeviceN colorspaces, returns the name of the colorant. <dl class="section note"><dt>Note<dd>Applies only for GetColorSpaceType() == kPaintCS_DeviceN. </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>The (0 based) index of the channel you want to examine. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The name of the colorant. </dl></div></div><a class="anchor" id="a6e6183cfe5b6a9d97bfa4d9972b9ad61"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IPreflightArtworkCSInfo::GetNumChannels </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the total number of channels (color + alpha). For information regarding subsets, eg the channels, or spot channels: <dl class="section see"><dt>See Also<dd></dl><dl class="section return"><dt>Returns<dd>The number of channels in the paint operation. </dl></div></div><a class="anchor" id="a3705c765d3d13a0d3b600879c9c97532"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt;int32&gt;&amp; IPreflightArtworkCSInfo::GetProcessChannelsMap </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the map for the process channels. This works on process colorspaces and NChannel colorspaces. The map will have the same number of channels as the process (or base process, in the case of NChannel) space. Each entry in the map is the channel index of the corresponding process space. For example for RGB+Spot NChannel, map[0] gives you the channel number corresponding to the Red channel. If the colorspace is ARGB then this would be 1.<dl class="section return"><dt>Returns<dd>The vector containing channel indices of process channels. Note that this is a const reference for maximum performance. Be careful of the scope; if you need to hold onto it for a while, be sure to assign it to a properly scoped variable. </dl></div></div><a class="anchor" id="a3eb8deb3d7627810fad8a1db0409a3d0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt;int32&gt;&amp; IPreflightArtworkCSInfo::GetRegistrationChannelsMap </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the map for the registration channel. This will be of size zero if there is no registration channel, else of size 1 with the single element being the channel index of the registration data.<dl class="section return"><dt>Returns<dd>The vector containing channel indices of spot channels. Note that this is a const reference for maximum performance. Be careful of the scope; if you need to hold onto it for a while, be sure to assign it to a properly scoped variable. </dl></div></div><a class="anchor" id="a13faeba38a4374ceb26382b7a01068f1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt;int32&gt;&amp; IPreflightArtworkCSInfo::GetSpotChannelsMap </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the map for the spot channels &ndash; that is, the channels in the colorspace that correspond to non-process channels. This does <em>not</em> include the CMYK channels if any; nor does it include a registration channel.<dl class="section return"><dt>Returns<dd>The vector containing channel indices of spot channels. Note that this is a const reference for maximum performance. Be careful of the scope; if you need to hold onto it for a while, be sure to assign it to a properly scoped variable. </dl></div></div><a class="anchor" id="a401a3dce43c10513ced6b0bfe9a49bab"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html#aba50158312405b3235980e936ee52aec">Type</a> IPreflightArtworkCSInfo::GetType </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the colorspace type, if applicable.<dl class="section return"><dt>Returns<dd>The colorspace type. </dl></div></div><a class="anchor" id="a655ec12c9967775f35041413a94edcd6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightArtworkCSInfo::Initialize </td><td>(</td><td class="paramtype">CAGMColorSpace &amp;&nbsp;</td><td class="paramname"><em>cs</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is used to initialize the interface. This takes an opaque type, so only InDesign internal code can call or implement this method.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cs</td><td>IN The opaque colorspace object that this interface gives you information about. </td></tr></table></dl></div></div><a class="anchor" id="a5fa9b443e1e8f15e37e5a359d98a6270"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a>* IPreflightArtworkCSInfo::QueryBase </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For hierarchical types, return the underlying, or base, type. For Indexed, returns the colorspace in which the index entries are stored (including NChannel). For NChannel, returns the process colorspace on which the NChannel is based. For all other types, returns nil.<dl class="section return"><dt>Returns<dd>A refcounted CSInfo or nil if there is no base type. </dl></div></div><a class="anchor" id="ac2ce70e4323dc406e90207352443ad99"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a>* IPreflightArtworkCSInfo::QueryCSRasterPortSafe </td><td>(</td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>alpha</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a colorspace that&#39;s raster port safe. AGM doesn&#39;t support DeviceN or separation images, for example, so these are promoted to full NChannel. Indexed colorspaces use their base colorspace (which is then checked again for safe promotion).<p>If the colorspace is already safe (and with the same alpha), returns a refcounted same-interface pointer.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">alpha</td><td>The desired alpha state of the resulting colorspace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted CSInfo or nil if there is no way to make this colorspace raster safe. Examples of the latter are pattern, invalid, kOther. </dl></div></div><a class="anchor" id="ae9b87987c9871af88ab0fc3382bfaf84"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a>* IPreflightArtworkCSInfo::QueryCSWithAlphaState </td><td>(</td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>alpha</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a colorspace with specified alpha state. If the alpha state already matches the current alpha state, simply returns a refcounted pointer to this colorspace. Otherwise it creates a new colorspace with the specified alpha state and returns that.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">alpha</td><td>The desired alpha state of the resulting colorspace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted CSInfo or nil if an error occurs. </dl></div></div><a class="anchor" id="a6fb728b5b4ca0deaeab236eaf5be472f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a>* IPreflightArtworkCSInfo::QueryProcess </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>If there&#39;s a process space in this or a child space, finds it and returns it. For simple process spaces, returns the same space. (But still refcounted.) For Indexed, recursively checks the base colorspace. For NChannel, returns the process colorspace on which the NChannel is based. If there is no base process space anywhere (for example, DeviceN), returns nil.<dl class="section return"><dt>Returns<dd>A refcounted CSInfo or nil if there is no base process type. </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_preflight_artwork_c_s_info.html">IPreflightArtworkCSInfo</a><li class="footer">Generated on Sat Sep 22 2018 10:54:24 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
