<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_text_parcel_list</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_text_parcel_list.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#nested-classes">Classes</a> | <a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_text_parcel_list-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITextParcelList Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><div class="dynheader"> Inheritance diagram for ITextParcelList:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_text_parcel_list.png" usemap="#ITextParcelList_map" /><map id="ITextParcelList_map" name="ITextParcelList_map"><area alt="IPMUnknown" coords="0,0,94,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> Classes</h2></td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_1_1const__iterator.html">const_iterator</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list_1_1const__reverse__iterator.html">const_reverse_iterator</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a0a07baae38fb5df4acbbdea9e89d9714"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITEXTPARCELLIST }</td></tr><tr class="separator:a0a07baae38fb5df4acbbdea9e89d9714"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afb071c4fed76972d5ee4b266cec3960a"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960a">RecomposeResult</a> { <br /> &nbsp;&nbsp;<a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960aa36c7f96a6565fec5c870ff16d60f4fb1">kRR_NothingToCompose</a>, <a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960aab89804c0c694e6e21fa02cd4b64d4158">kRR_DamagedBackParcel</a>, <a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960aafd079c9ca14d20da49fadbcc2baa2f83">kRR_Interrupted</a>, <a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960aaca21cfaf6408228ee05062bb82494df3">kRR_ComposedUpTo</a>, <br /> &nbsp;&nbsp;<a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960aaf6d43d392463c9de541a493f1a0d12f9">kRR_FullyComposed</a><br /> }</td></tr><tr class="separator:afb071c4fed76972d5ee4b266cec3960a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad869e1178e7947d152232a6b134fbbc0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad869e1178e7947d152232a6b134fbbc0"></a> typedef void(ITextParcelList::*&nbsp;</td><td class="memItemRight" valign="bottom"><b>ComputeMethod1</b> )(<a class="el" href="class_parcel_key.html">ParcelKey</a>, TextIndex *, int32 *) const </td></tr><tr class="separator:ad869e1178e7947d152232a6b134fbbc0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3d7fdde8c3c3a7736df6e34dd0bcc904"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3d7fdde8c3c3a7736df6e34dd0bcc904"></a> typedef void(ITextParcelList::*&nbsp;</td><td class="memItemRight" valign="bottom"><b>ComputeMethod2</b> )(<a class="el" href="class_parcel_key.html">ParcelKey</a>, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;, TextIndex *, int32 *) const </td></tr><tr class="separator:a3d7fdde8c3c3a7736df6e34dd0bcc904"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:af67a86cf83f0d282ea69aebbe103defb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af67a86cf83f0d282ea69aebbe103defb"></a> virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTextModelRef</b> () const =0</td></tr><tr class="separator:af67a86cf83f0d282ea69aebbe103defb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab5415339c45a5f545ccca88cc5143de5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab5415339c45a5f545ccca88cc5143de5"></a> virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetWaxStrandRef</b> () const =0</td></tr><tr class="separator:ab5415339c45a5f545ccca88cc5143de5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a34a50330f4a5d0f73f45086f363a91f6"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a34a50330f4a5d0f73f45086f363a91f6"></a> virtual <a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryStoryThread</b> () const =0</td></tr><tr class="separator:a34a50330f4a5d0f73f45086f363a91f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac737512e94194a3e181584bf12f3fd56"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac737512e94194a3e181584bf12f3fd56"></a> virtual <a class="el" href="class_range_data.html">RangeData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetThreadRange</b> () const =0</td></tr><tr class="separator:ac737512e94194a3e181584bf12f3fd56"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5b62ef79f3e76b12834cc446b49fa441"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5b62ef79f3e76b12834cc446b49fa441"></a> virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetThreadStart</b> (int32 *pSpan=nil) const =0</td></tr><tr class="separator:a5b62ef79f3e76b12834cc446b49fa441"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a55905202f81f0d3980eb6e102494655d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a55905202f81f0d3980eb6e102494655d"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetThreadSpan</b> (TextIndex *pStart=nil) const =0</td></tr><tr class="separator:a55905202f81f0d3980eb6e102494655d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a04951d13f56799cb1b15a857b9674acb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a04951d13f56799cb1b15a857b9674acb"></a> virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTextStart</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a04951d13f56799cb1b15a857b9674acb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7540c8ec23dad46fd3e5a944257acae8"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7540c8ec23dad46fd3e5a944257acae8"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTextSpan</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a7540c8ec23dad46fd3e5a944257acae8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af920fe80147561b9d2234f4c2bf6b3ad"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af920fe80147561b9d2234f4c2bf6b3ad"></a> virtual <a class="el" href="class_range_data.html">RangeData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTextRange</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:af920fe80147561b9d2234f4c2bf6b3ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adba688d316651af2ee3b6445935b56bd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="adba688d316651af2ee3b6445935b56bd"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetTextSpan</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, int32 span)=0</td></tr><tr class="separator:adba688d316651af2ee3b6445935b56bd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2ea251a6e4df1087d5d20d516646ba5f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2ea251a6e4df1087d5d20d516646ba5f"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelContaining</b> (TextIndex at) const =0</td></tr><tr class="separator:a2ea251a6e4df1087d5d20d516646ba5f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af75f5f8be7bc9b12bec81faecb2c2e98"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af75f5f8be7bc9b12bec81faecb2c2e98"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelContainingLeanLeft</b> (TextIndex at) const =0</td></tr><tr class="separator:af75f5f8be7bc9b12bec81faecb2c2e98"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7eec4a88e3339689c7e044b6adc6ab7e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7eec4a88e3339689c7e044b6adc6ab7e"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelContaining</b> (const <a class="el" href="class_range_data.html">RangeData</a> &amp;location) const =0</td></tr><tr class="separator:a7eec4a88e3339689c7e044b6adc6ab7e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4e2ca570a0b7ecc4ee9a99e83788212b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4e2ca570a0b7ecc4ee9a99e83788212b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelsContaining</b> (const <a class="el" href="class_range_data.html">RangeData</a> &amp;r, <a class="el" href="class_parcel_key.html">ParcelKey</a> *firstParcel, <a class="el" href="class_parcel_key.html">ParcelKey</a> *lastParcel) const =0</td></tr><tr class="separator:a4e2ca570a0b7ecc4ee9a99e83788212b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aee736e63fa9aa6271e4090cd64d10a94"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#aee736e63fa9aa6271e4090cd64d10a94">GetIsOverset</a> (TextIndex *pFirstOversetTextIndex=nil) const =0</td></tr><tr class="separator:aee736e63fa9aa6271e4090cd64d10a94"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2c27433ddc5c90e7f7d039bbefa45eff"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a2c27433ddc5c90e7f7d039bbefa45eff">GetFirstOversetTextIndex</a> (TextIndex *pThreadLast=nil) const =0</td></tr><tr class="separator:a2c27433ddc5c90e7f7d039bbefa45eff"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad2b929ef0f04d2877cce3867d1ed388e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad2b929ef0f04d2877cce3867d1ed388e"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetFirstLogicalParcelKey</b> () const =0</td></tr><tr class="separator:ad2b929ef0f04d2877cce3867d1ed388e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab48a56388ec17aa9208680660de56dce"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab48a56388ec17aa9208680660de56dce"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNextLogicalParcelKey</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:ab48a56388ec17aa9208680660de56dce"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac20d4e602a8898750882d2a03fdfaae9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac20d4e602a8898750882d2a03fdfaae9"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetLastLogicalParcelKey</b> () const =0</td></tr><tr class="separator:ac20d4e602a8898750882d2a03fdfaae9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a207783d8400c0b78ddb97d7cb04bbfe3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a207783d8400c0b78ddb97d7cb04bbfe3"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetLastLogicalNonOversetParcelKey</b> () const =0</td></tr><tr class="separator:a207783d8400c0b78ddb97d7cb04bbfe3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a67d67e4f17d9a97f4f5759fdf2a93931"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a67d67e4f17d9a97f4f5759fdf2a93931"></a> virtual <a class="el" href="class_i_text_parcel_list_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const =0</td></tr><tr class="separator:a67d67e4f17d9a97f4f5759fdf2a93931"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8a4dd4099d4ac2ed33430c03e865858f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8a4dd4099d4ac2ed33430c03e865858f"></a> virtual <a class="el" href="class_i_text_parcel_list_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a8a4dd4099d4ac2ed33430c03e865858f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab70dddb1b95e68db0d6e47bd986b350c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab70dddb1b95e68db0d6e47bd986b350c"></a> virtual <a class="el" href="class_i_text_parcel_list_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> () const =0</td></tr><tr class="separator:ab70dddb1b95e68db0d6e47bd986b350c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5f164553323e6ecb74f2bc918c59dcb4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5f164553323e6ecb74f2bc918c59dcb4"></a> virtual <a class="el" href="class_i_text_parcel_list_1_1const__iterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a5f164553323e6ecb74f2bc918c59dcb4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab8613fe5feb8cc74fe92a05735347c2a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab8613fe5feb8cc74fe92a05735347c2a"></a> virtual <a class="el" href="class_i_text_parcel_list_1_1const__reverse__iterator.html">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const =0</td></tr><tr class="separator:ab8613fe5feb8cc74fe92a05735347c2a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa925a0dd6cfd8e5adfc90293a06363de"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa925a0dd6cfd8e5adfc90293a06363de"></a> virtual <a class="el" href="class_i_text_parcel_list_1_1const__reverse__iterator.html">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:aa925a0dd6cfd8e5adfc90293a06363de"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af43301f07e8a7df72277e376ea9c905a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af43301f07e8a7df72277e376ea9c905a"></a> virtual <a class="el" href="class_i_text_parcel_list_1_1const__reverse__iterator.html">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const =0</td></tr><tr class="separator:af43301f07e8a7df72277e376ea9c905a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a588bf283c3fb97e5bef8c7d299917fd3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a588bf283c3fb97e5bef8c7d299917fd3"></a> virtual <a class="el" href="class_i_text_parcel_list_1_1const__reverse__iterator.html">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>rend</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a588bf283c3fb97e5bef8c7d299917fd3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af1e0aeb8fceacf1134f8648c920f03e1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af1e0aeb8fceacf1134f8648c920f03e1"></a> virtual Text::FirstLineOffsetMetric&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetFirstLineOffsetMetric</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:af1e0aeb8fceacf1134f8648c920f03e1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6106acef6202d7131dc5ede3c31ef22e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6106acef6202d7131dc5ede3c31ef22e"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetMinFirstLineOffset</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a6106acef6202d7131dc5ede3c31ef22e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a27ada7e337fe7bb2d3c7e8c07e0dc12e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a27ada7e337fe7bb2d3c7e8c07e0dc12e"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsVertical</b> () const =0</td></tr><tr class="separator:a27ada7e337fe7bb2d3c7e8c07e0dc12e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aabd6895a05042365c7963737dedd1b92"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aabd6895a05042365c7963737dedd1b92"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsRightToLeft</b> () const =0</td></tr><tr class="separator:aabd6895a05042365c7963737dedd1b92"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4182928ca2d740b1299e25a7f0c82205"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4182928ca2d740b1299e25a7f0c82205"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelHasBeenVJed</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a4182928ca2d740b1299e25a7f0c82205"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afc9861f1ff02ad8f456e069a44871a85"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="afc9861f1ff02ad8f456e069a44871a85"></a> virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelContentBounds</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:afc9861f1ff02ad8f456e069a44871a85"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaff1b07f9ef7d30d5e5e2356c37e195d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aaff1b07f9ef7d30d5e5e2356c37e195d"></a> virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelToContentMatrix</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:aaff1b07f9ef7d30d5e5e2356c37e195d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a00f410ee1c4bffb43223a90c07ea4d25"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a00f410ee1c4bffb43223a90c07ea4d25"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetMaxSoftBottomHeight</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a00f410ee1c4bffb43223a90c07ea4d25"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af42dc83b100059cbc7a5df269bfcb926"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af42dc83b100059cbc7a5df269bfcb926"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsDamaged</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:af42dc83b100059cbc7a5df269bfcb926"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adc6f74d541d9693dafe70940d6b6f310"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="adc6f74d541d9693dafe70940d6b6f310"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetDamaged</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:adc6f74d541d9693dafe70940d6b6f310"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a329379b8456e3594bd56a85209c31820"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a329379b8456e3594bd56a85209c31820"></a> virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetFirstDamagedParcel</b> () const =0</td></tr><tr class="separator:a329379b8456e3594bd56a85209c31820"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acbdc23e982bd9c97a66ae4b1d27343eb"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#acbdc23e982bd9c97a66ae4b1d27343eb">GetFirstParcelNeedingComposition</a> () const =0</td></tr><tr class="separator:acbdc23e982bd9c97a66ae4b1d27343eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a3ba3fb93993cf57eaa4d04ba25d2b8"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960a">RecomposeResult</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a5a3ba3fb93993cf57eaa4d04ba25d2b8">Recompose</a> (<a class="el" href="class_i_parcel_container.html">IParcelContainer</a> *container, int32 firstContainerPI, bool16 noDamageBackPrevContainers, Text::VerticalJustification vj, <a class="el" href="class_p_m_real.html">PMReal</a> vjMaxInterParaSpace, bool16 vjBalanceColumns, int32 firstDamagedPI, int32 firstNeedWrapCheckPI, TextIndex composeUpToTextIndex=kInvalidTextIndex, <a class="el" href="class_idle_timer.html">IdleTimer</a> *interruptCheck=nil, <a class="el" href="class_p_m_real.html">PMReal</a> *tileableHeightRemaining=nil)=0</td></tr><tr class="separator:a5a3ba3fb93993cf57eaa4d04ba25d2b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab4b8c56bf914305a89dbc331d2081fc0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#ab4b8c56bf914305a89dbc331d2081fc0">MarkDamage</a> (TextIndex at, int32 amt, int32 limitLeanLeftParcelIndex)=0</td></tr><tr class="separator:ab4b8c56bf914305a89dbc331d2081fc0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afe3e1c6b70107d84955790537c87b53d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#afe3e1c6b70107d84955790537c87b53d">AdjustSpans</a> (TextIndex at, int32 amt)=0</td></tr><tr class="separator:afe3e1c6b70107d84955790537c87b53d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af1cef2d9b72748550b439e4e6ebb63e5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af1cef2d9b72748550b439e4e6ebb63e5"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>MarkParcelInsertDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:af1cef2d9b72748550b439e4e6ebb63e5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a753f3afce75cac2891f015f0d699e7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5a753f3afce75cac2891f015f0d699e7"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>MarkParcelRemoveDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a5a753f3afce75cac2891f015f0d699e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a56665a4baa3e3a909687042fc22aa40b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a56665a4baa3e3a909687042fc22aa40b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>MarkResizeDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundsBefore, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundsAfter)=0</td></tr><tr class="separator:a56665a4baa3e3a909687042fc22aa40b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3b5900df06111d1a521f65d05a512b23"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3b5900df06111d1a521f65d05a512b23"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>MarkMoveDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a3b5900df06111d1a521f65d05a512b23"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a93dad3d65f40480d1c71fc34cd07c57b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a93dad3d65f40480d1c71fc34cd07c57b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>MarkGridDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a93dad3d65f40480d1c71fc34cd07c57b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab63f626c99a4eaacebab207442cd3ac7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#ab63f626c99a4eaacebab207442cd3ac7">MarkCompositionDamageNoLean</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> limitFirstParcelKey, TextIndex threadStart, TextIndex damageStart, int32 limitFirstParcelIndex, TextIndex damageEnd, int32 lastParcelIndex)=0</td></tr><tr class="separator:ab63f626c99a4eaacebab207442cd3ac7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6466a75a6ca09a42aba977959dda90f4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6466a75a6ca09a42aba977959dda90f4"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DamageFirstLine</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a6466a75a6ca09a42aba977959dda90f4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a324b7e4dd4642134c5e934219a521fe3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a324b7e4dd4642134c5e934219a521fe3"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DamageEntireParcel</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, int32 limitLeanLeftParcelIndex=kInvalidParcelIndex)=0</td></tr><tr class="separator:a324b7e4dd4642134c5e934219a521fe3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac190c33b97935222d0cb68338cca8cf3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac190c33b97935222d0cb68338cca8cf3"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DamageEntireParcelP1</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, int32 limitLeanLeftParcelIndex=kInvalidParcelIndex)=0</td></tr><tr class="separator:ac190c33b97935222d0cb68338cca8cf3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5cfe86420fd8ad5c8ee066935f8d266e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5cfe86420fd8ad5c8ee066935f8d266e"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DamageFirstLineInNextParcel</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a5cfe86420fd8ad5c8ee066935f8d266e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a443339e40676d329f3c256f3aa7a0da4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a443339e40676d329f3c256f3aa7a0da4"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DamageYRange</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYTop, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYBottom)=0</td></tr><tr class="separator:a443339e40676d329f3c256f3aa7a0da4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afaa8453cfbb9ee9e550f5cc93b3afe23"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="afaa8453cfbb9ee9e550f5cc93b3afe23"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DamageWaxAnchoredElementYRange</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYTop, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;waxYBottom)=0</td></tr><tr class="separator:afaa8453cfbb9ee9e550f5cc93b3afe23"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5fc498225645544483fd9cd3dd82b0ec"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5fc498225645544483fd9cd3dd82b0ec"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Damage</b> (ComputeMethod1, <a class="el" href="class_parcel_key.html">ParcelKey</a> key, int32 limitLeanLeftParcelIndex=kInvalidParcelIndex)=0</td></tr><tr class="separator:a5fc498225645544483fd9cd3dd82b0ec"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2ff931920ce6218ecf37e43687261f61"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2ff931920ce6218ecf37e43687261f61"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Damage</b> (ComputeMethod2, <a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;b1, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;b2)=0</td></tr><tr class="separator:a2ff931920ce6218ecf37e43687261f61"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a98905e1cd9c605c9c6aec719846c945b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a98905e1cd9c605c9c6aec719846c945b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ComputeResizeDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundsBefore, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;boundsAfter, TextIndex *pStart, int32 *pLen) const =0</td></tr><tr class="separator:a98905e1cd9c605c9c6aec719846c945b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abdefeb268ade7b722a7064a14056e186"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abdefeb268ade7b722a7064a14056e186"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ComputeFirstLineDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, TextIndex *pStart, int32 *pLen) const =0</td></tr><tr class="separator:abdefeb268ade7b722a7064a14056e186"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae33a8c0f897a0c9693f90c5ad6d85f23"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae33a8c0f897a0c9693f90c5ad6d85f23"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ComputeEntireParcelDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, TextIndex *pStart, int32 *pLen) const =0</td></tr><tr class="separator:ae33a8c0f897a0c9693f90c5ad6d85f23"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2029f17169dcc9d6b8cd96ba8d1ae642"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2029f17169dcc9d6b8cd96ba8d1ae642"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ComputeEntireParcelP1Damage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, TextIndex *pStart, int32 *pLen) const =0</td></tr><tr class="separator:a2029f17169dcc9d6b8cd96ba8d1ae642"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a15abfc2a61c8827da4ee5dce55eff424"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a15abfc2a61c8827da4ee5dce55eff424"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ComputeFirstLineInNextParcelDamage</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, TextIndex *pStart, int32 *pLen) const =0</td></tr><tr class="separator:a15abfc2a61c8827da4ee5dce55eff424"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a05f5d381d94e54a3ad9ebbce70f4e0e8"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a05f5d381d94e54a3ad9ebbce70f4e0e8"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Inval</b> (TextIndex start, int32 span) const =0</td></tr><tr class="separator:a05f5d381d94e54a3ad9ebbce70f4e0e8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0af25ece434fb863c62a4264e0fc94a4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0af25ece434fb863c62a4264e0fc94a4"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsValidStartBreakLocation</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, Text::StartBreakLocation mode) const =0</td></tr><tr class="separator:a0af25ece434fb863c62a4264e0fc94a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a187e58cfa083a34b9e2b38212c51284f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a187e58cfa083a34b9e2b38212c51284f"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetHasAnyValidStartBreakLocation</b> () const =0</td></tr><tr class="separator:a187e58cfa083a34b9e2b38212c51284f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a12bd4b8c7a0164dcd99d6714ce4b8938"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a12bd4b8c7a0164dcd99d6714ce4b8938"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetShapeData</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_p_m_rect.html">PMRect</a> *inkBounds, int32 *passCount, <a class="el" href="class_text_1_1_draw_pass_info.html">Text::DrawPassInfo</a> **passList)=0</td></tr><tr class="separator:a12bd4b8c7a0164dcd99d6714ce4b8938"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0c21b9335a43ccaa18707426f3804a81"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0c21b9335a43ccaa18707426f3804a81"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DrawParcel</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_graphics_data.html">GraphicsData</a> *gd, int32 iShapeFlags, const <a class="el" href="class_p_m_rect.html">PMRect</a> *areaToDraw, const int32 passCount, const <a class="el" href="class_text_1_1_draw_pass_info.html">Text::DrawPassInfo</a> *passList, void(*btdFunc)(void *), void(*btfdFunc)(void *), void *funcPrv, bool16 *pInkBoundsChanged)=0</td></tr><tr class="separator:a0c21b9335a43ccaa18707426f3804a81"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c1325420506bdb391853ee8870b35c2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8c1325420506bdb391853ee8870b35c2"></a> virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelComposedBounds</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a8c1325420506bdb391853ee8870b35c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a41f5e68531f3d422892c34603038e9f7"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a41f5e68531f3d422892c34603038e9f7">HitTestParcel</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;pasteboardPt, TextIndex *nextLine=nil)=0</td></tr><tr class="separator:a41f5e68531f3d422892c34603038e9f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8adf298e4c9f3ae5dbd94629e949e586"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a8adf298e4c9f3ae5dbd94629e949e586">IterateTextParcelListDrawOrder</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xform, <a class="el" href="class_i_callback.html">ICallback</a> *callbackInfo, int32 iShapeFlags, <a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a8adf298e4c9f3ae5dbd94629e949e586"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9eba990e2e7f1734ab1f93cdac5f7dbf"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a9eba990e2e7f1734ab1f93cdac5f7dbf">ShouldFakeTabAlignToChar</a> () const =0</td></tr><tr class="separator:a9eba990e2e7f1734ab1f93cdac5f7dbf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aeb476a768b66f87eec5bea2d8ec9c7e6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#aeb476a768b66f87eec5bea2d8ec9c7e6">CollectParcelChildren</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_u_i_d_list.html">UIDList</a> *list) const =0</td></tr><tr class="separator:aeb476a768b66f87eec5bea2d8ec9c7e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5825f9e44ffa042ddaa9d3756412a3cf"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a5825f9e44ffa042ddaa9d3756412a3cf">InsertWaxAnchoredElement</a> (IWaxAnchoredElement *wae, <a class="el" href="class_parcel_key.html">ParcelKey</a> toKey)=0</td></tr><tr class="separator:a5825f9e44ffa042ddaa9d3756412a3cf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2f351057453ff7cf02d2997fe65aa809"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2f351057453ff7cf02d2997fe65aa809"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoveWaxAnchoredElement</b> (IWaxAnchoredElement *wae)=0</td></tr><tr class="separator:a2f351057453ff7cf02d2997fe65aa809"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a406f54d2573d5baa790bea4ae7b51520"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a406f54d2573d5baa790bea4ae7b51520"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>MoveWaxAnchoredElement</b> (IWaxAnchoredElement *wae, <a class="el" href="class_parcel_key.html">ParcelKey</a> toKey)=0</td></tr><tr class="separator:a406f54d2573d5baa790bea4ae7b51520"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a31c7983f8ebcdcb89c789f0d8e0a0243"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a31c7983f8ebcdcb89c789f0d8e0a0243">NotifyInkBoundsChangedAt</a> (TextIndex at, bool16 fromRebuild)=0</td></tr><tr class="separator:a31c7983f8ebcdcb89c789f0d8e0a0243"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa1b7c43e1c16b37ea02715b041dc6b35"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#aa1b7c43e1c16b37ea02715b041dc6b35">NotifyParcelInkBoundsChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:aa1b7c43e1c16b37ea02715b041dc6b35"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a59aaabb4e7e7736008670cb7a7e41485"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a59aaabb4e7e7736008670cb7a7e41485">NotifyParcelPositionDependentContentSet</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a59aaabb4e7e7736008670cb7a7e41485"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4b9ab604e5fd60782612a99d2f011b35"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a4b9ab604e5fd60782612a99d2f011b35">HitTestParcel</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;waxPt, bool16 withinSTOnly, TextIndex *nextLine) const =0</td></tr><tr class="separator:a4b9ab604e5fd60782612a99d2f011b35"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a78e3e4bd81adb3aa66f2e8b7636daa07"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a78e3e4bd81adb3aa66f2e8b7636daa07">CollectParcelOwnedItems</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, <a class="el" href="class_k2_vector.html">OwnedItemDataList</a> *rList) const =0</td></tr><tr class="separator:a78e3e4bd81adb3aa66f2e8b7636daa07"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a95ca2231621bc080cb2ed0e6939024b5"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a95ca2231621bc080cb2ed0e6939024b5">GetParcelIsEmpty</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, bool16 *optionalIsOnlyLastCR=nil) const =0</td></tr><tr class="separator:a95ca2231621bc080cb2ed0e6939024b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4682407d290da385956755a5a50ffc83"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a4682407d290da385956755a5a50ffc83">NotifyParcelLayerChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_i_document_layer.html">IDocumentLayer</a> *newDocLayer)=0</td></tr><tr class="separator:a4682407d290da385956755a5a50ffc83"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7d627a6da41e92b89599b767efa14a53"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a7d627a6da41e92b89599b767efa14a53">NotifyParcelVisibilityChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a7d627a6da41e92b89599b767efa14a53"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a62f8092f381023bc858fc831bda85217"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a62f8092f381023bc858fc831bda85217">NotifyParcelZOrderChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a62f8092f381023bc858fc831bda85217"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a288cea71901164135811689a9b6b605e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a288cea71901164135811689a9b6b605e">NotifyParcelIgnoreWrapChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key)=0</td></tr><tr class="separator:a288cea71901164135811689a9b6b605e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adce12d8fe8785f97a4884b9a1278d2b1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#adce12d8fe8785f97a4884b9a1278d2b1">AddParcelInlineWraps</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="class_i_inline_data.html">IInlineData</a> *id, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;spreadRef, const <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;sodList)=0</td></tr><tr class="separator:adce12d8fe8785f97a4884b9a1278d2b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad45ae40b86e949c2c79cf69b79e3f86e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#ad45ae40b86e949c2c79cf69b79e3f86e">NotifyParcelWrapZOrderChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef, bool16 zOrderBasedWrap, const <a class="el" href="class_i_document_layer.html">IDocumentLayer</a> *sodDocLayer)=0</td></tr><tr class="separator:ad45ae40b86e949c2c79cf69b79e3f86e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9dd3e130529e62a099e576513a4313b8"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a9dd3e130529e62a099e576513a4313b8">NotifyParcelWrapSkipByLeadingChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)=0</td></tr><tr class="separator:a9dd3e130529e62a099e576513a4313b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9567f92f4faf229ae1897f8d10ee4c98"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a9567f92f4faf229ae1897f8d10ee4c98">NotifyParcelWrapNonGeometryChanged</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)=0</td></tr><tr class="separator:a9567f92f4faf229ae1897f8d10ee4c98"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0b61398bca97b97829bf183c1c74a077"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a0b61398bca97b97829bf183c1c74a077">RemoveParcelWrap</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key, const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;sodRef)=0</td></tr><tr class="separator:a0b61398bca97b97829bf183c1c74a077"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af397bbaeec88e4944496cb3115f22ee3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#af397bbaeec88e4944496cb3115f22ee3">RebuildWaxLine</a> (const <a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> *thread, const <a class="el" href="class_i_parcel_list.html">IParcelList</a> *pl, <a class="el" href="class_i_wax_line.html">IWaxLine</a> *waxLine) const =0</td></tr><tr class="separator:af397bbaeec88e4944496cb3115f22ee3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afa3f9636603ca6df4c6f9758e31c35b5"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#afa3f9636603ca6df4c6f9758e31c35b5">GetParcelContainsOversetContent</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:afa3f9636603ca6df4c6f9758e31c35b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae1d0de34d349d00e8e4e2e8776ba1e5c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#ae1d0de34d349d00e8e4e2e8776ba1e5c">NotifyStoryDirectionChanged</a> ()=0</td></tr><tr class="separator:ae1d0de34d349d00e8e4e2e8776ba1e5c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a669c954a0dccd1f952f174d1aec308fa"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_parcel_list.html#a669c954a0dccd1f952f174d1aec308fa">GetParcelComposing</a> () const =0</td></tr><tr class="separator:a669c954a0dccd1f952f174d1aec308fa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b6a8eccca32c304af212532b27df068"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1b6a8eccca32c304af212532b27df068"></a> virtual Text::VerticalJustification&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetComposingVerticalJustification</b> () const =0</td></tr><tr class="separator:a1b6a8eccca32c304af212532b27df068"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0014779bcbe98f6b55590ae2a361e613"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0014779bcbe98f6b55590ae2a361e613"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>CanBackDamageContainer</b> () const =0</td></tr><tr class="separator:a0014779bcbe98f6b55590ae2a361e613"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a9ab2959703f966f6faaaf273ded76f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5a9ab2959703f966f6faaaf273ded76f"></a> virtual ContainerComposer *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetCompositionContext</b> () const =0</td></tr><tr class="separator:a5a9ab2959703f966f6faaaf273ded76f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="afb071c4fed76972d5ee4b266cec3960a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960a">ITextParcelList::RecomposeResult</a></td></tr></table></div><div class="memdoc"><p>RecomposeResult <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="afb071c4fed76972d5ee4b266cec3960aa36c7f96a6565fec5c870ff16d60f4fb1"></a>kRR_NothingToCompose</em>&nbsp;</td><td class="fielddoc"><p>The Parcel was either not Wax damaged or after handling wrap check damage no wax was damaged as a result. The Parcel remains fully composed and without any wax damage. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="afb071c4fed76972d5ee4b266cec3960aab89804c0c694e6e21fa02cd4b64d4158"></a>kRR_DamagedBackParcel</em>&nbsp;</td><td class="fielddoc"><p>A Parcel in a previous container became damaged. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="afb071c4fed76972d5ee4b266cec3960aafd079c9ca14d20da49fadbcc2baa2f83"></a>kRR_Interrupted</em>&nbsp;</td><td class="fielddoc"><p>Composition was interrupted due to the interruptCheck. This will only be returned if and <a class="el" href="class_idle_timer.html">IdleTimer</a> is specified. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="afb071c4fed76972d5ee4b266cec3960aaca21cfaf6408228ee05062bb82494df3"></a>kRR_ComposedUpTo</em>&nbsp;</td><td class="fielddoc"><p>The container is now fully composed upto the specified TextIndex. This will only be returned if the optional composeUpToTextIndex parameter is not kInvalidTextIndex AND after the Column containing the TextIndex is fully composed the Container still needs composition. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="afb071c4fed76972d5ee4b266cec3960aaf6d43d392463c9de541a493f1a0d12f9"></a>kRR_FullyComposed</em>&nbsp;</td><td class="fielddoc"><p>The container is now fully composed. </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="adce12d8fe8785f97a4884b9a1278d2b1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::AddParcelInlineWraps </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_inline_data.html">IInlineData</a> *&nbsp;</td><td class="paramname"><em>id</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>spreadRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_k2_vector.html">TextWrapRefList</a> &amp;&nbsp;</td><td class="paramname"><em>sodList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Adds Wraps during composition that are children of an inlines. Because these Wraps are never from MasterPages, the X/YOffset component of the Wrap is always zero and so we never pass it in. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td><a class="el" href="class_parcel_key.html">ParcelKey</a> that the inline is registered in </td></tr><tr><td class="paramname">spreadRef</td><td><a class="el" href="class_u_i_d_ref.html">UIDRef</a> of <a class="el" href="class_i_spread.html">ISpread</a> that the key is on </td></tr><tr><td class="paramname">sodList</td><td>TextWrapRefList of active <a class="el" href="class_i_stand_off_data.html">IStandOffData</a></td></tr></table></dl></div></div><a class="anchor" id="afe3e1c6b70107d84955790537c87b53d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::AdjustSpans </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>amt</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Used only by WaxStrand to maintain consistent text spans in the parcels. </div></div><a class="anchor" id="aeb476a768b66f87eec5bea2d8ec9c7e6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::CollectParcelChildren </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>list</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Collects all the OwnedItems and WaxAnchoredElements associated with Parcel. This method supports <a class="el" href="class_i_visitor_helper.html">IVisitorHelper</a> implementations that have Text. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">list</td><td></td></tr></table></dl></div></div><a class="anchor" id="a78e3e4bd81adb3aa66f2e8b7636daa07"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::CollectParcelOwnedItems </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">OwnedItemDataList</a> *&nbsp;</td><td class="paramname"><em>rList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Appends the list of OwnedItems that are associated with the specified Parcel. Only those OwnedItems that are actually composed within the Parcel are added. Note that because of the presence of WaxAnchorPts and WaxAnchoredElements it is not sufficient to use the span of the Parcel to compute this. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">rList</td><td>The results are appended to the list. </td></tr></table></dl></div></div><a class="anchor" id="a2c27433ddc5c90e7f7d039bbefa45eff"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextParcelList::GetFirstOversetTextIndex </td><td>(</td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>pThreadLast</em> = <code>nil</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the TextIndex of the first character that is NOT mapped to a Parcel BEFORE the Parcel returned by ITextParcelListData::GetOversetParcelKey(). If all of the TextStoryThread is composed within those Parcel then kInvalidTextIndex is returned. Note that because of WaxAnchoredElements, this method is not sufficient to determine if the TextParcelList is overset, use <a class="el" href="class_i_text_parcel_list.html#aee736e63fa9aa6271e4090cd64d10a94">GetIsOverset()</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pThreadLast</td><td>will be set to the last TextIndex in the TextStoryThread. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>TextIndex of the first Text content which is composed beyond the last Logical Parcel. </dl></div></div><a class="anchor" id="acbdc23e982bd9c97a66ae4b1d27343eb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelList::GetFirstParcelNeedingComposition </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the first Parcel in the ParcelList which needs composition. Note because of the subtle iteraction with Parcels that needs to check for wrap, this method is not the same as simply returning the first damaged or first needs wrap check Parcel. In particular, a Parcel needing wrap check which is beyond the Parcel containing the end of the story thread is NOT considered to need composition. <dl class="section return"><dt>Returns<dd>Invalid <a class="el" href="class_parcel_key.html">ParcelKey</a> if no Parcel needs composition </dl></div></div><a class="anchor" id="aee736e63fa9aa6271e4090cd64d10a94"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelList::GetIsOverset </td><td>(</td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>pFirstOversetTextIndex</em> = <code>nil</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The TextParcelList is considered overset if any content other than the last CR in the associated TextStoryThread is not composed in Parcels BEFORE the Parcel returned by ITextParcelListData::GetLastOversetParcelKey(). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pFirstOversetTextIndex</td><td>Optional pointer that will be filled in the TextIndex of the first overset text. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if overset, kFalse otherwise. </dl></div></div><a class="anchor" id="a669c954a0dccd1f952f174d1aec308fa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> ITextParcelList::GetParcelComposing </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method tells callers if the TextParcelList is currently composing any Parcels within the list. <dl class="section return"><dt>Returns<dd><a class="el" href="class_parcel_key.html">ParcelKey</a> of the Parcel being currently composed. Will return an invalid <a class="el" href="class_parcel_key.html">ParcelKey</a> is not composing. </dl></div></div><a class="anchor" id="afa3f9636603ca6df4c6f9758e31c35b5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelList::GetParcelContainsOversetContent </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Parcels which compose complex content, such as Tables and Footnotes, which themselves manage TextStoryThreads in the same TextModel as this TextParcelList can be overset without this TextParcelList itself being overset. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the Parcel contains any complex content which is overset. </dl></div></div><a class="anchor" id="a95ca2231621bc080cb2ed0e6939024b5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelList::GetParcelIsEmpty </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>optionalIsOnlyLastCR</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the Parcel has no Text span AND no WaxAnchoredElemenents with any content. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_parcel_key.html">ParcelKey</a></td><td></td></tr><tr><td class="paramname">optionalIsOnlyLastCR</td><td>Pointer to bool which will be set to kTrue if the Parcel ONLY contains the final CR of the story thread, kFalse otherwise. </td></tr></table></dl></div></div><a class="anchor" id="a41f5e68531f3d422892c34603038e9f7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextParcelList::HitTestParcel </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>pasteboardPt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>nextLine</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a point in Pasteboard coordinates, return the TextIndex of the closest character/glyph in this Parcel. Only returns TextIndexes within this TextStoryThread. The TextParcelList is required to be fully composed upto this point. Note that it is not possible to hit below the last line in the story thread, the location returned will be to the left of the final CR. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel </td></tr><tr><td class="paramname">pasteboardPt</td><td></td></tr><tr><td class="paramname">nextLine</td><td>The TextIndex of the end of the WaxLine (which is the start of the next WaxLine) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The TextIndex of the closest character/glyph in this Parcel. </dl></div></div><a class="anchor" id="a4b9ab604e5fd60782612a99d2f011b35"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextParcelList::HitTestParcel </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>waxPt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>withinSTOnly</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>nextLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a point in Wax coordinates, return the TextIndex of the closest character/glyph in this Parcel. The TextParcelList is required to be fully composed upto this point. Note that it is not possible to hit below the last line in the story thread, the location returned will be to the left of the final CR. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>Parcel </td></tr><tr><td class="paramname">waxPt</td><td></td></tr><tr><td class="paramname">withinSTOnly</td><td>If kTrue, then the we will not burrow into Tables or WaxAnchoredElements looking for a better hits. </td></tr><tr><td class="paramname">nextLine</td><td>The TextIndex of the end of the WaxLine (which is the start of the next WaxLine) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The TextIndex of the closest character/glyph in this Parcel. </dl></div></div><a class="anchor" id="a5825f9e44ffa042ddaa9d3756412a3cf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::InsertWaxAnchoredElement </td><td>(</td><td class="paramtype">IWaxAnchoredElement *&nbsp;</td><td class="paramname"><em>wae</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>toKey</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">wae</td><td>The WaxAnchoredElement to insert. </td></tr><tr><td class="paramname">atParcel</td><td>The Parcel that the WaxAnchoredElement will start life in. </td></tr></table></dl></div></div><a class="anchor" id="a8adf298e4c9f3ae5dbd94629e949e586"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::IterateTextParcelListDrawOrder </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xform</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_callback.html">ICallback</a> *&nbsp;</td><td class="paramname"><em>callbackInfo</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>iShapeFlags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Iterate over every object in a given parcel and call its IterateDrawOrder method </div></div><a class="anchor" id="ab63f626c99a4eaacebab207442cd3ac7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::MarkCompositionDamageNoLean </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>limitFirstParcelKey</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>threadStart</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>damageStart</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>limitFirstParcelIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>damageEnd</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lastParcelIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method will damage a range of Text without causing any back-up damage to a Parcel previous to the one specified. The caller specifies the Text range to be damaged but they also must specify the range of the Parcels that may be damaged by this action. Only used during composition since for all changes to the TextModel we want to lean-left to previous Parcels and failure to do so will result in ASSERTs by the WaxLineCompositionIter. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">limitFirstParcelKey</td><td>The first Parcel that can become damaged - no damage before this point. If damageStart equals damageEnd, then this Parcel will be marked damaged, otherwise this Parcel will only be damaged if the start of the damage range is containing by this Parcel or we lean-left into it. </td></tr><tr><td class="paramname">threadStart</td><td>The TextIndex of the start of the Thread managed by this TextParcelList. We could calculate it ourselves but most callers have it anyway. </td></tr><tr><td class="paramname">damageStart</td><td>TextIndex of the first point of damage - must be within the Parcel specified by &#39;firstParcelKey&#39; </td></tr><tr><td class="paramname">limitFirstParcelIndex</td><td>Index within the controlling ParcelList of the Parcel specified by &#39;limitFirstParcelKey&#39; </td></tr><tr><td class="paramname">damageEnd</td><td>TextIndex of the end point of damage. </td></tr><tr><td class="paramname">lastParcelIndex</td><td>Index within the controlling ParcelList of the last Parcel to be damaged. Only used when damageStart equals damageEnd, otherwise the last Parcel damaged will be one containing the last TextIndex of the damage range. </td></tr></table></dl></div></div><a class="anchor" id="ab4b8c56bf914305a89dbc331d2081fc0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelList::MarkDamage </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>amt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>limitLeanLeftParcelIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Damage ranges of Text. This method does not damage waxLines, it just updates the span state. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>TextIndex for the start of the damage range. </td></tr><tr><td class="paramname">amt</td><td>Length of damage range, must be &gt; 0, must end before the end of the story thread owning the starting TextIndex. </td></tr><tr><td class="paramname">limitLeanLeftParcelIndex</td><td>If NOT kInvalidParcelIndex, the index in the controlling ParcelList for which we will not do lean left damage. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if limitLeanLeftParcelIndex was valid AND it resulted in a limit to leaning left. </dl></div></div><a class="anchor" id="a31c7983f8ebcdcb89c789f0d8e0a0243"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyInkBoundsChangedAt </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>fromRebuild</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method tells the TextParcelList that the WaxLine at the specified TextIndex has changed its ink bounds outside of composition. The WaxRun and WaxLine containing that TextIndex will have their caches invalidated appropriately before NotifyInkBoundsChanged() is called internally on the appropriate Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>TextIndex of the WaxLine that changed. </td></tr><tr><td class="paramname">fromRebuild</td><td>kTrue if the WaxLine at the specified TextIndex is being rebuilt, kFalse otherwise. </td></tr></table></dl></div></div><a class="anchor" id="a288cea71901164135811689a9b6b605e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelIgnoreWrapChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_parcel_key.html">ParcelKey</a></td><td></td></tr></table></dl></div></div><a class="anchor" id="aa1b7c43e1c16b37ea02715b041dc6b35"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelInkBoundsChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method tells the TextParcelList that some Wax element in the specified Parcel has changed its ink bounds outside of composition. </div></div><a class="anchor" id="a4682407d290da385956755a5a50ffc83"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelLayerChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_document_layer.html">IDocumentLayer</a> *&nbsp;</td><td class="paramname"><em>newDocLayer</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_parcel_key.html">ParcelKey</a></td><td></td></tr><tr><td class="paramname">newDocLayer</td><td></td></tr></table></dl></div></div><a class="anchor" id="a59aaabb4e7e7736008670cb7a7e41485"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelPositionDependentContentSet </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method tells the TextParcelList that some Wax element in the specified Parcel has become position dependent. This call is typically made outside of the composition of the Parcel. </div></div><a class="anchor" id="a7d627a6da41e92b89599b767efa14a53"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelVisibilityChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_parcel_key.html">ParcelKey</a></td><td></td></tr></table></dl></div></div><a class="anchor" id="a9567f92f4faf229ae1897f8d10ee4c98"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelWrapNonGeometryChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The specified active Wrap affecting the specified Parcel has changed either IStandOff::Mode from one BBox mode to another (such as kBoundingBox to kBand) or the IStandOff::Side. These changes do not result in a change to the PathGeometry of the Wrap but it will affect how Text will compose around the Wrap. This method will damage the appropriate text within the Parcel as required. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> of the wrap that has been affected. </td></tr></table></dl></div></div><a class="anchor" id="a9dd3e130529e62a099e576513a4313b8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelWrapSkipByLeadingChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The specified active Wrap affecting the specified Parcel has changed the SkipByLeading option. This method will damage the appropriate text within the Parcel as required. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> of the wrap that has been affected. </td></tr></table></dl></div></div><a class="anchor" id="ad45ae40b86e949c2c79cf69b79e3f86e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelWrapZOrderChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>zOrderBasedWrap</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_document_layer.html">IDocumentLayer</a> *&nbsp;</td><td class="paramname"><em>sodDocLayer</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The specified Wrap affecting the specified Parcel has changed in some way that is based on ZOrder. This could be ZOrder based on the Wraps <a class="el" href="class_i_hierarchy.html">IHierarchy</a>, the Wraps Layer, the ZOrder of the Wraps Layer, the visibility of the Wraps Layer or even Wrap being affected by ZOrder at all. The geometry, position and mode of the Wrap remains unchanged. This method will re-evaluate the Wrap relative to the effective ZOrder of the Parcel if required. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">sodRef</td><td><a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> of the wrap that has been affected. </td></tr><tr><td class="paramname">zOrderBasedWrap</td><td></td></tr><tr><td class="paramname">sodLayerVisible</td><td></td></tr><tr><td class="paramname">sodLayerIgnoreWhenHidden</td><td></td></tr><tr><td class="paramname">sodDocLayer</td><td></td></tr></table></dl></div></div><a class="anchor" id="a62f8092f381023bc858fc831bda85217"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyParcelZOrderChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname"><a class="el" href="class_parcel_key.html">ParcelKey</a></td><td></td></tr></table></dl></div></div><a class="anchor" id="ae1d0de34d349d00e8e4e2e8776ba1e5c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::NotifyStoryDirectionChanged </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The story direction (returned by GetIsVertical()) of this StoryThread has changed. </div></div><a class="anchor" id="af397bbaeec88e4944496cb3115f22ee3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelList::RebuildWaxLine </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> *&nbsp;</td><td class="paramname"><em>thread</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_parcel_list.html">IParcelList</a> *&nbsp;</td><td class="paramname"><em>pl</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_wax_line.html">IWaxLine</a> *&nbsp;</td><td class="paramname"><em>waxLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method manages the process of asking the <a class="el" href="class_i_paragraph_composer.html">IParagraphComposer</a> to rebuild the specified WaxLine to fit. This main caller of this method is the private method IWaxLine::BuildRuns(). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">Pointer</td><td>to <a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> of the WaxLine </td></tr><tr><td class="paramname">Pointer</td><td>to <a class="el" href="class_i_parcel_list.html">IParcelList</a> of this <a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a></td></tr><tr><td class="paramname">waxLine</td><td>Pointer to <a class="el" href="class_i_wax_line.html">IWaxLine</a> that needs WaxRuns to build </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the WaxLine successfully built it&#39;s runs. </dl></div></div><a class="anchor" id="a5a3ba3fb93993cf57eaa4d04ba25d2b8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_text_parcel_list.html#afb071c4fed76972d5ee4b266cec3960a">RecomposeResult</a> ITextParcelList::Recompose </td><td>(</td><td class="paramtype"><a class="el" href="class_i_parcel_container.html">IParcelContainer</a> *&nbsp;</td><td class="paramname"><em>container</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>firstContainerPI</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>noDamageBackPrevContainers</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Text::VerticalJustification&nbsp;</td><td class="paramname"><em>vj</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>vjMaxInterParaSpace</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>vjBalanceColumns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>firstDamagedPI</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>firstNeedWrapCheckPI</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>composeUpToTextIndex</em> = <code>kInvalidTextIndex</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_idle_timer.html">IdleTimer</a> *&nbsp;</td><td class="paramname"><em>interruptCheck</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>tileableHeightRemaining</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Recompose Parcels.<p>WARNING: This method should only be called by the implementors of the <a class="el" href="class_i_text_parcel_list_data.html">ITextParcelListData</a> which is the only code with enough knowledge of the proper context in which this can be called. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">container</td><td>Pointer to <a class="el" href="class_i_parcel_container.html">IParcelContainer</a> which will be used to drive the composition on the container. </td></tr><tr><td class="paramname">firstContainerPI</td><td>The index within the ParcelList of the first Parcel of the container. </td></tr><tr><td class="paramname">noDamageBackPrevContainers</td><td>If kTrue, composition of the specified container must not result in damage to any Parcels in previous ParcelContainers. This should only be set if the ParcelList being composed is associated with a containing ParcelList (such as the FrameList) otherwise incorrect composition will result. </td></tr><tr><td class="paramname">vj</td><td>VerticalJustification </td></tr><tr><td class="paramname">vjMaxInterParaSpace</td><td></td></tr><tr><td class="paramname">vjBalanceColumns</td><td></td></tr><tr><td class="paramname">firstDamagedPI</td><td>index within the <a class="el" href="class_i_parcel_list.html">IParcelList</a> of the first Parcel which is damaged. May be set to kInvalidParcelIndex if firstNeedWrapCheckPI is NOT kInvalidParcelIndex. </td></tr><tr><td class="paramname">firstNeedWrapCheckPI</td><td>index within the <a class="el" href="class_i_parcel_list.html">IParcelList</a> of the first Parcel which needs wrap check. May be set to kInvalidParcelIndex if firstDamagedPI is NOT kInvalidParcelIndex. </td></tr><tr><td class="paramname">composeUpToTextIndex</td><td>Optional parameter for TextIndex within the thread which the container will compose &#39;columns&#39; upto. If the TextIndex is beyond the end of the Container then it has no effect. If it ends within the Container, and the Container and stop composing in the &#39;column&#39; that it is in, then the method will return early. Otherwise the entire Container will be composed. </td></tr><tr><td class="paramname">interruptCheck</td><td>Optional pointer to <a class="el" href="class_idle_timer.html">IdleTimer</a> class that will be used in some circumstances to interrupt composition before the container is fully composed. </td></tr><tr><td class="paramname">tilableHeightRemaining</td><td>Options pointer to <a class="el" href="class_p_m_real.html">PMReal</a> which will be filled in with an estimate of the tileable height remaining in the Container (before VJ was run) if the returned value is kRR_FullyComposed. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>RecomposeResult </dl></div></div><a class="anchor" id="a0b61398bca97b97829bf183c1c74a077"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextParcelList::RemoveParcelWrap </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_text_wrap_ref.html">TextWrapRef</a> &amp;&nbsp;</td><td class="paramname"><em>sodRef</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The specified Wrap is removed from the specified Parcel. If the wrap is known to the Parcel then this method will damage Text that was overlapped by the wrap. The IStandOffParcelUsedList on the same boss as the <a class="el" href="class_i_stand_off_data.html">IStandOffData</a> will be called to unregister the Parcel. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td></td></tr><tr><td class="paramname">sod</td><td>Pointer to <a class="el" href="class_i_stand_off_data.html">IStandOffData</a> interface for the wrap </td></tr><tr><td class="paramname">xOffset</td><td>XOffset that the specified Parcel knows the StandOff by </td></tr><tr><td class="paramname">yOffset</td><td>YOffset that the specified Parcel knows the StandOff by </td></tr></table></dl></div></div><a class="anchor" id="a9eba990e2e7f1734ab1f93cdac5f7dbf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextParcelList::ShouldFakeTabAlignToChar </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The purpose of this API is for composition/regen code to determine if it should act like there is a tab character as the first character of paragraphs in this story thread. This gives table cells the ability to have align to character tab functionality without having an actual tab character in the model. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_text_parcel_list.html">ITextParcelList</a><li class="footer">Generated on Sat Sep 22 2018 10:54:31 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
