<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_wax_line</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_wax_line.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_wax_line-members.html">List of all members</a></div><div class="headertitle"><div class="title">IWaxLine Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_wax_line_8h_source.html">IWaxLine.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IWaxLine:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_wax_line.png" usemap="#IWaxLine_map" /><map id="IWaxLine_map" name="IWaxLine_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a738520e78e151c0237cd06f2cf1580e5"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IWAXLINE }</td></tr><tr class="separator:a738520e78e151c0237cd06f2cf1580e5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a44c016d9dfef1a0195ea35c010abac03"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>LineTightness</b> { <br /> &nbsp;&nbsp;<b>kUnknown</b>, <b>kVeryLoose</b>, <b>kLoose</b>, <b>kNormal</b>, <br /> &nbsp;&nbsp;<b>kTight</b>, <b>kVeryTight</b>, <b>kTooLoose_Obsolete</b>, <b>kTooTight_Obsolete</b><br /> }</td></tr><tr class="separator:a44c016d9dfef1a0195ea35c010abac03"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af1858845f167ea2663cb64f23417b37e"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kMaximumTilesPerLine</b> = 32 }</td></tr><tr class="separator:af1858845f167ea2663cb64f23417b37e"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:aa3529fd004eee054ab8871fed3e2f722"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#aa3529fd004eee054ab8871fed3e2f722">SetVOSWaxObject</a> (<a class="el" href="class_v_o_s___object.html">VOS_Object</a> *vosObject)=0</td></tr><tr class="separator:aa3529fd004eee054ab8871fed3e2f722"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0925b9a6b04680f0103d6e83c898653a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_v_o_s___object.html">VOS_Object</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a0925b9a6b04680f0103d6e83c898653a">GetVOSWaxObject</a> () const =0</td></tr><tr class="separator:a0925b9a6b04680f0103d6e83c898653a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3ddf0365d6ceda8e3292e3e6156aa97f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a3ddf0365d6ceda8e3292e3e6156aa97f">GetParcelKey</a> () const =0</td></tr><tr class="separator:a3ddf0365d6ceda8e3292e3e6156aa97f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a14fa08aaea4b1818a9858226add54089"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a14fa08aaea4b1818a9858226add54089"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetParcelKey</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> parcelKey)=0</td></tr><tr class="separator:a14fa08aaea4b1818a9858226add54089"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a57897c023fdfe2467652f30cb4fe664d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a57897c023fdfe2467652f30cb4fe664d"></a> virtual <a class="el" href="class_i_wax_run.html">IWaxRun</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryRun</b> (int32 index) const =0</td></tr><tr class="separator:a57897c023fdfe2467652f30cb4fe664d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2de1b8cf8f7b6de36bbb546bfdd70eca"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2de1b8cf8f7b6de36bbb546bfdd70eca"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetRunIndex</b> (const <a class="el" href="class_i_wax_run.html">IWaxRun</a> *run) const =0</td></tr><tr class="separator:a2de1b8cf8f7b6de36bbb546bfdd70eca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abdcf2b3fa3aa580fcfe8445c71ae47e4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abdcf2b3fa3aa580fcfe8445c71ae47e4"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetRunCount</b> () const =0</td></tr><tr class="separator:abdcf2b3fa3aa580fcfe8445c71ae47e4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a29ef1b105f45e60dccc73e8d601d728a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a29ef1b105f45e60dccc73e8d601d728a">DoWaxRunsExist</a> () const =0</td></tr><tr class="separator:a29ef1b105f45e60dccc73e8d601d728a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9e96a25b9991ccce226a6b43ea382174"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a9e96a25b9991ccce226a6b43ea382174">StartsLine</a> (const <a class="el" href="class_i_wax_run.html">IWaxRun</a> *waxRun) const =0</td></tr><tr class="separator:a9e96a25b9991ccce226a6b43ea382174"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a094f18b89738ce7b15959947ded2cd26"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a094f18b89738ce7b15959947ded2cd26">EndsLine</a> (const <a class="el" href="class_i_wax_run.html">IWaxRun</a> *waxRun) const =0</td></tr><tr class="separator:a094f18b89738ce7b15959947ded2cd26"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab5e8aa6f2520329cfd9d9ba4595d698f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_wax_glyph_iterator.html">IWaxGlyphIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#ab5e8aa6f2520329cfd9d9ba4595d698f">QueryWaxGlyphIterator</a> (bool16 includeLine=kFalse) const =0</td></tr><tr class="separator:ab5e8aa6f2520329cfd9d9ba4595d698f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3e13b3c222a7494b89d7d9ff8d08cc09"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_wax_run_iterator.html">IWaxRunIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a3e13b3c222a7494b89d7d9ff8d08cc09">QueryWaxRunIterator</a> (bool16 includeLine=kFalse) const =0</td></tr><tr class="separator:a3e13b3c222a7494b89d7d9ff8d08cc09"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5e101329829cac659068ffc7b714826b"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_wax_run.html">IWaxRun</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a5e101329829cac659068ffc7b714826b">QueryRunByTextOffset</a> (int32 textOffset, int32 *pGlyphOffset=nil) const =0</td></tr><tr class="separator:a5e101329829cac659068ffc7b714826b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab0af2ab2f56fd67a96d0340d260cc4fc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#ab0af2ab2f56fd67a96d0340d260cc4fc">SetDropCapIndents</a> (int32 howManyIndents, const <a class="el" href="class_p_m_real.html">PMReal</a> *indents, const int32 *lineCounts)=0</td></tr><tr class="separator:ab0af2ab2f56fd67a96d0340d260cc4fc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8eb4f6e0260cf63e1e2931c7c2adbb5e"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a8eb4f6e0260cf63e1e2931c7c2adbb5e">GetDropCapIndents</a> (<a class="el" href="class_p_m_real.html">PMReal</a> *indents=nil, int32 *lineCounts=nil) const =0</td></tr><tr class="separator:a8eb4f6e0260cf63e1e2931c7c2adbb5e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a918e3d3f39e0a9b58eac30ac4ae245c5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a918e3d3f39e0a9b58eac30ac4ae245c5">GetNthDropCapIndent</a> (int32 n) const =0</td></tr><tr class="separator:a918e3d3f39e0a9b58eac30ac4ae245c5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5d8510c6ad15dd05f99215fd01c518af"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a5d8510c6ad15dd05f99215fd01c518af">GetNextLineAffectedByDropcap</a> () const =0</td></tr><tr class="separator:a5d8510c6ad15dd05f99215fd01c518af"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a74f5631b678ae81f0abb96ead309e9d5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a74f5631b678ae81f0abb96ead309e9d5">GetDataBase</a> () const =0</td></tr><tr class="separator:a74f5631b678ae81f0abb96ead309e9d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2ae7bddf36ea9d71d69df504735c87a2"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a2ae7bddf36ea9d71d69df504735c87a2">GetTextSpan</a> () const =0</td></tr><tr class="separator:a2ae7bddf36ea9d71d69df504735c87a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6a5540f6db6e89fbe1348abfdd55b829"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6a5540f6db6e89fbe1348abfdd55b829"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTextSpanInTile</b> (int32 tileNum) const =0</td></tr><tr class="separator:a6a5540f6db6e89fbe1348abfdd55b829"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6afd3624bdab8f93a8a91100f4c41d66"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6afd3624bdab8f93a8a91100f4c41d66"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetTextSpanInTile</b> (int32 span, int32 tileNum=0)=0</td></tr><tr class="separator:a6afd3624bdab8f93a8a91100f4c41d66"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a84bff81e4d6552b87b282200d5df4417"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a84bff81e4d6552b87b282200d5df4417">GetUnjustifiedTextWidthInTile</a> (int32 tileNum) const =0</td></tr><tr class="separator:a84bff81e4d6552b87b282200d5df4417"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aec3cbed4c007cd599dfbd9f734f65035"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aec3cbed4c007cd599dfbd9f734f65035"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetUnjustifiedTextWidthInTile</b> (<a class="el" href="class_p_m_real.html">PMReal</a> unJTW, int32 tileNum=0)=0</td></tr><tr class="separator:aec3cbed4c007cd599dfbd9f734f65035"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa6ca568306f9166e6ba49db8428b92ed"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#aa6ca568306f9166e6ba49db8428b92ed">GetJustifiedTextWidthInTile</a> (int32 tileNum) const =0</td></tr><tr class="separator:aa6ca568306f9166e6ba49db8428b92ed"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a115e7e86130768d64c351b682912aede"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a115e7e86130768d64c351b682912aede"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetJustifiedTextWidthInTile</b> (<a class="el" href="class_p_m_real.html">PMReal</a> justWidth, int32 tileNum=0)=0</td></tr><tr class="separator:a115e7e86130768d64c351b682912aede"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab8672a2994da2d09839180ca4d5c67b5"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#ab8672a2994da2d09839180ca4d5c67b5">TextOrigin</a> (const <a class="el" href="class_i_wax_run.html">IWaxRun</a> *waxRun=nil) const =0</td></tr><tr class="separator:ab8672a2994da2d09839180ca4d5c67b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac2c013620de97e88d85d46b52f7ef087"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac2c013620de97e88d85d46b52f7ef087"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetYAdvance</b> () const =0</td></tr><tr class="separator:ac2c013620de97e88d85d46b52f7ef087"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a14c84ab9c291ff912731496814f6ac22"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a14c84ab9c291ff912731496814f6ac22"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNumberOfTiles</b> () const =0</td></tr><tr class="separator:a14c84ab9c291ff912731496814f6ac22"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4541d839a7102fb1ee471a414504fb86"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4541d839a7102fb1ee471a414504fb86"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetNumberOfTiles</b> (int32 numTiles)=0</td></tr><tr class="separator:a4541d839a7102fb1ee471a414504fb86"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c4402036548b2383fc08912d058a783"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a9c4402036548b2383fc08912d058a783">GetXPosition</a> (int32 tileNum=0) const =0</td></tr><tr class="separator:a9c4402036548b2383fc08912d058a783"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ade502469d13e3b4712305ce4279fe601"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ade502469d13e3b4712305ce4279fe601"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetXPosition</b> (<a class="el" href="class_p_m_real.html">PMReal</a> xPosition, int32 tileNum=0)=0</td></tr><tr class="separator:ade502469d13e3b4712305ce4279fe601"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2c4997618ce2ef8f08a8a144858c5993"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a2c4997618ce2ef8f08a8a144858c5993">GetYPosition</a> () const =0</td></tr><tr class="separator:a2c4997618ce2ef8f08a8a144858c5993"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3d3b63e9ac243afcb2905ee420fed2ec"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a3d3b63e9ac243afcb2905ee420fed2ec">GetTransform</a> () const =0</td></tr><tr class="separator:a3d3b63e9ac243afcb2905ee420fed2ec"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a25e4ef274fa4bb77051374667e6a0d2d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a25e4ef274fa4bb77051374667e6a0d2d">GetToParcelMatrix</a> () const =0</td></tr><tr class="separator:a25e4ef274fa4bb77051374667e6a0d2d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a80238868eeeba128223ca6d838eff331"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a80238868eeeba128223ca6d838eff331">GetToFrameMatrix</a> () const =0</td></tr><tr class="separator:a80238868eeeba128223ca6d838eff331"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1994c817134ba2366a78b0003c07e23a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a1994c817134ba2366a78b0003c07e23a">GetToSpreadMatrix</a> () const =0</td></tr><tr class="separator:a1994c817134ba2366a78b0003c07e23a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aec87473f21ae53fa4b1407b64f65d442"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#aec87473f21ae53fa4b1407b64f65d442">GetToPasteboardMatrix</a> () const =0</td></tr><tr class="separator:aec87473f21ae53fa4b1407b64f65d442"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac4960fcb87a12d8b7135c6361e895510"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac4960fcb87a12d8b7135c6361e895510"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetLineHeight</b> () const =0</td></tr><tr class="separator:ac4960fcb87a12d8b7135c6361e895510"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af486adbe8dba3da4bab2e1dcc6f766b7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af486adbe8dba3da4bab2e1dcc6f766b7"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetLineHeight</b> (<a class="el" href="class_p_m_real.html">PMReal</a> lineHeight)=0</td></tr><tr class="separator:af486adbe8dba3da4bab2e1dcc6f766b7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4cf975f0d80c90dc55aeb7c03dc02c9f"><td align="right" class="memItemLeft" valign="top">virtual Text::LeadingModel&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a4cf975f0d80c90dc55aeb7c03dc02c9f">GetLeadingModel</a> () const =0</td></tr><tr class="separator:a4cf975f0d80c90dc55aeb7c03dc02c9f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2d158f5c05248fff6ba530ffcdaae8f8"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2d158f5c05248fff6ba530ffcdaae8f8"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetLeadingModel</b> (Text::LeadingModel m)=0</td></tr><tr class="separator:a2d158f5c05248fff6ba530ffcdaae8f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a18dc2e17541557ca5bf4bb092522067e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a18dc2e17541557ca5bf4bb092522067e">GetLineHeightLeadingDiff</a> () const =0</td></tr><tr class="separator:a18dc2e17541557ca5bf4bb092522067e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a884a317d75b5d5b82e740824177824"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5a884a317d75b5d5b82e740824177824"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetLineHeightLeadingDiff</b> (<a class="el" href="class_p_m_real.html">PMReal</a> lineHeight)=0</td></tr><tr class="separator:a5a884a317d75b5d5b82e740824177824"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6955f1e69e85bd6d04ce17d7d17d8ef3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a6955f1e69e85bd6d04ce17d7d17d8ef3">GetLeadingModelOffset</a> () const =0</td></tr><tr class="separator:a6955f1e69e85bd6d04ce17d7d17d8ef3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa8b060eba13d6defae9e20ce04b1890e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa8b060eba13d6defae9e20ce04b1890e"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetLeadingModelOffset</b> (<a class="el" href="class_p_m_real.html">PMReal</a> offset)=0</td></tr><tr class="separator:aa8b060eba13d6defae9e20ce04b1890e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a19a8594a7558b2e73c15ad63ebbd2dec"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a19a8594a7558b2e73c15ad63ebbd2dec">GetWidth</a> (bool16 ignoreAllTrailing=kFalse) const =0</td></tr><tr class="separator:a19a8594a7558b2e73c15ad63ebbd2dec"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adf3016007f9efbe079c1344bc8fd0beb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="adf3016007f9efbe079c1344bc8fd0beb"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTargetWidth</b> (int32 tileNum=0) const =0</td></tr><tr class="separator:adf3016007f9efbe079c1344bc8fd0beb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a63c2ff2db238743b0377a8c2938b8000"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a63c2ff2db238743b0377a8c2938b8000"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetTargetWidth</b> (<a class="el" href="class_p_m_real.html">PMReal</a> targetWidth, int32 tileNum=0)=0</td></tr><tr class="separator:a63c2ff2db238743b0377a8c2938b8000"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aefb6d2dbc3f84c9ae405c6df3b7b0658"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#aefb6d2dbc3f84c9ae405c6df3b7b0658">SetJustificationViolationAmt</a> (int16 jva) const =0</td></tr><tr class="separator:aefb6d2dbc3f84c9ae405c6df3b7b0658"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a03989c57d6bd4b001acb3fbb9f1ae32c"><td align="right" class="memItemLeft" valign="top">virtual int16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a03989c57d6bd4b001acb3fbb9f1ae32c">GetJustificationViolationAmt</a> () const =0</td></tr><tr class="separator:a03989c57d6bd4b001acb3fbb9f1ae32c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a27ce77b39c6c76c13593e2a96bd0dad7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a27ce77b39c6c76c13593e2a96bd0dad7">SetHyphenationViolation</a> (bool16 violation)=0</td></tr><tr class="separator:a27ce77b39c6c76c13593e2a96bd0dad7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a36d916315650a51654da229139cf7069"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a36d916315650a51654da229139cf7069">GetHyphenationViolation</a> () const =0</td></tr><tr class="separator:a36d916315650a51654da229139cf7069"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a04370df9ac9d919a7c6406a6536e30d5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a04370df9ac9d919a7c6406a6536e30d5">SetLineTightness</a> (IWaxLine::LineTightness t)=0</td></tr><tr class="separator:a04370df9ac9d919a7c6406a6536e30d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afa4e51baf75aa57dff81e77dbd982480"><td align="right" class="memItemLeft" valign="top">virtual IWaxLine::LineTightness&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#afa4e51baf75aa57dff81e77dbd982480">GetLineTightness</a> () const =0</td></tr><tr class="separator:afa4e51baf75aa57dff81e77dbd982480"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad31c7493b0263e317d600f5abefbcfcc"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad31c7493b0263e317d600f5abefbcfcc"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetKeepsViolation</b> (bool16 onOff)=0</td></tr><tr class="separator:ad31c7493b0263e317d600f5abefbcfcc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a11ea58b53fd7efc0264a4d21bbee483a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a11ea58b53fd7efc0264a4d21bbee483a"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetKeepsViolation</b> () const =0</td></tr><tr class="separator:a11ea58b53fd7efc0264a4d21bbee483a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a36a045a62a2bc1076863ad3f0a3519ee"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a36a045a62a2bc1076863ad3f0a3519ee">SetComposedWithMissingFont</a> (bool16 missing)=0</td></tr><tr class="separator:a36a045a62a2bc1076863ad3f0a3519ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a1ad2fb25156dd00324780c2c4be7c3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a5a1ad2fb25156dd00324780c2c4be7c3">GetComposedWithMissingFont</a> () const =0</td></tr><tr class="separator:a5a1ad2fb25156dd00324780c2c4be7c3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6db8accc3da862d6d2b3124a0ea491b1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6db8accc3da862d6d2b3124a0ea491b1"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetHyphenState</b> (bool16 endsWithHyphen)=0</td></tr><tr class="separator:a6db8accc3da862d6d2b3124a0ea491b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9ae3c2ea0f4535729c5236f8f6c1e757"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9ae3c2ea0f4535729c5236f8f6c1e757"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>LineEndsWithHyphen</b> () const =0</td></tr><tr class="separator:a9ae3c2ea0f4535729c5236f8f6c1e757"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aea0e2f96c62a3abbf8869606fe6ead03"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#aea0e2f96c62a3abbf8869606fe6ead03">SetAlwaysRegenerate</a> (bool16) const =0</td></tr><tr class="separator:aea0e2f96c62a3abbf8869606fe6ead03"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a174816a3db7eeb3406fda4fc1a01b21e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a174816a3db7eeb3406fda4fc1a01b21e"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetAlwaysRegenerate</b> () const =0</td></tr><tr class="separator:a174816a3db7eeb3406fda4fc1a01b21e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9df0f3610405211ab4da26fa72b51993"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9df0f3610405211ab4da26fa72b51993"></a> virtual Text::GridAlignmentMetric&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetGridAlignmentMetric</b> () const =0</td></tr><tr class="separator:a9df0f3610405211ab4da26fa72b51993"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af0a85092fe40b14b8ec4c4053700a034"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af0a85092fe40b14b8ec4c4053700a034"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetGridAlignmentMetricOffset</b> () const =0</td></tr><tr class="separator:af0a85092fe40b14b8ec4c4053700a034"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0365794f485c9516b600b5d40a1776a0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0365794f485c9516b600b5d40a1776a0"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetGridAlignment</b> (Text::GridAlignmentMetric alignment, <a class="el" href="class_p_m_real.html">PMReal</a> metricOffset=0.0)=0</td></tr><tr class="separator:a0365794f485c9516b600b5d40a1776a0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2f383e6719e2ebab9ce1e9e296a513ee"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2f383e6719e2ebab9ce1e9e296a513ee"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetNoShuffle</b> (bool16 s)=0</td></tr><tr class="separator:a2f383e6719e2ebab9ce1e9e296a513ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2b7570972fc69cb45f56573fac6e7720"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2b7570972fc69cb45f56573fac6e7720"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNoShuffle</b> () const =0</td></tr><tr class="separator:a2b7570972fc69cb45f56573fac6e7720"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4be21290d72dac3bec6536a81d1a4aa4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4be21290d72dac3bec6536a81d1a4aa4"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetNoShuffleToParcelBottom</b> (bool16 s)=0</td></tr><tr class="separator:a4be21290d72dac3bec6536a81d1a4aa4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a33a5ba8fca5fe119e21ea08190d1a272"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a33a5ba8fca5fe119e21ea08190d1a272"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNoShuffleToParcelBottom</b> () const =0</td></tr><tr class="separator:a33a5ba8fca5fe119e21ea08190d1a272"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a86cffae53f6d3741273f8eb89ac758fe"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a86cffae53f6d3741273f8eb89ac758fe"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetRebuildRunsWhenShuffled</b> (bool16 b)=0</td></tr><tr class="separator:a86cffae53f6d3741273f8eb89ac758fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac91348b9054d9ebd3d210fdb7e87f762"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac91348b9054d9ebd3d210fdb7e87f762"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetRebuildRunsWhenShuffled</b> () const =0</td></tr><tr class="separator:ac91348b9054d9ebd3d210fdb7e87f762"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad89a11b33ace454342543139e697af28"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad89a11b33ace454342543139e697af28"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTOFLineHeight</b> () const =0</td></tr><tr class="separator:ad89a11b33ace454342543139e697af28"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a485baf48be51053993b2a5731bd8b98c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a485baf48be51053993b2a5731bd8b98c"></a> virtual Text::FirstLineOffsetMetric&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTOFLineHeightMetric</b> () const =0</td></tr><tr class="separator:a485baf48be51053993b2a5731bd8b98c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2a15e1963847ca0e137c3e448b658f42"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2a15e1963847ca0e137c3e448b658f42"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetTOFLineHeight</b> (<a class="el" href="class_p_m_real.html">PMReal</a> lineHeight, Text::FirstLineOffsetMetric lineHeightMetric)=0</td></tr><tr class="separator:a2a15e1963847ca0e137c3e448b658f42"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a90df5449071f57298e66b1e69a2df2b9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a90df5449071f57298e66b1e69a2df2b9"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetAtTOF</b> (bool16 v)=0</td></tr><tr class="separator:a90df5449071f57298e66b1e69a2df2b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad01b595cdc3e0140376acdb806c7eddf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad01b595cdc3e0140376acdb806c7eddf"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetAtTOF</b> () const =0</td></tr><tr class="separator:ad01b595cdc3e0140376acdb806c7eddf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a46bf2e7476036c6d35b0a9f35fe3af26"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a46bf2e7476036c6d35b0a9f35fe3af26"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetHasOwnedItem</b> (bool16 v)=0</td></tr><tr class="separator:a46bf2e7476036c6d35b0a9f35fe3af26"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a104ac914b98900547d43b180e11c18c2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a104ac914b98900547d43b180e11c18c2"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetHasOwnedItem</b> () const =0</td></tr><tr class="separator:a104ac914b98900547d43b180e11c18c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a96a5a4c8e1b00d2b47d2a32f44c293a6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a96a5a4c8e1b00d2b47d2a32f44c293a6">SetParcelPositionDependent</a> (bool16 v)=0</td></tr><tr class="separator:a96a5a4c8e1b00d2b47d2a32f44c293a6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa1fc6016d4dc5f17ecf11e04f7527562"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa1fc6016d4dc5f17ecf11e04f7527562"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetParcelPositionDependent</b> () const =0</td></tr><tr class="separator:aa1fc6016d4dc5f17ecf11e04f7527562"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a43b9e64a4ded9b0b5a954a9eb5c8fa45"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a43b9e64a4ded9b0b5a954a9eb5c8fa45"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIndentHerePosition</b> () const =0</td></tr><tr class="separator:a43b9e64a4ded9b0b5a954a9eb5c8fa45"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a66d2f68e75ba8dcd5692ed6f669b5bfa"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a66d2f68e75ba8dcd5692ed6f669b5bfa"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetIndentHerePosition</b> (<a class="el" href="class_p_m_real.html">PMReal</a> r)=0</td></tr><tr class="separator:a66d2f68e75ba8dcd5692ed6f669b5bfa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5c708eeec754294458436eefdf074e21"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a5c708eeec754294458436eefdf074e21">SetStoryThread</a> (<a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> *thread)=0</td></tr><tr class="separator:a5c708eeec754294458436eefdf074e21"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6c239eb7cda3778e901c68cee4410e17"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6c239eb7cda3778e901c68cee4410e17"></a> virtual <a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryStoryThread</b> () const =0</td></tr><tr class="separator:a6c239eb7cda3778e901c68cee4410e17"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae010ebd1a3a6fcbfe7c22c426c399746"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#ae010ebd1a3a6fcbfe7c22c426c399746">IsDamaged</a> () const =0</td></tr><tr class="separator:ae010ebd1a3a6fcbfe7c22c426c399746"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1c7a30e01d343ee56191ebf0b53a8662"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1c7a30e01d343ee56191ebf0b53a8662"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>IsGeometryDamaged</b> () const =0</td></tr><tr class="separator:a1c7a30e01d343ee56191ebf0b53a8662"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae4c28621fb1578085f3772ff221dd5ca"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae4c28621fb1578085f3772ff221dd5ca"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>IsKeepsDamaged</b> () const =0</td></tr><tr class="separator:ae4c28621fb1578085f3772ff221dd5ca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a93d2034a08a4730fb3a8113e4cbbf8f3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a93d2034a08a4730fb3a8113e4cbbf8f3"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>IsContentDamaged</b> () const =0</td></tr><tr class="separator:a93d2034a08a4730fb3a8113e4cbbf8f3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2a5ad7b50160631415d90ff9d4c11350"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2a5ad7b50160631415d90ff9d4c11350"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>IsDestroyed</b> () const =0</td></tr><tr class="separator:a2a5ad7b50160631415d90ff9d4c11350"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7c685f62c79ae926696c9d5707f52c8a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7c685f62c79ae926696c9d5707f52c8a"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetContentDamaged</b> ()=0</td></tr><tr class="separator:a7c685f62c79ae926696c9d5707f52c8a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae46c72a9c8f31c529519091cbc317bdb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae46c72a9c8f31c529519091cbc317bdb"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetGeometryDamaged</b> ()=0</td></tr><tr class="separator:ae46c72a9c8f31c529519091cbc317bdb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae8b420009e42669966d7546a7df20955"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae8b420009e42669966d7546a7df20955"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetKeepsDamaged</b> ()=0</td></tr><tr class="separator:ae8b420009e42669966d7546a7df20955"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae498b8b4a756658ba610894f2a988a3b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae498b8b4a756658ba610894f2a988a3b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetDestroyed</b> ()=0</td></tr><tr class="separator:ae498b8b4a756658ba610894f2a988a3b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa8b778c64e1a40c7ceaab3ba7765f66a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa8b778c64e1a40c7ceaab3ba7765f66a"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClearDamage</b> ()=0</td></tr><tr class="separator:aa8b778c64e1a40c7ceaab3ba7765f66a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab32f4f00cc06b8592689ca5b657c020f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#ab32f4f00cc06b8592689ca5b657c020f">Inval</a> (<a class="el" href="class_i_parcel_list.html">IParcelList</a> *pl, const <a class="el" href="class_p_m_rect.html">PMRect</a> *alternateInk=nil) const =0</td></tr><tr class="separator:ab32f4f00cc06b8592689ca5b657c020f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa6661b38f703d242e9eeb80ac3f4a56c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa6661b38f703d242e9eeb80ac3f4a56c"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetWaxAnchorPt</b> (bool16)=0</td></tr><tr class="separator:aa6661b38f703d242e9eeb80ac3f4a56c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4694d0eb5c266fac92e78934d9ea8168"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4694d0eb5c266fac92e78934d9ea8168"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetIsWaxAnchorPt</b> () const =0</td></tr><tr class="separator:a4694d0eb5c266fac92e78934d9ea8168"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a70a37c58e7d16d4da0ed477e55b704bf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a70a37c58e7d16d4da0ed477e55b704bf"></a> virtual <a class="el" href="class_i_wax_strand.html">IWaxStrand</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryWaxStrand</b> () const =0</td></tr><tr class="separator:a70a37c58e7d16d4da0ed477e55b704bf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae3b3c56b3ff25b835ab95aecbd1e5d77"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae3b3c56b3ff25b835ab95aecbd1e5d77"></a> virtual <a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryTextModel</b> () const =0</td></tr><tr class="separator:ae3b3c56b3ff25b835ab95aecbd1e5d77"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a94317be955a0ce6b6ef14b05df37a44c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a94317be955a0ce6b6ef14b05df37a44c">GetLineMetricOffset</a> (<a class="el" href="class_i_drawing_style.html#ac16d7a2da883be642725a47ec6b69b74">IDrawingStyle::CharacterHang</a> hangType) const =0</td></tr><tr class="separator:a94317be955a0ce6b6ef14b05df37a44c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a683b782d647eed0c083b52d0aef7448b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a683b782d647eed0c083b52d0aef7448b">SetLineTextOrigin</a> (const TextIndex absoluteTextIndex)=0</td></tr><tr class="separator:a683b782d647eed0c083b52d0aef7448b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2a1024c4543f9c52b4f622da0690a996"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a2a1024c4543f9c52b4f622da0690a996">GetContentBottom</a> () const =0</td></tr><tr class="separator:a2a1024c4543f9c52b4f622da0690a996"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1faaa0f8d39ab3410ac0a1281c1d477b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a1faaa0f8d39ab3410ac0a1281c1d477b">SetRequiresCallToListInvalService</a> (bool16 requiresCall)=0</td></tr><tr class="separator:a1faaa0f8d39ab3410ac0a1281c1d477b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a31265620452341aa0339cf6891c422fe"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a31265620452341aa0339cf6891c422fe"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetRequiresCallToListInvalService</b> () const =0</td></tr><tr class="separator:a31265620452341aa0339cf6891c422fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7700029eb7e129d1acd3b9bb4c98d207"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a7700029eb7e129d1acd3b9bb4c98d207">SetKeepWithPrevExternal</a> (bool16 v)=0</td></tr><tr class="separator:a7700029eb7e129d1acd3b9bb4c98d207"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7d8fc042805dce20ca722d04d05c411f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7d8fc042805dce20ca722d04d05c411f"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetKeepWithPrevExternal</b> () const =0</td></tr><tr class="separator:a7d8fc042805dce20ca722d04d05c411f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a777bad8995480099b58fa7ff623cfebd"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a777bad8995480099b58fa7ff623cfebd">SetKeepWithPrevParaLastLine</a> (bool16 v)=0</td></tr><tr class="separator:a777bad8995480099b58fa7ff623cfebd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1342223804b7f1e8758e50009d246b70"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1342223804b7f1e8758e50009d246b70"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetKeepWithPrevParaLastLine</b> () const =0</td></tr><tr class="separator:a1342223804b7f1e8758e50009d246b70"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88d661988ee6cfc225061d0513895371"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a88d661988ee6cfc225061d0513895371">SetKeepWithPrevFirst</a> (bool16 v)=0</td></tr><tr class="separator:a88d661988ee6cfc225061d0513895371"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac53715629ad5350bd97406b07c020465"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac53715629ad5350bd97406b07c020465"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetKeepWithPrevFirst</b> () const =0</td></tr><tr class="separator:ac53715629ad5350bd97406b07c020465"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a055932e734794f1b2b0f22745e9a5a27"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a055932e734794f1b2b0f22745e9a5a27">SetKeepWithPrevLast</a> (bool16 v)=0</td></tr><tr class="separator:a055932e734794f1b2b0f22745e9a5a27"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a881a27ff733fbbfbfcd0d773e246bc65"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a881a27ff733fbbfbfcd0d773e246bc65"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetKeepWithPrevLast</b> () const =0</td></tr><tr class="separator:a881a27ff733fbbfbfcd0d773e246bc65"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afef2a78e4cdbde0c745e940e463406f7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#afef2a78e4cdbde0c745e940e463406f7">SetNeedsPostProcessing</a> (bool16 v)=0</td></tr><tr class="separator:afef2a78e4cdbde0c745e940e463406f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab1de82a89a320d26d16ecdea70146342"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab1de82a89a320d26d16ecdea70146342"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNeedsPostProcessing</b> () const =0</td></tr><tr class="separator:ab1de82a89a320d26d16ecdea70146342"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a60e6a28a052360077f9e2eb54562e999"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a60e6a28a052360077f9e2eb54562e999">SetComposerWasSwappedToSingle</a> (bool16 v)=0</td></tr><tr class="separator:a60e6a28a052360077f9e2eb54562e999"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac4a4c8fbe67ca00a4bda15b4098dcd44"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac4a4c8fbe67ca00a4bda15b4098dcd44"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetComposerWasSwappedToSingle</b> () const =0</td></tr><tr class="separator:ac4a4c8fbe67ca00a4bda15b4098dcd44"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9360c0d7247b13462f696544c78e04e5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a9360c0d7247b13462f696544c78e04e5">SetCompositionYPosition</a> (<a class="el" href="class_p_m_real.html">PMReal</a> compYPos)=0</td></tr><tr class="separator:a9360c0d7247b13462f696544c78e04e5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7da34cd7ce1c5e0dbd1ce7b73819f55f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7da34cd7ce1c5e0dbd1ce7b73819f55f"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetCompositionYPosition</b> () const =0</td></tr><tr class="separator:a7da34cd7ce1c5e0dbd1ce7b73819f55f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4a0c3e4526fc2893e0d90e5720abc20c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4a0c3e4526fc2893e0d90e5720abc20c"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetYPositionAdjValid</b> () const =0</td></tr><tr class="separator:a4a0c3e4526fc2893e0d90e5720abc20c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a27c6ccdcf390a384c43d165c67e507c7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a27c6ccdcf390a384c43d165c67e507c7"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetYPositionAdj</b> (<a class="el" href="class_p_m_real.html">PMReal</a> yPosAdj)=0</td></tr><tr class="separator:a27c6ccdcf390a384c43d165c67e507c7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae4844cd62e2160c26fa51c3fb3f2825b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae4844cd62e2160c26fa51c3fb3f2825b"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetYPositionAdj</b> () const =0</td></tr><tr class="separator:ae4844cd62e2160c26fa51c3fb3f2825b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7cebf8513eba8c9eea13862d5a1e9dbf"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a7cebf8513eba8c9eea13862d5a1e9dbf">SetBreakMode</a> (Text::StartBreakLocation bl)=0</td></tr><tr class="separator:a7cebf8513eba8c9eea13862d5a1e9dbf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aae877383a54e3b9a675c336a6123f332"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aae877383a54e3b9a675c336a6123f332"></a> virtual Text::StartBreakLocation&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetBreakMode</b> () const =0</td></tr><tr class="separator:aae877383a54e3b9a675c336a6123f332"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab69d6bcab799afdcfd124beb8ccad253"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab69d6bcab799afdcfd124beb8ccad253"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetGotoNextX</b> (Text::StartBreakLocation nx)=0</td></tr><tr class="separator:ab69d6bcab799afdcfd124beb8ccad253"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a29303c90ecb1a06fdfe1dc324eca5db1"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a29303c90ecb1a06fdfe1dc324eca5db1"></a> virtual Text::StartBreakLocation&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetGotoNextX</b> () const =0</td></tr><tr class="separator:a29303c90ecb1a06fdfe1dc324eca5db1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a191bf09d1da5f8c23efa9c02673233d2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a191bf09d1da5f8c23efa9c02673233d2"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetSpaceBefore</b> (<a class="el" href="class_p_m_real.html">PMReal</a> sb)=0</td></tr><tr class="separator:a191bf09d1da5f8c23efa9c02673233d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae6ae7f9e6a39c0911d26c4d51901a2c3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae6ae7f9e6a39c0911d26c4d51901a2c3"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSpaceBefore</b> () const =0</td></tr><tr class="separator:ae6ae7f9e6a39c0911d26c4d51901a2c3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac9db8e26d811159ba99fe793bd85a19b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac9db8e26d811159ba99fe793bd85a19b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetSpaceAfter</b> (<a class="el" href="class_p_m_real.html">PMReal</a> sa)=0</td></tr><tr class="separator:ac9db8e26d811159ba99fe793bd85a19b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa5d7db47854e0f568dcd1bfc6be34e31"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa5d7db47854e0f568dcd1bfc6be34e31"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSpaceAfter</b> () const =0</td></tr><tr class="separator:aa5d7db47854e0f568dcd1bfc6be34e31"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a365bad2eb6e7abe287f5f57be71e334a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a365bad2eb6e7abe287f5f57be71e334a"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetSameParaSpacing</b> (<a class="el" href="class_p_m_real.html">PMReal</a> sb)=0</td></tr><tr class="separator:a365bad2eb6e7abe287f5f57be71e334a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abc04a92069ebea224b6e118b8366ca47"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abc04a92069ebea224b6e118b8366ca47"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSameParaSpacing</b> () const =0</td></tr><tr class="separator:abc04a92069ebea224b6e118b8366ca47"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a381a4729640e0527f3301505a45ab1a4"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a381a4729640e0527f3301505a45ab1a4">SetSpaceAfterIsSticky</a> (bool16 v)=0</td></tr><tr class="separator:a381a4729640e0527f3301505a45ab1a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a80b6734296e3dcf5acf9c12a73a703b5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a80b6734296e3dcf5acf9c12a73a703b5"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSpaceAfterIsSticky</b> () const =0</td></tr><tr class="separator:a80b6734296e3dcf5acf9c12a73a703b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae919d10bb649ebe5558383a835bffa87"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae919d10bb649ebe5558383a835bffa87"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetKeepWithNextNLines</b> (int32 n)=0</td></tr><tr class="separator:ae919d10bb649ebe5558383a835bffa87"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:add1544c19e46b4fd6879d49ae73d30fe"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="add1544c19e46b4fd6879d49ae73d30fe"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetKeepWithNextNLines</b> () const =0</td></tr><tr class="separator:add1544c19e46b4fd6879d49ae73d30fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9ed73f857630c4289881eefb14d4ba9a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9ed73f857630c4289881eefb14d4ba9a"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetKeepLastNLines</b> (int32 n)=0</td></tr><tr class="separator:a9ed73f857630c4289881eefb14d4ba9a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a48e13a32f922e6e131e479d538237ddf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a48e13a32f922e6e131e479d538237ddf"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetKeepLastNLines</b> () const =0</td></tr><tr class="separator:a48e13a32f922e6e131e479d538237ddf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a377713cab4b1b6f831fc6077fe448560"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a377713cab4b1b6f831fc6077fe448560">GetYPositionAdjIgnored</a> () const =0</td></tr><tr class="separator:a377713cab4b1b6f831fc6077fe448560"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c44606cee30d088cd32a85bce95326b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8c44606cee30d088cd32a85bce95326b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetYPositionAdjIgnored</b> ()=0</td></tr><tr class="separator:a8c44606cee30d088cd32a85bce95326b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab34de1ce553ffb37f57cf5094545aeee"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#ab34de1ce553ffb37f57cf5094545aeee">SetBulletNumberOffset</a> (<a class="el" href="class_p_m_real.html">PMReal</a> bnp)=0</td></tr><tr class="separator:ab34de1ce553ffb37f57cf5094545aeee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a983ef007dfd57c64231334660a97d74e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a983ef007dfd57c64231334660a97d74e"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetBulletNumberOffset</b> () const =0</td></tr><tr class="separator:a983ef007dfd57c64231334660a97d74e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5f710a638de4725e521769b07ee39398"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a5f710a638de4725e521769b07ee39398">GetHasColumnSpanOrSplit</a> () const =0</td></tr><tr class="separator:a5f710a638de4725e521769b07ee39398"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a334d5ee8f78d3b6e78d96acedbe4ba1a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a334d5ee8f78d3b6e78d96acedbe4ba1a">SetColumnSpan</a> (uchar count)=0</td></tr><tr class="separator:a334d5ee8f78d3b6e78d96acedbe4ba1a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aea688ea1d382a3eb3b3fe2fe6b1a91e9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#aea688ea1d382a3eb3b3fe2fe6b1a91e9">GetColumnSpan</a> (uchar *pCount=nil) const =0</td></tr><tr class="separator:aea688ea1d382a3eb3b3fe2fe6b1a91e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4ce121b7895a5a9ba88c0b263a54b65e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a4ce121b7895a5a9ba88c0b263a54b65e">SetColumnSplit</a> (uchar count, <a class="el" href="class_p_m_real.html">PMReal</a> insideGutter, <a class="el" href="class_p_m_real.html">PMReal</a> outsideGutter)=0</td></tr><tr class="separator:a4ce121b7895a5a9ba88c0b263a54b65e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0c8085f4e89b7a73873528366e47f20e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a0c8085f4e89b7a73873528366e47f20e">GetColumnSplit</a> (uchar *pCount=nil, <a class="el" href="class_p_m_real.html">PMReal</a> *pInsideGutter=nil, <a class="el" href="class_p_m_real.html">PMReal</a> *pOutsideGutter=nil) const =0</td></tr><tr class="separator:a0c8085f4e89b7a73873528366e47f20e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad2f12b75f95075dc0d79282691486539"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#ad2f12b75f95075dc0d79282691486539">InvalidateRuns</a> ()=0</td></tr><tr class="separator:ad2f12b75f95075dc0d79282691486539"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a712363b6f918f6a47ed378445d176562"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a712363b6f918f6a47ed378445d176562"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetRunsWereInvalidated</b> () const =0</td></tr><tr class="separator:a712363b6f918f6a47ed378445d176562"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a85cb8a9eeb2d64fdf90de66339e275f5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a85cb8a9eeb2d64fdf90de66339e275f5"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClearRunsWereInvalidated</b> ()=0</td></tr><tr class="separator:a85cb8a9eeb2d64fdf90de66339e275f5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3021432e962ff674fae4c736eef95ad3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a3021432e962ff674fae4c736eef95ad3">SetHasWAENoFitInParcel</a> (bool16, const <a class="el" href="class_parcel_key.html">ParcelKey</a> &amp;)=0</td></tr><tr class="separator:a3021432e962ff674fae4c736eef95ad3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a953865257aabf95cc1f3da79b36dffda"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a953865257aabf95cc1f3da79b36dffda"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetHasWAENoFitInParcel</b> (<a class="el" href="class_parcel_key.html">ParcelKey</a> &amp;) const =0</td></tr><tr class="separator:a953865257aabf95cc1f3da79b36dffda"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa6a940e26888d5c030ec641545a086bc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#aa6a940e26888d5c030ec641545a086bc">SetParaShadingOn</a> (bool16 bParaShadingOn)=0</td></tr><tr class="separator:aa6a940e26888d5c030ec641545a086bc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afe14785579d39159f56c0cd50893a1a9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="afe14785579d39159f56c0cd50893a1a9"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasParaShadingOn</b> () const =0</td></tr><tr class="separator:afe14785579d39159f56c0cd50893a1a9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a29aa95ccec18b263a816421be20ee370"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a29aa95ccec18b263a816421be20ee370">SetParaBorderOn</a> (bool16 bParaBorderOn)=0</td></tr><tr class="separator:a29aa95ccec18b263a816421be20ee370"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a591944f92674a55dcf8673bf67995f40"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a591944f92674a55dcf8673bf67995f40"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasParaBorderOn</b> () const =0</td></tr><tr class="separator:a591944f92674a55dcf8673bf67995f40"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a18dcad87d3e9e58b00743e4768c8fb47"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_wax_line.html#a18dcad87d3e9e58b00743e4768c8fb47">SetParaBorderMergingOn</a> (bool16 bParaBorderMergingOn)=0</td></tr><tr class="separator:a18dcad87d3e9e58b00743e4768c8fb47"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5bbdee59c11b7849c09152e202a96ef5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5bbdee59c11b7849c09152e202a96ef5"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasParaBorderMergingOn</b> () const =0</td></tr><tr class="separator:a5bbdee59c11b7849c09152e202a96ef5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>This interface manages the hierarchy for the wax-line. It also stores the position of the line and many other properties such as leading. </div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a29ef1b105f45e60dccc73e8d601d728a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::DoWaxRunsExist </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Are the IWaxRuns for this line already built? </div></div><a class="anchor" id="a094f18b89738ce7b15959947ded2cd26"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::EndsLine </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_wax_run.html">IWaxRun</a> *&nbsp;</td><td class="paramname"><em>waxRun</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Does this <a class="el" href="class_i_wax_run.html">IWaxRun</a> end the line? </div></div><a class="anchor" id="aea688ea1d382a3eb3b3fe2fe6b1a91e9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::GetColumnSpan </td><td>(</td><td class="paramtype">uchar *&nbsp;</td><td class="paramname"><em>pCount</em> = <code>nil</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the current column span value. Note that only the first WaxLine of the paragraph can be expected to have this value set, all other intra para WaxLines will not. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pCount</td><td>Optional pointer to value which will be set to the span IF a column span has been previously set. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if a column span was previously set, kFalse otherwise </dl></div></div><a class="anchor" id="a0c8085f4e89b7a73873528366e47f20e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::GetColumnSplit </td><td>(</td><td class="paramtype">uchar *&nbsp;</td><td class="paramname"><em>pCount</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>pInsideGutter</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>pOutsideGutter</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the current column split value. Note that only the first WaxLine of the paragraph can be expected to have this value set, all other intra para WaxLines will not. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pCount</td><td>Optional pointer to value which will be to the split count IF a column split has been previously set. </td></tr><tr><td class="paramname">pInsideGutter</td><td>Optional pointer to value which will be to the inside gutter width IF a column split has been previously set. </td></tr><tr><td class="paramname">pOutsideGutter</td><td>Optional pointer to value which will be to the outside gutter width IF a column split has been previously set. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if a column split was previously set, kFalse otherwise </dl></div></div><a class="anchor" id="a5a1ad2fb25156dd00324780c2c4be7c3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::GetComposedWithMissingFont </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetComposedWithMissingFont indicates whether this line&#39;s ending was decided using a missing font. When this occurs, we will force this line to recompose when opening the document if the font is back. <dl class="section return"><dt>Returns<dd>specifies if a missing font had to be used. </dl></div></div><a class="anchor" id="a2a1024c4543f9c52b4f622da0690a996"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetContentBottom </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the effective content bottom of the WaxLine. This value is used for fit-frame-to-content and cell autogrow computation. For normal lines this is simply the Y Position of the line. For lines containing Dropcaps and WaxAnchorPts this computation is slightly different. The content Top of the line is still the LineHeight or TOFLineHeight. </div></div><a class="anchor" id="a74f5631b678ae81f0abb96ead309e9d5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_data_base.html">IDataBase</a>* IWaxLine::GetDataBase </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the database containing this wax </div></div><a class="anchor" id="a8eb4f6e0260cf63e1e2931c7c2adbb5e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IWaxLine::GetDropCapIndents </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>indents</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>lineCounts</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>returns number of indents, will copy them if the pointers are non-nil </div></div><a class="anchor" id="a5f710a638de4725e521769b07ee39398"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::GetHasColumnSpanOrSplit </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>By default, WaxLines compose in a single &quot;column&quot;. Paragraph attributes exist that allow them to span more than one column OR split a single column into two or more sub-columns. <dl class="section return"><dt>Returns<dd>kTrue if the WaxLine is the first WaxLine of the paragraph which is spanning or splitting columns, kFalse otherwise. </dl></div></div><a class="anchor" id="a36d916315650a51654da229139cf7069"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::GetHyphenationViolation </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetHyphenationViolation indicates whether a hyphenation violation occurred <dl class="section return"><dt>Returns<dd>if an unwanted hyphen had to be used. </dl></div></div><a class="anchor" id="a03989c57d6bd4b001acb3fbb9f1ae32c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int16 IWaxLine::GetJustificationViolationAmt </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetJustificationViolationAmt returns a number from 0 = no violation to 100 == complete violation. <dl class="section return"><dt>Returns<dd>the justification violation amount </dl></div></div><a class="anchor" id="aa6ca568306f9166e6ba49db8428b92ed"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetJustifiedTextWidthInTile </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>tileNum</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Justified Width is the width to justify the text. In most cases this value is 0 and should be ignored. In the case of kashida justification the last line can be streched to match the rest of the lines in the paragraph. </div></div><a class="anchor" id="a4cf975f0d80c90dc55aeb7c03dc02c9f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual Text::LeadingModel IWaxLine::GetLeadingModel </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The LeadingModel determines how line leading is measured from line to line and thereby how lines are placed in the frame </div></div><a class="anchor" id="a6955f1e69e85bd6d04ce17d7d17d8ef3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetLeadingModelOffset </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is the offset into the LineHeight to the point from which line leading is to be measured 0.0 means measure leading from the line&#39;s yPosition. </div></div><a class="anchor" id="a18dc2e17541557ca5bf4bb092522067e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetLineHeightLeadingDiff </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is the difference of the LineHeight and the max Leading value in the line. </div></div><a class="anchor" id="a94317be955a0ce6b6ef14b05df37a44c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetLineMetricOffset </td><td>(</td><td class="paramtype"><a class="el" href="class_i_drawing_style.html#ac16d7a2da883be642725a47ec6b69b74">IDrawingStyle::CharacterHang</a>&nbsp;</td><td class="paramname"><em>hangType</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a CharacterHang type to get the result for, return a <a class="el" href="class_p_m_real.html">PMReal</a> representing the number of points upward the line must be adjusted </div></div><a class="anchor" id="afa4e51baf75aa57dff81e77dbd982480"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual IWaxLine::LineTightness IWaxLine::GetLineTightness </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetLineTightness indicates a &quot;tightness&quot; of this line which is considered in order to favor justification consistency. <dl class="section return"><dt>Returns<dd>this line&#39;s tightness rating. </dl></div></div><a class="anchor" id="a5d8510c6ad15dd05f99215fd01c518af"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::GetNextLineAffectedByDropcap </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>return kTrue if the next line following this one will be affected by a dropcap. </div></div><a class="anchor" id="a918e3d3f39e0a9b58eac30ac4ae245c5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetNthDropCapIndent </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>n too big == last one, n too small == 0 &mdash; this allows shortcuts </div></div><a class="anchor" id="a3ddf0365d6ceda8e3292e3e6156aa97f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> IWaxLine::GetParcelKey </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Hierarchy: this WaxLine is inside the parcel specified: overset == !ParcelKey.IsValid() </div></div><a class="anchor" id="a2ae7bddf36ea9d71d69df504735c87a2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IWaxLine::GetTextSpan </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Range of characters in the text model mapped to this wax. Note: The wax span and model span differ when the text model has been altered but the wax has not been fully recomposed. </div></div><a class="anchor" id="a80238868eeeba128223ca6d838eff331"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a> IWaxLine::GetToFrameMatrix </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a matrix which will transform a WaxLine relative coordinate to the Frame coordinate system of the Frame that the WaxLine is in. </div></div><a class="anchor" id="a25e4ef274fa4bb77051374667e6a0d2d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a> IWaxLine::GetToParcelMatrix </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a matrix which will transform a WaxLine relative coordinate to the Parcel coordinate system of the Parcel that the WaxLine is in. </div></div><a class="anchor" id="aec87473f21ae53fa4b1407b64f65d442"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a> IWaxLine::GetToPasteboardMatrix </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a matrix which will transform a WaxLine relative coordinate to the Pasteboard coordinate system. </div></div><a class="anchor" id="a1994c817134ba2366a78b0003c07e23a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a> IWaxLine::GetToSpreadMatrix </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a matrix which will transform a WaxLine relative coordinate to the Spread coordinate system. </div></div><a class="anchor" id="a3d3b63e9ac243afcb2905ee420fed2ec"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_matrix.html">PMMatrix</a> IWaxLine::GetTransform </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The WaxLine exists in its own zero-based coordinate system. These matrixes will handle the transformations between the various target coordinate systems: Returns a matrix which will transform a WaxLine relative coordinate to the Parcel &quot;content&quot; coordinate system, a.k.a. the &quot;Wax&quot; coordinate system, of the Parcel that the WaxLine is in. </div></div><a class="anchor" id="a84bff81e4d6552b87b282200d5df4417"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetUnjustifiedTextWidthInTile </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>tileNum</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Unjustified Text Width is the width of the Text calculated by the composer in order to fit within the tile. So the difference between this value and the target width of the tile is the amount of space that the composer will fill up by justifying the text in the tile. If the return value is zero then the composer did not set a value (older documents). </div></div><a class="anchor" id="a0925b9a6b04680f0103d6e83c898653a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_v_o_s___object.html">VOS_Object</a>* IWaxLine::GetVOSWaxObject </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>get pointer to vos object that owns this line. Generally internal use only. </div></div><a class="anchor" id="a19a8594a7558b2e73c15ad63ebbd2dec"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetWidth </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>ignoreAllTrailing</em> = <code>kFalse</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>If ignoreAllTrailing is True the width will not include the width of white space or non selectable glyphs. </div></div><a class="anchor" id="a9c4402036548b2383fc08912d058a783"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetXPosition </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>tileNum</em> = <code>0</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>x position of each tile. first tile is the line&#39;s x position </div></div><a class="anchor" id="a2c4997618ce2ef8f08a8a144858c5993"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IWaxLine::GetYPosition </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>y-position of bottom of line height </div></div><a class="anchor" id="a377713cab4b1b6f831fc6077fe448560"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::GetYPositionAdjIgnored </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">The YPositionAdj is only valid when the Parcel the WaxLine has composed

</pre><p> into has VJ set or the WaxLine needs post-processing and in all other cases when the WaxLine is composed SetYPositionAdjIgnored() will be called. </div></div><a class="anchor" id="ab32f4f00cc06b8592689ca5b657c020f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::Inval </td><td>(</td><td class="paramtype"><a class="el" href="class_i_parcel_list.html">IParcelList</a> *&nbsp;</td><td class="paramname"><em>pl</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>alternateInk</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>if alternateInk is nil, <a class="el" href="class_i_wax_line_shape.html#adbc85c9eb96b5653621ad38f45570d0d">IWaxLineShape::GetInkBounds()</a> will be used. </div></div><a class="anchor" id="ad2f12b75f95075dc0d79282691486539"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::InvalidateRuns </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is used to remove all the WaxRuns associated with the WaxLine and mark that the Runs were invalidated. This information will be used on the next rebuild to re-validate the inkbounds. This method should be used whenever the rebuild state of WaxLine is expected to be changed. Examples are WaxLines with any type of calculated text. </div></div><a class="anchor" id="ae010ebd1a3a6fcbfe7c22c426c399746"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::IsDamaged </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Damage recording methods. </div></div><a class="anchor" id="a5e101329829cac659068ffc7b714826b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_wax_run.html">IWaxRun</a>* IWaxLine::QueryRunByTextOffset </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>textOffset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pGlyphOffset</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>QueryRunByTextOffset returns the WaxRun that contains the specified textOffset in the WaxLine. pGlyphOffset will be set to the offset within the run to the specified glyph (it can be expensive to generate this). NOTE: not all runs have glyphs, so it&#39;s possible that *pGlyphOffset will come back invalid (e.g. as -1) </div></div><a class="anchor" id="ab5e8aa6f2520329cfd9d9ba4595d698f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_wax_glyph_iterator.html">IWaxGlyphIterator</a>* IWaxLine::QueryWaxGlyphIterator </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>includeLine</em> = <code>kFalse</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>QueryWaxGlyphIterator provides iteration through all the glyphs in this waxLine. It may not visit every run, since not all runs contain glyphs. if includeLine is true, then the Matrix will include the line&#39;s transform (thereby converting to parcel coordinates) </div></div><a class="anchor" id="a3e13b3c222a7494b89d7d9ff8d08cc09"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_wax_run_iterator.html">IWaxRunIterator</a>* IWaxLine::QueryWaxRunIterator </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>includeLine</em> = <code>kFalse</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>QueryWaxRunIterator only iterates the leaf waxRuns - basically it just hides the wax hierarchy, providing access to the glyphs (or other &quot;drawn&quot; data). if includeLine is true, then the Matrix will include the line&#39;s transform (thereby converting to parcel coordinates) </div></div><a class="anchor" id="aea0e2f96c62a3abbf8869606fe6ead03"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetAlwaysRegenerate </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Rebuild the Runs everytime the WaxLine is drawn. The composer is allowed to set this value at regen time when it only has a const pointer. </div></div><a class="anchor" id="a7cebf8513eba8c9eea13862d5a1e9dbf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetBreakMode </td><td>(</td><td class="paramtype">Text::StartBreakLocation&nbsp;</td><td class="paramname"><em>bl</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>These values refer to the attributes used to compose the WaxLine rather their actual composed location.<p>If the WaxLine is the first of the Paragraph then GetBreakMode() and GetSpaceBefore() may return non-zero values.<p>If the WaxLine is the last of the Paragraph then GetGotoNextX(), GetSpaceAfter() and GetKeepWithNextNLines() may return non-zero values. </div></div><a class="anchor" id="ab34de1ce553ffb37f57cf5094545aeee"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetBulletNumberOffset </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>bnp</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">BulletNumberPosition is only used for lines with text wrap and a bullet/number

</pre><p> adornment contains a tab character. </div></div><a class="anchor" id="a334d5ee8f78d3b6e78d96acedbe4ba1a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetColumnSpan </td><td>(</td><td class="paramtype">uchar&nbsp;</td><td class="paramname"><em>count</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the column span to the specified value. Valid values for span are greater than or equal to 2 and less than or equal to 40. However, if span is set to 255 then it is equivalent to &quot;all&quot;. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">count</td><td></td></tr></table></dl></div></div><a class="anchor" id="a4ce121b7895a5a9ba88c0b263a54b65e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetColumnSplit </td><td>(</td><td class="paramtype">uchar&nbsp;</td><td class="paramname"><em>count</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>insideGutter</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>outsideGutter</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets the column split to the specified values. Valid values for count are greater than or equal to 2 and less than or equal to 40. insideGutter and outsideGutter need to be greater than or equal to 0.0. </div></div><a class="anchor" id="a36a045a62a2bc1076863ad3f0a3519ee"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetComposedWithMissingFont </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>missing</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>SetComposedWithMissingFont indicates whether this line&#39;s ending was decided using a missing font. When this occurs, we will force this line to recompose when opening the document if the font is back. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">missing</td><td>specifies if a missing font had to be used. </td></tr></table></dl></div></div><a class="anchor" id="a60e6a28a052360077f9e2eb54562e999"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetComposerWasSwappedToSingle </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>v</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>WaxLines which were asked to compose with the paragraph composer, but were actually composed with the single-line composer because of certain restrictions should set this flag to true. </div></div><a class="anchor" id="a9360c0d7247b13462f696544c78e04e5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetCompositionYPosition </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>compYPos</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The CompositionYPosition is what is set by the ParagraphComposer. By default there is not YPositionAdj so the value returned by <a class="el" href="class_i_wax_line.html#a2c4997618ce2ef8f08a8a144858c5993">GetYPosition()</a> is the same as GetCompositionYPosition(). If post-processing occurs, whether it be specified in the WaxLine with <a class="el" href="class_i_wax_line.html#afef2a78e4cdbde0c745e940e463406f7">SetNeedsPostProcessing()</a> or by Parcel VJ, then a YPosition Adj will be set. </div></div><a class="anchor" id="ab0af2ab2f56fd67a96d0340d260cc4fc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetDropCapIndents </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>howManyIndents</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>indents</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32 *&nbsp;</td><td class="paramname"><em>lineCounts</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>sets LISTS of dropcap indents </div></div><a class="anchor" id="a3021432e962ff674fae4c736eef95ad3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetHasWAENoFitInParcel </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname">, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_parcel_key.html">ParcelKey</a> &amp;&nbsp;</td><td class="paramname">&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For Internal Use Only: If a Wax Anchored Element doesn&#39;t fit in a parcel, we note down its anchor waxline index. This is done so that we can limit backing up otherwise it may cause a forever loop. </div></div><a class="anchor" id="a27ce77b39c6c76c13593e2a96bd0dad7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetHyphenationViolation </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>violation</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>SetHyphenationViolation indicates whether a hyphenation violation occurred <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">violation</td><td>specifies if an unwanted hyphen had to be used. </td></tr></table></dl></div></div><a class="anchor" id="aefb6d2dbc3f84c9ae405c6df3b7b0658"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetJustificationViolationAmt </td><td>(</td><td class="paramtype">int16&nbsp;</td><td class="paramname"><em>jva</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>SetJustificationViolationAmt sets the justification violation for a line. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">jva</td><td>specifies the justification violation: 0 = no violation, 100 == complete violation. </td></tr></table></dl></div></div><a class="anchor" id="a7700029eb7e129d1acd3b9bb4c98d207"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetKeepWithPrevExternal </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>v</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Support for keeps on WaxLines. ...External keeps represents the previous paragraph having KeepWithNextNLines in effect. ...First keeps represents the containing paragraph having KeepTogether or KeepFirstNLines in effect. ...Last keeps represents the containing paragraph having KeepLastNLines in effect. External keeps represents the previous paragraph having KeepWithNextNLines in effect. </div></div><a class="anchor" id="a88d661988ee6cfc225061d0513895371"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetKeepWithPrevFirst </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>v</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>First keeps represents the containing paragraph having KeepTogether or KeepFirstNLines in effect. </div></div><a class="anchor" id="a055932e734794f1b2b0f22745e9a5a27"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetKeepWithPrevLast </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>v</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Last keeps represents the containing paragraph having KeepLastNLines in effect. </div></div><a class="anchor" id="a777bad8995480099b58fa7ff623cfebd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetKeepWithPrevParaLastLine </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>v</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Prev Para Last Line represents this paragraph having KeepWithPrev in effect which simply means keep the first WaxLine of this Paragraph with the last WaxLine of the previous Paragraph. </div></div><a class="anchor" id="a683b782d647eed0c083b52d0aef7448b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetLineTextOrigin </td><td>(</td><td class="paramtype">const TextIndex&nbsp;</td><td class="paramname"><em>absoluteTextIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Optimization. Will be called by the wax iterator. </div></div><a class="anchor" id="a04370df9ac9d919a7c6406a6536e30d5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetLineTightness </td><td>(</td><td class="paramtype">IWaxLine::LineTightness&nbsp;</td><td class="paramname"><em>t</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>SetLineTightness indicates a &quot;tightness&quot; of this line which is considered in order to favor justification consistency. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">t</td><td>specifies this line&#39;s tightness. </td></tr></table></dl></div></div><a class="anchor" id="afef2a78e4cdbde0c745e940e463406f7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetNeedsPostProcessing </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>v</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>WaxLines which need post-processing due to paragrpah attributes require adjustments to the CompositionYPosition with SetYPositionAdj(). Although the adjustment mechanism is the same, this not the same as Parcel VJ which does not mark the WaxLines. </div></div><a class="anchor" id="a18dcad87d3e9e58b00743e4768c8fb47"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetParaBorderMergingOn </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bParaBorderMergingOn</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For Internal Use Only: If Paragraph Border Merging is enabled, we note here on the waxline about the same. </div></div><a class="anchor" id="a29aa95ccec18b263a816421be20ee370"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetParaBorderOn </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bParaBorderOn</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For Internal Use Only: If paragraph border is applied on a waxline, we note here on the waxline about the same. </div></div><a class="anchor" id="aa6a940e26888d5c030ec641545a086bc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetParaShadingOn </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bParaShadingOn</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For Internal Use Only: If paragraph shading is applied on a waxline, we note here on the waxline about the same. </div></div><a class="anchor" id="a96a5a4c8e1b00d2b47d2a32f44c293a6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetParcelPositionDependent </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>v</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>If the WaxLine needs to be damaged when the Parcel that is composed into is moved relative to the pasteboard then this should be set to kTrue. Some examples are:<ul><li>The ITiler will return this information for Tiles that are aligned to certain grids.</ul><ul><li>Certain WaxAnchorPts will set this to kTrue if any of their Text content is aligned to grids</ul><ul><li>WaxLines which contain Inlines will have this set to kTrue by the composer. </ul></div></div><a class="anchor" id="a1faaa0f8d39ab3410ac0a1281c1d477b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetRequiresCallToListInvalService </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>requiresCall</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>When set this flag causes calls to SetGeometryDamage to have the side effect of calling all available IListInvalService service providers with the line that&#39;s being geometry damaged. These services are rarely needed, but can be used by text adornments to clear cached data on wax runs. </div></div><a class="anchor" id="a381a4729640e0527f3301505a45ab1a4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetSpaceAfterIsSticky </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>v</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if space after in line should stay when line is last line in parcel </div></div><a class="anchor" id="a5c708eeec754294458436eefdf074e21"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetStoryThread </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_story_thread.html">ITextStoryThread</a> *&nbsp;</td><td class="paramname"><em>thread</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>When the WaxLine is applied into the Wax the WaxStrand will update the thread information. This information is used to speed the lookup of Frame information by getting the ParcelList from the StoryThread and using the ParcelIndex to get the appropriate Parcel. </div></div><a class="anchor" id="aa3529fd004eee054ab8871fed3e2f722"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IWaxLine::SetVOSWaxObject </td><td>(</td><td class="paramtype"><a class="el" href="class_v_o_s___object.html">VOS_Object</a> *&nbsp;</td><td class="paramname"><em>vosObject</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>SetVOSWaxObject is for internal initialization only. </div></div><a class="anchor" id="a9e96a25b9991ccce226a6b43ea382174"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IWaxLine::StartsLine </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_wax_run.html">IWaxRun</a> *&nbsp;</td><td class="paramname"><em>waxRun</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Does this <a class="el" href="class_i_wax_run.html">IWaxRun</a> start the line? </div></div><a class="anchor" id="ab8672a2994da2d09839180ca4d5c67b5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex IWaxLine::TextOrigin </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_wax_run.html">IWaxRun</a> *&nbsp;</td><td class="paramname"><em>waxRun</em> = <code>nil</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Finds the run within the line and returns it&#39;s first TextIndex. Passing nil returns the first TextIndex of the line. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_wax_line.html">IWaxLine</a><li class="footer">Generated on Sat Sep 22 2018 10:54:33 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
