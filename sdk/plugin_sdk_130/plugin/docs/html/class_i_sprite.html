<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_sprite</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_sprite.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_sprite-members.html">List of all members</a></div><div class="headertitle"><div class="title">ISprite Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_sprite_8h_source.html">ISprite.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ISprite:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_sprite.png" usemap="#ISprite_map" /><map id="ISprite_map" name="ISprite_map"><area alt="IPMUnknown" coords="0,0,101,24" href="class_i_p_m_unknown.html" shape="rect" /><area alt="CSprite" coords="0,112,101,136" href="class_c_sprite.html" shape="rect" /><area alt="NoHandleSprite" coords="0,168,101,192" href="class_no_handle_sprite.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a1724404df8ce8ef1ff1359ee38eb854f"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ISPRITE }</td></tr><tr class="separator:a1724404df8ce8ef1ff1359ee38eb854f"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a699fbdd2b8c0b75d97354c8376dc2063"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#a699fbdd2b8c0b75d97354c8376dc2063">CreateSprite</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, <a class="el" href="class_u_i_d_list.html">UIDList</a> *itemList, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;startPt, bool16 bDrawItems=kTrue)=0</td></tr><tr class="separator:a699fbdd2b8c0b75d97354c8376dc2063"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af5a02c65fc5491ae34b4fdf5c0a84f19"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#af5a02c65fc5491ae34b4fdf5c0a84f19">DestroySprite</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc)=0</td></tr><tr class="separator:af5a02c65fc5491ae34b4fdf5c0a84f19"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a909ad7206e88153e0a4acccd56c1dfa3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#a909ad7206e88153e0a4acccd56c1dfa3">DisableShapes</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, bool16 disable)=0</td></tr><tr class="separator:a909ad7206e88153e0a4acccd56c1dfa3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a91708449b9bd6e415bdb52d0d326b127"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#a91708449b9bd6e415bdb52d0d326b127">Show</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm=nil)=0</td></tr><tr class="separator:a91708449b9bd6e415bdb52d0d326b127"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac037d0a8b214b898db5fa6337e92f110"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#ac037d0a8b214b898db5fa6337e92f110">Scroll</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;delta, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm=nil)=0</td></tr><tr class="separator:ac037d0a8b214b898db5fa6337e92f110"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5d28989e2344e1e9f64cf2548c687c63"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#a5d28989e2344e1e9f64cf2548c687c63">Erase</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm=nil)=0</td></tr><tr class="separator:a5d28989e2344e1e9f64cf2548c687c63"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5b703ff30dca4461dd6cd477bf2fbe85"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#a5b703ff30dca4461dd6cd477bf2fbe85">Hide</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, bool16 bForceRedraw, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm=nil)=0</td></tr><tr class="separator:a5b703ff30dca4461dd6cd477bf2fbe85"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a21f0e3ed096c70bb63ac007de0a63aa8"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="struct_sys_rect.html">SysRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#a21f0e3ed096c70bb63ac007de0a63aa8">GetDeviceBounds</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm=nil)=0</td></tr><tr class="separator:a21f0e3ed096c70bb63ac007de0a63aa8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aff61630fcbf9ba628e4535591316aaf1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#aff61630fcbf9ba628e4535591316aaf1">InvalidateBBox</a> ()=0</td></tr><tr class="separator:aff61630fcbf9ba628e4535591316aaf1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a459ad8a74749435caffbec8133e81f76"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#a459ad8a74749435caffbec8133e81f76">ValidSprite</a> () const =0</td></tr><tr class="separator:a459ad8a74749435caffbec8133e81f76"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3b35c7b35ca18203c4f02f61f0d241e8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_sprite.html#a3b35c7b35ca18203c4f02f61f0d241e8">NeedsUpdate</a> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags) const =0</td></tr><tr class="separator:a3b35c7b35ca18203c4f02f61f0d241e8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p><a class="el" href="class_i_sprite.html">ISprite</a> is an interface used by trackers to update the screen while tracking. For example, when resizing a page item, a resize tracker will create a sprite. The sprite represents the page item that is being resized and is called by the tracker to &quot;Show&quot; every time the mouse is moved. Sprites can draw in wire frame mode or in &quot;patient user&quot; mode. When in wire frame mode, the original page item continues to draw unchanged while an outline of the page item is dynamically updated to show the effect of the change made by the tracker. In patient-user mode, the layout is continually redrawn to show the full effect of the change made by the tracker, as if the user released the mouse after each step.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_shape.html">IShape</a></dl></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a699fbdd2b8c0b75d97354c8376dc2063"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISprite::CreateSprite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>itemList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>startPt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bDrawItems</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates sprite <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device that the sprite will draw to. </td></tr><tr><td class="paramname">itemList</td><td>- IN: The uidlist indicates those items that the sprite is rendering. It uses those items to compute the offscreen bounding box. If drawItemList is kTrue then the sprite will draw the items in the uid list during show. If itemList is nil that means the sprite should draw its own paths (if any) and ignore the item list related drawing. The path creation trackers use a nil item list because the actual page item isn&#39;t created until the end of dynamics. </td></tr><tr><td class="paramname">startPt</td><td>- start point </td></tr><tr><td class="paramname">bDrawItems</td><td>- IN: tells the sprite whether or not to draw the uid items during show. Set to kFalse only if the sprite implementation has another way that it draws the updated paths/shapes (such as spline editting). </td></tr></table></dl><dl class="section return"><dt>Returns<dd>returns kFalse if low memory. In that case the sprite might do nothing or use XOR in <a class="el" href="class_i_sprite.html#a91708449b9bd6e415bdb52d0d326b127">ISprite::Show()</a>. If returns kTrue the sprite succeed in creating offscreens. </dl><p>Implemented in <a class="el" href="class_c_sprite.html#a325ab7ff8b5168e5b38669ae4ece8bad">CSprite</a>.</div></div><a class="anchor" id="af5a02c65fc5491ae34b4fdf5c0a84f19"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISprite::DestroySprite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Releases references to offscreens and cleans up. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. Used to issue an draw invalidations or screen redraws that may be necessary as part of the cleanup process. </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_sprite.html#a5f2de4868130dfdadf2c1bfacfcdffb7">CSprite</a>.</div></div><a class="anchor" id="a909ad7206e88153e0a4acccd56c1dfa3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISprite::DisableShapes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>disable</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>If called, this will disable the shapes in the uidlist from drawing in the background offscreen. This is different than the bDrawItems flag in CreateSprite. DisableShapes specifically affects only the items drawing during the creation of the background. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. Necessary to obtain the <a class="el" href="class_i_draw_mgr.html">IDrawMgr</a> for the port in order to tell the <a class="el" href="class_i_draw_mgr.html">IDrawMgr</a> to Disable the shape. </td></tr><tr><td class="paramname">disable</td><td>- IN: kTrue to disable the drawing of the shape. kFalse to enable the drawing. </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_sprite.html#a88eff37710477bce0538d1263acf0971">CSprite</a>.</div></div><a class="anchor" id="a5d28989e2344e1e9f64cf2548c687c63"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISprite::Erase </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For the case when the sprite fails to create an offscreen you can still use it for dynamics. But to do so requires the user to call erase so the old drawing is cleaned up. Erase should be called with the previous position. i.e., if the object is moving call show, then erase, then move the object, then show, then erase, then move the object, then show, etc. Of course erase should only be called immediately before moving the object (and only if the object is to move). flags are IShape::flags <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags. </td></tr><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_sprite.html#a1a1badbea1740b6001fe5c9a141538d5">CSprite</a>.</div></div><a class="anchor" id="a21f0e3ed096c70bb63ac007de0a63aa8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="struct_sys_rect.html">SysRect</a> ISprite::GetDeviceBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the bounds used by the sprite. The bounds includes everything the sprite would draw during show given the same flags and matrix. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the bounds used by the sprite. </dl><p>Implemented in <a class="el" href="class_c_sprite.html#aa48c2385b364f59c09a726d92f7de2c9">CSprite</a>.</div></div><a class="anchor" id="a5b703ff30dca4461dd6cd477bf2fbe85"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISprite::Hide </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bForceRedraw</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Removes any sprite related extra drawing. Restores the screen to reflect what is in the spread. This function is somewhat implementation dependent. For instance, in path creation it may be used to update with the newly created segment, or for rotation getting rid of the tracker line <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">bForceRedraw</td><td>- IN: Whether or not to force the gc to redraw before returning. </td></tr><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_sprite.html#a07aaa66e4af4e2e69b3feaf5913d81fe">CSprite</a>.</div></div><a class="anchor" id="aff61630fcbf9ba628e4535591316aaf1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISprite::InvalidateBBox </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tells the sprite that the object&#39;s bbox has changed and to recalculate the cached version in the sprite. <p>Implemented in <a class="el" href="class_c_sprite.html#afb2ab306c6a120c08d6683523c8e015a">CSprite</a>.</div></div><a class="anchor" id="a3b35c7b35ca18203c4f02f61f0d241e8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISprite::NeedsUpdate </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue when sprite needs to update, kFalse otherwise. Typically a sprite won&#39;t need updating unless it has moved, but this hook allows clients to override. <p>Implemented in <a class="el" href="class_c_sprite.html#a6f83faed4887c7f389bc942c51fbaee0">CSprite</a>.</div></div><a class="anchor" id="ac037d0a8b214b898db5fa6337e92f110"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISprite::Scroll </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>delta</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Scroll the sprite. In general this recreates the background and repaints. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">delta</td><td>- IN: The amount to scroll. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags. </td></tr><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse means the sprite is in low memory and that it drew the objects directly to gc. </dl><p>Implemented in <a class="el" href="class_c_sprite.html#a076563d0bcdaf842373e224350e3e672">CSprite</a>.</div></div><a class="anchor" id="a91708449b9bd6e415bdb52d0d326b127"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISprite::Show </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Show the sprite. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse means the sprite is in low memory and that it drew the objects directly to gc. </dl><p>Implemented in <a class="el" href="class_c_sprite.html#ae135af197fac3175483bc4326d6949ce">CSprite</a>.</div></div><a class="anchor" id="a459ad8a74749435caffbec8133e81f76"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISprite::ValidSprite </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tells whether the sprite has been initialized &ndash; that is, CreateSprite has been called. <p>Implemented in <a class="el" href="class_c_sprite.html#aa6c1d3e7699cac4c2f519526556083d6">CSprite</a>.</div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_sprite.html">ISprite</a><li class="footer">Generated on Sat Sep 22 2018 10:54:28 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
