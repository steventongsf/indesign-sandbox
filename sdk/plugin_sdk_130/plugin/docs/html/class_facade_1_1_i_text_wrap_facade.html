<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_facade_1_1_i_text_wrap_facade</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_facade_1_1_i_text_wrap_facade.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_facade_1_1_i_text_wrap_facade-members.html">List of all members</a></div><div class="headertitle"><div class="title">Facade::ITextWrapFacade Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_text_wrap_facade_8h_source.html">ITextWrapFacade.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for Facade::ITextWrapFacade:</div><div class="dyncontent"><div class="center"><img alt="" src="class_facade_1_1_i_text_wrap_facade.png" usemap="#Facade::ITextWrapFacade_map" /><map id="Facade::ITextWrapFacade_map" name="Facade::ITextWrapFacade_map"><area alt="IPMUnknown" coords="0,0,160,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a7318aac081710e0f4d15dd987460f6cd"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITEXTWRAPFACADE }</td></tr><tr class="separator:a7318aac081710e0f4d15dd987460f6cd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a456812e77cea232ac0bd8cb925b3fa41"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kUnchanged</b> = 0xFFFF }</td></tr><tr class="separator:a456812e77cea232ac0bd8cb925b3fa41"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0bbd1ad3304a4242f59c85ada660e549"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>IgnoreEnum</b> { <b>kDoNotIgnore</b> = 0, <b>kIgnore</b> = 1, <b>kLeaveUnchanged</b> }</td></tr><tr class="separator:a0bbd1ad3304a4242f59c85ada660e549"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:afa0c8ae3f3a0ced3c11e0a959e0cd3c8"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_stand_off.html#a3ab0e1dfc6cb6bb64e290d6c1513c71a">IStandOff::mode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#afa0c8ae3f3a0ced3c11e0a959e0cd3c8">GetMode</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;pageItem) const =0</td></tr><tr class="separator:afa0c8ae3f3a0ced3c11e0a959e0cd3c8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a86f2f72e42edadb4722db9e19c5428dc"><td align="right" class="memItemLeft" valign="top">virtual bool32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a86f2f72e42edadb4722db9e19c5428dc">GetUserModified</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;pageItem) const =0</td></tr><tr class="separator:a86f2f72e42edadb4722db9e19c5428dc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a50e8711baf7d7674bf3b4807631ccc23"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a50e8711baf7d7674bf3b4807631ccc23">SetMode</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;pageItems, <a class="el" href="class_i_stand_off.html#a3ab0e1dfc6cb6bb64e290d6c1513c71a">IStandOff::mode</a> mode, bool16 setUserModified=kFalse) const =0</td></tr><tr class="separator:a50e8711baf7d7674bf3b4807631ccc23"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7d0502151c5ecdb0cdd11cd906892ffb"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a7d0502151c5ecdb0cdd11cd906892ffb">SetContourWrapSettings</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;imageItems, IStandOffContourWrapSettings::ContourWrapType contourType, int16 pathIndex, int16 alphaIndex, <a class="el" href="class_p_m_real.html">PMReal</a> tolerance, uint8 threshhold, bool8 allowHoles) const =0</td></tr><tr class="separator:a7d0502151c5ecdb0cdd11cd906892ffb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acfb92b8d6192809b4d6548356a7ecd35"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#acfb92b8d6192809b4d6548356a7ecd35">GetContourWrapSettings</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageItem, IStandOffContourWrapSettings::ContourWrapType *contourTypePtr, int16 *pathIndexPtr=nil, int16 *alphaIndexPtr=nil, <a class="el" href="class_p_m_real.html">PMReal</a> *tolerancePtr=nil, uint8 *threshholdPtr=nil, bool8 *allowHolesPtr=nil) const =0</td></tr><tr class="separator:acfb92b8d6192809b4d6548356a7ecd35"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a30ad6249aba86643bdbfa9084b18279d"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a30ad6249aba86643bdbfa9084b18279d">SetInvert</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;textWrapItems, bool8 bInvert) const =0</td></tr><tr class="separator:a30ad6249aba86643bdbfa9084b18279d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6585edf48dfca02e7c296f8633085a7d"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a6585edf48dfca02e7c296f8633085a7d">GetInvert</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textWrapItem, bool8 &amp;bInvert) const =0</td></tr><tr class="separator:a6585edf48dfca02e7c296f8633085a7d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b27f93d36cd276427d99bb8ffd355ae"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a1b27f93d36cd276427d99bb8ffd355ae">SetMargins</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;textWrapItems, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;topMargin, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;leftMargin, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;bottomMargin, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;rightMargin) const =0</td></tr><tr class="separator:a1b27f93d36cd276427d99bb8ffd355ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a442a467f9dd93e5f73da0b84b6e6a93b"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a442a467f9dd93e5f73da0b84b6e6a93b">GetMargins</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textWrapItem, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;topMargin, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;leftMargin, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;bottomMargin, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;rightMargin, bool8 &amp;singleDistance) const =0</td></tr><tr class="separator:a442a467f9dd93e5f73da0b84b6e6a93b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afa7e514454a1e96fd481c81f66820c4b"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#afa7e514454a1e96fd481c81f66820c4b">SetActiveFromMaster</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;textWrapItems, bool16 bActive) const =0</td></tr><tr class="separator:afa7e514454a1e96fd481c81f66820c4b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4ce589fb3ce2cd1642423d3c18f52f30"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a4ce589fb3ce2cd1642423d3c18f52f30">GetActiveFromMaster</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textWrapItem, bool16 &amp;bActive) const =0</td></tr><tr class="separator:a4ce589fb3ce2cd1642423d3c18f52f30"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afea6d39badd8d7eccf112ebc71d5afd6"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#afea6d39badd8d7eccf112ebc71d5afd6">SetSide</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;textWrapItems, <a class="el" href="class_i_stand_off.html#ac6472421fe6f23237eccadabf291a486">IStandOff::side</a> Side) const =0</td></tr><tr class="separator:afea6d39badd8d7eccf112ebc71d5afd6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af268d0bcad2c01e7003f941e2368a62d"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#af268d0bcad2c01e7003f941e2368a62d">GetSide</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;textWrapItem, <a class="el" href="class_i_stand_off.html#ac6472421fe6f23237eccadabf291a486">IStandOff::side</a> &amp;Side) const =0</td></tr><tr class="separator:af268d0bcad2c01e7003f941e2368a62d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a368bc20622261ffee0ce4408974287c9"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a368bc20622261ffee0ce4408974287c9">SetIgnoreWrap</a> (const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;ignoreWrapItems, bool8 bIgnore) const =0</td></tr><tr class="separator:a368bc20622261ffee0ce4408974287c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a652f397e230025eae741b01c97942b90"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a652f397e230025eae741b01c97942b90">GetIgnoreWrap</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;ignoreWrapItem, bool8 &amp;ignore) const =0</td></tr><tr class="separator:a652f397e230025eae741b01c97942b90"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af7230267738bd5dd93722c7057eff73b"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#af7230267738bd5dd93722c7057eff73b">GetSkipByLeadingHeight</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;workspace, bool16 &amp;skipByLeading) const =0</td></tr><tr class="separator:af7230267738bd5dd93722c7057eff73b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac4d8dc5682d0bf573b5c1490a1364092"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#ac4d8dc5682d0bf573b5c1490a1364092">SetSkipByLeadingHeight</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;workspace, bool16 skipByLeading) const =0</td></tr><tr class="separator:ac4d8dc5682d0bf573b5c1490a1364092"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acabd00100634044eb6101c6fb82bae53"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#acabd00100634044eb6101c6fb82bae53">GetZOrderBasedTextWrap</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;workspace, bool16 &amp;zOrder) const =0</td></tr><tr class="separator:acabd00100634044eb6101c6fb82bae53"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4bf4cd11f832e7f19ee5f421e40d7f1b"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a4bf4cd11f832e7f19ee5f421e40d7f1b">SetZOrderBasedTextWrap</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;workspace, bool16 useZOrder) const =0</td></tr><tr class="separator:a4bf4cd11f832e7f19ee5f421e40d7f1b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abfa02972b8fca6763b48aea023a179e9"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html#abfa02972b8fca6763b48aea023a179e9">CopyTextWrap</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;srcPageItem, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;dstPageItem) const =0</td></tr><tr class="separator:abfa02972b8fca6763b48aea023a179e9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>A high level API for dealing with text wrap. To use this <a class="el" href="namespace_facade.html">Facade</a>, include this header file and the use the following example syntax: theMode = Utils&lt;Facade::ITextWrapFacade&gt;()-&gt;GetMode( pageItem );<dl class="section author"><dt>Author<dd>David Stephens </dl></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="abfa02972b8fca6763b48aea023a179e9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void Facade::ITextWrapFacade::CopyTextWrap </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>srcPageItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>dstPageItem</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: When replacing a page item with wrap, either via the Place dialog, relinking an image or pasting another page item into the parent frame, we sometimes want to preserve the text wrap of the page item that is being replaced. This method is used to copy the text wrap settings from one page item to another. It also will copy the actual text wrap path if the path was modified by the user. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">srcPageItem</td><td>IN: Notice that this parameter is a const. </td></tr><tr><td class="paramname">dstPageItem</td><td>IN: On return, this page item will have the same text wrap settings (if possible) as the source. Sometimes it is not possible to copy the settings. For example, the text wrap on the source may be using an embedded clipping path which does not exist in the destination. In such cases, this routine will get as close as possible. For the said example, it will choose &quot;Same As Clipping&quot; instead. </td></tr></table></dl></div></div><a class="anchor" id="a4ce589fb3ce2cd1642423d3c18f52f30"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::GetActiveFromMaster </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textWrapItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>bActive</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Is a MasterPage based text wrap active on Spreads that it appears on? <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textWrapItem</td><td>IN: The text wrap item from which we will get the bActive setting. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the text wrap is user modified, kFalse otherwise. </dl></div></div><a class="anchor" id="acfb92b8d6192809b4d6548356a7ecd35"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::GetContourWrapSettings </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">IStandOffContourWrapSettings::ContourWrapType *&nbsp;</td><td class="paramname"><em>contourTypePtr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int16 *&nbsp;</td><td class="paramname"><em>pathIndexPtr</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int16 *&nbsp;</td><td class="paramname"><em>alphaIndexPtr</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>tolerancePtr</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint8 *&nbsp;</td><td class="paramname"><em>threshholdPtr</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8 *&nbsp;</td><td class="paramname"><em>allowHolesPtr</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Get the current ContourWrapSettings for a given image, document workspace, or the session workspace. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">imageItem</td><td>IN: The image whose ContourWrapSettings we are interested in obtaining. Note that imageItem is not the text wrap item (i.e. not the standoff). Alternatively a <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace may be used. </td></tr><tr><td class="paramname">contourTypePtr</td><td>OUT: If non-nil, then the current contour type will be returned. </td></tr><tr><td class="paramname">pathIndexPtr</td><td>OUT: If non-nil and the contourType is kEmbeddPath, then the zero-based index of the path will be returned in this parameter. </td></tr><tr><td class="paramname">alphaIndexPtr</td><td>OUT: If non-nil and the contourType or kAlpha, then the zero-based index of the alpha channel will be returned in this parameter. </td></tr><tr><td class="paramname">tolerancePtr</td><td>OUT: If non-nil, then the current tolerance value will be returned. </td></tr><tr><td class="paramname">threshholdPtr</td><td>OUT: If non-nil, then the current threshhold value between 0 and 255 will be returned. </td></tr><tr><td class="paramname">allowHolesPtr</td><td>OUT: If non-nil, then the current allowHoles setting will be returned. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Any errors or kSuccess if successful. </dl></div></div><a class="anchor" id="a652f397e230025eae741b01c97942b90"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::GetIgnoreWrap </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>ignoreWrapItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8 &amp;&nbsp;</td><td class="paramname"><em>ignore</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Is the text wrap path currently ignored? <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ignoreWrapItem</td><td>IN: The MultiColumnTextFrame or parent item from which we will get the ignore setting. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if text wrap is currently ignored, kFalse otherwise. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_text_options_8h_source.html">ITextOptions.h</a> for document and session preferences settings. </dl></div></div><a class="anchor" id="a6585edf48dfca02e7c296f8633085a7d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::GetInvert </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textWrapItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8 &amp;&nbsp;</td><td class="paramname"><em>bInvert</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Is the text wrap path inverted? <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textWrapItem</td><td>IN: The text wrap item from which we will get the bInvert setting. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the text wrap is user modified, kFalse otherwise. </dl></div></div><a class="anchor" id="a442a467f9dd93e5f73da0b84b6e6a93b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::GetMargins </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textWrapItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>topMargin</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>leftMargin</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>bottomMargin</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>rightMargin</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8 &amp;&nbsp;</td><td class="paramname"><em>singleDistance</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Get the current margins (outsets) for a given text wrap. Use kUnchanged to leave a value unchanged. If a text wrap is non-rectangular, then the topMargin is applied as an outset to the entire path. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textWrapItem</td><td>IN: The text wrap item from which we will obtain the margin settings. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr><tr><td class="paramname">topMargin</td><td>OUT: The top margin. </td></tr><tr><td class="paramname">leftMargin</td><td>OUT: The left margin. </td></tr><tr><td class="paramname">bottomMargin</td><td>OUT: The bottom margin. </td></tr><tr><td class="paramname">rightMargin</td><td>OUT: The right margin. </td></tr><tr><td class="paramname">singleDistance</td><td>OUT: Whether the item only supports one value for all sides (i.e. topMargin is the only valid margin) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Any errors or kSuccess if successful. </dl></div></div><a class="anchor" id="afa0c8ae3f3a0ced3c11e0a959e0cd3c8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_stand_off.html#a3ab0e1dfc6cb6bb64e290d6c1513c71a">IStandOff::mode</a> Facade::ITextWrapFacade::GetMode </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>pageItem</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Get the text wrap mode for the given page item, Document workspace, or the session workspace. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageItem</td><td>IN: The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item we are interested in. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The text wrap mode for the given pageItem. </dl></div></div><a class="anchor" id="af268d0bcad2c01e7003f941e2368a62d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::GetSide </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>textWrapItem</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_stand_off.html#ac6472421fe6f23237eccadabf291a486">IStandOff::side</a> &amp;&nbsp;</td><td class="paramname"><em>Side</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Get the text wrap side for the given page item, Document workspace, or the session workspace. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageItem</td><td>IN: The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item we are interested in. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The text wrap side for the given pageItem. </dl></div></div><a class="anchor" id="af7230267738bd5dd93722c7057eff73b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::GetSkipByLeadingHeight </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>workspace</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>skipByLeading</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: <a class="el" href="class_facade_1_1_i_text_wrap_facade.html#af7230267738bd5dd93722c7057eff73b">GetSkipByLeadingHeight()</a> returns kTrue if the text tiler will skip down by the leading height when an obstruction is encountered. kFalse will be returned if the tiler will skip down 1 point. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">workspace</td><td>IN - the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the target workspace. This <a class="el" href="class_u_i_d_ref.html">UIDRef</a> can be either a document workspace or the session workspace. </td></tr><tr><td class="paramname">skipByLeading</td><td>OUT - kTrue if the tiler will skip by leading height. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>ErrorCode - kSuccess if successful, an error otherwise </dl></div></div><a class="anchor" id="a86f2f72e42edadb4722db9e19c5428dc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool32 Facade::ITextWrapFacade::GetUserModified </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>pageItem</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Get whether given page item has a user modified/edited text wrap. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageItem</td><td>IN: The <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item we are interested in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>ChangedType - whether or not the given page item has a user-modified path </dl></div></div><a class="anchor" id="acabd00100634044eb6101c6fb82bae53"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::GetZOrderBasedTextWrap </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>workspace</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>zOrder</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: <a class="el" href="class_facade_1_1_i_text_wrap_facade.html#acabd00100634044eb6101c6fb82bae53">GetZOrderBasedTextWrap()</a> returns kTrue if text wrap only affects items above it in the z-order. kFalse is returned if text wrap affects all text regardless of the z-order. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">workspace</td><td>IN - the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the target workspace. This <a class="el" href="class_u_i_d_ref.html">UIDRef</a> can be either a document workspace or the session workspace. </td></tr><tr><td class="paramname">zOrder</td><td>OUT - kTrue indicates z-order based text wrap will be used. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>ErrorCode - kSuccess if successful, an error otherwise </dl></div></div><a class="anchor" id="afa7e514454a1e96fd481c81f66820c4b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetActiveFromMaster </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>textWrapItems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bActive</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Should a MasterPage based text wrap be active on Spreads that is appears on? <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textWrapItems</td><td>IN: The list of text wrap items to which we will apply the bActive setting. Alternatively a list with the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace may be used. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr><tr><td class="paramname">bActive</td><td>IN: kTrue to have MasterPage based wrap be active on Spreads in which it appears </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Any errors or kSuccess if successful. </dl></div></div><a class="anchor" id="a7d0502151c5ecdb0cdd11cd906892ffb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetContourWrapSettings </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>imageItems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">IStandOffContourWrapSettings::ContourWrapType&nbsp;</td><td class="paramname"><em>contourType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int16&nbsp;</td><td class="paramname"><em>pathIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int16&nbsp;</td><td class="paramname"><em>alphaIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>tolerance</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint8&nbsp;</td><td class="paramname"><em>threshhold</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8&nbsp;</td><td class="paramname"><em>allowHoles</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Images with a text wrap mode of <a class="el" href="class_i_stand_off.html#a3ab0e1dfc6cb6bb64e290d6c1513c71aa5319a236293e731b609487078ca150ac">IStandOff::kManualContour</a> have additional options available including using an embedded Photoshop clipping path, performing edge detection on the image or on a given alpha channel, wrapping around the image bounds, wrapping around the graphic frame which contains the image, or wrapping around whatever is currently clipping the image (either a clipping path or the frame itself). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">imageItems</td><td>IN: The list of images to which we will apply the settings (not a list of text wrap items) </td></tr><tr><td class="paramname">contourType</td><td>IN: The text wrap contour type to apply. </td></tr><tr><td class="paramname">pathIndex</td><td>IN: If the countourType is kEmbeddedPath then pathIndex represents the zero based index of the embedded path to use. </td></tr><tr><td class="paramname">alphaIndex</td><td>IN: If the countourType is kAlpha, then alphaIndex represents the zero based index of the alpha channel to use. </td></tr><tr><td class="paramname">tolerance</td><td>IN: Edge detection based on the image or an alpha channel occurs in two steps. The first step generates a polygonal path which perfectly matches what InDesign believes is the edge. Because the polygonal path may contain thousands of points, it is smoothed into a bezier path during the second step if tolerance is non-zero. During this smoothing step, the tolerance indicates how closely the resulting path must match A value between 0 and 100 which indicates how closely the resulting path must match the polygonal path from step 1. </td></tr><tr><td class="paramname">threshhold</td><td>IN: During edge detection of an image or alpha channel, the source pixels are converted to grayscale and then to a 1-bit bitmap. The threshhold is a value between 0 and 255. Any gray value greater than or equal to the threshold will be mapped to white. All other pixels will be mapped to black. </td></tr><tr><td class="paramname">allowHoles</td><td>IN: If kFalse, then all subpaths representing holes will be removed. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Any errors or kSuccess if successful. </dl></div></div><a class="anchor" id="a368bc20622261ffee0ce4408974287c9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetIgnoreWrap </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>ignoreWrapItems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8&nbsp;</td><td class="paramname"><em>bIgnore</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Should the text wrap be ignored? <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ignoreWrapItems</td><td>IN: The list of MultiColumnTextFrame or parent items to which we will apply the ignore setting. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr><tr><td class="paramname">bIgnore</td><td>IN: kTrue to ignore text wrap. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the text wrap is user modified, kFalse otherwise. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_text_options_8h_source.html">ITextOptions.h</a> for document and session preferences settings. </dl></div></div><a class="anchor" id="a30ad6249aba86643bdbfa9084b18279d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetInvert </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>textWrapItems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8&nbsp;</td><td class="paramname"><em>bInvert</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Should the text wrap path be inverted? <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textWrapItems</td><td>IN: The list of text wrap items to which we will apply the bInvert setting. Alternatively a list with the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace may be used. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr><tr><td class="paramname">bInvert</td><td>IN: kTrue to invert the text wrap. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Any errors or kSuccess if successful. </dl></div></div><a class="anchor" id="a1b27f93d36cd276427d99bb8ffd355ae"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetMargins </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>textWrapItems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>topMargin</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>leftMargin</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>bottomMargin</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>rightMargin</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Set the margins (outsets) for text wrap. Use kUnchanged to leave a value unchanged. If a text wrap is non-rectangular, then the topMargin will be applied as an outset to the entire path. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textWrapItems</td><td>IN: The list of text wrap items to which we will apply the margin settings. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr><tr><td class="paramname">topMargin</td><td>IN: The top margin. Use kUnchanged to leave current setting unchanged. </td></tr><tr><td class="paramname">leftMargin</td><td>IN: The left margin. Use kUnchanged to leave current setting unchanged. </td></tr><tr><td class="paramname">bottomMargin</td><td>IN: The bottom margin. Use kUnchanged to leave current setting unchanged. </td></tr><tr><td class="paramname">rightMargin</td><td>IN: The right margin. Use kUnchanged to leave current setting unchanged. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Any errors or kSuccess if successful. </dl></div></div><a class="anchor" id="a50e8711baf7d7674bf3b4807631ccc23"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetMode </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>pageItems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_stand_off.html#a3ab0e1dfc6cb6bb64e290d6c1513c71a">IStandOff::mode</a>&nbsp;</td><td class="paramname"><em>mode</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>setUserModified</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Allows the client to specify a text wrap mode for several page items at once, or for the document- or session-workspace. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageItems</td><td>IN: The list of page items to which we will apply the text wrap. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr><tr><td class="paramname">Mode</td><td>IN: The text wrap mode to apply. </td></tr><tr><td class="paramname">setUserModified</td><td>IN: User modified paths become locked such that if the geometry (shape) of a page item changes, the text wrap does NOT update to match the new geometry. However, it will continue to move when the page item moves. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Any errors or kSuccess if successful. </dl></div></div><a class="anchor" id="afea6d39badd8d7eccf112ebc71d5afd6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetSide </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_list.html">UIDList</a> &amp;&nbsp;</td><td class="paramname"><em>textWrapItems</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_stand_off.html#ac6472421fe6f23237eccadabf291a486">IStandOff::side</a>&nbsp;</td><td class="paramname"><em>Side</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: Allows the client to specify a text wrap side for several page items at once, or for the document- or session-workspace. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textWrapItems</td><td>IN: The list of text wrap items to which we will apply the Side setting. Alternatively a list with the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace may be used. Alternatively, you can pass in the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the document or session workspace. </td></tr><tr><td class="paramname">Side</td><td>IN: The text wrap side to apply. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Any errors or kSuccess if successful. </dl></div></div><a class="anchor" id="ac4d8dc5682d0bf573b5c1490a1364092"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetSkipByLeadingHeight </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>workspace</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>skipByLeading</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: <a class="el" href="class_facade_1_1_i_text_wrap_facade.html#ac4d8dc5682d0bf573b5c1490a1364092">SetSkipByLeadingHeight()</a> is used to set the tiler behavior when a text wrap obstruction is encountered and the tiler needs to move down to find a tile. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">workspace</td><td>IN - the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the target workspace. This <a class="el" href="class_u_i_d_ref.html">UIDRef</a> can be either a document workspace or the session workspace. Changing the session workspace setting will cause all new documents to take on the new setting. Changing the document workspace setting changes the setting in only that document. </td></tr><tr><td class="paramname">skipByLeading</td><td>IN - pass kTrue to make the tiler skip down by the leading height when an obstruction is encountered. Pass kFalse to make the tiler skip down 1 point. If moving down by the leading height, then the next line of text may or may not abut the bottom of the obstruction but it will be faster to compose and the lines of text in a multi-column text frame are more likely to align. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>ErrorCode - kSuccess if successful, an error otherwise </dl></div></div><a class="anchor" id="a4bf4cd11f832e7f19ee5f421e40d7f1b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode Facade::ITextWrapFacade::SetZOrderBasedTextWrap </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>workspace</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>useZOrder</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Description: <a class="el" href="class_facade_1_1_i_text_wrap_facade.html#a4bf4cd11f832e7f19ee5f421e40d7f1b">SetZOrderBasedTextWrap()</a> is used to set whether or not text wrap is z-order based. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">workspace</td><td>IN - the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the target workspace. This <a class="el" href="class_u_i_d_ref.html">UIDRef</a> can be either a document workspace or the session workspace. Changing the session workspace setting will cause all new documents to take on the new setting. Changing the document workspace setting changes the setting in only that document. </td></tr><tr><td class="paramname">useZOrder</td><td>IN - pass kTrue to force text wrap items to only affect text which is above the text wrap in the z-order. Pass kFalse to have text wrap affect all text regardless of the z-order. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>ErrorCode - kSuccess if successful, an error otherwise </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="namespace_facade.html">Facade</a><li class="navelem"><a class="el" href="class_facade_1_1_i_text_wrap_facade.html">ITextWrapFacade</a><li class="footer">Generated on Sat Sep 22 2018 10:56:43 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
