<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_table_suite</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_table_suite.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#nested-classes">Classes</a> | <a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_table_suite-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITableSuite Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_table_suite_8h_source.html">ITableSuite.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ITableSuite:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_table_suite.png" usemap="#ITableSuite_map" /><map id="ITableSuite_map" name="ITableSuite_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> Classes</h2></td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite_1_1_freeze_tick_holder.html">FreezeTickHolder</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_table_suite_1_1_override_state.html">OverrideState</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite_1_1_user_row_number.html">UserRowNumber</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:afecb72b26b5525f04602699cc4de7877"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITABLE_ISUITE }</td></tr><tr class="separator:afecb72b26b5525f04602699cc4de7877"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a950059445478e990b9cea07c288da09a"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a950059445478e990b9cea07c288da09a">ESplitDirection</a> { <b>eVerticalSplit</b>, <b>eHorizontalSplit</b> }</td></tr><tr class="separator:a950059445478e990b9cea07c288da09a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3d44a36076f150df3d2412729560711a"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="struct_i_table_suite_1_1_override_state.html">OverrideState</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3d44a36076f150df3d2412729560711a">OverrideStateVector</a></td></tr><tr class="separator:a3d44a36076f150df3d2412729560711a"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a5ab324b77de49b34161439e5b8876c7a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a5ab324b77de49b34161439e5b8876c7a">CanInsertRows</a> (Tables::ERelativePosition pos) const =0</td></tr><tr class="separator:a5ab324b77de49b34161439e5b8876c7a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9a4aa670cfb63e4aeae38461c281fa9e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a9a4aa670cfb63e4aeae38461c281fa9e">CanInsertColumns</a> (Tables::ERelativePosition pos) const =0</td></tr><tr class="separator:a9a4aa670cfb63e4aeae38461c281fa9e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a807e221a52e5e5aef81ee3b7fad24461"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a807e221a52e5e5aef81ee3b7fad24461">CanDeleteRows</a> (void) const =0</td></tr><tr class="separator:a807e221a52e5e5aef81ee3b7fad24461"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae97522c09e870016cb408f007cad6bf9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae97522c09e870016cb408f007cad6bf9">CanDeleteColumns</a> (void) const =0</td></tr><tr class="separator:ae97522c09e870016cb408f007cad6bf9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab3fd4efe3be40ff3916c6b8eb979359a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ab3fd4efe3be40ff3916c6b8eb979359a">CanMergeCells</a> (void) const =0</td></tr><tr class="separator:ab3fd4efe3be40ff3916c6b8eb979359a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6c73785570b250269c615968dc780583"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a6c73785570b250269c615968dc780583">CanUnmergeCell</a> (void) const =0</td></tr><tr class="separator:a6c73785570b250269c615968dc780583"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae48787d446b6f86eec2b1779d4e7570a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae48787d446b6f86eec2b1779d4e7570a">CanSplitCells</a> (<a class="el" href="class_i_table_suite.html#a950059445478e990b9cea07c288da09a">ESplitDirection</a> direction) const =0</td></tr><tr class="separator:ae48787d446b6f86eec2b1779d4e7570a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aabef3daf5b84899d21a07e7b51c38c3e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aabef3daf5b84899d21a07e7b51c38c3e">CanEditTable</a> (void) const =0</td></tr><tr class="separator:aabef3daf5b84899d21a07e7b51c38c3e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3342c9ad2f03d46b57b19b95ef945ec3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3342c9ad2f03d46b57b19b95ef945ec3">CanConvertTableToText</a> () const =0</td></tr><tr class="separator:a3342c9ad2f03d46b57b19b95ef945ec3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a263cbe0575d51e71447c4d0010bce244"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a263cbe0575d51e71447c4d0010bce244">CanDeleteTable</a> () const =0</td></tr><tr class="separator:a263cbe0575d51e71447c4d0010bce244"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a295e2da5bb0c90333c7fd8458d7fd22b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a295e2da5bb0c90333c7fd8458d7fd22b">InsertRows</a> (int32 howMany, Tables::ERelativePosition pos, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;rowHeight, Tables::EContinuation continuation=Tables::eStructureAllAttrs)=0</td></tr><tr class="separator:a295e2da5bb0c90333c7fd8458d7fd22b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4176cc85966ef8ba316c8c6acd973a1b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a4176cc85966ef8ba316c8c6acd973a1b">InsertColumns</a> (int32 howMany, Tables::ERelativePosition pos, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;colWidth, Tables::EContinuation continuation=Tables::eStructureAllAttrs)=0</td></tr><tr class="separator:a4176cc85966ef8ba316c8c6acd973a1b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af65e7f4c14196cdcea3691599e326cbc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#af65e7f4c14196cdcea3691599e326cbc">DeleteRows</a> (void)=0</td></tr><tr class="separator:af65e7f4c14196cdcea3691599e326cbc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab733e1ea02086b177bbdd5fae7f83216"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ab733e1ea02086b177bbdd5fae7f83216">DeleteColumns</a> (void)=0</td></tr><tr class="separator:ab733e1ea02086b177bbdd5fae7f83216"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5446b3797f3ce5ba0b6f0f3a106b3292"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a5446b3797f3ce5ba0b6f0f3a106b3292">MergeCells</a> (void)=0</td></tr><tr class="separator:a5446b3797f3ce5ba0b6f0f3a106b3292"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5425b449dae8d89f6185c0ac00377475"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a5425b449dae8d89f6185c0ac00377475">UnmergeCell</a> (void)=0</td></tr><tr class="separator:a5425b449dae8d89f6185c0ac00377475"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaf1d17b13b85bf54d48d79f3b3eab5da"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aaf1d17b13b85bf54d48d79f3b3eab5da">SplitCells</a> (<a class="el" href="class_i_table_suite.html#a950059445478e990b9cea07c288da09a">ESplitDirection</a> direction)=0</td></tr><tr class="separator:aaf1d17b13b85bf54d48d79f3b3eab5da"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a7653e0041162e75bc44ef20596f461"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a5a7653e0041162e75bc44ef20596f461">ConvertTableToText</a> (const <a class="el" href="class_p_m_string.html">PMString</a> colSeparator=&quot;\t&quot;, const <a class="el" href="class_p_m_string.html">PMString</a> rowSeparator=&quot;\r&quot;)=0</td></tr><tr class="separator:a5a7653e0041162e75bc44ef20596f461"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7686e2263af4251422d95e21ab4cdcb5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a7686e2263af4251422d95e21ab4cdcb5">DeleteTable</a> ()=0</td></tr><tr class="separator:a7686e2263af4251422d95e21ab4cdcb5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae1b5fa41d4e6872bf12cdf682f1606e3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae1b5fa41d4e6872bf12cdf682f1606e3">CanClearAllTableOverrides</a> () const =0</td></tr><tr class="separator:ae1b5fa41d4e6872bf12cdf682f1606e3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac621bfc8cf189eb81e244aabe367c2d3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ac621bfc8cf189eb81e244aabe367c2d3">CanClearSelectionOverrides</a> () const =0</td></tr><tr class="separator:ac621bfc8cf189eb81e244aabe367c2d3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aec3cf04e203342b14bbeb7a554804459"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aec3cf04e203342b14bbeb7a554804459">ClearAllTableOverrides</a> (<a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &amp;attrs) const =0</td></tr><tr class="separator:aec3cf04e203342b14bbeb7a554804459"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a48eb0f7635d9a076d616081ec7252490"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a48eb0f7635d9a076d616081ec7252490">ClearSelectionOverrides</a> (<a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &amp;attrs, <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data) const =0</td></tr><tr class="separator:a48eb0f7635d9a076d616081ec7252490"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a862565157e6b4197b7d6b216447b6c3f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a862565157e6b4197b7d6b216447b6c3f">CanResizeRows</a> (void) const =0</td></tr><tr class="separator:a862565157e6b4197b7d6b216447b6c3f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae9a907f234d5d0e54e77301faf971852"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae9a907f234d5d0e54e77301faf971852">CanResizeColumns</a> (void) const =0</td></tr><tr class="separator:ae9a907f234d5d0e54e77301faf971852"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa169fa556fcd91de4e5eda76c699fe86"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aa169fa556fcd91de4e5eda76c699fe86">ResizeRows</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height)=0</td></tr><tr class="separator:aa169fa556fcd91de4e5eda76c699fe86"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a338ce098273d94542a3b4382c37263a1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a338ce098273d94542a3b4382c37263a1">ResizeColumns</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width)=0</td></tr><tr class="separator:a338ce098273d94542a3b4382c37263a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a74486e023cd912abbf93a265e72c7213"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a74486e023cd912abbf93a265e72c7213">CanResizeCellHeight</a> (void) const =0</td></tr><tr class="separator:a74486e023cd912abbf93a265e72c7213"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adb609ed61442975a2dcc365a9bc78fae"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#adb609ed61442975a2dcc365a9bc78fae">CanResizeCellWidth</a> (void) const =0</td></tr><tr class="separator:adb609ed61442975a2dcc365a9bc78fae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a30dfa54bc8b123d1e671e52bdce60b4a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a30dfa54bc8b123d1e671e52bdce60b4a">ResizeCellHeight</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height)=0</td></tr><tr class="separator:a30dfa54bc8b123d1e671e52bdce60b4a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af21875e8fba2133d0215fb5fa2af96ab"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#af21875e8fba2133d0215fb5fa2af96ab">ResizeCellWidth</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width)=0</td></tr><tr class="separator:af21875e8fba2133d0215fb5fa2af96ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c63d3cf5288770396fa5281e60ad291"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a8c63d3cf5288770396fa5281e60ad291">CanRedistributeRows</a> (void) const =0</td></tr><tr class="separator:a8c63d3cf5288770396fa5281e60ad291"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abf08d1697de95684320d94496018dc9c"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#abf08d1697de95684320d94496018dc9c">CanRedistributeColumns</a> (void) const =0</td></tr><tr class="separator:abf08d1697de95684320d94496018dc9c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae6b2f1faf5487ad32fd2bd699ed527ff"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae6b2f1faf5487ad32fd2bd699ed527ff">RedistributeRows</a> (void)=0</td></tr><tr class="separator:ae6b2f1faf5487ad32fd2bd699ed527ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a592c728d597ca9deef3def1d6c30c29d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a592c728d597ca9deef3def1d6c30c29d">RedistributeColumns</a> (void)=0</td></tr><tr class="separator:a592c728d597ca9deef3def1d6c30c29d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd6c48283a2f696787eb457197285f9c"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#afd6c48283a2f696787eb457197285f9c">CanSwapCellStrokeFill</a> (void) const =0</td></tr><tr class="separator:afd6c48283a2f696787eb457197285f9c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad67046928257d7af1d95e01e79feb402"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ad67046928257d7af1d95e01e79feb402">SwapCellStrokeFill</a> (void)=0</td></tr><tr class="separator:ad67046928257d7af1d95e01e79feb402"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa109f3ba331698ea4a43aebf23578a97"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aa109f3ba331698ea4a43aebf23578a97">ChangeBodyRowDimensionTo</a> (int32 newRowDim) const =0</td></tr><tr class="separator:aa109f3ba331698ea4a43aebf23578a97"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4f1e9ba58f0a90e67cc02806f2c21f63"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a4f1e9ba58f0a90e67cc02806f2c21f63">ChangeColumnDimensionTo</a> (int32 newColDim) const =0</td></tr><tr class="separator:a4f1e9ba58f0a90e67cc02806f2c21f63"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae4b9355ef09ba088225317ca9be9b169"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae4b9355ef09ba088225317ca9be9b169">ChangeHeaderRowDimensionTo</a> (int32 newRowDim) const =0</td></tr><tr class="separator:ae4b9355ef09ba088225317ca9be9b169"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3dac05105f46f9e0577d361eeeea12e0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3dac05105f46f9e0577d361eeeea12e0">ChangeFooterRowDimensionTo</a> (int32 newRowDim) const =0</td></tr><tr class="separator:a3dac05105f46f9e0577d361eeeea12e0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a566d864ba515ed29682b3d8e257ce6aa"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a566d864ba515ed29682b3d8e257ce6aa">CanChangeTableDimensions</a> (void) const =0</td></tr><tr class="separator:a566d864ba515ed29682b3d8e257ce6aa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2cb8aac86fe8665b3749dc92ab6a0c0c"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a2cb8aac86fe8665b3749dc92ab6a0c0c">CanConvertToHeaderRows</a> (void) const =0</td></tr><tr class="separator:a2cb8aac86fe8665b3749dc92ab6a0c0c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad3b6f0a0dc7f10995dae759ea6c3ccf2"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ad3b6f0a0dc7f10995dae759ea6c3ccf2">ConvertToHeaderRows</a> (void)=0</td></tr><tr class="separator:ad3b6f0a0dc7f10995dae759ea6c3ccf2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa60abcce6a84457ded07280e57b2502d"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aa60abcce6a84457ded07280e57b2502d">CanConvertToFooterRows</a> (void) const =0</td></tr><tr class="separator:aa60abcce6a84457ded07280e57b2502d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adbfe8db056c3382dc5c71367bd87998f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#adbfe8db056c3382dc5c71367bd87998f">ConvertToFooterRows</a> (void)=0</td></tr><tr class="separator:adbfe8db056c3382dc5c71367bd87998f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac506e9507ebb76f3661025e739f14d2a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ac506e9507ebb76f3661025e739f14d2a">CanConvertToBodyRows</a> (void) const =0</td></tr><tr class="separator:ac506e9507ebb76f3661025e739f14d2a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad3973efa62ce5976b394d832fcaa6e51"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ad3973efa62ce5976b394d832fcaa6e51">ConvertToBodyRows</a> (void)=0</td></tr><tr class="separator:ad3973efa62ce5976b394d832fcaa6e51"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a49e0e374d21477c7ea00026ea64c0d37"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a49e0e374d21477c7ea00026ea64c0d37">CanCreateTableStyleFromSelection</a> (void) const =0</td></tr><tr class="separator:a49e0e374d21477c7ea00026ea64c0d37"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4784b6466ca5d13f77b11db058a18951"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a4784b6466ca5d13f77b11db058a18951">CreateTableStyleFromSelection</a> (void)=0</td></tr><tr class="separator:a4784b6466ca5d13f77b11db058a18951"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac6cff688185af84378c76c83a314f1a1"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ac6cff688185af84378c76c83a314f1a1">CanApplyTableStyle</a> (int32 nthStyle) const =0</td></tr><tr class="separator:ac6cff688185af84378c76c83a314f1a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a95eb09662a1c9d24ab6257fa0cd83b97"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a95eb09662a1c9d24ab6257fa0cd83b97">ApplyTableStyle</a> (int32 nthStyle)=0</td></tr><tr class="separator:a95eb09662a1c9d24ab6257fa0cd83b97"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af262fe44d94673ca59b6aa7e034a694b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af262fe44d94673ca59b6aa7e034a694b"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>CanFreezeTick</b> () const =0</td></tr><tr class="separator:af262fe44d94673ca59b6aa7e034a694b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9d415a5a9a63fb7e80cab56216023026"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9d415a5a9a63fb7e80cab56216023026"></a> virtual <a class="el" href="class_i_table_suite_1_1_freeze_tick_holder.html">FreezeTickHolder</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>FreezeTick</b> ()=0</td></tr><tr class="separator:a9d415a5a9a63fb7e80cab56216023026"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2b9444801817e3b43226b2b05d153cfd"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a2b9444801817e3b43226b2b05d153cfd">CanGetRowSize</a> (void) const =0</td></tr><tr class="separator:a2b9444801817e3b43226b2b05d153cfd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a92fc805e5a552b28b2d7fc1036776915"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a92fc805e5a552b28b2d7fc1036776915">CanGetColumnSize</a> (void) const =0</td></tr><tr class="separator:a92fc805e5a552b28b2d7fc1036776915"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8549d457c3ffe13883194d2b8a4e9eb7"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a8549d457c3ffe13883194d2b8a4e9eb7">GetRowSize</a> (void) const =0</td></tr><tr class="separator:a8549d457c3ffe13883194d2b8a4e9eb7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adc3c42ed4d07983f75615dd1308cc2cc"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#adc3c42ed4d07983f75615dd1308cc2cc">GetColumnSize</a> (void) const =0</td></tr><tr class="separator:adc3c42ed4d07983f75615dd1308cc2cc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a514106da1d532f1a26eefb070d2fdaee"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a514106da1d532f1a26eefb070d2fdaee">CanGetCellWidth</a> (void) const =0</td></tr><tr class="separator:a514106da1d532f1a26eefb070d2fdaee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0ed7960072002c2f0a78d6a4e2e440f9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a0ed7960072002c2f0a78d6a4e2e440f9">CanGetCellHeight</a> (void) const =0</td></tr><tr class="separator:a0ed7960072002c2f0a78d6a4e2e440f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a74a0203659a5d7da6a4359cadcfcdb48"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a74a0203659a5d7da6a4359cadcfcdb48">GetCellWidth</a> (void) const =0</td></tr><tr class="separator:a74a0203659a5d7da6a4359cadcfcdb48"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b7eb3de7f70831cb57341f621eb1fa5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a1b7eb3de7f70831cb57341f621eb1fa5">GetCellHeight</a> (void) const =0</td></tr><tr class="separator:a1b7eb3de7f70831cb57341f621eb1fa5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a03d94f78b34c06628e1d55d98db904e1"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a03d94f78b34c06628e1d55d98db904e1">CanApplyTableOverrides</a> () const =0</td></tr><tr class="separator:a03d94f78b34c06628e1d55d98db904e1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3ead008ea43ce412fe978d174e38c0f0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3ead008ea43ce412fe978d174e38c0f0">ApplyTableOverrides</a> (const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:a3ead008ea43ce412fe978d174e38c0f0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0cda8417fb7fa0fe6aa9e944cdefb992"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a0cda8417fb7fa0fe6aa9e944cdefb992">QueryTableAttribute</a> (<a class="el" href="class_i_d_type.html">ClassID</a> whichAttr) const =0</td></tr><tr class="separator:a0cda8417fb7fa0fe6aa9e944cdefb992"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a0e6e1004119d2fb804d4aec8a8b4bd"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a5a0e6e1004119d2fb804d4aec8a8b4bd">ApplyCellOverrides</a> (const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:a5a0e6e1004119d2fb804d4aec8a8b4bd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af4bcde472caae3f4bcb0a7e39ce54876"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#af4bcde472caae3f4bcb0a7e39ce54876">CanApplyCellOverrides</a> (void) const =0</td></tr><tr class="separator:af4bcde472caae3f4bcb0a7e39ce54876"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3244eb2e7afeecdd8a033ce80763484d"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3244eb2e7afeecdd8a033ce80763484d">CanGetCellAttribute</a> (<a class="el" href="class_i_d_type.html">ClassID</a> whichAttr) const =0</td></tr><tr class="separator:a3244eb2e7afeecdd8a033ce80763484d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a48ab09f1cb44e9aaf4cebd9832e96d14"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a48ab09f1cb44e9aaf4cebd9832e96d14">QueryCellAttribute</a> (<a class="el" href="class_i_d_type.html">ClassID</a> whichAttr) const =0</td></tr><tr class="separator:a48ab09f1cb44e9aaf4cebd9832e96d14"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a952469b967e56a1e5e70e3cab5aacbd0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a952469b967e56a1e5e70e3cab5aacbd0">CanApplyCellStrokes</a> (const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data) const =0</td></tr><tr class="separator:a952469b967e56a1e5e70e3cab5aacbd0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a45f2bc6b39f01a7ed79588c6a35b99ba"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a45f2bc6b39f01a7ed79588c6a35b99ba">ApplyCellStrokes</a> (const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data)=0</td></tr><tr class="separator:a45f2bc6b39f01a7ed79588c6a35b99ba"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a95ee2e29cf267115fcea171b38fcdc52"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a95ee2e29cf267115fcea171b38fcdc52">CanGetCellStrokes</a> (const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data) const =0</td></tr><tr class="separator:a95ee2e29cf267115fcea171b38fcdc52"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abb0ea09258923700c325ba212ee3657e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#abb0ea09258923700c325ba212ee3657e">GetCellStrokes</a> (<a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;data) const =0</td></tr><tr class="separator:abb0ea09258923700c325ba212ee3657e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2034e639731aad16a0fa266d8d652ed0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a2034e639731aad16a0fa266d8d652ed0">CanGetApplyCellStrokesBySelection</a> (void) const =0</td></tr><tr class="separator:a2034e639731aad16a0fa266d8d652ed0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae325441491f203126e0e4a15821c5338"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae325441491f203126e0e4a15821c5338">ApplyCellStrokesBySelection</a> (const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *attr)=0</td></tr><tr class="separator:ae325441491f203126e0e4a15821c5338"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a44c4d4cd3da52cb9f687ce6e342499ec"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a44c4d4cd3da52cb9f687ce6e342499ec">GetCellStrokesBySelection</a> () const =0</td></tr><tr class="separator:a44c4d4cd3da52cb9f687ce6e342499ec"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a78029f9fad6d96ebfd21aa72cfc8c133"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a78029f9fad6d96ebfd21aa72cfc8c133">ApplyRowOverrides</a> (const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *attrs)=0</td></tr><tr class="separator:a78029f9fad6d96ebfd21aa72cfc8c133"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7ec630ba88f4ba9b0543e9db76598431"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a7ec630ba88f4ba9b0543e9db76598431">CanApplyRowOverrides</a> (void) const =0</td></tr><tr class="separator:a7ec630ba88f4ba9b0543e9db76598431"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a30fdfacaf0228273c9ccf1bac63c0280"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a30fdfacaf0228273c9ccf1bac63c0280">CanApplyRowKeeps</a> (void) const =0</td></tr><tr class="separator:a30fdfacaf0228273c9ccf1bac63c0280"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abd0c2d5aebf81afd64ee5b85b3bd427a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#abd0c2d5aebf81afd64ee5b85b3bd427a">CanGetRowAttribute</a> (<a class="el" href="class_i_d_type.html">ClassID</a> whichAttr) const =0</td></tr><tr class="separator:abd0c2d5aebf81afd64ee5b85b3bd427a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aebf6baebb20e8b896c39266eff733d1e"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aebf6baebb20e8b896c39266eff733d1e">QueryRowAttribute</a> (<a class="el" href="class_i_d_type.html">ClassID</a> whichAttr) const =0</td></tr><tr class="separator:aebf6baebb20e8b896c39266eff733d1e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6787efb7e89fe3d1aa2806f33ab6a610"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a6787efb7e89fe3d1aa2806f33ab6a610">CanGetColAttribute</a> (<a class="el" href="class_i_d_type.html">ClassID</a> whichAttr) const =0</td></tr><tr class="separator:a6787efb7e89fe3d1aa2806f33ab6a610"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a07274fd937b850254f3f6a345ddac0af"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a07274fd937b850254f3f6a345ddac0af">QueryColAttribute</a> (<a class="el" href="class_i_d_type.html">ClassID</a> whichAttr) const =0</td></tr><tr class="separator:a07274fd937b850254f3f6a345ddac0af"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1c3ebacff2e1cabdd4e09276076da51f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a1c3ebacff2e1cabdd4e09276076da51f">CanGetOverridesInTable</a> () const =0</td></tr><tr class="separator:a1c3ebacff2e1cabdd4e09276076da51f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8a1cc103dc520cf996261109596c8920"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a8a1cc103dc520cf996261109596c8920">GetOverridesInTable</a> (Tables::ERowColumn patternType, int32 firstPatternCount, int32 secondPatternCount, int32 skipFirst, int32 skipLast, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *findAttrsFirst, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *findAttrsSecond, <a class="el" href="class_i_table_suite.html#a3d44a36076f150df3d2412729560711a">OverrideStateVector</a> *resultFirst, <a class="el" href="class_i_table_suite.html#a3d44a36076f150df3d2412729560711a">OverrideStateVector</a> *resultSecond) const =0</td></tr><tr class="separator:a8a1cc103dc520cf996261109596c8920"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af14cd27f267080f0719be01d054d3cd7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#af14cd27f267080f0719be01d054d3cd7">ClearRowPatternFillOverrides</a> (const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *firstOverrideAttrs, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *secondOverrideAttrs, const int32 pattern1, const int32 pattern2, const int32 skipFirst, const int32 skipLast)=0</td></tr><tr class="separator:af14cd27f267080f0719be01d054d3cd7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a534b8859de58683a069a57d722d995f0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a534b8859de58683a069a57d722d995f0">ClearColumnPatternFillOverrides</a> (const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *firstOverrideAttrs, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *secondOverrideAttrs, const int32 pattern1, const int32 pattern2, const int32 skipFirst, const int32 skipLast)=0</td></tr><tr class="separator:a534b8859de58683a069a57d722d995f0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a44e780e7860b25b6d4279816d74b963b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a44e780e7860b25b6d4279816d74b963b">GetStrokeOverridesInTable</a> (Tables::ERowColumn patternType, int32 firstPatternCount, int32 secondPatternCount, int32 skipFirst, int32 skipLast, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;firstData, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;secontData, <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;resultFirst, <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;resultSecond) const =0</td></tr><tr class="separator:a44e780e7860b25b6d4279816d74b963b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaeee05fc32e02aba4bc035724282b113"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aaeee05fc32e02aba4bc035724282b113">ClearRowPatternStrokeOverrides</a> (const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;firstOverrideAttrs, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;secondOverrideAttrs, const int32 pattern1, const int32 pattern2, const int32 skipFirst, const int32 skipLast)=0</td></tr><tr class="separator:aaeee05fc32e02aba4bc035724282b113"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a45ac75e8a86507218d23f55b84a5b398"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a45ac75e8a86507218d23f55b84a5b398">ClearColumnPatternStrokeOverrides</a> (const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;firstOverrideAttrs, const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;secondOverrideAttrs, const int32 pattern1, const int32 pattern2, const int32 skipFirst, const int32 skipLast)=0</td></tr><tr class="separator:a45ac75e8a86507218d23f55b84a5b398"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a43e02e5950f6a8df8eaa5b913f948474"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a43e02e5950f6a8df8eaa5b913f948474">GetBorderOverridesInTable</a> (const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *findAttrs, <a class="el" href="class_i_table_suite.html#a3d44a36076f150df3d2412729560711a">OverrideStateVector</a> *results) const =0</td></tr><tr class="separator:a43e02e5950f6a8df8eaa5b913f948474"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5f2c28c9e614228ceb938402d3336fa1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a5f2c28c9e614228ceb938402d3336fa1">ClearOverridesIntersectingBorder</a> (const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *leftSideAttrs, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *topSideAttrs, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *rightSideAttrs, const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *bottomSideAttrs)=0</td></tr><tr class="separator:a5f2c28c9e614228ceb938402d3336fa1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a93d56b56981cb177be4632415589ff13"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a93d56b56981cb177be4632415589ff13">CanGetWritingDirection</a> (void) const =0</td></tr><tr class="separator:a93d56b56981cb177be4632415589ff13"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a090e3686f5ef43d7160f3b66d83f517f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a090e3686f5ef43d7160f3b66d83f517f">IsWritingDirectionHorizontal</a> (void) const =0</td></tr><tr class="separator:a090e3686f5ef43d7160f3b66d83f517f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a271b9a5057887d45f8690b4686ade5bd"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_suite_1_1_user_row_number.html">UserRowNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a271b9a5057887d45f8690b4686ade5bd">GetUserCurrentRowNumber</a> (void) const =0</td></tr><tr class="separator:a271b9a5057887d45f8690b4686ade5bd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9a0abfe449ce6cbe0db26d679c8debbd"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a9a0abfe449ce6cbe0db26d679c8debbd">GetUserCurrentColNumber</a> (void) const =0</td></tr><tr class="separator:a9a0abfe449ce6cbe0db26d679c8debbd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a10577af45bd9caae22cc212fe96e1ca9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a10577af45bd9caae22cc212fe96e1ca9">CanGetTextFramesSpannedBySelection</a> () const =0</td></tr><tr class="separator:a10577af45bd9caae22cc212fe96e1ca9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab65479e6234f5d6886a90997c7a29a4d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_k2_vector.html">K2Vector</a><br class="typebreak" /> &lt; <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ab65479e6234f5d6886a90997c7a29a4d">GetTextFramesSpannedBySelection</a> () const =0</td></tr><tr class="separator:ab65479e6234f5d6886a90997c7a29a4d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a01cabc5f9ded7ef7e9e3f37ee95f6478"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a01cabc5f9ded7ef7e9e3f37ee95f6478">CanGetSpanInformationFromSelection</a> () const =0</td></tr><tr class="separator:a01cabc5f9ded7ef7e9e3f37ee95f6478"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a80b1dfaafae57b8ed2e4394c091f2755"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a80b1dfaafae57b8ed2e4394c091f2755"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetHSpanSmallestHorizMergedCellInSelection</b> () const =0</td></tr><tr class="separator:a80b1dfaafae57b8ed2e4394c091f2755"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a76bda72c57a01a34c6efc12543f43a22"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a76bda72c57a01a34c6efc12543f43a22"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetHSpanLargestHorizMergedCellInSelection</b> () const =0</td></tr><tr class="separator:a76bda72c57a01a34c6efc12543f43a22"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a47073e08f10211d5972e6fe60eb4cd90"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a47073e08f10211d5972e6fe60eb4cd90"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetVSpanSmallestVertMergedCellInSelection</b> () const =0</td></tr><tr class="separator:a47073e08f10211d5972e6fe60eb4cd90"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0cf6c4e71b23ce3e0afbef6c0dec39cd"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0cf6c4e71b23ce3e0afbef6c0dec39cd"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetVSpanLargestVertMergedCellInSelection</b> () const =0</td></tr><tr class="separator:a0cf6c4e71b23ce3e0afbef6c0dec39cd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab87160b264fb84966c70764ccfe3e0be"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ab87160b264fb84966c70764ccfe3e0be">CanGetUserRowSelection</a> (int32 rowNum) const =0</td></tr><tr class="separator:ab87160b264fb84966c70764ccfe3e0be"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4c02237a51772e7f447f84d63edae747"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4c02237a51772e7f447f84d63edae747"></a> virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetUserRowSelection</b> (const int32 rowNum, const ITableSuite::UserRowNumber::RowType rowType) const =0</td></tr><tr class="separator:a4c02237a51772e7f447f84d63edae747"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a65a8dd79f4406a56f44c89e31c9b9e25"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a65a8dd79f4406a56f44c89e31c9b9e25">IsHeaderSelection</a> () const =0</td></tr><tr class="separator:a65a8dd79f4406a56f44c89e31c9b9e25"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3e4be77c51afbb921de27ddde149baf2"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3e4be77c51afbb921de27ddde149baf2">IsFooterSelection</a> () const =0</td></tr><tr class="separator:a3e4be77c51afbb921de27ddde149baf2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8f99db169a759265e4d765dbeec3ced0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a8f99db169a759265e4d765dbeec3ced0">isWholeTableSelected</a> () const =0</td></tr><tr class="separator:a8f99db169a759265e4d765dbeec3ced0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a87e9f210786fa9d12fa17ceac8c0ad5d"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a87e9f210786fa9d12fa17ceac8c0ad5d">CanGetMaxMinRowSizeOfSelection</a> () const =0</td></tr><tr class="separator:a87e9f210786fa9d12fa17ceac8c0ad5d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4511be1c4e9ea141ac03341d5ab87999"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a4511be1c4e9ea141ac03341d5ab87999">GetMaxRowSizeOfSelection</a> () const =0</td></tr><tr class="separator:a4511be1c4e9ea141ac03341d5ab87999"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af5a524cec9b13bfdbb29d6b330dc74dc"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#af5a524cec9b13bfdbb29d6b330dc74dc">GetMinRowSizeOfSelection</a> () const =0</td></tr><tr class="separator:af5a524cec9b13bfdbb29d6b330dc74dc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad8ae0ec6b44df2c5396b6ccfe571b32e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ad8ae0ec6b44df2c5396b6ccfe571b32e">CanGetSelectionActiveStrokes</a> (void) const =0</td></tr><tr class="separator:ad8ae0ec6b44df2c5396b6ccfe571b32e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acdca8f1920c1f84f342bc84668d5fa7e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="acdca8f1920c1f84f342bc84668d5fa7e"></a> virtual Tables::ESelectionSides&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSelectionActiveStrokes</b> (void)=0</td></tr><tr class="separator:acdca8f1920c1f84f342bc84668d5fa7e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0d77053c0d3b007ddf168a58cf7f9adb"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a0d77053c0d3b007ddf168a58cf7f9adb">CanGetTableProperties</a> (void) const =0</td></tr><tr class="separator:a0d77053c0d3b007ddf168a58cf7f9adb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaeae5741e3b5f09201b62b86b7faa86d"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aaeae5741e3b5f09201b62b86b7faa86d">CanGetHeader</a> (void) const =0</td></tr><tr class="separator:aaeae5741e3b5f09201b62b86b7faa86d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afbcb1a92af01f095c1c80ad10ad9ec49"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#afbcb1a92af01f095c1c80ad10ad9ec49">CanGetFooter</a> (void) const =0</td></tr><tr class="separator:afbcb1a92af01f095c1c80ad10ad9ec49"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aca22d0bcadf77a4b771ab1fa1944f563"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aca22d0bcadf77a4b771ab1fa1944f563">GetNumRowsInTable</a> (void) const =0</td></tr><tr class="separator:aca22d0bcadf77a4b771ab1fa1944f563"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a681f18a7b9a7df6e9d13fedb91be93a4"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a681f18a7b9a7df6e9d13fedb91be93a4">GetNumColsInTable</a> (void) const =0</td></tr><tr class="separator:a681f18a7b9a7df6e9d13fedb91be93a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac16541ed17c375070b1a4905b6c23b14"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ac16541ed17c375070b1a4905b6c23b14">GetNumHeaderRowsInTable</a> (void) const =0</td></tr><tr class="separator:ac16541ed17c375070b1a4905b6c23b14"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ada12296dc67e8290fa59004b78c41e07"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ada12296dc67e8290fa59004b78c41e07">GetNumFooterRowsInTable</a> (void) const =0</td></tr><tr class="separator:ada12296dc67e8290fa59004b78c41e07"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3ec77defced3fe10d91270dc78e322de"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3ec77defced3fe10d91270dc78e322de">GetUserNumRowsInTable</a> (void) const =0</td></tr><tr class="separator:a3ec77defced3fe10d91270dc78e322de"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3b76b55662f04bb6ca4b3597ef97705b"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3b76b55662f04bb6ca4b3597ef97705b">GetUserNumColsInTable</a> (void) const =0</td></tr><tr class="separator:a3b76b55662f04bb6ca4b3597ef97705b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a90926e01ff53a160ae5c37d39349956e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a90926e01ff53a160ae5c37d39349956e">TableContainsHeaders</a> (void) const =0</td></tr><tr class="separator:a90926e01ff53a160ae5c37d39349956e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2cfc996cbaab4586bfc110c773a563bd"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a2cfc996cbaab4586bfc110c773a563bd">TableContainsFooters</a> (void) const =0</td></tr><tr class="separator:a2cfc996cbaab4586bfc110c773a563bd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3016dfdcf560c97be17c9ad20775ba87"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3016dfdcf560c97be17c9ad20775ba87">CanInsertTable</a> () const =0</td></tr><tr class="separator:a3016dfdcf560c97be17c9ad20775ba87"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a20fe3f72bdedb10d0227d0e370bed269"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a20fe3f72bdedb10d0227d0e370bed269">InsertTable</a> (const int32 numRows, const int32 numCols, const int32 headerRows, const int32 footerRows, const <a class="el" href="class_i_d_type.html">UID</a> &amp;tableStyleUID=kInvalidUID, const Tables::EDirection direction=Tables::eLTR)=0</td></tr><tr class="separator:a20fe3f72bdedb10d0227d0e370bed269"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a931b654063c043899b028180914e0dbf"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a931b654063c043899b028180914e0dbf">CanConvertTextToTable</a> () const =0</td></tr><tr class="separator:a931b654063c043899b028180914e0dbf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa61aa9196df706aa71c5e74fab30dba6"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#aa61aa9196df706aa71c5e74fab30dba6">ConvertTextToTable</a> (const <a class="el" href="class_p_m_string.html">PMString</a> colSeparator=&quot;\t&quot;, const <a class="el" href="class_p_m_string.html">PMString</a> rowSeparator=&quot;\r&quot;, const int32 userNumCols=1, const <a class="el" href="class_i_d_type.html">UID</a> &amp;tableStyleUID=kInvalidUID) const =0</td></tr><tr class="separator:aa61aa9196df706aa71c5e74fab30dba6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2ab4afb3f7468071299b7f586fbdd98d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a2ab4afb3f7468071299b7f586fbdd98d">ConvertTextToTable</a> (const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_p_m_string.html">PMString</a> &gt; &amp;colSeparators, const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_p_m_string.html">PMString</a> &gt; &amp;rowSeparators, const int32 userNumCols=1, const <a class="el" href="class_i_d_type.html">UID</a> &amp;tableStyleUID=kInvalidUID) const =0</td></tr><tr class="separator:a2ab4afb3f7468071299b7f586fbdd98d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6cc304e38a8c5d6ac1f05ace72b424e5"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a6cc304e38a8c5d6ac1f05ace72b424e5">AnyFootnotesInSelection</a> () const =0</td></tr><tr class="separator:a6cc304e38a8c5d6ac1f05ace72b424e5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd63490bd0ca550a5b4a55bfd17385f3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#afd63490bd0ca550a5b4a55bfd17385f3">CanGetTableDirection</a> (void) const =0</td></tr><tr class="separator:afd63490bd0ca550a5b4a55bfd17385f3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae412d377e1c7a23f8b76ffb56f7ca448"><td align="right" class="memItemLeft" valign="top">virtual Tables::EDirection&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae412d377e1c7a23f8b76ffb56f7ca448">GetTableDirection</a> (void) const =0</td></tr><tr class="separator:ae412d377e1c7a23f8b76ffb56f7ca448"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4e4c5dd9843ddd930a714bd0dadfd4ca"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a4e4c5dd9843ddd930a714bd0dadfd4ca">CanChangeTableDirection</a> (void) const =0</td></tr><tr class="separator:a4e4c5dd9843ddd930a714bd0dadfd4ca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae10dbfb46c041987092527edc0bb7970"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ae10dbfb46c041987092527edc0bb7970">ChangeTableDirection</a> (Tables::EDirection NewDirection) const =0</td></tr><tr class="separator:ae10dbfb46c041987092527edc0bb7970"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3bc0df3b7ef99cd5baaf2238343008bc"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3bc0df3b7ef99cd5baaf2238343008bc">CanMoveRows</a> (int32 toRow) const =0</td></tr><tr class="separator:a3bc0df3b7ef99cd5baaf2238343008bc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a27031c6582eeaee7269d62060c5b9bec"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a27031c6582eeaee7269d62060c5b9bec">MoveRows</a> (<a class="el" href="class_i_table_model.html">ITableModel</a> *sourceTable, <a class="el" href="class_grid_area.html">GridArea</a> fromArea, int32 toRow, Tables::ERelativePosition, bool16 duplicateFlag)=0</td></tr><tr class="separator:a27031c6582eeaee7269d62060c5b9bec"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a798b570a2a09ba32055e6fd2af9070c3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a798b570a2a09ba32055e6fd2af9070c3">CanMoveColumns</a> (int32 toColumn) const =0</td></tr><tr class="separator:a798b570a2a09ba32055e6fd2af9070c3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a261c1522190ec098c071088b01458a7a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a261c1522190ec098c071088b01458a7a">MoveColumns</a> (<a class="el" href="class_i_table_model.html">ITableModel</a> *sourceTable, <a class="el" href="class_grid_area.html">GridArea</a> fromArea, int32 toColumn, Tables::ERelativePosition pos, bool16 duplicateFlag)=0</td></tr><tr class="separator:a261c1522190ec098c071088b01458a7a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3022eb24a0ae1fc0a9c03099b4b9f951"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a3022eb24a0ae1fc0a9c03099b4b9f951">CanPasteRows</a> (bool16 isPasteAfter) const =0</td></tr><tr class="separator:a3022eb24a0ae1fc0a9c03099b4b9f951"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab87f9be27248eec0f783ca9e12949a8f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ab87f9be27248eec0f783ca9e12949a8f">CanConvertCellsType</a> (<a class="el" href="class_i_d_type.html">CellType</a> destType) const =0</td></tr><tr class="separator:ab87f9be27248eec0f783ca9e12949a8f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a236e357678f562a361ed0718f52a3154"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a236e357678f562a361ed0718f52a3154">ConvertCellsType</a> (<a class="el" href="class_i_d_type.html">CellType</a> destType, bool16 tryToPreserveData)=0</td></tr><tr class="separator:a236e357678f562a361ed0718f52a3154"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c0677f325272a4bc8853674ae324c4d"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a9c0677f325272a4bc8853674ae324c4d">CanPasteColumns</a> (bool16 isPasteAfter) const =0</td></tr><tr class="separator:a9c0677f325272a4bc8853674ae324c4d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5b67c3b80d6e2c949371d88c2e128f65"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a5b67c3b80d6e2c949371d88c2e128f65">GetFocussedArea</a> () const =0</td></tr><tr class="separator:a5b67c3b80d6e2c949371d88c2e128f65"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a840ced1b36e02902288395e54e8fe879"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a840ced1b36e02902288395e54e8fe879">CanGetFocussedArea</a> () const =0</td></tr><tr class="separator:a840ced1b36e02902288395e54e8fe879"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad67ab1e77f23acf8172c283717833105"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ad67ab1e77f23acf8172c283717833105">CanPastePageItem</a> () const =0</td></tr><tr class="separator:ad67ab1e77f23acf8172c283717833105"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab2323a1ad75b7cd63705043cf4c2d696"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ab2323a1ad75b7cd63705043cf4c2d696">PastePageItem</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor, <a class="el" href="class_u_i_d_ref.html">UIDRef</a> pageItemUID, bool16 preventCopy)=0</td></tr><tr class="separator:ab2323a1ad75b7cd63705043cf4c2d696"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a63267c8415c8b6bd3374537f77777f78"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#a63267c8415c8b6bd3374537f77777f78">IsAnyTextCellSelected</a> () const =0</td></tr><tr class="separator:a63267c8415c8b6bd3374537f77777f78"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab6574d736df5a683444e51a81be7fe77"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_suite.html#ab6574d736df5a683444e51a81be7fe77">IsAnyGraphicCellSelected</a> () const =0</td></tr><tr class="separator:ab6574d736df5a683444e51a81be7fe77"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Manipulates the table selection.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_selection_utils.html">ISelectionUtils</a></dl></div><h2 class="groupheader">Member Typedef Documentation</h2><a class="anchor" id="a3d44a36076f150df3d2412729560711a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef <a class="el" href="class_k2_vector.html">K2Vector</a>&lt;<a class="el" href="struct_i_table_suite_1_1_override_state.html">OverrideState</a>&gt; <a class="el" href="class_i_table_suite.html#a3d44a36076f150df3d2412729560711a">ITableSuite::OverrideStateVector</a></td></tr></table></div><div class="memdoc"><p>Collection of override state information returned by <a class="el" href="class_i_table_suite.html#a8a1cc103dc520cf996261109596c8920">GetOverridesInTable()</a>. </div></div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a950059445478e990b9cea07c288da09a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_table_suite.html#a950059445478e990b9cea07c288da09a">ITableSuite::ESplitDirection</a></td></tr></table></div><div class="memdoc"><p>Directions in which a cell can be split. </div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a6cc304e38a8c5d6ac1f05ace72b424e5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::AnyFootnotesInSelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if any footnotes were found in the selection <dl class="section return"><dt>Returns<dd>bool16 true if any footnotes were found in the selection </dl></div></div><a class="anchor" id="a5a0e6e1004119d2fb804d4aec8a8b4bd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ApplyCellOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Override the given cell attributes. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">attrs</td><td>list of attributes to be overridden. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#af4bcde472caae3f4bcb0a7e39ce54876">CanApplyCellOverrides()</a> == kTrue. </dl></div></div><a class="anchor" id="a45f2bc6b39f01a7ed79588c6a35b99ba"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ApplyCellStrokes </td><td>(</td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Change the cell stroke attributes to the values given by data. The attributes to be changed and their new values are identified by the data interface which allows them to be set in a single call. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">data</td><td>identifyies cell stroke attributes to be changed and their new values. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a952469b967e56a1e5e70e3cab5aacbd0">CanApplyCellStrokes()</a> == kTrue. </dl></div></div><a class="anchor" id="ae325441491f203126e0e4a15821c5338"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ApplyCellStrokesBySelection </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>attr</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Change cell stroke attributes using the selection&#39;s cell stroke data. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">interface</td><td>pointer to data boss class </td></tr></table></dl></div></div><a class="anchor" id="a78029f9fad6d96ebfd21aa72cfc8c133"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ApplyRowOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Override the given row attributes associated with the selection. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a7ec630ba88f4ba9b0543e9db76598431">CanApplyRowOverrides()</a> == kTrue. </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">attrs</td><td>list of attributes to be overridden. </td></tr></table></dl></div></div><a class="anchor" id="a3ead008ea43ce412fe978d174e38c0f0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ApplyTableOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>attrs</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Override the given table attributes. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">attrs</td><td>list of attributes to be overridden. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a03d94f78b34c06628e1d55d98db904e1">CanApplyTableOverrides()</a> == kTrue. </dl></div></div><a class="anchor" id="a95eb09662a1c9d24ab6257fa0cd83b97"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ApplyTableStyle </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nthStyle</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY, UNTESTED! </div></div><a class="anchor" id="af4bcde472caae3f4bcb0a7e39ce54876"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanApplyCellOverrides </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a5a0e6e1004119d2fb804d4aec8a8b4bd">ApplyCellOverrides()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a952469b967e56a1e5e70e3cab5aacbd0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanApplyCellStrokes </td><td>(</td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a45f2bc6b39f01a7ed79588c6a35b99ba">ApplyCellStrokes()</a> can be called to change the cell stroke attributes indicated in data, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">data</td><td>identifies the cell stroke attributes to be changed. </td></tr></table></dl></div></div><a class="anchor" id="a30fdfacaf0228273c9ccf1bac63c0280"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanApplyRowKeeps </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if you can apply keeps/start on attributes to this row </div></div><a class="anchor" id="a7ec630ba88f4ba9b0543e9db76598431"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanApplyRowOverrides </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a78029f9fad6d96ebfd21aa72cfc8c133">ApplyRowOverrides()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a03d94f78b34c06628e1d55d98db904e1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanApplyTableOverrides </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a3ead008ea43ce412fe978d174e38c0f0">ApplyTableOverrides()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="ac6cff688185af84378c76c83a314f1a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanApplyTableStyle </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nthStyle</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY, UNTESTED! </div></div><a class="anchor" id="a566d864ba515ed29682b3d8e257ce6aa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanChangeTableDimensions </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#aa109f3ba331698ea4a43aebf23578a97">ChangeBodyRowDimensionTo()</a>, <a class="el" href="class_i_table_suite.html#a4f1e9ba58f0a90e67cc02806f2c21f63">ChangeColumnDimensionTo()</a>, <a class="el" href="class_i_table_suite.html#ae4b9355ef09ba088225317ca9be9b169">ChangeHeaderRowDimensionTo()</a> or <a class="el" href="class_i_table_suite.html#a3dac05105f46f9e0577d361eeeea12e0">ChangeFooterRowDimensionTo()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a4e4c5dd9843ddd930a714bd0dadfd4ca"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanChangeTableDirection </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if you can change the table direction <dl class="section return"><dt>Returns<dd>bool16 true if you can change the table direction </dl></div></div><a class="anchor" id="ae1b5fa41d4e6872bf12cdf682f1606e3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanClearAllTableOverrides </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#aec3cf04e203342b14bbeb7a554804459">ClearAllTableOverrides()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="ac621bfc8cf189eb81e244aabe367c2d3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanClearSelectionOverrides </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a48eb0f7635d9a076d616081ec7252490">ClearSelectionOverrides()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="ab87f9be27248eec0f783ca9e12949a8f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanConvertCellsType </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="paramname"><em>destType</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a236e357678f562a361ed0718f52a3154">ConvertCellsType()</a> can be called on selected cells, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">destType</td><td>cell type to be converted into </td></tr></table></dl></div></div><a class="anchor" id="a3342c9ad2f03d46b57b19b95ef945ec3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanConvertTableToText </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a5a7653e0041162e75bc44ef20596f461">ConvertTableToText()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a931b654063c043899b028180914e0dbf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanConvertTextToTable </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if you can convert the selected text to a table <dl class="section return"><dt>Returns<dd>bool16 true if can convert text to a table </dl></div></div><a class="anchor" id="ac506e9507ebb76f3661025e739f14d2a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanConvertToBodyRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if Can Convert the selection To Body Rows <dl class="section return"><dt>Returns<dd>bool16 </dl></div></div><a class="anchor" id="aa60abcce6a84457ded07280e57b2502d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanConvertToFooterRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if Can Convert the selection To Footer Rows <dl class="section return"><dt>Returns<dd>bool16 </dl></div></div><a class="anchor" id="a2cb8aac86fe8665b3749dc92ab6a0c0c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanConvertToHeaderRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if Can Convert the selection To Header Rows <dl class="section return"><dt>Returns<dd>bool16 </dl></div></div><a class="anchor" id="a49e0e374d21477c7ea00026ea64c0d37"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanCreateTableStyleFromSelection </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY, UNTESTED! </div></div><a class="anchor" id="ae97522c09e870016cb408f007cad6bf9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanDeleteColumns </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#ab733e1ea02086b177bbdd5fae7f83216">DeleteColumns()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a807e221a52e5e5aef81ee3b7fad24461"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanDeleteRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#af65e7f4c14196cdcea3691599e326cbc">DeleteRows()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a263cbe0575d51e71447c4d0010bce244"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanDeleteTable </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a7686e2263af4251422d95e21ab4cdcb5">DeleteTable()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="aabef3daf5b84899d21a07e7b51c38c3e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanEditTable </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if you can edit the table, this is for InCopy because you can lock text </div></div><a class="anchor" id="a2034e639731aad16a0fa266d8d652ed0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetApplyCellStrokesBySelection </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a44c4d4cd3da52cb9f687ce6e342499ec">GetCellStrokesBySelection()</a> or <a class="el" href="class_i_table_suite.html#ae325441491f203126e0e4a15821c5338">ApplyCellStrokesBySelection()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a3244eb2e7afeecdd8a033ce80763484d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetCellAttribute </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the value of the given attribute is the same for all selected cells and <a class="el" href="class_i_table_suite.html#a48ab09f1cb44e9aaf4cebd9832e96d14">QueryCellAttribute()</a> can be called, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichAttr</td><td>identifies the attribute to be checked, <a class="el" href="classk_cell_attr_bottom_inset_boss.html">kCellAttrBottomInsetBoss</a> for example. </td></tr></table></dl></div></div><a class="anchor" id="a0ed7960072002c2f0a78d6a4e2e440f9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetCellHeight </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a1b7eb3de7f70831cb57341f621eb1fa5">GetCellHeight()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a95ee2e29cf267115fcea171b38fcdc52"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetCellStrokes </td><td>(</td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#abb0ea09258923700c325ba212ee3657e">GetCellStrokes()</a> can be called to get the value of the attributes indicated by data, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">data</td><td>identifies the cell stroke attributes to be obtained. </td></tr></table></dl></div></div><a class="anchor" id="a514106da1d532f1a26eefb070d2fdaee"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetCellWidth </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a74a0203659a5d7da6a4359cadcfcdb48">GetCellWidth()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a6787efb7e89fe3d1aa2806f33ab6a610"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetColAttribute </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if all cols in the selection have the same value for whichAttr and <a class="el" href="class_i_table_suite.html#a07274fd937b850254f3f6a345ddac0af">QueryColAttribute()</a> can be called, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichAttr</td><td>identifies the attribute to be checked, <a class="el" href="classk_col_attr_width_boss.html">kColAttrWidthBoss</a> for example. </td></tr></table></dl></div></div><a class="anchor" id="a92fc805e5a552b28b2d7fc1036776915"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetColumnSize </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if selected columns have the same width and <a class="el" href="class_i_table_suite.html#adc3c42ed4d07983f75615dd1308cc2cc">GetColumnSize()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a840ced1b36e02902288395e54e8fe879"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetFocussedArea </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the grid area of selected region is valid area, kFalse otherwise.<dl class="section return"><dt>Returns<dd>bool16 return kTrue if a valid grid area can be returned </dl></div></div><a class="anchor" id="afbcb1a92af01f095c1c80ad10ad9ec49"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetFooter </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if you there is a footer in the table and you can make a selection in it <dl class="section return"><dt>Returns<dd>bool16 true if you there is a footer in the table and you can make a selection in it </dl></div></div><a class="anchor" id="aaeae5741e3b5f09201b62b86b7faa86d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetHeader </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if you there is a header in the table and you can make a selection in it <dl class="section return"><dt>Returns<dd>bool16 true if you there is a header in the table and you can make a selection in it </dl></div></div><a class="anchor" id="a87e9f210786fa9d12fa17ceac8c0ad5d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetMaxMinRowSizeOfSelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if you can get the max/min row size of the selecton <dl class="section return"><dt>Returns<dd>bool16 true if you can get the max/min row size of the selecton </dl></div></div><a class="anchor" id="a1c3ebacff2e1cabdd4e09276076da51f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetOverridesInTable </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a8a1cc103dc520cf996261109596c8920">GetOverridesInTable()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="abd0c2d5aebf81afd64ee5b85b3bd427a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetRowAttribute </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if all rows in the selection have the same value for whichAttr and <a class="el" href="class_i_table_suite.html#aebf6baebb20e8b896c39266eff733d1e">QueryRowAttribute()</a> can be called, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichAttr</td><td>identifies the attribute to be checked, <a class="el" href="classk_row_attr_height_boss.html">kRowAttrHeightBoss</a> for example. </td></tr></table></dl></div></div><a class="anchor" id="a2b9444801817e3b43226b2b05d153cfd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetRowSize </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if selected rows have the same height and <a class="el" href="class_i_table_suite.html#a8549d457c3ffe13883194d2b8a4e9eb7">GetRowSize()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="ad8ae0ec6b44df2c5396b6ccfe571b32e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetSelectionActiveStrokes </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the sides of the cells which are active in the selection (sides can be set using the stroke proxy) <dl class="section return"><dt>Returns<dd>sides selected </dl></div></div><a class="anchor" id="a01cabc5f9ded7ef7e9e3f37ee95f6478"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetSpanInformationFromSelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The following functions are used to find the span of the smallest/largest merged cell in the selection should only be used by the ui when calculating the min and max values for a edit box </div></div><a class="anchor" id="afd63490bd0ca550a5b4a55bfd17385f3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetTableDirection </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if you can get the table direction <dl class="section return"><dt>Returns<dd>bool16 true if you can get direction </dl></div></div><a class="anchor" id="a0d77053c0d3b007ddf168a58cf7f9adb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetTableProperties </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if you can get the properties of the table <dl class="section return"><dt>Returns<dd>bool16 true if you can get the properties of the table </dl></div></div><a class="anchor" id="a10577af45bd9caae22cc212fe96e1ca9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetTextFramesSpannedBySelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#ab65479e6234f5d6886a90997c7a29a4d">GetTextFramesSpannedBySelection()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="ab87160b264fb84966c70764ccfe3e0be"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetUserRowSelection </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>rowNum</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the model row number that corresponds with the row number and row type as the user see it. USED ONLY BY THE GOTOROW DIALOG<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">int32</td><td>row number as the user sees it (1-based) </td></tr><tr><td class="paramname">ITableSuite::UserRowNumber::RowType</td><td>(eHeader, eFooter, eBody)</td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>rowNum &gt; currentSelectionModel.TotalRows.start &amp;&amp; rowNum &lt;= currentSelectionModel.TotalRows.End </dl><dl class="section post"><dt>Postcondition<dd>result &gt;= currentSelectionModel.TotalRows.start &amp;&amp; result &lt; currentSelectionModel.TotalRows.End </dl></div></div><a class="anchor" id="a93d56b56981cb177be4632415589ff13"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanGetWritingDirection </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a090e3686f5ef43d7160f3b66d83f517f">IsWritingDirectionHorizontal()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a9a4aa670cfb63e4aeae38461c281fa9e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanInsertColumns </td><td>(</td><td class="paramtype">Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a4176cc85966ef8ba316c8c6acd973a1b">InsertColumns()</a> can be called, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pos</td><td>insert before or after the columns in the selection. </td></tr></table></dl></div></div><a class="anchor" id="a5ab324b77de49b34161439e5b8876c7a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanInsertRows </td><td>(</td><td class="paramtype">Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a295e2da5bb0c90333c7fd8458d7fd22b">InsertRows()</a> can be called, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pos</td><td>insert before or after the rows in the selection. </td></tr></table></dl></div></div><a class="anchor" id="a3016dfdcf560c97be17c9ad20775ba87"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanInsertTable </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if you can insert a new table <dl class="section return"><dt>Returns<dd>bool16 true if you can insert a table </dl></div></div><a class="anchor" id="ab3fd4efe3be40ff3916c6b8eb979359a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanMergeCells </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a5446b3797f3ce5ba0b6f0f3a106b3292">MergeCells()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a798b570a2a09ba32055e6fd2af9070c3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanMoveColumns </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>toColumn</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if columns can be moved to destination column, kFalse otherwise.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">toColumn</td><td>The destination column</td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 return kTrue if columns can be moved to destination column, kFalse otherwise </dl></div></div><a class="anchor" id="a3bc0df3b7ef99cd5baaf2238343008bc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanMoveRows </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>toRow</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if rows can be moved to destination row, kFalse otherwise.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">toRow</td><td>The destination row</td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 return kTrue if rows can be moved to destination row, kFalse otherwise </dl></div></div><a class="anchor" id="a9c0677f325272a4bc8853674ae324c4d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanPasteColumns </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isPasteAfter</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if column(s) can be pasted after/before the selected area in the table, kFalse otherwise.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">isPasteAfter</td><td>specifies whether the column is to be pasted after the selected area or before the selected area</td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 return kTrue if column(s) can be pasted </dl></div></div><a class="anchor" id="ad67ab1e77f23acf8172c283717833105"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanPastePageItem </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Returns kTrue if we can paste page item into the grid area of selected region, kFalse otherwise.

</pre><dl class="section return"><dt>Returns<dd>bool16 return kTrue if we can paste page item into the grid area of selected region </dl></div></div><a class="anchor" id="a3022eb24a0ae1fc0a9c03099b4b9f951"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanPasteRows </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isPasteAfter</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if row(s) can be pasted after/before the selected area in the table, kFalse otherwise.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">isPasteAfter</td><td>specifies whether the row is to be pasted after the selected area or before the selected area</td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 return kTrue if row(s) can be pasted </dl></div></div><a class="anchor" id="abf08d1697de95684320d94496018dc9c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanRedistributeColumns </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a592c728d597ca9deef3def1d6c30c29d">RedistributeColumns()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a8c63d3cf5288770396fa5281e60ad291"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanRedistributeRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#ae6b2f1faf5487ad32fd2bd699ed527ff">RedistributeRows()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a74486e023cd912abbf93a265e72c7213"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanResizeCellHeight </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a30dfa54bc8b123d1e671e52bdce60b4a">ResizeCellHeight()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="adb609ed61442975a2dcc365a9bc78fae"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanResizeCellWidth </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#af21875e8fba2133d0215fb5fa2af96ab">ResizeCellWidth()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="ae9a907f234d5d0e54e77301faf971852"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanResizeColumns </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a338ce098273d94542a3b4382c37263a1">ResizeColumns()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a862565157e6b4197b7d6b216447b6c3f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanResizeRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#aa169fa556fcd91de4e5eda76c699fe86">ResizeRows()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="ae48787d446b6f86eec2b1779d4e7570a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanSplitCells </td><td>(</td><td class="paramtype"><a class="el" href="class_i_table_suite.html#a950059445478e990b9cea07c288da09a">ESplitDirection</a>&nbsp;</td><td class="paramname"><em>direction</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is obsolete. Please use <a class="el" href="class_i_table_suite.html#ae48787d446b6f86eec2b1779d4e7570a">CanSplitCells()</a>. Returns kTrue if SplitCell() can be called, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">direction</td><td>of split, vertical or horizontal. Returns kTrue if <a class="el" href="class_i_table_suite.html#aaf1d17b13b85bf54d48d79f3b3eab5da">SplitCells()</a> can be called, kFalse otherwise. </td></tr><tr><td class="paramname">direction</td><td>of split, vertical or horizontal. </td></tr></table></dl></div></div><a class="anchor" id="afd6c48283a2f696787eb457197285f9c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanSwapCellStrokeFill </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#ad67046928257d7af1d95e01e79feb402">SwapCellStrokeFill()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="a6c73785570b250269c615968dc780583"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::CanUnmergeCell </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_suite.html#a5425b449dae8d89f6185c0ac00377475">UnmergeCell()</a> can be called, kFalse otherwise. </div></div><a class="anchor" id="aa109f3ba331698ea4a43aebf23578a97"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ChangeBodyRowDimensionTo </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>newRowDim</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Increase or decrease the number of body rows in the selected table to match the specified dimension. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newRowDim</td><td>total number of body rows the table will have. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a566d864ba515ed29682b3d8e257ce6aa">CanChangeTableDimensions()</a> == kTrue. </dl></div></div><a class="anchor" id="a4f1e9ba58f0a90e67cc02806f2c21f63"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ChangeColumnDimensionTo </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>newColDim</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Increase or decrease the number of columns in the selected table to match the specified dimension. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newColDim</td><td>total number of columns the table will have. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a566d864ba515ed29682b3d8e257ce6aa">CanChangeTableDimensions()</a> == kTrue. </dl></div></div><a class="anchor" id="a3dac05105f46f9e0577d361eeeea12e0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ChangeFooterRowDimensionTo </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>newRowDim</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Increase or decrease the number of footer rows in the selected table to match the specified dimension. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newRowDim</td><td>total number of footer rows the table will have. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a566d864ba515ed29682b3d8e257ce6aa">CanChangeTableDimensions()</a> == kTrue. </dl></div></div><a class="anchor" id="ae4b9355ef09ba088225317ca9be9b169"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ChangeHeaderRowDimensionTo </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>newRowDim</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Increase or decrease the number of header rows in the selected table to match the specified dimension. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newRowDim</td><td>total number of header rows the table will have. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a566d864ba515ed29682b3d8e257ce6aa">CanChangeTableDimensions()</a> == kTrue. </dl></div></div><a class="anchor" id="ae10dbfb46c041987092527edc0bb7970"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ChangeTableDirection </td><td>(</td><td class="paramtype">Tables::EDirection&nbsp;</td><td class="paramname"><em>NewDirection</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Change direction of table<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">NewDirection</td><td>the direction for the new table </td></tr></table></dl></div></div><a class="anchor" id="aec3cf04e203342b14bbeb7a554804459"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ClearAllTableOverrides </td><td>(</td><td class="paramtype"><a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &amp;&nbsp;</td><td class="paramname"><em>attrs</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clear the given table attribute overides for the selected table. Table attribute boss classes have one of the following prefixes in their name: <ul><li> kTableAttr <li> kCellAttr <li> kRowAttr <li> kColAttr </ul><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">attrs</td><td>list of table attributes to be cleared. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#ae1b5fa41d4e6872bf12cdf682f1606e3">CanClearAllTableOverrides()</a> == kTrue. </dl></div></div><a class="anchor" id="a534b8859de58683a069a57d722d995f0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ClearColumnPatternFillOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>firstOverrideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>secondOverrideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>pattern1</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>pattern2</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>skipFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>skipLast</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY The following function clears the FILL overrides which intersect with alternating row or column FILL pattern Note: This function is called when using the table alternating pattern UI, there is no use otherwise <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">firstOverrideAttrs</td><td>the overrides on the first set </td></tr><tr><td class="paramname">secondOverrideAttrs</td><td>the overrides on the first set </td></tr><tr><td class="paramname">pattern1</td><td>count in first set </td></tr><tr><td class="paramname">pattern2</td><td>count in second set </td></tr><tr><td class="paramname">skipFirst</td><td>number from top skipped </td></tr><tr><td class="paramname">skipLast</td><td>number from bottom skipped </td></tr></table></dl></div></div><a class="anchor" id="a45ac75e8a86507218d23f55b84a5b398"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ClearColumnPatternStrokeOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>firstOverrideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>secondOverrideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>pattern1</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>pattern2</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>skipFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>skipLast</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY The following function clears the STROKE overrides which intersect with alternating row or column STROKE pattern Note: This function is called when using the table alternating pattern UI, there is no use otherwise <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">firstOverrideAttrs</td><td>the overrides on the first set </td></tr><tr><td class="paramname">secondOverrideAttrs</td><td>the overrides on the first set </td></tr><tr><td class="paramname">pattern1</td><td>count in first set </td></tr><tr><td class="paramname">pattern2</td><td>count in second set </td></tr><tr><td class="paramname">skipFirst</td><td>number from top skipped </td></tr><tr><td class="paramname">skipLast</td><td>number from bottom skipped </td></tr></table></dl></div></div><a class="anchor" id="a5f2c28c9e614228ceb938402d3336fa1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ClearOverridesIntersectingBorder </td><td>(</td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>leftSideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>topSideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>rightSideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>bottomSideAttrs</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clears the overrides which intersect the table border The attributes to clear for each side<p>Note: This function is called when using the table border UI, there is no need to call it otherwise </div></div><a class="anchor" id="af14cd27f267080f0719be01d054d3cd7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ClearRowPatternFillOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>firstOverrideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>secondOverrideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>pattern1</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>pattern2</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>skipFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>skipLast</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY The following function clears the FILL overrides which intersect with alternating row or column FILL pattern Note: This function is called when using the table alternating pattern UI, there is no use otherwise <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">firstOverrideAttrs</td><td>the overrides on the first set </td></tr><tr><td class="paramname">secondOverrideAttrs</td><td>the overrides on the first set </td></tr><tr><td class="paramname">pattern1</td><td>count in first set </td></tr><tr><td class="paramname">pattern2</td><td>count in second set </td></tr><tr><td class="paramname">skipFirst</td><td>number from top skipped </td></tr><tr><td class="paramname">skipLast</td><td>number from bottom skipped </td></tr></table></dl></div></div><a class="anchor" id="aaeee05fc32e02aba4bc035724282b113"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ClearRowPatternStrokeOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>firstOverrideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>secondOverrideAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>pattern1</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>pattern2</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>skipFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>skipLast</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY The following function clears the STROKE overrides which intersect with alternating row or column STROKE pattern Note: This function is called when using the table alternating pattern UI, there is no use otherwise <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">firstOverrideAttrs</td><td>the overrides on the first set </td></tr><tr><td class="paramname">secondOverrideAttrs</td><td>the overrides on the first set </td></tr><tr><td class="paramname">pattern1</td><td>count in first set </td></tr><tr><td class="paramname">pattern2</td><td>count in second set </td></tr><tr><td class="paramname">skipFirst</td><td>number from top skipped </td></tr><tr><td class="paramname">skipLast</td><td>number from bottom skipped </td></tr></table></dl></div></div><a class="anchor" id="a48eb0f7635d9a076d616081ec7252490"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ClearSelectionOverrides </td><td>(</td><td class="paramtype"><a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &amp;&nbsp;</td><td class="paramname"><em>attrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clear the given table attribute overides for the selected cells. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">attrs</td><td>gives the table attributes to be cleared. </td></tr><tr><td class="paramname">data</td><td>gives the cell stroke attributes to be cleared. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#ac621bfc8cf189eb81e244aabe367c2d3">CanClearSelectionOverrides()</a> == kTrue. </dl></div></div><a class="anchor" id="a236e357678f562a361ed0718f52a3154"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ConvertCellsType </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="paramname"><em>destType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>tryToPreserveData</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to convert the type of cells in sellection <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">destType</td><td>cell type to be converted into </td></tr><tr><td class="paramname">tryToPreserveData</td><td>if true, the data is preserved into the cell after converion, if possible. </td></tr></table></dl></div></div><a class="anchor" id="a5a7653e0041162e75bc44ef20596f461"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ConvertTableToText </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>colSeparator</em> = <code>&quot;\t&quot;</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>rowSeparator</em> = <code>&quot;\r&quot;</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert selected table to text. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a3342c9ad2f03d46b57b19b95ef945ec3">CanConvertTableToText()</a> == kTrue. </dl></div></div><a class="anchor" id="aa61aa9196df706aa71c5e74fab30dba6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a> ITableSuite::ConvertTextToTable </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>colSeparator</em> = <code>&quot;\t&quot;</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>rowSeparator</em> = <code>&quot;\r&quot;</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>userNumCols</em> = <code>1</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">UID</a> &amp;&nbsp;</td><td class="paramname"><em>tableStyleUID</em> = <code>kInvalidUID</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Converts the current text selection to a table at the selection&#39;s location<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">colSeparator</td><td>column separator to delimit end of column </td></tr><tr><td class="paramname">rowSeparator</td><td>row separator to delimit end of row </td></tr><tr><td class="paramname">userNumCols</td><td>number of columns specified by user, used if rowSeparator==colSeparator </td></tr><tr><td class="paramname">tableStyleUID</td><td>[IN] optional, the table style for the new table, if this is <code>kInvalidUID</code>, the root table style is used </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_u_i_d_ref.html">UIDRef</a> the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the table created </dl></div></div><a class="anchor" id="a2ab4afb3f7468071299b7f586fbdd98d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a> ITableSuite::ConvertTextToTable </td><td>(</td><td class="paramtype">const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_p_m_string.html">PMString</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>colSeparators</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_p_m_string.html">PMString</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>rowSeparators</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>userNumCols</em> = <code>1</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">UID</a> &amp;&nbsp;</td><td class="paramname"><em>tableStyleUID</em> = <code>kInvalidUID</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Same as above except parameters 1 and 2 are lists instead of single strings<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">colSeparator</td><td>list of column separators to delimit end of column </td></tr><tr><td class="paramname">rowSeparator</td><td>list of row separators to delimit end of row </td></tr><tr><td class="paramname">userNumCols</td><td>number of columns specified by user, used if rowSeparator==colSeparator </td></tr><tr><td class="paramname">tableStyleUID</td><td>[IN] optional, the table style for the new table, if this is <code>kInvalidUID</code>, the root table style is used </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_u_i_d_ref.html">UIDRef</a> the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the table created </dl></div></div><a class="anchor" id="ad3973efa62ce5976b394d832fcaa6e51"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ConvertToBodyRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Converts the selection To Body Rows </div></div><a class="anchor" id="adbfe8db056c3382dc5c71367bd87998f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ConvertToFooterRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Converts the selection To Footer Rows </div></div><a class="anchor" id="ad3b6f0a0dc7f10995dae759ea6c3ccf2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ConvertToHeaderRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Converts the selection To Header Rows </div></div><a class="anchor" id="a4784b6466ca5d13f77b11db058a18951"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::CreateTableStyleFromSelection </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY, UNTESTED! </div></div><a class="anchor" id="ab733e1ea02086b177bbdd5fae7f83216"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::DeleteColumns </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete selected columns. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#ae97522c09e870016cb408f007cad6bf9">CanDeleteColumns()</a> == kTrue. </dl></div></div><a class="anchor" id="af65e7f4c14196cdcea3691599e326cbc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::DeleteRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete selected rows. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a807e221a52e5e5aef81ee3b7fad24461">CanDeleteRows()</a> == kTrue. </dl></div></div><a class="anchor" id="a7686e2263af4251422d95e21ab4cdcb5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::DeleteTable </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete selected table. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a263cbe0575d51e71447c4d0010bce244">CanDeleteTable()</a> == kTrue. </dl></div></div><a class="anchor" id="a43e02e5950f6a8df8eaa5b913f948474"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::GetBorderOverridesInTable </td><td>(</td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>findAttrs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_table_suite.html#a3d44a36076f150df3d2412729560711a">OverrideStateVector</a> *&nbsp;</td><td class="paramname"><em>results</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Collects the overrides in the table that intersect the table border Finds the attributes in findAttrs Returns in results<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">findAttrs</td><td></td></tr><tr><td class="paramname">results</td><td></td></tr></table></dl></div></div><a class="anchor" id="a1b7eb3de7f70831cb57341f621eb1fa5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableSuite::GetCellHeight </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get visible height of cell, note if one cell is merged with another the overall height of both cells is returned. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a0ed7960072002c2f0a78d6a4e2e440f9">CanGetCellHeight()</a> == kTrue </dl><dl class="section return"><dt>Returns<dd>cell height. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="abb0ea09258923700c325ba212ee3657e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::GetCellStrokes </td><td>(</td><td class="paramtype"><a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>data</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the value of the attributes indicated by data. Use of data allows the values of several attributes (stroke weight, color etc.) to be retrieved in a single call rather than individually. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">data</td><td>identifies the cell stroke attributes to be obtained on input and contains their values on return. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a95ee2e29cf267115fcea171b38fcdc52">CanGetCellStrokes()</a></dl></div></div><a class="anchor" id="a44c4d4cd3da52cb9f687ce6e342499ec"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableSuite::GetCellStrokesBySelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire an interface pointer to the selection&#39;s cell stroke data. The <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> returned can be used to query an <a class="el" href="class_i_cell_stroke_attr_data.html">ICellStrokeAttrData</a> interface that carries the cell stroke data. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a2034e639731aad16a0fa266d8d652ed0">CanGetApplyCellStrokesBySelection()</a> == kTrue. </dl><dl class="section return"><dt>Returns<dd>IPMUnkown interface pointer to data boss object. </dl><dl class="section post"><dt>Postcondition<dd>caller is responsible for releasing the returned interface pointer. </dl></div></div><a class="anchor" id="a74a0203659a5d7da6a4359cadcfcdb48"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableSuite::GetCellWidth </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get visible width of cell, for example if one cell is merged with another the overall width of both is returned. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a514106da1d532f1a26eefb070d2fdaee">CanGetCellWidth()</a> == kTrue </dl><dl class="section return"><dt>Returns<dd>cell width. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="adc3c42ed4d07983f75615dd1308cc2cc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableSuite::GetColumnSize </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get width of columns in the underlying grid of the table. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a92fc805e5a552b28b2d7fc1036776915">CanGetColumnSize()</a> == kTrue </dl><dl class="section return"><dt>Returns<dd>column width. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="a5b67c3b80d6e2c949371d88c2e128f65"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_area.html">GridArea</a> ITableSuite::GetFocussedArea </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the grid area of selected region inside table<dl class="section return"><dt>Returns<dd><a class="el" href="class_grid_area.html">GridArea</a></dl></div></div><a class="anchor" id="a4511be1c4e9ea141ac03341d5ab87999"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableSuite::GetMaxRowSizeOfSelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Finds the row in the selection with the maximum row size <dl class="section return"><dt>Returns<dd><a class="el" href="class_p_m_real.html">PMReal</a> the maximum row size </dl></div></div><a class="anchor" id="af5a524cec9b13bfdbb29d6b330dc74dc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableSuite::GetMinRowSizeOfSelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Finds the row in the selection with the minumun row size <dl class="section return"><dt>Returns<dd><a class="el" href="class_p_m_real.html">PMReal</a> the minumun row size </dl></div></div><a class="anchor" id="a681f18a7b9a7df6e9d13fedb91be93a4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITableSuite::GetNumColsInTable </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of columns in the underlying grid of the selected table. For example if a table was created with 5 columns then two of the columns were merged together the user would see 4 columns but the number of columns in the underlying grid would still be 5. <dl class="section return"><dt>Returns<dd>the number of columns in the underlying grid of the selected table. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="ada12296dc67e8290fa59004b78c41e07"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITableSuite::GetNumFooterRowsInTable </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of footer rows in this table <dl class="section return"><dt>Returns<dd>int32 the number of footer rows in the table </dl></div></div><a class="anchor" id="ac16541ed17c375070b1a4905b6c23b14"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITableSuite::GetNumHeaderRowsInTable </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of header rows in this table <dl class="section return"><dt>Returns<dd>int32 the number of header rows in the table </dl></div></div><a class="anchor" id="aca22d0bcadf77a4b771ab1fa1944f563"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITableSuite::GetNumRowsInTable </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of rows in the underlying grid of the selected table. For example if a table was created with 5 rows then two of the rows were merged together the user would see 4 rows but the number of rows in the underlying grid would still be 5. <dl class="section return"><dt>Returns<dd>the number of rows in the underlying grid of the selected table. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="a8a1cc103dc520cf996261109596c8920"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::GetOverridesInTable </td><td>(</td><td class="paramtype">Tables::ERowColumn&nbsp;</td><td class="paramname"><em>patternType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>firstPatternCount</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>secondPatternCount</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>skipFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>skipLast</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>findAttrsFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="paramname"><em>findAttrsSecond</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_table_suite.html#a3d44a36076f150df3d2412729560711a">OverrideStateVector</a> *&nbsp;</td><td class="paramname"><em>resultFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_table_suite.html#a3d44a36076f150df3d2412729560711a">OverrideStateVector</a> *&nbsp;</td><td class="paramname"><em>resultSecond</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY Note: This function is called when using the table alternating pattern UI, there is no use otherwise Collects the overrides in the table based on the pattern passed in, findAttrsFirst and findAttrsSecond. findAttrsFirst maybe nil only if firstPatterCount = 0 findAttrsSecond maybe nil only if secondPatternCount = 0<p>For each attribute in the findAttrs (first or second) that is overriden, an entry is made in the corresponding result OverrideStateVector. If the value of all override is the same as that of the attribute in the findAttrs then the <a class="el" href="struct_i_table_suite_1_1_override_state.html">OverrideState</a> entry.valueSameAsFind is set to kTrue. A value of kFalse indicates the presence of override(s) but the value being different from that in findAttrs. If no entry is made in resultFirst || resultSecond for the corresponding attribute then there are no overrides.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">patternType</td><td>column or row </td></tr><tr><td class="paramname">firstPatternCount</td><td>count in first set </td></tr><tr><td class="paramname">secondPatternCount</td><td>count in second set </td></tr><tr><td class="paramname">skipFirst</td><td>number from top skipped </td></tr><tr><td class="paramname">skipLast</td><td>number from bottom skipped </td></tr><tr><td class="paramname">findAttrsFirst</td><td>IN attributes in first set to look for </td></tr><tr><td class="paramname">findAttrsSecond</td><td>IN attributes in first set to look for </td></tr><tr><td class="paramname">resultFirst</td><td>OUT the overrides on the first set </td></tr><tr><td class="paramname">resultSecond</td><td>OUT the overrides on the second set </td></tr></table></dl><dl class="section post"><dt>Postcondition<dd>delete resultFirst and resultSecond before they go out of scope. </dl></div></div><a class="anchor" id="a8549d457c3ffe13883194d2b8a4e9eb7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableSuite::GetRowSize </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get height of rows in the underlying grid of the table. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a2b9444801817e3b43226b2b05d153cfd">CanGetRowSize()</a> == kTrue. </dl><dl class="section return"><dt>Returns<dd>row height. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="a44e780e7860b25b6d4279816d74b963b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::GetStrokeOverridesInTable </td><td>(</td><td class="paramtype">Tables::ERowColumn&nbsp;</td><td class="paramname"><em>patternType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>firstPatternCount</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>secondPatternCount</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>skipFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>skipLast</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>firstData</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>secontData</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>resultFirst</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> &amp;&nbsp;</td><td class="paramname"><em>resultSecond</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>INTERNAL USE ONLY Collects the overrides in the table based on the pattern passed in, findAttrsFirst and findAttrsSecond. findAttrsFirst maybe nil only if firstPatterCount = 0 findAttrsSecond maybe nil only if secondPatternCount = 0<p>For each attribute in the findAttrs (first or second) that is overriden, an entry is made in the corresponding result <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a>. If the value of all override is the same as that of the attribute in the findAttrs then the <a class="el" href="struct_i_cell_stroke_attr_data_1_1_data.html">ICellStrokeAttrData::Data</a> entry is set. No value indicates the presence of override(s) but the value being different from that in findAttrs. If no entry is made in resultFirst || resultSecond for the corresponding attribute then there are no overrides.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">patternType</td><td>column or row </td></tr><tr><td class="paramname">firstPatternCount</td><td>count in first set </td></tr><tr><td class="paramname">secondPatternCount</td><td>count in second set </td></tr><tr><td class="paramname">skipFirst</td><td>number from top skipped </td></tr><tr><td class="paramname">skipLast</td><td>number from bottom skipped </td></tr><tr><td class="paramname">findAttrsFirst</td><td>IN attributes in first set to look for </td></tr><tr><td class="paramname">findAttrsSecond</td><td>IN attributes in first set to look for </td></tr><tr><td class="paramname">resultFirst</td><td>OUT the overrides on the first set </td></tr><tr><td class="paramname">resultSecond</td><td>OUT the overrides on the second set </td></tr></table></dl><dl class="section post"><dt>Postcondition<dd>delete resultFirst and resultSecond before they go out of scope. </dl></div></div><a class="anchor" id="ae412d377e1c7a23f8b76ffb56f7ca448"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual Tables::EDirection ITableSuite::GetTableDirection </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get direction of table<dl class="section return"><dt>Returns<dd>EDirection the direction of the table </dl></div></div><a class="anchor" id="ab65479e6234f5d6886a90997c7a29a4d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_k2_vector.html">K2Vector</a>&lt;<a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a>*&gt;* ITableSuite::GetTextFramesSpannedBySelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a collection of <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> interface pointers to each text frame touched by the selection. <dl class="section return"><dt>Returns<dd>a collection of <a class="el" href="class_i_text_frame_column.html">ITextFrameColumn</a> interface pointers to each text frame touched by the selection. </dl><dl class="section post"><dt>Postcondition<dd>delete the returned <a class="el" href="class_k2_vector.html">K2Vector</a> pointer before it goes out of scope. </dl></div></div><a class="anchor" id="a9a0abfe449ce6cbe0db26d679c8debbd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITableSuite::GetUserCurrentColNumber </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number the column in which the selection lies as seen by the user. For example if two columns are merged together they are seen as one column to the user. <dl class="section return"><dt>Returns<dd>the current column as seen by the user (1 &gt;= result &lt;= <a class="el" href="class_i_table_suite.html#a3b76b55662f04bb6ca4b3597ef97705b">GetUserNumColsInTable()</a>). </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="a271b9a5057887d45f8690b4686ade5bd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_suite_1_1_user_row_number.html">UserRowNumber</a> ITableSuite::GetUserCurrentRowNumber </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of the row in which the selection lies as seen by the user. For example if two rows are merged together they are seen as one row by the user. <dl class="section return"><dt>Returns<dd>the current row as seen by the user (1 &gt;= result &lt;= <a class="el" href="class_i_table_suite.html#a3ec77defced3fe10d91270dc78e322de">GetUserNumRowsInTable()</a>). </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="a3b76b55662f04bb6ca4b3597ef97705b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITableSuite::GetUserNumColsInTable </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of columns in the selected table as seen by the user. If two columns are merged together they count as one column to the user. <dl class="section return"><dt>Returns<dd>the number of columns in the selected table as seen by the user. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="a3ec77defced3fe10d91270dc78e322de"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITableSuite::GetUserNumRowsInTable </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of rows in the selected table as seen by the user. If two rows are merged together they count as one row to the user. <dl class="section return"><dt>Returns<dd>the number of rows in the selected table as seen by the user. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="a4176cc85966ef8ba316c8c6acd973a1b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::InsertColumns </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>howMany</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>colWidth</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::EContinuation&nbsp;</td><td class="paramname"><em>continuation</em> = <code>Tables::eStructureAllAttrs</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Insert columns before or after the columns in the selection. Width is in points. If colWidth is zero then the new width is determined from the column relative to which the insertion is being made. A non zero colWidth value will result in all inserted columns having that width. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">howMany</td><td>number of columns to insert. </td></tr><tr><td class="paramname">pos</td><td>before or after the columns in the selection. </td></tr><tr><td class="paramname">colWidth</td><td>width of columns or zero to determine automatically. </td></tr><tr><td class="paramname">continuation</td><td></td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a9a4aa670cfb63e4aeae38461c281fa9e">CanInsertColumns()</a> == kTrue. </dl></div></div><a class="anchor" id="a295e2da5bb0c90333c7fd8458d7fd22b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::InsertRows </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>howMany</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>rowHeight</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::EContinuation&nbsp;</td><td class="paramname"><em>continuation</em> = <code>Tables::eStructureAllAttrs</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Insert rows before or after the rows in the selection. The rowHeight is in points. If rowHeight is zero then the row height is determined by the auto-grow and minimum row height attribute of the row relative to which the insertion is being made. A non zero rowHeight value will result in all inserted rows having that minimum height. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">howMany</td><td>number of rows to insert. </td></tr><tr><td class="paramname">pos</td><td>before or after the rows in the selection. </td></tr><tr><td class="paramname">continuation</td><td></td></tr><tr><td class="paramname">rowHeight</td><td>height of rows in points or zero to determine automatically. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a5ab324b77de49b34161439e5b8876c7a">CanInsertRows()</a> == kTrue. </dl></div></div><a class="anchor" id="a20fe3f72bdedb10d0227d0e370bed269"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::InsertTable </td><td>(</td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>numRows</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>numCols</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>headerRows</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>footerRows</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">UID</a> &amp;&nbsp;</td><td class="paramname"><em>tableStyleUID</em> = <code>kInvalidUID</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::EDirection&nbsp;</td><td class="paramname"><em>direction</em> = <code>Tables::eLTR</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Inserts a new table at the current text selection location<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">numRows</td><td>number of rows </td></tr><tr><td class="paramname">numCols</td><td>number of columns </td></tr><tr><td class="paramname">headerRows</td><td>number of header rows </td></tr><tr><td class="paramname">footerRows</td><td>number of footer rows </td></tr><tr><td class="paramname">[IN]</td><td>tableStyleUID optional, the table style for the new table, if this is not provided, the default table style is used </td></tr><tr><td class="paramname">direction</td><td>the direction for the new table </td></tr></table></dl></div></div><a class="anchor" id="ab6574d736df5a683444e51a81be7fe77"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::IsAnyGraphicCellSelected </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Returns kTrue if there is any graphic cell in the grid area of selected region, kFalse otherwise

</pre><dl class="section return"><dt>Returns<dd>bool16 Returns kTrue if there is any graphic cell in the grid area of selected region </dl></div></div><a class="anchor" id="a63267c8415c8b6bd3374537f77777f78"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::IsAnyTextCellSelected </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if there is any text cell in the grid area of selected region, kFalse otherwise<dl class="section return"><dt>Returns<dd>bool16 Returns kTrue if there is any text cell in the grid area of selected region </dl></div></div><a class="anchor" id="a3e4be77c51afbb921de27ddde149baf2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::IsFooterSelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if this selection is in the footer set Note: Will return false if the selection spans all three sets (ie is a whole table selection) </div></div><a class="anchor" id="a65a8dd79f4406a56f44c89e31c9b9e25"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::IsHeaderSelection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if this selection is in the header set Note: Will return false if the selection spans all three sets (ie is a whole table selection) </div></div><a class="anchor" id="a8f99db169a759265e4d765dbeec3ced0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::isWholeTableSelected </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if this selection is the whole table Note: IsHeaderSelection and IsFooterSelection will return false if this is true </div></div><a class="anchor" id="a090e3686f5ef43d7160f3b66d83f517f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::IsWritingDirectionHorizontal </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if the Writing direction of the story the table is in is horizontal </div></div><a class="anchor" id="a5446b3797f3ce5ba0b6f0f3a106b3292"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::MergeCells </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Merge selected cells. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#ab3fd4efe3be40ff3916c6b8eb979359a">CanMergeCells()</a> == kTrue. </dl></div></div><a class="anchor" id="a261c1522190ec098c071088b01458a7a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::MoveColumns </td><td>(</td><td class="paramtype"><a class="el" href="class_i_table_model.html">ITableModel</a> *&nbsp;</td><td class="paramname"><em>sourceTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="paramname"><em>fromArea</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>toColumn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>duplicateFlag</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to move column(s) in a table<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sourceTable</td><td>specifies the table within which columns are to be moved </td></tr><tr><td class="paramname">fromArea</td><td>specifies the grid area which is to be moved </td></tr><tr><td class="paramname">toColumn</td><td>specifies the column where the selected columns are to be moved </td></tr><tr><td class="paramname">pos</td><td>specifies the relative position with respect to toColumn </td></tr><tr><td class="paramname">duplicateFlag</td><td>specifies whether columns need to be duplicated or not </td></tr></table></dl></div></div><a class="anchor" id="a27031c6582eeaee7269d62060c5b9bec"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::MoveRows </td><td>(</td><td class="paramtype"><a class="el" href="class_i_table_model.html">ITableModel</a> *&nbsp;</td><td class="paramname"><em>sourceTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="paramname"><em>fromArea</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>toRow</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ERelativePosition&nbsp;</td><td class="paramname">, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>duplicateFlag</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to move row(s) in a table<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sourceTable</td><td>specifies the table within which rows are to be moved </td></tr><tr><td class="paramname">fromArea</td><td>specifies the grid area which is to be moved </td></tr><tr><td class="paramname">toRow</td><td>specifies the row where the selected rows are to be moved </td></tr><tr><td class="paramname">pos</td><td>specifies the relative position with respect to toRow </td></tr><tr><td class="paramname">duplicateFlag</td><td>specifies whether rows need to be duplicated or not </td></tr></table></dl></div></div><a class="anchor" id="ab2323a1ad75b7cd63705043cf4c2d696"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::PastePageItem </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>pageItemUID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>preventCopy</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to paste a page item into a graphic cell. Call CanPastePageItem before this operation<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td><a class="el" href="class_grid_address.html">GridAddress</a> of destination cell </td></tr><tr><td class="paramname">pageItemUID</td><td>UID of object to be pasted into the cell </td></tr><tr><td class="paramname">preventCopy</td><td>The object would not be copied, just removed from the source and pasted here. This is not cut-paste. It should be used, only if object is already in the scrap database. </td></tr></table></dl></div></div><a class="anchor" id="a48ab09f1cb44e9aaf4cebd9832e96d14"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableSuite::QueryCellAttribute </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire the <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> interface pointer of the given cell attribute for the selection. Using this pointer a data interface can be queried on the boss object to find the attribute value. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichAttr</td><td>identifies the table attribute boss class wanted, <a class="el" href="classk_cell_attr_bottom_inset_boss.html">kCellAttrBottomInsetBoss</a> for example. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> interface pointer of the given cell attribute for the selection. </dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a3244eb2e7afeecdd8a033ce80763484d">CanGetCellAttribute()</a> == kTrue. </dl><dl class="section post"><dt>Postcondition<dd>caller is responsible for releasing the returned interface pointer. </dl></div></div><a class="anchor" id="a07274fd937b850254f3f6a345ddac0af"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableSuite::QueryColAttribute </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire an IPMUnkown interface pointer for whichAttr. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichAttr</td><td>identifies the attribute wanted, <a class="el" href="classk_col_attr_width_boss.html">kColAttrWidthBoss</a> for example. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>self.CanGetColAttribute(whichAttr) == kTrue. </dl><dl class="section return"><dt>Returns<dd>IPMUnkown interface pointer for whichAttr. </dl><dl class="section post"><dt>Postcondition<dd>caller is responsible for releasing the returned interface pointer. </dl></div></div><a class="anchor" id="aebf6baebb20e8b896c39266eff733d1e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableSuite::QueryRowAttribute </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire an IPMUnkown interface pointer for whichAttr. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichAttr</td><td>identifies the attribute wanted, <a class="el" href="classk_row_attr_height_boss.html">kRowAttrHeightBoss</a> for example. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>self.CanGetRowAttribute(whichAttr) == kTrue. </dl><dl class="section return"><dt>Returns<dd>IPMUnkown interface pointer for whichAttr. </dl><dl class="section post"><dt>Postcondition<dd>caller is responsible for releasing the returned interface pointer. </dl></div></div><a class="anchor" id="a0cda8417fb7fa0fe6aa9e944cdefb992"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableSuite::QueryTableAttribute </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire the <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> interface pointer of the given table attribute for the selection. Other interfaces that exist on the boss object can be queried from this. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whichAttr</td><td>identifies the table attribute boss class wanted, <a class="el" href="classk_table_attr_col_stroke_weight_boss.html">kTableAttrColStrokeWeightBoss</a> for example. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> interface pointer of the given table attribute for the selection. </dl><dl class="section post"><dt>Postcondition<dd>caller is responsible for releasing the returned interface pointer. </dl></div></div><a class="anchor" id="a592c728d597ca9deef3def1d6c30c29d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::RedistributeColumns </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Redistribute the width of columns across the space between the left of the first selected column and the right of the last selected column to give evenly sized columns. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#abf08d1697de95684320d94496018dc9c">CanRedistributeColumns()</a> == kTrue. </dl></div></div><a class="anchor" id="ae6b2f1faf5487ad32fd2bd699ed527ff"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::RedistributeRows </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Redistribute the height of rows across the space between the top of the first selected row and the bottom of the last selected row to give evenly sized rows. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a8c63d3cf5288770396fa5281e60ad291">CanRedistributeRows()</a> == kTrue. </dl></div></div><a class="anchor" id="a30dfa54bc8b123d1e671e52bdce60b4a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ResizeCellHeight </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>height</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Change the height of selected cells. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">height.</td><td></td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a74486e023cd912abbf93a265e72c7213">CanResizeCellHeight()</a> == kTrue. </dl></div></div><a class="anchor" id="af21875e8fba2133d0215fb5fa2af96ab"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ResizeCellWidth </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>width</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Change the width of selected cells. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">width.</td><td></td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#adb609ed61442975a2dcc365a9bc78fae">CanResizeCellWidth()</a> == kTrue. </dl></div></div><a class="anchor" id="a338ce098273d94542a3b4382c37263a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ResizeColumns </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>width</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Change the width of columns in the underlying grid of the table. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">width.</td><td></td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#ae9a907f234d5d0e54e77301faf971852">CanResizeColumns()</a> == kTrue. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="aa169fa556fcd91de4e5eda76c699fe86"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::ResizeRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>height</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Change the height of rows in the underlying grid of the table. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">height.</td><td></td></tr></table></dl><dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a862565157e6b4197b7d6b216447b6c3f">CanResizeRows()</a> == kTrue. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="aaf1d17b13b85bf54d48d79f3b3eab5da"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::SplitCells </td><td>(</td><td class="paramtype"><a class="el" href="class_i_table_suite.html#a950059445478e990b9cea07c288da09a">ESplitDirection</a>&nbsp;</td><td class="paramname"><em>direction</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is obsolete. Please use <a class="el" href="class_i_table_suite.html#aaf1d17b13b85bf54d48d79f3b3eab5da">SplitCells()</a>. Split selected cell in the given direction. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">direction</td><td>of split, vertical or horizontal. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>CanSplitCell(direction) == kTrue. Split selected cells in the given direction. </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">direction</td><td>of split, vertical or horizontal. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>CanSplitCells(direction) == kTrue. </dl></div></div><a class="anchor" id="ad67046928257d7af1d95e01e79feb402"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::SwapCellStrokeFill </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Swap the stroke and fill rendering attibutes for the selected cells. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#afd6c48283a2f696787eb457197285f9c">CanSwapCellStrokeFill()</a> == kTrue. </dl></div></div><a class="anchor" id="a2cfc996cbaab4586bfc110c773a563bd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::TableContainsFooters </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if table which the selection is in has any Footer rows. <dl class="section return"><dt>Returns<dd>bool16 true if the table contains footers </dl></div></div><a class="anchor" id="a90926e01ff53a160ae5c37d39349956e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableSuite::TableContainsHeaders </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if table which the selection is in has any Header rows. <dl class="section return"><dt>Returns<dd>bool16 true if the table contains headers </dl></div></div><a class="anchor" id="a5425b449dae8d89f6185c0ac00377475"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableSuite::UnmergeCell </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Unmerge selected cell. <dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_suite.html#a6c73785570b250269c615968dc780583">CanUnmergeCell()</a> == kTrue. </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_table_suite.html">ITableSuite</a><li class="footer">Generated on Sat Sep 22 2018 10:54:30 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
