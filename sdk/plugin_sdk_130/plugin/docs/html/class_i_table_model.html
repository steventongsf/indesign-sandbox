<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_table_model</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_table_model.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="class_i_table_model-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITableModel Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_table_model_8h_source.html">ITableModel.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ITableModel:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_table_model.png" usemap="#ITableModel_map" /><map id="ITableModel_map" name="ITableModel_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a7a0c20b1988f6c3860c5e730ed85a3db"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITABLEMODEL }</td></tr><tr class="memdesc:a7a0c20b1988f6c3860c5e730ed85a3db"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">kDefaultIID <br /></td></tr><tr class="separator:a7a0c20b1988f6c3860c5e730ed85a3db"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr><td colspan="2"><div class="groupHeader">Table Dimensions</div></td></tr><tr class="memitem:aff994bb3d0f7be0bfb26264d2220f004"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_row_range.html">RowRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#aff994bb3d0f7be0bfb26264d2220f004">GetHeaderRows</a> () const =0</td></tr><tr class="separator:aff994bb3d0f7be0bfb26264d2220f004"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a86c4e3eaef94e85ec82883311a80d4a1"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a86c4e3eaef94e85ec82883311a80d4a1">GetHeaderArea</a> () const =0</td></tr><tr class="separator:a86c4e3eaef94e85ec82883311a80d4a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0736429bd5e4f8dabfa38b0a6ae1ec24"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_row_range.html">RowRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a0736429bd5e4f8dabfa38b0a6ae1ec24">GetBodyRows</a> () const =0</td></tr><tr class="separator:a0736429bd5e4f8dabfa38b0a6ae1ec24"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2189b0e120fcf256bfba3aef38941df5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a2189b0e120fcf256bfba3aef38941df5">GetBodyArea</a> () const =0</td></tr><tr class="separator:a2189b0e120fcf256bfba3aef38941df5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a02913ae25003598014ed376268a323bb"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_row_range.html">RowRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a02913ae25003598014ed376268a323bb">GetFooterRows</a> () const =0</td></tr><tr class="separator:a02913ae25003598014ed376268a323bb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a75b7050b615d0c5ac78d869099646d53"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a75b7050b615d0c5ac78d869099646d53">GetFooterArea</a> () const =0</td></tr><tr class="separator:a75b7050b615d0c5ac78d869099646d53"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1babd6575d49279113278843955078fd"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_row_range.html">RowRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a1babd6575d49279113278843955078fd">GetTotalRows</a> () const =0</td></tr><tr class="separator:a1babd6575d49279113278843955078fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a06d2852367dfe246ea8b47260d721c09"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_col_range.html">ColRange</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a06d2852367dfe246ea8b47260d721c09">GetTotalCols</a> () const =0</td></tr><tr class="separator:a06d2852367dfe246ea8b47260d721c09"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae2c05f6bd973bf4d835c162e0e4226db"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ae2c05f6bd973bf4d835c162e0e4226db">GetTotalArea</a> () const =0</td></tr><tr class="separator:ae2c05f6bd973bf4d835c162e0e4226db"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Cell spans</div></td></tr><tr class="memitem:ad64d53a0edef41ea81ca8584a29e58ff"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ad64d53a0edef41ea81ca8584a29e58ff">IsAnchor</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element) const =0</td></tr><tr class="separator:ad64d53a0edef41ea81ca8584a29e58ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae4365ace307d66e588273e333572107c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_span.html">GridSpan</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ae4365ace307d66e588273e333572107c">GetCellSpan</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor) const =0</td></tr><tr class="separator:ae4365ace307d66e588273e333572107c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9b21e5c8d91782af8af87ef01f68b954"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_area.html">GridArea</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a9b21e5c8d91782af8af87ef01f68b954">GetCellArea</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor) const =0</td></tr><tr class="separator:a9b21e5c8d91782af8af87ef01f68b954"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aac3646f90129cd9cf17d69d37ef2666c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_address.html">GridAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#aac3646f90129cd9cf17d69d37ef2666c">FindCellAnchor</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element) const =0</td></tr><tr class="separator:aac3646f90129cd9cf17d69d37ef2666c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Validators</div></td></tr><tr class="memitem:add574ac0d8797f8f75d140a6aee57695"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#add574ac0d8797f8f75d140a6aee57695">IsValid</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element) const =0</td></tr><tr class="separator:add574ac0d8797f8f75d140a6aee57695"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a84ac18c02e156a5e85a6340b2d4b8c41"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a84ac18c02e156a5e85a6340b2d4b8c41">IsValidRow</a> (int32 row) const =0</td></tr><tr class="separator:a84ac18c02e156a5e85a6340b2d4b8c41"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c8396a4f7db2076f541f7802af2a590"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a8c8396a4f7db2076f541f7802af2a590">IsValidColumn</a> (int32 col) const =0</td></tr><tr class="separator:a8c8396a4f7db2076f541f7802af2a590"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac1a48e7ff1fdac5083fa761cc5112644"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ac1a48e7ff1fdac5083fa761cc5112644">ContainsCompleteCells</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells) const =0</td></tr><tr class="separator:ac1a48e7ff1fdac5083fa761cc5112644"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">GridID to GridAddress conversion</div></td></tr><tr><td colspan="2"><div class="groupText"><pre class="fragment">Every element in a table has a unique GridID associated with it that does not

</pre><p> change for the lifetime of the table. </div></td></tr><tr class="memitem:a315d90d77faa37c27b25be712a6ee420"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_i_d.html">GridID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a315d90d77faa37c27b25be712a6ee420">GetGridID</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element) const =0</td></tr><tr class="separator:a315d90d77faa37c27b25be712a6ee420"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab79f85998ef7333418c91317870e53f5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_grid_address.html">GridAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ab79f85998ef7333418c91317870e53f5">GetGridAddress</a> (<a class="el" href="class_grid_i_d.html">GridID</a> gridID) const =0</td></tr><tr class="separator:ab79f85998ef7333418c91317870e53f5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Cell Content</div></td></tr><tr class="memitem:aa705e5e66b26372d01d63798215e82d4"><td align="right" class="memItemLeft" valign="top">virtual boost::shared_ptr<br class="typebreak" /> &lt; <a class="el" href="class_content_boss_accessor.html">ContentBossAccessor</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#aa705e5e66b26372d01d63798215e82d4">CreateContentBossAccessor</a> (void) const =0</td></tr><tr class="separator:aa705e5e66b26372d01d63798215e82d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aeee9b6b4ed996796550e1cf052a98d52"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_cell_content.html">ICellContent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#aeee9b6b4ed996796550e1cf052a98d52">QueryCellContentBoss</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor) const =0</td></tr><tr class="separator:aeee9b6b4ed996796550e1cf052a98d52"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c539c7b143d00bab74c9b3b94f19948"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_cell_content_mgr.html">ICellContentMgr</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a9c539c7b143d00bab74c9b3b94f19948">QueryContentMgr</a> (<a class="el" href="class_i_d_type.html">CellType</a> type) const =0</td></tr><tr class="separator:a9c539c7b143d00bab74c9b3b94f19948"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Create segments</div></td></tr><tr class="memitem:aca3a0a4ff454aacac90db9c50ccbd2a1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#aca3a0a4ff454aacac90db9c50ccbd2a1">CreateRowSegment</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;distanceFromTableTopEdge, const <a class="el" href="class_col_range.html">ColRange</a> &amp;segmentCols)=0</td></tr><tr class="separator:aca3a0a4ff454aacac90db9c50ccbd2a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5e03c03f504e6ab28038a6363361f49f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a5e03c03f504e6ab28038a6363361f49f">CreateRowSegment</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;distanceFromTableTopEdge, const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_col_range.html">ColRange</a> &gt; &amp;segmentCols)=0</td></tr><tr class="separator:a5e03c03f504e6ab28038a6363361f49f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a15d3a3fa8bc1b53d89de51fd75a45900"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a15d3a3fa8bc1b53d89de51fd75a45900">CreateColSegment</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;distanceFromTableLeftEdge, const <a class="el" href="class_row_range.html">RowRange</a> &amp;segmentRows)=0</td></tr><tr class="separator:a15d3a3fa8bc1b53d89de51fd75a45900"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Convert to header &amp; footer</div></td></tr><tr class="memitem:a7e3747d63e9e20ffef2dad5ce39a0f4f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a7e3747d63e9e20ffef2dad5ce39a0f4f">ConvertToHeaderRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:a7e3747d63e9e20ffef2dad5ce39a0f4f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a1ac9c5a4687ba42fc26d309ce5ab15"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a1a1ac9c5a4687ba42fc26d309ce5ab15">CanConvertToHeaderRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows) const =0</td></tr><tr class="separator:a1a1ac9c5a4687ba42fc26d309ce5ab15"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af84af88977857892f2e77f3476ea95fd"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#af84af88977857892f2e77f3476ea95fd">ConvertToFooterRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:af84af88977857892f2e77f3476ea95fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a75c766a10b9260f25978fb62440e01c3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a75c766a10b9260f25978fb62440e01c3">CanConvertToFooterRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows) const =0</td></tr><tr class="separator:a75c766a10b9260f25978fb62440e01c3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1f968eca62c74a47fbf4c2e928069c80"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a1f968eca62c74a47fbf4c2e928069c80">ConvertToBodyRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:a1f968eca62c74a47fbf4c2e928069c80"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac3233b5bef18fe65f9911a0c816a0d1a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ac3233b5bef18fe65f9911a0c816a0d1a">CanConvertToBodyRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows) const =0</td></tr><tr class="separator:ac3233b5bef18fe65f9911a0c816a0d1a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a680c1f1e1ec129bc51b8b56990cb9361"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a680c1f1e1ec129bc51b8b56990cb9361">ConvertToHeaderRowsButNoAnchors</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:a680c1f1e1ec129bc51b8b56990cb9361"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abdd6e87c779cb746f1f2f0801d3ba82c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#abdd6e87c779cb746f1f2f0801d3ba82c">ConvertToFooterRowsButNoAnchors</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:abdd6e87c779cb746f1f2f0801d3ba82c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a84f9a7c40fec38ef05ee9106feb2eae0"><td align="right" class="memItemLeft" valign="top">virtual Tables::EDirection&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a84f9a7c40fec38ef05ee9106feb2eae0">GetTableDirection</a> () const =0</td></tr><tr class="separator:a84f9a7c40fec38ef05ee9106feb2eae0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9604844157416857fad8f6f36e81787b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a9604844157416857fad8f6f36e81787b">ChangeTableDirection</a> (const Tables::EDirection directionRTL)=0</td></tr><tr class="separator:a9604844157416857fad8f6f36e81787b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab75201aeeed186c403b58eb22b18c407"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ab75201aeeed186c403b58eb22b18c407">ConvertCellsType</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, const <a class="el" href="class_i_d_type.html">CellType</a> destType, bool16 tryToPreserveData=kFalse)=0</td></tr><tr class="separator:ab75201aeeed186c403b58eb22b18c407"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aca4e5021996d7996f2a34c77f3e04368"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#aca4e5021996d7996f2a34c77f3e04368">CanConvertCellsType</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, const <a class="el" href="class_i_d_type.html">CellType</a> destType) const =0</td></tr><tr class="separator:aca4e5021996d7996f2a34c77f3e04368"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6dbe18cc87bfb3da21bc38c557b1283a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a6dbe18cc87bfb3da21bc38c557b1283a">GetCellType</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;cell) const =0</td></tr><tr class="separator:a6dbe18cc87bfb3da21bc38c557b1283a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a> Grid and span modifiers.</h2></td></tr><tr class="memitem:a2a0848143f4fc7b18bfa26e8dd56d544"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>ESplitDirection</b> { <b>eVerticalSplit</b>, <b>eHorizontalSplit</b> }</td></tr><tr class="separator:a2a0848143f4fc7b18bfa26e8dd56d544"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8a8c07feb7d3dd9fac56655d44653639"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a8a8c07feb7d3dd9fac56655d44653639">EDeleteState</a> { <b>eNotDeleting</b>, <b>eTableInitiatedDelete</b>, <b>eTextInitiatedDelete</b> }</td></tr><tr class="separator:a8a8c07feb7d3dd9fac56655d44653639"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0da3f8c1e6d8f7d847eaa4394c88702d"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a0da3f8c1e6d8f7d847eaa4394c88702d">EInsertState</a> { <b>eNotInserting</b>, <b>eTableInitiatedInsert</b>, <b>eTextInitiatedInsert</b> }</td></tr><tr class="separator:a0da3f8c1e6d8f7d847eaa4394c88702d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a14023514b760886a2d617253675c53ae"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a14023514b760886a2d617253675c53ae">InsertRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows, const Tables::ERelativePosition pos, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height, const Tables::EContinuation continuation=Tables::eStructureAllAttrs)=0</td></tr><tr class="separator:a14023514b760886a2d617253675c53ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af8f722e33299752938536d8898a907d0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#af8f722e33299752938536d8898a907d0">InsertRowsButNotAnchors</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows, const Tables::ERelativePosition pos, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;height, const Tables::EContinuation continuation=Tables::eStructureAllAttrs)=0</td></tr><tr class="separator:af8f722e33299752938536d8898a907d0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae5872ce53ff26bd911a1e85a3c3b33b1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ae5872ce53ff26bd911a1e85a3c3b33b1">InsertColumns</a> (const <a class="el" href="class_col_range.html">ColRange</a> &amp;cols, const Tables::ERelativePosition pos, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;width, const Tables::EContinuation continuation=Tables::eStructureAllAttrs)=0</td></tr><tr class="separator:ae5872ce53ff26bd911a1e85a3c3b33b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adab283a544b17c7fe7ba20fc4265de8d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#adab283a544b17c7fe7ba20fc4265de8d">DeleteRows</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:adab283a544b17c7fe7ba20fc4265de8d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:affc335a78ffa27ffe60b6ad3cbc1e784"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#affc335a78ffa27ffe60b6ad3cbc1e784">DeleteRowsButNotAnchors</a> (const <a class="el" href="class_row_range.html">RowRange</a> &amp;rows)=0</td></tr><tr class="separator:affc335a78ffa27ffe60b6ad3cbc1e784"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6e002d6af706b001d8e8391782a694aa"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a6e002d6af706b001d8e8391782a694aa">DeleteColumns</a> (const <a class="el" href="class_col_range.html">ColRange</a> &amp;cols)=0</td></tr><tr class="separator:a6e002d6af706b001d8e8391782a694aa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd527d4011b670d86bb71135ab85af3c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#afd527d4011b670d86bb71135ab85af3c">MergeCells</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area)=0</td></tr><tr class="separator:afd527d4011b670d86bb71135ab85af3c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3b121f524517cf9d41d8ecc7f48c5c99"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a3b121f524517cf9d41d8ecc7f48c5c99">CanMergeCells</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area) const =0</td></tr><tr class="separator:a3b121f524517cf9d41d8ecc7f48c5c99"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7b2c401869059f654c814bc115c81895"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a7b2c401869059f654c814bc115c81895">UnmergeCell</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor)=0</td></tr><tr class="separator:a7b2c401869059f654c814bc115c81895"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a40e5ce71ea3fcaa780c0185ffc2822ce"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a40e5ce71ea3fcaa780c0185ffc2822ce">SplitCells</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, ESplitDirection direction)=0</td></tr><tr class="separator:a40e5ce71ea3fcaa780c0185ffc2822ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a084d5f0099827fb14456969e926934ee"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a084d5f0099827fb14456969e926934ee">CanSplitCells</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells, ESplitDirection direction) const =0</td></tr><tr class="separator:a084d5f0099827fb14456969e926934ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab445de5e0caa259119cf4faea5db2559"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a8a8c07feb7d3dd9fac56655d44653639">EDeleteState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ab445de5e0caa259119cf4faea5db2559">DeleteState</a> () const =0</td></tr><tr class="separator:ab445de5e0caa259119cf4faea5db2559"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa89cbb2c5a92813a0e39609f84d2b655"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a0da3f8c1e6d8f7d847eaa4394c88702d">EInsertState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#aa89cbb2c5a92813a0e39609f84d2b655">InsertState</a> () const =0</td></tr><tr class="separator:aa89cbb2c5a92813a0e39609f84d2b655"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a> Iteration</h2></td></tr><tr class="memitem:a4a1a878068a783fca54ec2367af33c20"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="class_cell_iterator.html">CellIterator</a>&lt; <a class="el" href="class_i_table_model.html">ITableModel</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a></td></tr><tr class="separator:a4a1a878068a783fca54ec2367af33c20"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a67287e9849bed4d07973373e7e492a85"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="class_cell_iterator.html">CellIterator</a>&lt; <a class="el" href="class_i_table_model.html">ITableModel</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a67287e9849bed4d07973373e7e492a85">iterator</a></td></tr><tr class="separator:a67287e9849bed4d07973373e7e492a85"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3ff17de1df4b0379fc9fc71c0151aa4e"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="struct_reverse_cell_iterator.html">ReverseCellIterator</a><br class="typebreak" /> &lt; <a class="el" href="class_i_table_model.html">ITableModel</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a3ff17de1df4b0379fc9fc71c0151aa4e">reverse_iterator</a></td></tr><tr class="separator:a3ff17de1df4b0379fc9fc71c0151aa4e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6c4d3bc7793f5444966a8c2f8b05ce2e"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="struct_reverse_cell_iterator.html">ReverseCellIterator</a><br class="typebreak" /> &lt; <a class="el" href="class_i_table_model.html">ITableModel</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a></td></tr><tr class="separator:a6c4d3bc7793f5444966a8c2f8b05ce2e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a37779e5e4c655bf7e15d24fb2bc93f54"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a37779e5e4c655bf7e15d24fb2bc93f54">begin</a> () const =0</td></tr><tr class="separator:a37779e5e4c655bf7e15d24fb2bc93f54"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af8cfeb06e3c65d465a05c013b7a6abd5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#af8cfeb06e3c65d465a05c013b7a6abd5">begin</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area) const =0</td></tr><tr class="separator:af8cfeb06e3c65d465a05c013b7a6abd5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad8b7f1d5016ac255f9de8003fd163e3c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ad8b7f1d5016ac255f9de8003fd163e3c">end</a> () const =0</td></tr><tr class="separator:ad8b7f1d5016ac255f9de8003fd163e3c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad6bc9b58370e330b0584879a5550a7c1"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ad6bc9b58370e330b0584879a5550a7c1">end</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area) const =0</td></tr><tr class="separator:ad6bc9b58370e330b0584879a5550a7c1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae1ad8ae0716d47628deac5c2be37f2eb"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#ae1ad8ae0716d47628deac5c2be37f2eb">make_iterator</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;gridRef) const =0</td></tr><tr class="separator:ae1ad8ae0716d47628deac5c2be37f2eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a68ae764e86a95619189fbb6f45c48def"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a68ae764e86a95619189fbb6f45c48def">rbegin</a> () const =0</td></tr><tr class="separator:a68ae764e86a95619189fbb6f45c48def"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a311c216f87fdb27f917bce74eddc8d6a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a311c216f87fdb27f917bce74eddc8d6a">rbegin</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area) const =0</td></tr><tr class="separator:a311c216f87fdb27f917bce74eddc8d6a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7b65d3f8a7cc30b4f58b9d8ee0c2ae10"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a7b65d3f8a7cc30b4f58b9d8ee0c2ae10">rend</a> () const =0</td></tr><tr class="separator:a7b65d3f8a7cc30b4f58b9d8ee0c2ae10"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a28fe01297af5268d30c41e9fc124767f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a28fe01297af5268d30c41e9fc124767f">rend</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;area) const =0</td></tr><tr class="separator:a28fe01297af5268d30c41e9fc124767f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a826bc9d756e02b328239cdc1525f9714"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a826bc9d756e02b328239cdc1525f9714">rmake_iterator</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;gridRef) const =0</td></tr><tr class="separator:a826bc9d756e02b328239cdc1525f9714"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a> Copy-paste</h2></td></tr><tr class="memitem:a2459560715301dd5247edfca2f928d15"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a2459560715301dd5247edfca2f928d15">EWhatState</a> { <br /> &nbsp;&nbsp;<b>eTableAttrsStyle</b> = 0x01, <b>eRowAttrs</b> = 0x02, <b>eColAttrs</b> = 0x04, <b>eCellAttrs</b> = 0x08, <br /> &nbsp;&nbsp;<b>eCellContent</b> = 0x10, <a class="el" href="class_i_table_model.html#a2459560715301dd5247edfca2f928d15a1ff1e2908f058a4163cbefede05eebd9">eCells</a> = 0x18, <a class="el" href="class_i_table_model.html#a2459560715301dd5247edfca2f928d15afdabc36ae639c04cc7be4e1ed7fbd420">eAll</a> = 0x1f <br /> }</td></tr><tr class="separator:a2459560715301dd5247edfca2f928d15"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3d194d85225f1efbdfa3d95bff5e0a24"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a3d194d85225f1efbdfa3d95bff5e0a24">CanCopy</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells) const =0</td></tr><tr class="separator:a3d194d85225f1efbdfa3d95bff5e0a24"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a25cfc77b7b7b1791b4fb00212482876f"><td align="right" class="memItemLeft" valign="top">virtual TableMemento *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a25cfc77b7b7b1791b4fb00212482876f">Copy</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells) const =0</td></tr><tr class="separator:a25cfc77b7b7b1791b4fb00212482876f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abfc6df1bd442043aae7f756c6349556f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#abfc6df1bd442043aae7f756c6349556f">CanClear</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells) const =0</td></tr><tr class="separator:abfc6df1bd442043aae7f756c6349556f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7f0758921a679f9caf4c5f0c40ec815a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a7f0758921a679f9caf4c5f0c40ec815a">Clear</a> (const <a class="el" href="class_grid_area.html">GridArea</a> &amp;cells)=0</td></tr><tr class="separator:a7f0758921a679f9caf4c5f0c40ec815a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0554933de16dcca9858e63da57c84431"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a0554933de16dcca9858e63da57c84431">Paste</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;atAnchor, <a class="el" href="class_i_table_model.html#a2459560715301dd5247edfca2f928d15">EWhatState</a> what, TableMemento *toAdopt)=0</td></tr><tr class="separator:a0554933de16dcca9858e63da57c84431"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab27e5dbd11e491f69a11b0dd7ebe6d67"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab27e5dbd11e491f69a11b0dd7ebe6d67"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Paste</b> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;atAnchor, <a class="el" href="class_i_table_model.html#a2459560715301dd5247edfca2f928d15">EWhatState</a> what, TableMemento *toAdopt, bool16 clearRedundantRows)=0</td></tr><tr class="separator:ab27e5dbd11e491f69a11b0dd7ebe6d67"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a927751aa55c3c03e7da4ee5e8154c651"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_model.html#a927751aa55c3c03e7da4ee5e8154c651">CanPaste</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;atAnchor, const <a class="el" href="class_grid_span.html">GridSpan</a> &amp;mementoSpan, const <a class="el" href="class_i_table_model.html">ITableModel</a> *sourceTable, const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;fromAnchor) const =0</td></tr><tr class="separator:a927751aa55c3c03e7da4ee5e8154c651"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Public interface exposing the table model.<p>The table model allows content to be arranged into rows and columns of cells. The rows and columns in the table form a grid which is used for addressing. Each element in the grid is addressed by a GridAddress(row, column).<p>For instance, a <a class="el" href="class_grid_address.html">GridAddress</a> (1, 2) refers to the grid element in row 1, column 2. A table has a set of header, body and footer rows. The rows in a table are grouped in this order. Header rows, then body rows followed by footer rows. There should be at least one body rows. Header and footer rows may have a count of zero. Valid row values are in the row range represented by GetTotalRows. Valid column values are in the column range represented by GetTotalCols.<p>One or more elements can be grouped together to form a &quot;cell&quot;. Cells have content and may span multiple rows and columns, i.e. multiple elements in the grid. The extent of a cell is represented by its <a class="el" href="class_grid_span.html">GridSpan</a>.<p>A &quot;trivial cell&quot; has a (row, column) span of (1, 1). Every element in the grid maps to at most one cell. The topLeft element of a cell is called an anchor. A cell is addressed by the <a class="el" href="class_grid_address.html">GridAddress</a> of it&#39;s anchor.<p>Also see <a class="el" href="class_i_table_attr_modifier.html">ITableAttrModifier</a> and <a class="el" href="class_i_table_attr_accessor.html">ITableAttrAccessor</a>.<dl class="section author"><dt>Author<dd>Joe Shankar </dl></div><h2 class="groupheader">Member Typedef Documentation</h2><a class="anchor" id="a4a1a878068a783fca54ec2367af33c20"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef <a class="el" href="class_cell_iterator.html">CellIterator</a>&lt;<a class="el" href="class_i_table_model.html">ITableModel</a>&gt; <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">ITableModel::const_iterator</a></td></tr></table></div><div class="memdoc"><p>Used to traverse through the <a class="el" href="class_grid_address.html">GridAddress</a> locations within a table model </div></div><a class="anchor" id="a6c4d3bc7793f5444966a8c2f8b05ce2e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef <a class="el" href="struct_reverse_cell_iterator.html">ReverseCellIterator</a>&lt;<a class="el" href="class_i_table_model.html">ITableModel</a>&gt; <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">ITableModel::const_reverse_iterator</a></td></tr></table></div><div class="memdoc"><p>Used to traverse (in reverse direction) through the <a class="el" href="class_grid_address.html">GridAddress</a> locations within a table model </div></div><a class="anchor" id="a67287e9849bed4d07973373e7e492a85"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef <a class="el" href="class_cell_iterator.html">CellIterator</a>&lt;<a class="el" href="class_i_table_model.html">ITableModel</a>&gt; <a class="el" href="class_i_table_model.html#a67287e9849bed4d07973373e7e492a85">ITableModel::iterator</a></td></tr></table></div><div class="memdoc"><p>Used to traverse through the <a class="el" href="class_grid_address.html">GridAddress</a> locations within a table model </div></div><a class="anchor" id="a3ff17de1df4b0379fc9fc71c0151aa4e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">typedef <a class="el" href="struct_reverse_cell_iterator.html">ReverseCellIterator</a>&lt;<a class="el" href="class_i_table_model.html">ITableModel</a>&gt; <a class="el" href="class_i_table_model.html#a3ff17de1df4b0379fc9fc71c0151aa4e">ITableModel::reverse_iterator</a></td></tr></table></div><div class="memdoc"><p>Used to traverse (in reverse direction) through the <a class="el" href="class_grid_address.html">GridAddress</a> locations within a table model </div></div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a8a8c07feb7d3dd9fac56655d44653639"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_table_model.html#a8a8c07feb7d3dd9fac56655d44653639">ITableModel::EDeleteState</a></td></tr></table></div><div class="memdoc"><p>Used to specify different states relating to table deletion. </div></div><a class="anchor" id="a0da3f8c1e6d8f7d847eaa4394c88702d"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_table_model.html#a0da3f8c1e6d8f7d847eaa4394c88702d">ITableModel::EInsertState</a></td></tr></table></div><div class="memdoc"><p>Used to specify different states relating to table insertion. </div></div><a class="anchor" id="a2459560715301dd5247edfca2f928d15"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_table_model.html#a2459560715301dd5247edfca2f928d15">ITableModel::EWhatState</a></td></tr></table></div><div class="memdoc"><p>Specifies what aspect to Paste These are the various aspects of a table that may be affected by Paste. Only eAll &amp; eCells is currently supported. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a2459560715301dd5247edfca2f928d15a1ff1e2908f058a4163cbefede05eebd9"></a>eCells</em>&nbsp;</td><td class="fielddoc"><p>cell attributes and content </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a2459560715301dd5247edfca2f928d15afdabc36ae639c04cc7be4e1ed7fbd420"></a>eAll</em>&nbsp;</td><td class="fielddoc"><p>table, row, column, cell attr and content </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a37779e5e4c655bf7e15d24fb2bc93f54"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a> ITableModel::begin </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Use to acquire an iterator that refers to the cell at the start of the table structure, i.e. GridAddress(0,0). </div></div><a class="anchor" id="af8cfeb06e3c65d465a05c013b7a6abd5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a> ITableModel::begin </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Use to acquire an iterator that refers to cell at the start of the <a class="el" href="class_grid_area.html">GridArea</a> specified. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>specifies dimension of grid-elements covered of interest </td></tr></table></dl></div></div><a class="anchor" id="abfc6df1bd442043aae7f756c6349556f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanClear </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Precondition for self.Clear<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td></td></tr></table></dl></div></div><a class="anchor" id="aca4e5021996d7996f2a34c77f3e04368"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanConvertCellsType </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="paramname"><em>destType</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if <a class="el" href="class_i_table_model.html#ab75201aeeed186c403b58eb22b18c407">ConvertCellsType()</a> can be called, kFalse otherwise. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td><a class="el" href="class_grid_area.html">GridArea</a> of cells to be converted </td></tr><tr><td class="paramname">destType</td><td>cell type to be converted into </td></tr></table></dl></div></div><a class="anchor" id="ac3233b5bef18fe65f9911a0c816a0d1a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanConvertToBodyRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if the given rows can be converted to body rows. All body rows are maintained in one contiguous range after all header rows and before all footer rows. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the header or footer rows to be converted to body rows. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>self.GetTotalRows().Contains(rows) </dl><dl class="section return"><dt>Returns<dd>kTrue if rows can be passed to CanConvertToBodyRows if self.GetHeaderRows().Contains(rows) or self.GetFooterRows().Contains(rows) </dl></div></div><a class="anchor" id="a75c766a10b9260f25978fb62440e01c3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanConvertToFooterRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if the given rows can be converted to footer rows. All footer rows are maintained in a contiguous range after all body rows. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the body rows to be converted to footer rows. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if rows can be passed to ConvertToFooterRows or ConvertToFooterRowsButNoAnchors. </dl></div></div><a class="anchor" id="a1a1ac9c5a4687ba42fc26d309ce5ab15"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanConvertToHeaderRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if the given rows can be converted to header rows. All header rows are maintained in a contiguous range before all body rows. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the body rows to be converted to header rows. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if rows can be passed to ConvertToHeaderRows or ConvertToHeaderRowsButNoAnchors. </dl></div></div><a class="anchor" id="a3d194d85225f1efbdfa3d95bff5e0a24"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanCopy </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if a given area within the table can be copied.<dl class="section pre"><dt>Precondition<dd>self.GetTableArea().Contains(cells) </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>specifies the dimension of the area containing cells of interest </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if it is valid to call self.Copy(cells), kFalse otherwise </dl></div></div><a class="anchor" id="a3b121f524517cf9d41d8ecc7f48c5c99"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanMergeCells </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if the given area is appropriate for a merge-cells operation. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>specifies dimension of area containing cells of interest </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if area can be passed to the MergeCells call </dl></div></div><a class="anchor" id="a927751aa55c3c03e7da4ee5e8154c651"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanPaste </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>atAnchor</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_grid_span.html">GridSpan</a> &amp;&nbsp;</td><td class="paramname"><em>mementoSpan</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_table_model.html">ITableModel</a> *&nbsp;</td><td class="paramname"><em>sourceTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>fromAnchor</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if a memento of mementoSpan can be pasted location specified by atAnchor. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">atAnchor</td><td>specifies location of interest </td></tr><tr><td class="paramname">mementoSpan</td><td>gives the dimension (height,width) of cell to be pasted </td></tr><tr><td class="paramname">memento</td><td>give the structure to ensure complete cells in sets to paste into </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if a memento of mementoSpan can be pasted at location atAnchor </dl></div></div><a class="anchor" id="a084d5f0099827fb14456969e926934ee"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::CanSplitCells </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">ESplitDirection&nbsp;</td><td class="paramname"><em>direction</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is obsolete. Please use CanSplitCells. Determine whether a particular cell can be split. <dl class="section pre"><dt>Precondition<dd>direction == eVerticalSplit or direction == eHorizontalSplit </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>location of the cell </td></tr><tr><td class="paramname">direction</td><td>specify whether vertical or horizontal split of interest </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the cell with specified anchor can be split in given direction, kFalse if this can&#39;t be done, or if the location does not represent the anchor point of a cellDetermine whether cells with anchors in a particular area can be split. </dl><dl class="section pre"><dt>Precondition<dd>direction == eVerticalSplit or direction == eHorizontalSplit </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>area of cells to split, does not need to contain complete cells </td></tr><tr><td class="paramname">direction</td><td>specify whether vertical or horizontal split of interest </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if all of the cells can be split in given direction, kFalse if this can&#39;t be done, or if the area does not contain any anchors </dl></div></div><a class="anchor" id="a9604844157416857fad8f6f36e81787b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::ChangeTableDirection </td><td>(</td><td class="paramtype">const Tables::EDirection&nbsp;</td><td class="paramname"><em>directionRTL</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Changes the table direction.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">directionRTL</td><td>Direction to change table. </td></tr></table></dl></div></div><a class="anchor" id="a7f0758921a679f9caf4c5f0c40ec815a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::Clear </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clears the content in cells.<dl class="section pre"><dt>Precondition<dd>self.CanClear </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td></td></tr></table></dl></div></div><a class="anchor" id="ac1a48e7ff1fdac5083fa761cc5112644"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::ContainsCompleteCells </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if the specified area can be decomposed into a set of complete cells. The cells will be complete iff all the grid-elements that compose a cell are contained within the area. See the documentation for <a class="el" href="class_grid_address.html">GridAddress</a> for more material on distinction between grid-elements and cells. <dl class="section return"><dt>Returns<dd>kTrue if cells are a complete rectangular, selectable area, kFalse otherwise </dl></div></div><a class="anchor" id="ab75201aeeed186c403b58eb22b18c407"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::ConvertCellsType </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="paramname"><em>destType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>tryToPreserveData</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to convert the type of cells <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td><a class="el" href="class_grid_area.html">GridArea</a> of cells to be converted </td></tr><tr><td class="paramname">destType</td><td>cell type to be converted into </td></tr><tr><td class="paramname">tryToPreserveData</td><td>if true, the data is preserved into the cell after converion, if possible. </td></tr></table></dl></div></div><a class="anchor" id="a1f968eca62c74a47fbf4c2e928069c80"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::ConvertToBodyRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Converts header or footer rows to body rows. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>to convert to body rows. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>self.CanConvertToBodyRows(rows) </dl><dl class="section post"><dt>Postcondition<dd>self.GetBodyRows.Contains(rows) <dd> self.GetHeaderRows().Contains(rows) == false <dd> self.GetFooterRows().Contains(rows) == false </dl></div></div><a class="anchor" id="af84af88977857892f2e77f3476ea95fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::ConvertToFooterRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Converts body rows to footer rows. <dl class="section pre"><dt>Precondition<dd>self.CanConvertToFooterRows() </dl><dl class="section post"><dt>Postcondition<dd>let preFooterRows = self.GetFooterRows() <dd> self.GetFooterRows == <a class="el" href="class_row_range.html">RowRange</a>(rows.start, preFooterRows.count + rows.count) </dl></div></div><a class="anchor" id="abdd6e87c779cb746f1f2f0801d3ba82c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::ConvertToFooterRowsButNoAnchors </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For Internal use. </div></div><a class="anchor" id="a7e3747d63e9e20ffef2dad5ce39a0f4f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::ConvertToHeaderRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Converts body rows to header rows. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>to be converted to headers. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>self.CanConvertToHeaderRows() </dl><dl class="section post"><dt>Postcondition<dd>let preHeaderRows = self.GetHeaderRows() <dd> self.GetHeaderRows == <a class="el" href="class_row_range.html">RowRange</a>(preHeaderRows.start, preHeaderRows.count + rows.count) </dl></div></div><a class="anchor" id="a680c1f1e1ec129bc51b8b56990cb9361"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::ConvertToHeaderRowsButNoAnchors </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For Internal use. </div></div><a class="anchor" id="a25cfc77b7b7b1791b4fb00212482876f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TableMemento* ITableModel::Copy </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a TableMemento representing the internal state of the cells.<p>This may be restored with a corresponding Paste call. Caller is responsible for deleting storage of the returned memento.<dl class="section pre"><dt>Precondition<dd><a class="el" href="class_i_table_model.html#a3d194d85225f1efbdfa3d95bff5e0a24">CanCopy()</a> == kTrue </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td>specifies the dimension of the area containing cells to copy </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a memento that can be used in subsequent paste operations </dl></div></div><a class="anchor" id="a15d3a3fa8bc1b53d89de51fd75a45900"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::CreateColSegment </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>distanceFromTableLeftEdge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>segmentRows</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates col segment. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">distanceFromTableLeftEdge</td><td>specifies segment pos, relative to left edge of the table </td></tr><tr><td class="paramname">segmentRows</td><td>specifies the range of rows within the table for the new segment </td></tr></table></dl></div></div><a class="anchor" id="aa705e5e66b26372d01d63798215e82d4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual boost::shared_ptr&lt;<a class="el" href="class_content_boss_accessor.html">ContentBossAccessor</a>&gt; ITableModel::CreateContentBossAccessor </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">                Efficient access to content bosses. Typical usage:

                &lt;pre&gt;

</pre><p> boost::shared_ptr&lt;<a class="el" href="class_content_boss_accessor.html">ContentBossAccessor</a>&gt; cbAccessor(table-&gt;<a class="el" href="class_i_table_model.html#aa705e5e66b26372d01d63798215e82d4">CreateContentBossAccessor()</a>); cbAccessor-&gt;QueryCellContentBoss(anchor); The returned <a class="el" href="class_content_boss_accessor.html">ContentBossAccessor</a> cannot be used across structure changes specifically row and column insertion or deletion. The following sequence would be illegal. <ol><li> cb = table.CreateContentBossAccessor <li> table.insert/delete rows/columnns. <li> cb.QueryCellContentBoss </ol></div></div><a class="anchor" id="aca3a0a4ff454aacac90db9c50ccbd2a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::CreateRowSegment </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>distanceFromTableTopEdge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_col_range.html">ColRange</a> &amp;&nbsp;</td><td class="paramname"><em>segmentCols</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates row segment. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">distanceFromTableTopEdge</td><td>specifies segment pos, relative to top edge of the table </td></tr><tr><td class="paramname">segmentCols</td><td>specifies the range of columns within the table for the new segment </td></tr></table></dl></div></div><a class="anchor" id="a5e03c03f504e6ab28038a6363361f49f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::CreateRowSegment </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>distanceFromTableTopEdge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_col_range.html">ColRange</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>segmentCols</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates row segment. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">distanceFromTableTopEdge</td><td>specifies segment pos, relative to top edge of the table </td></tr><tr><td class="paramname">segmentCols</td><td>specifies the vector of the range of columns within the table for the new segment(s) </td></tr></table></dl></div></div><a class="anchor" id="a6e002d6af706b001d8e8391782a694aa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::DeleteColumns </td><td>(</td><td class="paramtype">const <a class="el" href="class_col_range.html">ColRange</a> &amp;&nbsp;</td><td class="paramname"><em>cols</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete (cols&amp;#46;count) columns starting from the column at (cols&amp;#46;start). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cols</td><td>gives range of columns to remove from table </td></tr></table></dl></div></div><a class="anchor" id="adab283a544b17c7fe7ba20fc4265de8d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::DeleteRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete the number (rows&amp;#46;count) rows starting from the position (rows&amp;#46;start). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the range of rows to remove from this table </td></tr></table></dl></div></div><a class="anchor" id="affc335a78ffa27ffe60b6ad3cbc1e784"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::DeleteRowsButNotAnchors </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete the number (rows&amp;#46;count) rows starting from the row given by (rows&amp;#46;start), leaving the anchor characters behind.<p>This is meant to be called when deleting a table via a text deletion. In this case it is undesirable for the table to delete the anchor characters.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the range of rows to remove from the table </td></tr></table></dl></div></div><a class="anchor" id="ab445de5e0caa259119cf4faea5db2559"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a8a8c07feb7d3dd9fac56655d44653639">EDeleteState</a> ITableModel::DeleteState </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find out if who intitiated the delete of the table. Might be in states such as: not-deleting, text-deleting or table-deletnig. <dl class="section return"><dt>Returns<dd>the current state relating to the ongoing deletion </dl></div></div><a class="anchor" id="ad8b7f1d5016ac255f9de8003fd163e3c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a> ITableModel::end </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Use to acquire an iterator that refers to cell just off the end of the whole table. Use this when the iteration should end at the last cell. </div></div><a class="anchor" id="ad6bc9b58370e330b0584879a5550a7c1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a> ITableModel::end </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Use to acquire an iterator that refers to the last cell for traversal through specified <a class="el" href="class_grid_area.html">GridArea</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>specifies dimension of grid-elements covered of interest </td></tr></table></dl><dl class="section return"><dt>Returns<dd>iterator that refers to the specified location. </dl></div></div><a class="anchor" id="aac3646f90129cd9cf17d69d37ef2666c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_address.html">GridAddress</a> ITableModel::FindCellAnchor </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the anchor (top-left location) of the cell this element is in. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>specifies the grid-element for this query </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the location of the anchor (top-left) for the given grid-element </dl></div></div><a class="anchor" id="a2189b0e120fcf256bfba3aef38941df5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_area.html">GridArea</a> ITableModel::GetBodyArea </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the area covered by the body rows. <dl class="section return"><dt>Returns<dd>the area of body rows in a <a class="el" href="class_grid_area.html">GridArea</a> object. </dl></div></div><a class="anchor" id="a0736429bd5e4f8dabfa38b0a6ae1ec24"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_row_range.html">RowRange</a> ITableModel::GetBodyRows </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the range of body rows in the underlying table structure. <dl class="section return"><dt>Returns<dd>the body rows in a <a class="el" href="class_row_range.html">RowRange</a> object </dl></div></div><a class="anchor" id="a9b21e5c8d91782af8af87ef01f68b954"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_area.html">GridArea</a> ITableModel::GetCellArea </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the absolute location of the elements the cell consists of. i.e. <pre><a class="el" href="class_grid_area.html">GridArea</a>(anchor, this-&gt;<a class="el" href="class_i_table_model.html#ae4365ace307d66e588273e333572107c">GetCellSpan()</a>) </pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>specifies the location for the cell query is about </td></tr></table></dl></div></div><a class="anchor" id="ae4365ace307d66e588273e333572107c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_span.html">GridSpan</a> ITableModel::GetCellSpan </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> to determine the number of elements the cell consists of, i.e. the number of rows and columns the cell spans. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>specifies the location for the cell this query is about </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_grid_span.html">GridSpan</a> object that represents the cell-span (height,width) of the cell. </dl></div></div><a class="anchor" id="a6dbe18cc87bfb3da21bc38c557b1283a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">CellType</a> ITableModel::GetCellType </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>cell</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the type of cell (kTextContentType, kPageItemContentType etc.) <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cells</td><td><a class="el" href="class_grid_area.html">GridArea</a> of cells to be converted </td></tr></table></dl></div></div><a class="anchor" id="a75b7050b615d0c5ac78d869099646d53"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_area.html">GridArea</a> ITableModel::GetFooterArea </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the area covered by the footer rows. <dl class="section return"><dt>Returns<dd>the area of footer rows in a <a class="el" href="class_grid_area.html">GridArea</a> object. </dl></div></div><a class="anchor" id="a02913ae25003598014ed376268a323bb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_row_range.html">RowRange</a> ITableModel::GetFooterRows </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the range of footer rows in the underlying table structure. <dl class="section return"><dt>Returns<dd>the footer rows in a <a class="el" href="class_row_range.html">RowRange</a> object </dl></div></div><a class="anchor" id="ab79f85998ef7333418c91317870e53f5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_address.html">GridAddress</a> ITableModel::GetGridAddress </td><td>(</td><td class="paramtype"><a class="el" href="class_grid_i_d.html">GridID</a>&nbsp;</td><td class="paramname"><em>gridID</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The gridID should have been obtained by a previous call to GetGridID. <dl class="section return"><dt>Returns<dd>the <a class="el" href="class_grid_address.html">GridAddress</a> represented by the gridID. </dl></div></div><a class="anchor" id="a315d90d77faa37c27b25be712a6ee420"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_i_d.html">GridID</a> ITableModel::GetGridID </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> to find the <a class="el" href="class_grid_i_d.html">GridID</a> for a particular location. This<dl class="section pre"><dt>Precondition<dd>location should be within the table </dl><dl class="section return"><dt>Returns<dd>the persistent <a class="el" href="class_grid_i_d.html">GridID</a> that identifies element, or kInvalidGridID if the element is invalid. </dl></div></div><a class="anchor" id="a86c4e3eaef94e85ec82883311a80d4a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_area.html">GridArea</a> ITableModel::GetHeaderArea </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the area covered by the header rows. <dl class="section return"><dt>Returns<dd>the area of header rows in a <a class="el" href="class_grid_area.html">GridArea</a> object. </dl></div></div><a class="anchor" id="aff994bb3d0f7be0bfb26264d2220f004"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_row_range.html">RowRange</a> ITableModel::GetHeaderRows </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the range of header rows in the underlying table structure. <dl class="section return"><dt>Returns<dd>the header rows in a <a class="el" href="class_row_range.html">RowRange</a> object </dl></div></div><a class="anchor" id="a84f9a7c40fec38ef05ee9106feb2eae0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual Tables::EDirection ITableModel::GetTableDirection </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the table direction.<dl class="section return"><dt>Returns<dd>the direction of the table. </dl></div></div><a class="anchor" id="ae2c05f6bd973bf4d835c162e0e4226db"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_grid_area.html">GridArea</a> ITableModel::GetTotalArea </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the area covered by the whole table model. <dl class="section return"><dt>Returns<dd>the whole table area in a <a class="el" href="class_grid_area.html">GridArea</a> object. </dl></div></div><a class="anchor" id="a06d2852367dfe246ea8b47260d721c09"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_col_range.html">ColRange</a> ITableModel::GetTotalCols </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the total columns in the underlying table structure. <dl class="section return"><dt>Returns<dd>total columns in a <a class="el" href="class_col_range.html">ColRange</a> object </dl></div></div><a class="anchor" id="a1babd6575d49279113278843955078fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_row_range.html">RowRange</a> ITableModel::GetTotalRows </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> for the total rows including headers, body and footers in the underlying table structure. <dl class="section return"><dt>Returns<dd>total rows in a <a class="el" href="class_row_range.html">RowRange</a> object </dl></div></div><a class="anchor" id="ae5872ce53ff26bd911a1e85a3c3b33b1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::InsertColumns </td><td>(</td><td class="paramtype">const <a class="el" href="class_col_range.html">ColRange</a> &amp;&nbsp;</td><td class="paramname"><em>cols</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>width</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::EContinuation&nbsp;</td><td class="paramname"><em>continuation</em> = <code>Tables::eStructureAllAttrs</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Inserts cols&amp;#46;count columns before or after cols&amp;#46;start depending on pos.<p>Width is in points. If colWidth is 0.0 then the new width is determined from the column relative to which the insertion is being made. A non zero value of width will result in all inserted columns having that width.<p>[Documentation note for width semantics: Update <a class="el" href="_i_table_suite_8h_source.html">ITableSuite.h</a> &amp; <a class="el" href="_i_table_commands_8h_source.html">ITableCommands.h</a> to reflect changes.]<dl class="section pre"><dt>Precondition<dd>EContinuation should include attributes if width = 0 </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cols</td><td>specifies the range of columns within the table for the insertion, if this is not an empty range then the rows will be replaced </td></tr><tr><td class="paramname">pos</td><td>Specifies the relative position, before or after the given range in the table </td></tr><tr><td class="paramname">height</td><td>desired column height in points </td></tr><tr><td class="paramname">continuation</td><td>one of enumerated constants specifying how existing table properties should apply to these new rows </td></tr></table></dl></div></div><a class="anchor" id="a14023514b760886a2d617253675c53ae"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::InsertRows </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>height</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::EContinuation&nbsp;</td><td class="paramname"><em>continuation</em> = <code>Tables::eStructureAllAttrs</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Inserts rows&amp;#46;count rows before or after rows&amp;#46;start depending on pos.<p>Height is in points. If rowHeight is 0.0 then the row height is determined by the auto-grow and minimum row height attribute of the row relative to which the insertion is being made. A non zero value of height will result in all inserted rows having that minimum height.<p>[Documentation note for height semantics: Update <a class="el" href="_i_table_suite_8h_source.html">ITableSuite.h</a> &amp; <a class="el" href="_i_table_commands_8h_source.html">ITableCommands.h</a> and <a class="el" href="_i_table_utils_8h_source.html">ITableUtils.h</a> to reflect changes.]<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the range of rows within table for the insertion, if this is not an empty range then the rows will be replaced </td></tr><tr><td class="paramname">pos</td><td>Specifies the relative position, before or after the given range in the table </td></tr><tr><td class="paramname">height</td><td>desired row height in points </td></tr><tr><td class="paramname">continuation</td><td>one of enumerated constants specifying how existing table properties should apply to these new rows </td></tr></table></dl></div></div><a class="anchor" id="af8f722e33299752938536d8898a907d0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::InsertRowsButNotAnchors </td><td>(</td><td class="paramtype">const <a class="el" href="class_row_range.html">RowRange</a> &amp;&nbsp;</td><td class="paramname"><em>rows</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::ERelativePosition&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>height</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const Tables::EContinuation&nbsp;</td><td class="paramname"><em>continuation</em> = <code>Tables::eStructureAllAttrs</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Inserts rows&amp;#46;count rows before or after rows&amp;#46;start depending on pos.<p>This is meant to be called when we already have anchors for the rows we are adding, such as the case where we are coping a text frame containing part of a table<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rows</td><td>specifies the range of rows within table for the insertion, if this is not an empty range then the rows will be replaced </td></tr><tr><td class="paramname">pos</td><td>Specifies the relative position, before or after the given range in the table </td></tr><tr><td class="paramname">height</td><td>desired row height in points </td></tr><tr><td class="paramname">continuation</td><td>one of enumerated constants specifying how existing table properties should apply to these new rows </td></tr></table></dl></div></div><a class="anchor" id="aa89cbb2c5a92813a0e39609f84d2b655"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a0da3f8c1e6d8f7d847eaa4394c88702d">EInsertState</a> ITableModel::InsertState </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Whether we should insert anchors with these rows or not <dl class="section return"><dt>Returns<dd>the current state relating to the ongoing deletion </dl></div></div><a class="anchor" id="ad64d53a0edef41ea81ca8584a29e58ff"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::IsAnchor </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p><a class="el" href="class_accessor.html">Accessor</a> to determine if a given location is an anchor cell. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>Identifies the grid element to be tested. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if gridRef is the top-left element in a cell. </dl></div></div><a class="anchor" id="add574ac0d8797f8f75d140a6aee57695"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::IsValid </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if element at the given location is within the range of elements in the underlying table grid. <dl class="section post"><dt>Postcondition<dd>result = self.GetTableArea().Contains(element) </dl><dl class="section return"><dt>Returns<dd>kTrue if the location is within the table bounds, kFalse otherwise </dl></div></div><a class="anchor" id="a8c8396a4f7db2076f541f7802af2a590"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::IsValidColumn </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>col</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if given column lies within columns spanned by this table. <dl class="section return"><dt>Returns<dd>kTrue if col is within the table models range of rows </dl></div></div><a class="anchor" id="a84ac18c02e156a5e85a6340b2d4b8c41"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableModel::IsValidRow </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>row</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine if a given row lies within the range of rows spanned by this table. <dl class="section return"><dt>Returns<dd>kTrue if row is within the table models range of rows </dl></div></div><a class="anchor" id="ae1ad8ae0716d47628deac5c2be37f2eb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a4a1a878068a783fca54ec2367af33c20">const_iterator</a> ITableModel::make_iterator </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>gridRef</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire a forward iterator. <dl class="section return"><dt>Returns<dd>iterator referring to the given <a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="afd527d4011b670d86bb71135ab85af3c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::MergeCells </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Merges the elements specified by area. This function makes the anchor identified by (area.TopLeft) span all elements in &#39;area&#39;.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">area</td><td>Specifies a rectangle of elements in the grid to be merged. </td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>self.CanMergeCells(area) = kTrue </dl></div></div><a class="anchor" id="a0554933de16dcca9858e63da57c84431"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::Paste </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>atAnchor</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_table_model.html#a2459560715301dd5247edfca2f928d15">EWhatState</a>&nbsp;</td><td class="paramname"><em>what</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TableMemento *&nbsp;</td><td class="paramname"><em>toAdopt</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Accepts the TableMemento created by a previous call to Copy and applies into the model at atAnchor.<p>Ownership of storage is transferred from the caller to the implementation of Paste.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">atAnchor</td><td>location at which to paste </td></tr><tr><td class="paramname">what</td><td>specifies what properties to transfer </td></tr><tr><td class="paramname">toAdopt</td><td></td></tr></table></dl><dl class="section pre"><dt>Precondition<dd>self.GetTableArea().Contains(<a class="el" href="class_grid_area.html">GridArea</a>(atAnchor, memento.GetSpan()) </dl></div></div><a class="anchor" id="aeee9b6b4ed996796550e1cf052a98d52"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_cell_content.html">ICellContent</a>* ITableModel::QueryCellContentBoss </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Use <a class="el" href="class_content_boss_accessor.html">ContentBossAccessor</a> for accessing a range of cells. QueryCellContentBoss is not as efficient as the <a class="el" href="class_content_boss_accessor.html">ContentBossAccessor</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>refers to location of cell for which content boss object is sought </td></tr></table></dl></div></div><a class="anchor" id="a9c539c7b143d00bab74c9b3b94f19948"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_cell_content_mgr.html">ICellContentMgr</a>* ITableModel::QueryContentMgr </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="paramname"><em>type</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Access to content managers. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">type</td><td>The type of cell you wish the manager for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a reference-incremented ptr to the cell content manager for the specified cell type </dl></div></div><a class="anchor" id="a68ae764e86a95619189fbb6f45c48def"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a> ITableModel::rbegin </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire a (reverse) iterator that can be used for a traversal of cells in reverse order via ++ starting at the specified location. <dl class="section return"><dt>Returns<dd>(reverse) iterator referring to given location </dl></div></div><a class="anchor" id="a311c216f87fdb27f917bce74eddc8d6a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a> ITableModel::rbegin </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire a (reverse) iterator for delimiting end of traversal of cells in reverse order (via ++). This will normally be the beginning of the collection. <dl class="section return"><dt>Returns<dd>(reverse) iterator that will mark end of iteration </dl></div></div><a class="anchor" id="a7b65d3f8a7cc30b4f58b9d8ee0c2ae10"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a> ITableModel::rend </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire a (reverse) iterator for delimiting end of traversal of cells in reverse order (via ++). This will normally be the beginning of the collection. <dl class="section return"><dt>Returns<dd>(reverse) iterator that will mark end of iteration </dl></div></div><a class="anchor" id="a28fe01297af5268d30c41e9fc124767f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a> ITableModel::rend </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>area</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire a (reverse) iterator for delimiting the end of an iteration that ends at the given location. <dl class="section return"><dt>Returns<dd>(reverse) iterator to refer to mark the given location in the collection </dl></div></div><a class="anchor" id="a826bc9d756e02b328239cdc1525f9714"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_table_model.html#a6c4d3bc7793f5444966a8c2f8b05ce2e">const_reverse_iterator</a> ITableModel::rmake_iterator </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>gridRef</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire a (reverse) iterator. <dl class="section return"><dt>Returns<dd>(reverse) iterator referring to the given <a class="el" href="class_grid_address.html">GridAddress</a></dl></div></div><a class="anchor" id="a40e5ce71ea3fcaa780c0185ffc2822ce"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::SplitCells </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_area.html">GridArea</a> &amp;&nbsp;</td><td class="paramname"><em>cells</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">ESplitDirection&nbsp;</td><td class="paramname"><em>direction</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method is obsolete. Please use SplitCells. Split the cell in half vertically or horizontally. <dl class="section pre"><dt>Precondition<dd>self.CanSplitCellSplit the cells with anchors in the area in half vertically or horizontally. <dd> self.CanSplitCells </dl></div></div><a class="anchor" id="a7b2c401869059f654c814bc115c81895"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableModel::UnmergeCell </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Anchor specifies a non-trivial cell to be unmerged. This function will make all elements spanned by the anchor trivial cells. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_table_model.html">ITableModel</a><li class="footer">Generated on Sat Sep 22 2018 10:54:30 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
