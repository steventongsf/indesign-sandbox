<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_meta_data_access</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_meta_data_access.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_meta_data_access-members.html">List of all members</a></div><div class="headertitle"><div class="title">IMetaDataAccess Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_meta_data_access_8h_source.html">IMetaDataAccess.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IMetaDataAccess:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_meta_data_access.png" usemap="#IMetaDataAccess_map" /><map id="IMetaDataAccess_map" name="IMetaDataAccess_map"><area alt="IPMUnknown" coords="0,0,111,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a3fbdfbb206fb599b4a4bbb95c67ed12e"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IMETADATAACCESS }</td></tr><tr class="separator:a3fbdfbb206fb599b4a4bbb95c67ed12e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0c916944994acf6b18a26a9b42912914"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914">IteratorOptions</a> { <a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914a643ffff065a4432d42feb4fabdda6893">kIterJustChildren</a> = 0x0100UL, <a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914af43764386d1e0c797e3eb46b8e8b4dae">kIterJustLeafNodes</a> = 0x0200UL, <a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914af56a8bfa3188e6c4d4611ab3a5783d8c">kIterJustLeafName</a> = 0x0400UL, <a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914a66cfd18e54122d2aecef8493780c6205">kIterOmitQualifiers</a> = 0x0800UL }</td></tr><tr class="separator:a0c916944994acf6b18a26a9b42912914"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa5e3854d58e5cc37a85306cc9e3aa460"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#aa5e3854d58e5cc37a85306cc9e3aa460">SkipOptions</a> { <a class="el" href="class_i_meta_data_access.html#aa5e3854d58e5cc37a85306cc9e3aa460ab2cd07599412b32bf291c878a19a51b7">kIterSkipSubtree</a> = 0x0001UL, <a class="el" href="class_i_meta_data_access.html#aa5e3854d58e5cc37a85306cc9e3aa460a6da55cbb45a6fab99a3b3c84d4e05b19">kIterSkipSiblings</a> = 0x0002UL }</td></tr><tr class="separator:aa5e3854d58e5cc37a85306cc9e3aa460"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a13bdfa1056e63a85f11df7efe21c2a90"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a13bdfa1056e63a85f11df7efe21c2a90">Package</a> (const bool16 &amp;package=kTrue)=0</td></tr><tr class="separator:a13bdfa1056e63a85f11df7efe21c2a90"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3caf673f04810761ae1a1f305321b360"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a3caf673f04810761ae1a1f305321b360">IsPackaged</a> () const =0</td></tr><tr class="separator:a3caf673f04810761ae1a1f305321b360"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a369e56b70a26450421e4aa39ff0e0956"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a369e56b70a26450421e4aa39ff0e0956">AllowInPlaceModification</a> (const bool16 &amp;inPlaceModification=kTrue)=0</td></tr><tr class="separator:a369e56b70a26450421e4aa39ff0e0956"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af04f8f3398d105de02deab360988cfd7"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#af04f8f3398d105de02deab360988cfd7">CanModifyInPlace</a> () const =0</td></tr><tr class="separator:af04f8f3398d105de02deab360988cfd7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a95e982a75a336c39eea45e0fe9d001df"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a95e982a75a336c39eea45e0fe9d001df">Expandable</a> (const bool16 &amp;expandable=kTrue)=0</td></tr><tr class="separator:a95e982a75a336c39eea45e0fe9d001df"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac11b4deb7b8ba73a17e66b7cbef918fa"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ac11b4deb7b8ba73a17e66b7cbef918fa">IsExpandable</a> () const =0</td></tr><tr class="separator:ac11b4deb7b8ba73a17e66b7cbef918fa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6eda7f20b735d0f1eed222a24db2e6a8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a6eda7f20b735d0f1eed222a24db2e6a8">LoadFromStream</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *stream, int32 numOfBytes=-1)=0</td></tr><tr class="separator:a6eda7f20b735d0f1eed222a24db2e6a8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4b6badcf0715078d8b839d9edd4a2c59"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a4b6badcf0715078d8b839d9edd4a2c59">SaveToStream</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *stream, const bool16 &amp;package=kTrue, const bool16 &amp;allowInPlaceModification=kTrue, const bool16 &amp;expandable=kTrue, const bool16 &amp;packetDisabled=kFalse) const =0</td></tr><tr class="separator:a4b6badcf0715078d8b839d9edd4a2c59"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a034b4b8b44f41a2d0167b4e31479a2f0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a034b4b8b44f41a2d0167b4e31479a2f0">AppendFromStream</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *stream, const bool16 replaceOld, const bool16 treatAllAsExternal=kFalse)=0</td></tr><tr class="separator:a034b4b8b44f41a2d0167b4e31479a2f0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af0625c94f562eb1a31929f3cb200a79e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#af0625c94f562eb1a31929f3cb200a79e">Enumerate</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;subPath, const <a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914">IMetaDataAccess::IteratorOptions</a> &amp;options=<a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914a643ffff065a4432d42feb4fabdda6893">IMetaDataAccess::kIterJustChildren</a>) const =0</td></tr><tr class="separator:af0625c94f562eb1a31929f3cb200a79e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae75b6e83c9314cf48ab02bbcc4391857"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ae75b6e83c9314cf48ab02bbcc4391857">Enumerate</a> () const =0</td></tr><tr class="separator:ae75b6e83c9314cf48ab02bbcc4391857"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3435a683a827133085f4b36a7b04ae48"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a3435a683a827133085f4b36a7b04ae48">Get</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *options=0) const =0</td></tr><tr class="separator:a3435a683a827133085f4b36a7b04ae48"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:add5b20af225b2d17a62a826b2825fd99"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#add5b20af225b2d17a62a826b2825fd99">Set</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> options=<a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a>)=0</td></tr><tr class="separator:add5b20af225b2d17a62a826b2825fd99"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad7f4ef27c1dc4c3a37de704f2837c7b5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ad7f4ef27c1dc4c3a37de704f2837c7b5">Remove</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path)=0</td></tr><tr class="separator:ad7f4ef27c1dc4c3a37de704f2837c7b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac8721a0db88c0b7b9937f6ccd1abf670"><td align="right" class="memItemLeft" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ac8721a0db88c0b7b9937f6ccd1abf670">Count</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path) const =0</td></tr><tr class="separator:ac8721a0db88c0b7b9937f6ccd1abf670"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad65951e44292b848a139988c49bc7321"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ad65951e44292b848a139988c49bc7321">PropertyExists</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path) const =0</td></tr><tr class="separator:ad65951e44292b848a139988c49bc7321"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9cc5c9fcbb9af37fff30c666786eab85"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a9cc5c9fcbb9af37fff30c666786eab85">AppendArrayItem</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;arrayName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, const MetaDataStructContainerType type, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> options=<a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a>)=0</td></tr><tr class="separator:a9cc5c9fcbb9af37fff30c666786eab85"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1277b6045aa16524101f5b15488d32ac"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a1277b6045aa16524101f5b15488d32ac">SetArrayItem</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;arrayName, int32 index, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> options=<a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a>)=0</td></tr><tr class="separator:a1277b6045aa16524101f5b15488d32ac"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a550bf52600b4c9abc7ad8fa7474c015e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a550bf52600b4c9abc7ad8fa7474c015e">GetArrayItem</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;arrayName, int32 index, <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *options=0) const =0</td></tr><tr class="separator:a550bf52600b4c9abc7ad8fa7474c015e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8679cd60352ea5818b92b7596bb48420"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a8679cd60352ea5818b92b7596bb48420">DeleteArrayItem</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;arrayName, int32 index)=0</td></tr><tr class="separator:a8679cd60352ea5818b92b7596bb48420"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8ff25aceb27ba76c68bffe1844a878ea"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a8ff25aceb27ba76c68bffe1844a878ea">SetStructField</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;structName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> options=<a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a>)=0</td></tr><tr class="separator:a8ff25aceb27ba76c68bffe1844a878ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae8415b5f07f680c4a786ecb54921c6ce"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ae8415b5f07f680c4a786ecb54921c6ce">GetStructField</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;structName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldName, <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *options=0) const =0</td></tr><tr class="separator:ae8415b5f07f680c4a786ecb54921c6ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a43dcf44ae2ff88f33febdfc80dedfd0e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a43dcf44ae2ff88f33febdfc80dedfd0e">DeleteStructField</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;structName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldName)=0</td></tr><tr class="separator:a43dcf44ae2ff88f33febdfc80dedfd0e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a975766764f6cb975b743c852914e5387"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a975766764f6cb975b743c852914e5387">SetLocalizedText</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;arrayName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;genericLang, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;specificLang, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> options=<a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a>)=0</td></tr><tr class="separator:a975766764f6cb975b743c852914e5387"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae806635ab1c9bd906257b9fd2026b80b"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ae806635ab1c9bd906257b9fd2026b80b">GetLocalizedText</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;arrayName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;genericLang, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;specificLang, <a class="el" href="class_p_m_string.html">PMString</a> &amp;actualLang, <a class="el" href="class_p_m_string.html">PMString</a> &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *options=0) const =0</td></tr><tr class="separator:ae806635ab1c9bd906257b9fd2026b80b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6869c9fac0c6ea8ca987ddd8c095b6d4"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a6869c9fac0c6ea8ca987ddd8c095b6d4">ComposeArrayItemPath</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;schemaNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;arrayName, int32 index, <a class="el" href="class_p_m_string.html">PMString</a> &amp;path) const =0</td></tr><tr class="separator:a6869c9fac0c6ea8ca987ddd8c095b6d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5e3a6a023f71f4b8283291d711ea9b9b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a5e3a6a023f71f4b8283291d711ea9b9b">ComposeStructFieldPath</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;schemaNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;structName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldName, <a class="el" href="class_p_m_string.html">PMString</a> &amp;path) const =0</td></tr><tr class="separator:a5e3a6a023f71f4b8283291d711ea9b9b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afc6203406d5fcffcf5ec28f0118b58f8"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#afc6203406d5fcffcf5ec28f0118b58f8">ComposeLangSelector</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;schemaNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;arrayName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;langName, <a class="el" href="class_p_m_string.html">PMString</a> &amp;path) const =0</td></tr><tr class="separator:afc6203406d5fcffcf5ec28f0118b58f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad27e93f376c2f0ba846afee9bf7451e2"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ad27e93f376c2f0ba846afee9bf7451e2">SetBoolean</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, const bool16 &amp;value)=0</td></tr><tr class="separator:ad27e93f376c2f0ba846afee9bf7451e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a06e8efdb02a18ac6ba78c04e3e3d03a4"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a06e8efdb02a18ac6ba78c04e3e3d03a4">GetBoolean</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, bool16 &amp;value) const =0</td></tr><tr class="separator:a06e8efdb02a18ac6ba78c04e3e3d03a4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abb6f2122ca63570f8e532a0b3a04dd24"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#abb6f2122ca63570f8e532a0b3a04dd24">SetDateTime</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, const XMP_DateTime &amp;value)=0</td></tr><tr class="separator:abb6f2122ca63570f8e532a0b3a04dd24"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a50d13154e5e276a825330edc34ac020e"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a50d13154e5e276a825330edc34ac020e">GetDateTime</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, XMP_DateTime &amp;value) const =0</td></tr><tr class="separator:a50d13154e5e276a825330edc34ac020e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a770b86b7337cb00b2ee5d1026b20f6fb"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a770b86b7337cb00b2ee5d1026b20f6fb">SetResourceRef</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, const <a class="el" href="classmetadata_1_1_resource_ref.html">metadata::ResourceRef</a> &amp;resource)=0</td></tr><tr class="separator:a770b86b7337cb00b2ee5d1026b20f6fb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aebfce636fee14cd2fc601388e8580559"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#aebfce636fee14cd2fc601388e8580559">GetResourceRef</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, <a class="el" href="classmetadata_1_1_resource_ref.html">metadata::ResourceRef</a> &amp;resource) const =0</td></tr><tr class="separator:aebfce636fee14cd2fc601388e8580559"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a994fae5beea8c3218fb15c5c10ce0af6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a994fae5beea8c3218fb15c5c10ce0af6">SetInstanceID</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;instanceID)=0</td></tr><tr class="separator:a994fae5beea8c3218fb15c5c10ce0af6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a81ba4303335c3e912d139ae18a4410a5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a81ba4303335c3e912d139ae18a4410a5">GetInstanceID</a> () const =0</td></tr><tr class="separator:a81ba4303335c3e912d139ae18a4410a5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a1b8581893790e368bfe671c1128089"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a1a1b8581893790e368bfe671c1128089">GenerateUniqueID</a> () const =0</td></tr><tr class="separator:a1a1b8581893790e368bfe671c1128089"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a192f550c27f8dad5837b5ce10397de37"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a192f550c27f8dad5837b5ce10397de37">RegisterNamespace</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;suggestedPrefix, <a class="el" href="class_p_m_string.html">PMString</a> &amp;registeredPrefix)=0</td></tr><tr class="separator:a192f550c27f8dad5837b5ce10397de37"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0c8774118bd962b5e3ec5b9427126167"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a0c8774118bd962b5e3ec5b9427126167">GetNamespacePrefix</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, <a class="el" href="class_p_m_string.html">PMString</a> &amp;prefix) const =0</td></tr><tr class="separator:a0c8774118bd962b5e3ec5b9427126167"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab9279639679ee2b0e021f24f25384977"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ab9279639679ee2b0e021f24f25384977">GetNamespace</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;prefix, <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns) const =0</td></tr><tr class="separator:ab9279639679ee2b0e021f24f25384977"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab414925743c62dd79a0b64d3e1c92bc3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ab414925743c62dd79a0b64d3e1c92bc3">DeleteNamespace</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns)=0</td></tr><tr class="separator:ab414925743c62dd79a0b64d3e1c92bc3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa3b2e3a56d64f4b8570f2d89664e5544"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#aa3b2e3a56d64f4b8570f2d89664e5544">ClearAllProperties</a> ()=0</td></tr><tr class="separator:aa3b2e3a56d64f4b8570f2d89664e5544"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa709c443298e849e8da39bf569937a92"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#aa709c443298e849e8da39bf569937a92">DuplicateSubtree</a> (<a class="el" href="class_p_m_string.html">PMString</a> const &amp;srcNS, <a class="el" href="class_p_m_string.html">PMString</a> const &amp;srcPath, <a class="el" href="class_p_m_string.html">PMString</a> const &amp;destNS, <a class="el" href="class_p_m_string.html">PMString</a> const &amp;destPath)=0</td></tr><tr class="separator:aa709c443298e849e8da39bf569937a92"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a050bc1a3604f3a6df6522cb5f88d098e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a050bc1a3604f3a6df6522cb5f88d098e"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>NewXMP</b> ()=0</td></tr><tr class="separator:a050bc1a3604f3a6df6522cb5f88d098e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9caeea1b9c7bed22b22d33c9420dc6ff"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9caeea1b9c7bed22b22d33c9420dc6ff"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PrepareForSave</b> (bool16 bIncludePantry=kFalse)=0</td></tr><tr class="separator:a9caeea1b9c7bed22b22d33c9420dc6ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abd9507fd526058ec387f200ab79fa6fa"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abd9507fd526058ec387f200ab79fa6fa"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoteChange</b> (<a class="el" href="class_p_m_string.html">PMString</a> const &amp;changeStr)=0</td></tr><tr class="separator:abd9507fd526058ec387f200ab79fa6fa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab27c63da1269e503df6a9270074ee99d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab27c63da1269e503df6a9270074ee99d"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoteMetaDataChanged</b> ()=0</td></tr><tr class="separator:ab27c63da1269e503df6a9270074ee99d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac17d959c3379d9703b62edf3ecf5f9b2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac17d959c3379d9703b62edf3ecf5f9b2"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>OpenXMP</b> ()=0</td></tr><tr class="separator:ac17d959c3379d9703b62edf3ecf5f9b2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aee659ffceb6f44590dc8dececdbc8c43"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aee659ffceb6f44590dc8dececdbc8c43"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>BranchXMP</b> ()=0</td></tr><tr class="separator:aee659ffceb6f44590dc8dececdbc8c43"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af2857a256b1bc23fbf37288b68b16e84"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af2857a256b1bc23fbf37288b68b16e84"></a> virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>XMPDocOpsReady</b> ()=0</td></tr><tr class="separator:af2857a256b1bc23fbf37288b68b16e84"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4f0093b2f1be7ada34c2424bebe9e610"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4f0093b2f1be7ada34c2424bebe9e610"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddIngredientXMP</b> (std::string *filepath, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_toPart, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_fromPart, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_linkForm, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_linkCategory, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_filePath, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_alternatePaths, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_fileModTime, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_placedXResolution, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_placedYResolution, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;in_placedResolutionUnit)=0</td></tr><tr class="separator:a4f0093b2f1be7ada34c2424bebe9e610"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0c79c1aad61ceaae940f82b89e199cbf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0c79c1aad61ceaae940f82b89e199cbf"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoveIngredientXMP</b> (int nth)=0</td></tr><tr class="separator:a0c79c1aad61ceaae940f82b89e199cbf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a392ffd400bde924a5b0a4a3d2ce81ffb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a392ffd400bde924a5b0a4a3d2ce81ffb"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClearIngredientsXMP</b> ()=0</td></tr><tr class="separator:a392ffd400bde924a5b0a4a3d2ce81ffb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac8928bd573b0daf17c462c3130660f1f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ac8928bd573b0daf17c462c3130660f1f">SetStructField</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;structName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldName, const std::string &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> options=<a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a>)=0</td></tr><tr class="separator:ac8928bd573b0daf17c462c3130660f1f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7b1d09a3e53f55f8c92562256a14e015"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a7b1d09a3e53f55f8c92562256a14e015">GetStructField</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;structName, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldNs, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;fieldName, std::string &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *options=0) const =0</td></tr><tr class="separator:a7b1d09a3e53f55f8c92562256a14e015"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae37bd9925a93604e806d5815a454abdb"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#ae37bd9925a93604e806d5815a454abdb">Set</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, const std::string &amp;value, const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> options=<a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a>)=0</td></tr><tr class="separator:ae37bd9925a93604e806d5815a454abdb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a150f22e0b350d1d5d4203ec822789265"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a150f22e0b350d1d5d4203ec822789265">Get</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;ns, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;path, std::string &amp;value, <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *options=0) const =0</td></tr><tr class="separator:a150f22e0b350d1d5d4203ec822789265"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a24a9bba379a2feb9b8816bb8446329e7"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_meta_data_access.html#a24a9bba379a2feb9b8816bb8446329e7">GenerateDocumentID</a> () const =0</td></tr><tr class="separator:a24a9bba379a2feb9b8816bb8446329e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>This interface is a low level API that encapsulates routines of the XMPToolkit. <dl class="section see"><dt>See Also<dd><a class="el" href="class_i_adobe_basic_job_meta_data.html">IAdobeBasicJobMetaData</a><dd><a class="el" href="class_i_adobe_core_meta_data.html">IAdobeCoreMetaData</a><dd><a class="el" href="class_i_adobe_media_mgmt_meta_data.html">IAdobeMediaMgmtMetaData</a><dd><a class="el" href="class_i_adobe_rights_mgmt_meta_data.html">IAdobeRightsMgmtMetaData</a></dl></div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a0c916944994acf6b18a26a9b42912914"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914">IMetaDataAccess::IteratorOptions</a></td></tr></table></div><div class="memdoc"><p>Iterator options <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a0c916944994acf6b18a26a9b42912914a643ffff065a4432d42feb4fabdda6893"></a>kIterJustChildren</em>&nbsp;</td><td class="fielddoc"><p>Iterate only children </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a0c916944994acf6b18a26a9b42912914af43764386d1e0c797e3eb46b8e8b4dae"></a>kIterJustLeafNodes</em>&nbsp;</td><td class="fielddoc"><p>Iterate only leaf nodes </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a0c916944994acf6b18a26a9b42912914af56a8bfa3188e6c4d4611ab3a5783d8c"></a>kIterJustLeafName</em>&nbsp;</td><td class="fielddoc"><p>Iterate only leaf names </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a0c916944994acf6b18a26a9b42912914a66cfd18e54122d2aecef8493780c6205"></a>kIterOmitQualifiers</em>&nbsp;</td><td class="fielddoc"><p>Iterate omitting qualifiers </td></tr></table></div></div><a class="anchor" id="aa5e3854d58e5cc37a85306cc9e3aa460"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_meta_data_access.html#aa5e3854d58e5cc37a85306cc9e3aa460">IMetaDataAccess::SkipOptions</a></td></tr></table></div><div class="memdoc"><p>Skip options. These are used by <a class="el" href="class_i_meta_data_iterator.html#a4a264efa8aeb2dcc0cc7e736f590016b">IMetaDataIterator::Skip</a> method <dl class="section see"><dt>See Also<dd><a class="el" href="class_i_meta_data_iterator.html#a4a264efa8aeb2dcc0cc7e736f590016b">IMetaDataIterator::Skip</a></dl><table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa5e3854d58e5cc37a85306cc9e3aa460ab2cd07599412b32bf291c878a19a51b7"></a>kIterSkipSubtree</em>&nbsp;</td><td class="fielddoc"><p>Skip the subtree below the current node </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aa5e3854d58e5cc37a85306cc9e3aa460a6da55cbb45a6fab99a3b3c84d4e05b19"></a>kIterSkipSiblings</em>&nbsp;</td><td class="fielddoc"><p>Skip the subtree below and remaining siblings of the current node. </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a369e56b70a26450421e4aa39ff0e0956"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::AllowInPlaceModification </td><td>(</td><td class="paramtype">const bool16 &amp;&nbsp;</td><td class="paramname"><em>inPlaceModification</em> = <code>kTrue</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the MetaData block&#39;s in place modification attribute. If in place modification is allowed it means that external software can modify the MetaData block. Next time the publication is opened we will keep changes made externally to any external property. The MetaData package mechanism will also indicate that this block can be modified in place. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">inPlaceModification</td><td>IN The in place modification attribute. </td></tr></table></dl></div></div><a class="anchor" id="a9cc5c9fcbb9af37fff30c666786eab85"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::AppendArrayItem </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>arrayName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const MetaDataStructContainerType&nbsp;</td><td class="paramname"><em>type</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a>&nbsp;</td><td class="paramname"><em>options</em> = <code><a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Array item access Append a new item to an array. The array will be automatically created if it doesn&#39;t exist. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the array. Must not be an empty string. </td></tr><tr><td class="paramname">arrayName</td><td>IN The name of the array. </td></tr><tr><td class="paramname">value</td><td>IN The value of the array item. </td></tr><tr><td class="paramname">type</td><td>IN The type of the array. </td></tr><tr><td class="paramname">options</td><td>IN Bit flags that describe the array item. Default to <a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a> if the flags are not needed. </td></tr></table></dl></div></div><a class="anchor" id="a034b4b8b44f41a2d0167b4e31479a2f0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::AppendFromStream </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"><em>stream</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>replaceOld</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16&nbsp;</td><td class="paramname"><em>treatAllAsExternal</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Appends external properties from the stream. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">stream</td><td>IN The stream that contains the metadata (in UTF8 format) to be appended. </td></tr><tr><td class="paramname">replaceOld</td><td>IN If kFalse, a property that exists in current metadata will not be replace by the same property in the stream. </td></tr><tr><td class="paramname">treatAllAsExternal</td><td>IN Optional. If kTrue, all properties are treated as external. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if succeeded. kFalse otherwise. </dl></div></div><a class="anchor" id="af04f8f3398d105de02deab360988cfd7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::CanModifyInPlace </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query the MetaData block&#39;s in place modification attribute. <dl class="section return"><dt>Returns<dd>kTrue if this MetaData block allows in place modification. kFalse otherwise. </dl></div></div><a class="anchor" id="aa3b2e3a56d64f4b8570f2d89664e5544"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::ClearAllProperties </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Some other useful methods. Set the MetaData block back to being empty. </div></div><a class="anchor" id="a6869c9fac0c6ea8ca987ddd8c095b6d4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::ComposeArrayItemPath </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>schemaNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>arrayName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>index</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>XPath composition utilities Compose the XPath expression for an item in an array. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">schemaNs</td><td>IN The namespace of the stream. Must not be empty. </td></tr><tr><td class="paramname">arrayName</td><td>IN The name of the array. Must not be empty. May be a general XPath expression. </td></tr><tr><td class="paramname">index</td><td>IN The index of the array item. Arrays in XMP are indexed from 1. Use <a class="el" href="namespacemetadata.html#ab8095791f3e897426345191c066bb228a2709e3ea073646b64dd7866f1a046880">metadata::kArrayLastItem</a> for the last item in the array. </td></tr><tr><td class="paramname">path</td><td>OUT The composed path. This will be of the from &quot;arrayName/ *[i]&quot;. If index is <a class="el" href="namespacemetadata.html#ab8095791f3e897426345191c066bb228a2709e3ea073646b64dd7866f1a046880">metadata::kArrayLastItem</a>, the path will be &quot;arrayName/ *[last()]&quot;. </td></tr></table></dl></div></div><a class="anchor" id="afc6203406d5fcffcf5ec28f0118b58f8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::ComposeLangSelector </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>schemaNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>arrayName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>langName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Compose the XPath expression for a qualifier. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">schemaNs</td><td>IN The namespace of the stream. Must not be empty. </td></tr><tr><td class="paramname">arrayName</td><td>IN The name of the array. Must not be empty. May be a general XPath expression. </td></tr><tr><td class="paramname">langName</td><td>IN The name of the language. Must not be empty. </td></tr><tr><td class="paramname">path</td><td>OUT The composed path. This will be of the from &quot;arrayName/ *[@xml:lang=&#39;langName&#39;]&quot;. </td></tr></table></dl></div></div><a class="anchor" id="a5e3a6a023f71f4b8283291d711ea9b9b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::ComposeStructFieldPath </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>schemaNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>structName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Compose the XPath expression for a field in a struct. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">schemaNs</td><td>IN The namespace of the stream. Must not be empty. </td></tr><tr><td class="paramname">structName</td><td>IN The name of the struct. Must not be empty. May be a general XPath expression. </td></tr><tr><td class="paramname">fieldNs</td><td>IN The namespace of the field. May be empty. </td></tr><tr><td class="paramname">fieldName</td><td>IN The name of the field. Must not be empty. </td></tr><tr><td class="paramname">path</td><td>OUT The composed path. This will be of the from &quot;structName\fNS:fieldName&quot;, where &quot;fNS is the prefix for fieldNs. </td></tr></table></dl></div></div><a class="anchor" id="ac8721a0db88c0b7b9937f6ccd1abf670"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual size_t IMetaDataAccess::Count </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the number of items in the structured container specified by ns and path. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Number of items in the container. </dl></div></div><a class="anchor" id="a8679cd60352ea5818b92b7596bb48420"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::DeleteArrayItem </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>arrayName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>index</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete an array item. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the array. Must not be an empty string. </td></tr><tr><td class="paramname">arrayName</td><td>IN The name of the array. </td></tr><tr><td class="paramname">index</td><td>IN The index of the array item. Arrays are indexed from 1. Use <a class="el" href="namespacemetadata.html#ab8095791f3e897426345191c066bb228a2709e3ea073646b64dd7866f1a046880">metadata::kArrayLastItem</a> for the last item in the array. </td></tr></table></dl></div></div><a class="anchor" id="ab414925743c62dd79a0b64d3e1c92bc3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::DeleteNamespace </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete a namespace. Does nothing if the namespace is not registered. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The <a class="el" href="class_u_r_i.html">URI</a> of the namespace. </td></tr></table></dl></div></div><a class="anchor" id="a43dcf44ae2ff88f33febdfc80dedfd0e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::DeleteStructField </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>structName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldName</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Delete a field within a structure. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the structure. Must not be an empty string. </td></tr><tr><td class="paramname">structName</td><td>IN The name of the structure. </td></tr><tr><td class="paramname">fieldNs</td><td>IN The namespace of the field. Maybe be an empty string. </td></tr><tr><td class="paramname">fieldName</td><td>IN The name of the field. </td></tr></table></dl></div></div><a class="anchor" id="aa709c443298e849e8da39bf569937a92"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::DuplicateSubtree </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> const &amp;&nbsp;</td><td class="paramname"><em>srcNS</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> const &amp;&nbsp;</td><td class="paramname"><em>srcPath</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> const &amp;&nbsp;</td><td class="paramname"><em>destNS</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> const &amp;&nbsp;</td><td class="paramname"><em>destPath</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Duplicates a subtree in the metadata block.<p>Note: As written, this utility does not perform any merging between the source and destination subtrees. If the destination subtree exists, it will be deleted before the subtree is duplicated.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">srcNS</td><td>IN The namespace for the source subtree </td></tr><tr><td class="paramname">srcPath</td><td>IN The path for the source subtree </td></tr><tr><td class="paramname">destNS</td><td>IN The namespace for the destination subtree </td></tr><tr><td class="paramname">destPath</td><td>IN The path for the destination subtree </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the subtree was successfully duplicated, else kFalse </dl></div></div><a class="anchor" id="af0625c94f562eb1a31929f3cb200a79e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a>* IMetaDataAccess::Enumerate </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>subPath</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914">IMetaDataAccess::IteratorOptions</a> &amp;&nbsp;</td><td class="paramname"><em>options</em> = <code><a class="el" href="class_i_meta_data_access.html#a0c916944994acf6b18a26a9b42912914a643ffff065a4432d42feb4fabdda6893">IMetaDataAccess::kIterJustChildren</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Wrappers on the XMPToolkit library Return an <a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a> interface which must be released by the caller. <a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a> enables one to iterate all the paths in this MetaData block. <dl class="section see"><dt>See Also<dd><a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace to enumerate. </td></tr><tr><td class="paramname">subPath</td><td>IN Specifies the scope of the enumeration. </td></tr><tr><td class="paramname">options</td><td>IN The available option flags are: kXMP_IterJustChildren - Just visit the immediate children of the root, default is subtree. kXMP_IterJustLeafNodes - Just visit the leaf nodes, default visits all nodes. kXMP_IterJustLeafName - Return just the leaf part of the path, default is the full path. kXMP_IterOmitQualifiers - Omit all qualifiers.</td></tr></table></dl><dl class="section return"><dt>Returns<dd>An interface which iterates properties of the specified subPath. Must be released by the caller. </dl></div></div><a class="anchor" id="ae75b6e83c9314cf48ab02bbcc4391857"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a>* IMetaDataAccess::Enumerate </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return an <a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a> interface which must be released by the caller. <a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a> enables one to iterate all the paths in this MetaData block. <dl class="section see"><dt>See Also<dd><a class="el" href="class_i_meta_data_iterator.html">IMetaDataIterator</a></dl><dl class="section return"><dt>Returns<dd>An interface which iterates properties of all paths. Must be released by the caller. </dl></div></div><a class="anchor" id="a95e982a75a336c39eea45e0fe9d001df"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::Expandable </td><td>(</td><td class="paramtype">const bool16 &amp;&nbsp;</td><td class="paramname"><em>expandable</em> = <code>kTrue</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the MetaData block&#39;s expandable attribute. If expandable is kTrue then when the package is written out pad bytes will be included so that external entities can add MetaData properties to the packet. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">expandable</td><td>IN The expandable attribute. </td></tr></table></dl></div></div><a class="anchor" id="a24a9bba379a2feb9b8816bb8446329e7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IMetaDataAccess::GenerateDocumentID </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Generate a document ID. <dl class="section return"><dt>Returns<dd>the ID. </dl></div></div><a class="anchor" id="a1a1b8581893790e368bfe671c1128089"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IMetaDataAccess::GenerateUniqueID </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Generate a unique ID. <dl class="section return"><dt>Returns<dd>the ID. </dl></div></div><a class="anchor" id="a3435a683a827133085f4b36a7b04ae48"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::Get </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *&nbsp;</td><td class="paramname"><em>options</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>General property access Get the value at the property specified by ns and path. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property.. </td></tr><tr><td class="paramname">value</td><td>OUT The value of the property. </td></tr><tr><td class="paramname">options</td><td>OUT Bit flags that describe the property. Default to 0 if the flags are not wanted. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse if any node along the path doesn&#39;t exist. kTrue otherwise. </dl></div></div><a class="anchor" id="a150f22e0b350d1d5d4203ec822789265"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::Get </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">std::string &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *&nbsp;</td><td class="paramname"><em>options</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>General property access Get the value at the property specified by ns and path. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property.. </td></tr><tr><td class="paramname">value</td><td>OUT The value of the property. </td></tr><tr><td class="paramname">options</td><td>OUT Bit flags that describe the property. Default to 0 if the flags are not wanted. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse if any node along the path doesn&#39;t exist. kTrue otherwise. </dl></div></div><a class="anchor" id="a550bf52600b4c9abc7ad8fa7474c015e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetArrayItem </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>arrayName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>index</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *&nbsp;</td><td class="paramname"><em>options</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the value of an array item. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the array. Must not be an empty string. </td></tr><tr><td class="paramname">arrayName</td><td>IN The name of the array. </td></tr><tr><td class="paramname">index</td><td>IN The index of the array item. Arrays are indexed from 1. Use <a class="el" href="namespacemetadata.html#ab8095791f3e897426345191c066bb228a2709e3ea073646b64dd7866f1a046880">metadata::kArrayLastItem</a> for the last item in the array. </td></tr><tr><td class="paramname">value</td><td>OUT The value of the array item. </td></tr><tr><td class="paramname">options</td><td>OUT Bit flags that describe the array item. Default to 0 if the flags are not wanted. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse if the array item doesn&#39;t exist. kTrue otherwise. </dl></div></div><a class="anchor" id="a06e8efdb02a18ac6ba78c04e3e3d03a4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetBoolean </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 &amp;&nbsp;</td><td class="paramname"><em>value</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the boolean value of the specified property. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr><tr><td class="paramname">value</td><td>OUT The value of the property. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the property is found, kFalse otherwise. </dl></div></div><a class="anchor" id="a50d13154e5e276a825330edc34ac020e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetDateTime </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">XMP_DateTime &amp;&nbsp;</td><td class="paramname"><em>value</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the DateTime value of the specified property. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr><tr><td class="paramname">value</td><td>OUT The value of the property. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the property is found, kFalse otherwise. </dl></div></div><a class="anchor" id="a81ba4303335c3e912d139ae18a4410a5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IMetaDataAccess::GetInstanceID </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the instance ID of the document. <dl class="section return"><dt>Returns<dd>the instance ID. </dl></div></div><a class="anchor" id="ae806635ab1c9bd906257b9fd2026b80b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetLocalizedText </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>arrayName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>genericLang</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>specificLang</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>actualLang</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *&nbsp;</td><td class="paramname"><em>options</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the value of an item within an alt-text array. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the structure. Must not be an empty string. </td></tr><tr><td class="paramname">arrayName</td><td>IN The name of the structure. May be a general XPath expression. Must not be empty. </td></tr><tr><td class="paramname">genericLang</td><td>IN The name of the generic language as an RFC 1766 string. May be an empty string if no generic language is wanted </td></tr><tr><td class="paramname">specificLang</td><td>IN The name of the specific language as an RFC 1766 string. Must not be empty. Maybe &quot;x-default&quot;. </td></tr><tr><td class="paramname">actualLang</td><td>OUT The language of the selected array item, if an appropriate array item is found. </td></tr><tr><td class="paramname">value</td><td>OUT The value of the field. </td></tr><tr><td class="paramname">options</td><td>OUT Bit flags that describe the property. Default to 0 if the flags are not wanted. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse if any node along the path doesn&#39;t exist. kTrue otherwise. </dl></div></div><a class="anchor" id="ab9279639679ee2b0e021f24f25384977"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetNamespace </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>prefix</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the <a class="el" href="class_u_r_i.html">URI</a> of a registered namespacename. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">prefix</td><td>IN The prefix of the namespace. </td></tr><tr><td class="paramname">ns</td><td>OUT The <a class="el" href="class_u_r_i.html">URI</a> of the namespace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the namespace is registered. kFalse otherwise. </dl></div></div><a class="anchor" id="a0c8774118bd962b5e3ec5b9427126167"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetNamespacePrefix </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>prefix</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the prefix of a registered namespacename. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The <a class="el" href="class_u_r_i.html">URI</a> of the namespace. </td></tr><tr><td class="paramname">prefix</td><td>OUT The prefix of the namespace. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the namespace is registered. kFalse otherwise. </dl></div></div><a class="anchor" id="aebfce636fee14cd2fc601388e8580559"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetResourceRef </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="classmetadata_1_1_resource_ref.html">metadata::ResourceRef</a> &amp;&nbsp;</td><td class="paramname"><em>resource</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get ResourceRef specified by ns and path. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property.. </td></tr><tr><td class="paramname">resource</td><td>OUT The value of the property. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse if any node along the path doesn&#39;t exist. kTrue otherwise. </dl></div></div><a class="anchor" id="ae8415b5f07f680c4a786ecb54921c6ce"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetStructField </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>structName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *&nbsp;</td><td class="paramname"><em>options</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a field within a structure. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the structure. Must not be an empty string. </td></tr><tr><td class="paramname">structName</td><td>IN The name of the structure. </td></tr><tr><td class="paramname">fieldNs</td><td>IN The namespace of the field. Maybe be an empty string. </td></tr><tr><td class="paramname">fieldName</td><td>IN The name of the field. </td></tr><tr><td class="paramname">value</td><td>OUT The value of the field. </td></tr><tr><td class="paramname">options</td><td>OUT Bit flags that describe the property. Default to 0 if the flags are not wanted. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse if any node along the path doesn&#39;t exist. kTrue otherwise. </dl></div></div><a class="anchor" id="a7b1d09a3e53f55f8c92562256a14e015"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::GetStructField </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>structName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">std::string &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a> *&nbsp;</td><td class="paramname"><em>options</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a field within a structure. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the structure. Must not be an empty string. </td></tr><tr><td class="paramname">structName</td><td>IN The name of the structure. </td></tr><tr><td class="paramname">fieldNs</td><td>IN The namespace of the field. Maybe be an empty string. </td></tr><tr><td class="paramname">fieldName</td><td>IN The name of the field. </td></tr><tr><td class="paramname">value</td><td>OUT The value of the field. </td></tr><tr><td class="paramname">options</td><td>OUT Bit flags that describe the property. Default to 0 if the flags are not wanted. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse if any node along the path doesn&#39;t exist. kTrue otherwise. </dl></div></div><a class="anchor" id="ac11b4deb7b8ba73a17e66b7cbef918fa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::IsExpandable </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query the MetaData block&#39;s expandable attribute. <dl class="section return"><dt>Returns<dd>kTrue if this MetaData block is expandable. kFalse otherwise. </dl></div></div><a class="anchor" id="a3caf673f04810761ae1a1f305321b360"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::IsPackaged </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query the MetaData block&#39;s packaged attribute. <dl class="section return"><dt>Returns<dd>kTrue if this MetaData block is packaged. kFalse otherwise. </dl></div></div><a class="anchor" id="a6eda7f20b735d0f1eed222a24db2e6a8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::LoadFromStream </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"><em>stream</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>numOfBytes</em> = <code>-1</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Persistance operations Load this MetaData block from the given stream. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">stream</td><td>IN The stream that contains medadata (in UTF8 format). </td></tr><tr><td class="paramname">numOfBytes</td><td>IN Length of the metadata block. Pass -1 if the length is unknown. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if succeeded. kFalse otherwise. </dl></div></div><a class="anchor" id="a13bdfa1056e63a85f11df7efe21c2a90"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::Package </td><td>(</td><td class="paramtype">const bool16 &amp;&nbsp;</td><td class="paramname"><em>package</em> = <code>kTrue</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>MetaData attributes Set the MetaData block&#39;s packaged attribute. If packaged is kTrue then whenever this MetaData block is saved to a stream it will be packaged in a MetaData package. In addition when the data for this interface is saved to the database, if packaged is kTrue then the data will be streamed to the contiguous block section of the database, otherwise it will be written into a regular database stream. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">package</td><td>IN The packaged attribute. </td></tr></table></dl></div></div><a class="anchor" id="ad65951e44292b848a139988c49bc7321"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::PropertyExists </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Check if a property exists. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the property exists, kFalse otherwise. </dl></div></div><a class="anchor" id="a192f550c27f8dad5837b5ce10397de37"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::RegisterNamespace </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>suggestedPrefix</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>registeredPrefix</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Namespaces Register a namespacename (which should be a <a class="el" href="class_u_r_i.html">URI</a>) and a suggested prefix for composing qualified names. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace to be registered. </td></tr><tr><td class="paramname">suggestedPrefix</td><td>IN The suggested prefix to be used if the <a class="el" href="class_u_r_i.html">URI</a> is not yet registered. Must be a valid XML name. </td></tr><tr><td class="paramname">registeredPrefix</td><td>OUT The prefix actually registered for this <a class="el" href="class_u_r_i.html">URI</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the registered prefix matches the suggested prefix. kFalse otherwise. </dl></div></div><a class="anchor" id="ad7f4ef27c1dc4c3a37de704f2837c7b5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::Remove </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Remove the specifed property and all of its sub-properties. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr></table></dl></div></div><a class="anchor" id="a4b6badcf0715078d8b839d9edd4a2c59"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IMetaDataAccess::SaveToStream </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"><em>stream</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16 &amp;&nbsp;</td><td class="paramname"><em>package</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16 &amp;&nbsp;</td><td class="paramname"><em>allowInPlaceModification</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16 &amp;&nbsp;</td><td class="paramname"><em>expandable</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16 &amp;&nbsp;</td><td class="paramname"><em>packetDisabled</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Save this MetaData block to the given stream. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">stream</td><td>IN The stream where the metadata will be written. The data will be in UTF8 format. </td></tr><tr><td class="paramname">package</td><td>IN If kTrue, the MetaData block is streamed out in a MetaData package. </td></tr><tr><td class="paramname">allowInPlaceModification</td><td>IN If kTrue, the writable attribute in the package header is set. </td></tr><tr><td class="paramname">expandable</td><td>IN if kTrue, padding is added. </td></tr><tr><td class="paramname">packetDisabled</td><td>IN If kTrue, a disabled packet id is generated instead of the standard one. This is used internally. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if succeeded. kFalse otherwise. </dl></div></div><a class="anchor" id="add5b20af225b2d17a62a826b2825fd99"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::Set </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a>&nbsp;</td><td class="paramname"><em>options</em> = <code><a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the specified value at the end of the specified path, with the optionally specified features. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr><tr><td class="paramname">value</td><td>IN The value of the property. </td></tr><tr><td class="paramname">options</td><td>IN Bit flags that describe the property. Default to <a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a> if the flags are not needed. </td></tr></table></dl></div></div><a class="anchor" id="ae37bd9925a93604e806d5815a454abdb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::Set </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const std::string &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a>&nbsp;</td><td class="paramname"><em>options</em> = <code><a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the specified value at the end of the specified path, with the optionally specified features. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr><tr><td class="paramname">value</td><td>IN The value of the property. </td></tr><tr><td class="paramname">options</td><td>IN Bit flags that describe the property. Default to <a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a> if the flags are not needed. </td></tr></table></dl></div></div><a class="anchor" id="a1277b6045aa16524101f5b15488d32ac"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::SetArrayItem </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>arrayName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>index</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a>&nbsp;</td><td class="paramname"><em>options</em> = <code><a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Modify an array item. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the array. Must not be an empty string. </td></tr><tr><td class="paramname">arrayName</td><td>IN The name of the array. </td></tr><tr><td class="paramname">index</td><td>IN The index of the array item. Arrays are indexed from 1. Use <a class="el" href="namespacemetadata.html#ab8095791f3e897426345191c066bb228a2709e3ea073646b64dd7866f1a046880">metadata::kArrayLastItem</a> for the last item in the array. </td></tr><tr><td class="paramname">value</td><td>IN The value of the array item. </td></tr><tr><td class="paramname">options</td><td>IN Bit flags that describe the array item. Default to <a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a> if the flags are not needed. </td></tr></table></dl></div></div><a class="anchor" id="ad27e93f376c2f0ba846afee9bf7451e2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::SetBoolean </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const bool16 &amp;&nbsp;</td><td class="paramname"><em>value</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The following set and get properties from common data types. Set the boolean value of the specified property. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr><tr><td class="paramname">value</td><td>IN The value of the property. </td></tr></table></dl></div></div><a class="anchor" id="abb6f2122ca63570f8e532a0b3a04dd24"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::SetDateTime </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const XMP_DateTime &amp;&nbsp;</td><td class="paramname"><em>value</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the DateTime value of the specified property. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the property. </td></tr><tr><td class="paramname">path</td><td>IN The path of the property. </td></tr><tr><td class="paramname">value</td><td>IN The value of the property. </td></tr></table></dl></div></div><a class="anchor" id="a994fae5beea8c3218fb15c5c10ce0af6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::SetInstanceID </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>instanceID</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the instance ID of the document. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">instanceID</td><td>IN The instance ID. </td></tr></table></dl></div></div><a class="anchor" id="a975766764f6cb975b743c852914e5387"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::SetLocalizedText </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>arrayName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>genericLang</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>specificLang</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a>&nbsp;</td><td class="paramname"><em>options</em> = <code><a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Localized text in alt-text array Set the value of an item within an alt-text array. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the structure. Must not be an empty string. </td></tr><tr><td class="paramname">arrayName</td><td>IN The name of the structure. May be a general XPath expression. Must not be empty. </td></tr><tr><td class="paramname">genericLang</td><td>IN The name of the generic language as an RFC 1766 string. May be an empty string if no generic language is wanted </td></tr><tr><td class="paramname">specificLang</td><td>IN The name of the specific language as an RFC 1766 string. Must not be empty. Maybe &quot;x-default&quot;. </td></tr><tr><td class="paramname">value</td><td>IN The value of the item. </td></tr><tr><td class="paramname">options</td><td>IN Bit flags that describe the property. Default to <a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a> if the flags are not needed. </td></tr></table></dl></div></div><a class="anchor" id="a770b86b7337cb00b2ee5d1026b20f6fb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::SetResourceRef </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>path</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="classmetadata_1_1_resource_ref.html">metadata::ResourceRef</a> &amp;&nbsp;</td><td class="paramname"><em>resource</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the specified ResourceRef at the end of the specified path, with the optionally specified features. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the properties. </td></tr><tr><td class="paramname">path</td><td>IN The path of the properties. </td></tr><tr><td class="paramname">resource</td><td>IN The ResourceRef to be set. </td></tr></table></dl></div></div><a class="anchor" id="a8ff25aceb27ba76c68bffe1844a878ea"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::SetStructField </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>structName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a>&nbsp;</td><td class="paramname"><em>options</em> = <code><a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Structure field access Set a field within a structure. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the structure. Must not be an empty string. </td></tr><tr><td class="paramname">structName</td><td>IN The name of the structure. </td></tr><tr><td class="paramname">fieldNs</td><td>IN The namespace of the field. Maybe be an empty string. </td></tr><tr><td class="paramname">fieldName</td><td>IN The name of the field. </td></tr><tr><td class="paramname">value</td><td>IN The value of the field. </td></tr><tr><td class="paramname">options</td><td>IN Bit flags that describe the property. Default to <a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a> if the flags are not needed. </td></tr></table></dl></div></div><a class="anchor" id="ac8928bd573b0daf17c462c3130660f1f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IMetaDataAccess::SetStructField </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>ns</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>structName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldNs</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>fieldName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const std::string &amp;&nbsp;</td><td class="paramname"><em>value</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="namespacemetadata.html#a832ede4f5de6c115c0f02f9fbe6ec882">metadata::PropertyOptions</a>&nbsp;</td><td class="paramname"><em>options</em> = <code><a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Structure field access Set a field within a structure. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ns</td><td>IN The namespace of the structure. Must not be an empty string. </td></tr><tr><td class="paramname">structName</td><td>IN The name of the structure. </td></tr><tr><td class="paramname">fieldNs</td><td>IN The namespace of the field. Maybe be an empty string. </td></tr><tr><td class="paramname">fieldName</td><td>IN The name of the field. </td></tr><tr><td class="paramname">value</td><td>IN The value of the field. </td></tr><tr><td class="paramname">options</td><td>IN Bit flags that describe the property. Default to <a class="el" href="namespacemetadata.html#af4a9223cd69bc0cb9ecc414883228e6cac0a631473e90e8d97cee57a8018e7cb5">metadata::kNoOptions</a> if the flags are not needed. </td></tr></table></dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_meta_data_access.html">IMetaDataAccess</a><li class="footer">Generated on Sat Sep 22 2018 10:54:20 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
