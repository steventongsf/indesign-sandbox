<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_image_cache_mgr</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_image_cache_mgr.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_image_cache_mgr-members.html">List of all members</a></div><div class="headertitle"><div class="title">IImageCacheMgr Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_image_cache_mgr_8h_source.html">IImageCacheMgr.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IImageCacheMgr:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_image_cache_mgr.png" usemap="#IImageCacheMgr_map" /><map id="IImageCacheMgr_map" name="IImageCacheMgr_map"><area alt="IPMUnknown" coords="0,0,108,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a1a329bf71924493126ccce552280205e"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IIMAGECACHEMGR }</td></tr><tr class="separator:a1a329bf71924493126ccce552280205e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1f86d6ce9da89e8a005da5da0f9851f8"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br /> &nbsp;&nbsp;<b>kWildCard</b> = 0, <b>kRasterImage</b> = 1, <b>kAlphaMask</b> = 2, <b>kLinkThumbnail</b> = 4, <br /> &nbsp;&nbsp;<b>kUncalibratedRasterImage</b> = 5, <b>kXP_DSH_PI</b> = 10, <b>kXP_DSH_ST</b> = 11, <b>kXP_DSH_FI</b> = 12, <br /> &nbsp;&nbsp;<b>kXP_DSH_CT</b> = 13, <b>kXP_ISH_PI</b> = 14, <b>kXP_ISH_ST</b> = 15, <b>kXP_ISH_FI</b> = 16, <br /> &nbsp;&nbsp;<b>kXP_ISH_CT</b> = 17, <b>kXP_OGL_PI</b> = 18, <b>kXP_OGL_ST</b> = 19, <b>kXP_OGL_FI</b> = 20, <br /> &nbsp;&nbsp;<b>kXP_OGL_CT</b> = 21, <b>kXP_IGL_PI</b> = 22, <b>kXP_IGL_ST</b> = 23, <b>kXP_IGL_FI</b> = 24, <br /> &nbsp;&nbsp;<b>kXP_IGL_CT</b> = 25, <b>kXP_BE1_PI</b> = 26, <b>kXP_BE1_ST</b> = 27, <b>kXP_BE1_FI</b> = 28, <br /> &nbsp;&nbsp;<b>kXP_BE1_CT</b> = 29, <b>kXP_BE2_PI</b> = 30, <b>kXP_BE2_ST</b> = 31, <b>kXP_BE2_FI</b> = 32, <br /> &nbsp;&nbsp;<b>kXP_BE2_CT</b> = 33, <b>kXP_BE3_PI</b> = 34, <b>kXP_BE3_ST</b> = 35, <b>kXP_BE3_FI</b> = 36, <br /> &nbsp;&nbsp;<b>kXP_BE3_CT</b> = 37, <b>kXP_BE4_PI</b> = 38, <b>kXP_BE4_ST</b> = 39, <b>kXP_BE4_FI</b> = 40, <br /> &nbsp;&nbsp;<b>kXP_BE4_CT</b> = 41, <b>kXP_SAT_PI</b> = 42, <b>kXP_SAT_ST</b> = 43, <b>kXP_SAT_FI</b> = 44, <br /> &nbsp;&nbsp;<b>kXP_SAT_CT</b> = 45, <b>kXP_FTH_PI</b> = 46, <b>kXP_FTH_ST</b> = 47, <b>kXP_FTH_FI</b> = 48, <br /> &nbsp;&nbsp;<b>kXP_FTH_CT</b> = 49, <b>kXP_DRF_PI</b> = 50, <b>kXP_DRF_ST</b> = 51, <b>kXP_DRF_FI</b> = 52, <br /> &nbsp;&nbsp;<b>kXP_DRF_CT</b> = 53, <b>kXP_GRF_PI</b> = 54, <b>kXP_GRF_ST</b> = 55, <b>kXP_GRF_FI</b> = 56, <br /> &nbsp;&nbsp;<b>kXP_GRF_CT</b> = 57 <br /> }</td></tr><tr class="separator:a1f86d6ce9da89e8a005da5da0f9851f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a9ba045d0d4f2a7bbcd4e06c0b83ad0f3"><td align="right" class="memItemLeft" valign="top">virtual ErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#a9ba045d0d4f2a7bbcd4e06c0b83ad0f3">Add</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, <a class="el" href="class_i_image_cache.html">IImageCache</a> *cache, bool8 purgeFirst=kFalse, uint32 selector=kRasterImage)=0</td></tr><tr class="separator:a9ba045d0d4f2a7bbcd4e06c0b83ad0f3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a41a1027dcb13883076c6bb5f6c876b05"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#a41a1027dcb13883076c6bb5f6c876b05">Purge</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, <a class="el" href="class_i_image_cache.html">IImageCache</a> *cache)=0</td></tr><tr class="separator:a41a1027dcb13883076c6bb5f6c876b05"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af4b328fca11618923a1af6b829a59fe4"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#af4b328fca11618923a1af6b829a59fe4">Purge</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;resolution, uint32 selector=kWildCard)=0</td></tr><tr class="separator:af4b328fca11618923a1af6b829a59fe4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad42bdcbd8c90085f04e7b3793c8e1ffb"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#ad42bdcbd8c90085f04e7b3793c8e1ffb">Purge</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, uint32 selector=kWildCard)=0</td></tr><tr class="separator:ad42bdcbd8c90085f04e7b3793c8e1ffb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afa236aae32c6dcc6367f0754080e99f7"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#afa236aae32c6dcc6367f0754080e99f7">Purge</a> (const <a class="el" href="class_i_data_base.html">IDataBase</a> *db, uint32 selector=kWildCard)=0</td></tr><tr class="separator:afa236aae32c6dcc6367f0754080e99f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2bc877b37770491e2dcb15e7c646192c"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#a2bc877b37770491e2dcb15e7c646192c">GetSize</a> (void) const =0</td></tr><tr class="separator:a2bc877b37770491e2dcb15e7c646192c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af030f36db423b2b2a3e42bbc1763f3f4"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#af030f36db423b2b2a3e42bbc1763f3f4">GetClosestMatchResolution</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;resolution, uint32 selector=kRasterImage, uint32 *selectorFound=nil) const =0</td></tr><tr class="separator:af030f36db423b2b2a3e42bbc1763f3f4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a220f62d53e1b1904a826c20ba33a214a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_image_cache.html">IImageCache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#a220f62d53e1b1904a826c20ba33a214a">QueryClosestResolution</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;resolution, uint32 selector=kRasterImage, uint32 *selectorFound=nil)=0</td></tr><tr class="separator:a220f62d53e1b1904a826c20ba33a214a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1edd53d1a2b4d3124e89d14c52826e0a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_image_cache.html">IImageCache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#a1edd53d1a2b4d3124e89d14c52826e0a">QueryPreviousResolution</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, const <a class="el" href="class_i_image_cache.html">IImageCache</a> &amp;currentCache, uint32 selector=kRasterImage, uint32 *selectorFound=nil)=0</td></tr><tr class="separator:a1edd53d1a2b4d3124e89d14c52826e0a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b5daddc863d78af42305b22cabe735d"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_image_cache.html">IImageCache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#a1b5daddc863d78af42305b22cabe735d">QueryNextResolution</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, const <a class="el" href="class_i_image_cache.html">IImageCache</a> &amp;currentCache, uint32 selector=kRasterImage, uint32 *selectorFound=nil)=0</td></tr><tr class="separator:a1b5daddc863d78af42305b22cabe735d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0675403738cdf6f017a091a973e1c653"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_image_cache.html">IImageCache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#a0675403738cdf6f017a091a973e1c653">Resample</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;imageRef, uint32 srcSelector, uint32 dstSelector, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;resToResampleFrom, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;resToResampleTo, <a class="el" href="class_i_image_stream_manager.html#a929088088e9b1ee01ce083dff8924ead">IImageStreamManager::ResamplingType</a> &amp;sampleType, bool32 bForceNonVirtual=kFalse)=0</td></tr><tr class="separator:a0675403738cdf6f017a091a973e1c653"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad5d627c5da410ceab9bb9c66b014240e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#ad5d627c5da410ceab9bb9c66b014240e">SetMaxSize</a> (uint32 kiloBytes)=0</td></tr><tr class="separator:ad5d627c5da410ceab9bb9c66b014240e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a76506f41ce82e0aebb474053f1dcbd6b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_image_cache_mgr.html#a76506f41ce82e0aebb474053f1dcbd6b">PurgeMemory</a> (int32 level, bool16 inGrowZone)=0</td></tr><tr class="separator:a76506f41ce82e0aebb474053f1dcbd6b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p><a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a> Description: The <a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a> is used to store 1 or more in-memory raster images for a given page item. Image&#39;s are identified by a <a class="el" href="class_u_i_d_ref.html">UIDRef</a>, resolution and a 32-bit selector. The <a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a> makes it easy for the Draw method of an <a class="el" href="class_i_shape.html">IShape</a> implementation to store caches at various resolutions for its page item and easily retrieve them. One major benefit of the <a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a> is that it allows copies of page items to easily share caches. It also has the ability to serialize caches to temp files in low memory situations without forcing the client to reconstruct the cache from scratch. </div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a1f86d6ce9da89e8a005da5da0f9851f8"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">anonymous enum</td></tr></table></div><div class="memdoc"><p>Selectors enumeration </div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a9ba045d0d4f2a7bbcd4e06c0b83ad0f3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual ErrorCode IImageCacheMgr::Add </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_image_cache.html">IImageCache</a> *&nbsp;</td><td class="paramname"><em>cache</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8&nbsp;</td><td class="paramname"><em>purgeFirst</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>selector</em> = <code>kRasterImage</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Add Add a cache to the list along with information about the size of the cache and the amount of time needed to compute the cache. cache-&gt;<a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef()</a> will be called. purgeFirst signals the <a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a> that it should remove this item first during a <a class="el" href="class_i_image_cache_mgr.html#a76506f41ce82e0aebb474053f1dcbd6b">PurgeMemory()</a> call. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">imageRef</td><td>- IN: the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item. </td></tr><tr><td class="paramname">cache</td><td>- IN: the cache to add. </td></tr><tr><td class="paramname">purgeFirst</td><td>- IN: A hint to the memory management system that it is okay to purge this cache first as it is being used for a short term purpose. </td></tr><tr><td class="paramname">selector</td><td>- IN: Another key. This key allows the client to store different types of caches. For example, you may have a color managed version, an uncalibrated version, a drop shadow mask and an alpha mask all at the same resolution for a given page item. </td></tr></table></dl></div></div><a class="anchor" id="af030f36db423b2b2a3e42bbc1763f3f4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IImageCacheMgr::GetClosestMatchResolution </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>resolution</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>selector</em> = <code>kRasterImage</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 *&nbsp;</td><td class="paramname"><em>selectorFound</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the resolution of the <a class="el" href="class_i_image_cache.html">IImageCache</a> which would be returned via <a class="el" href="class_i_image_cache_mgr.html#a220f62d53e1b1904a826c20ba33a214a">QueryClosestResolution()</a>. This call avoids add-refing of the <a class="el" href="class_i_image_cache.html">IImageCache</a> and keeps it out of any LRU lists. Returns kTrue if an image is found. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">imageRef</td><td>- IN: the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item. </td></tr><tr><td class="paramname">resolution</td><td>- IN/OUT: On input, the desired resolution. On output, the actual resolution found. </td></tr><tr><td class="paramname">selector</td><td>- IN: Another key. This key allows the client to store different types of caches. For example, you may have a color managed version, an uncalibrated version, a drop shadow mask and an alpha mask all at the same resolution for a given page item. </td></tr><tr><td class="paramname">selectorFound</td><td>- OUT: Optional. If non-nil and a cache is found, the selector of the cache is returned. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if a cache is found, kFalse otherwise. </dl></div></div><a class="anchor" id="a2bc877b37770491e2dcb15e7c646192c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IImageCacheMgr::GetSize </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the total size of the image caches tracked by the <a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a></div></div><a class="anchor" id="a41a1027dcb13883076c6bb5f6c876b05"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IImageCacheMgr::Purge </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_image_cache.html">IImageCache</a> *&nbsp;</td><td class="paramname"><em>cache</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Purge an image cache and call cache-&gt;<a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release()</a>. <dl class="section return"><dt>Returns<dd>Return amount of memory purged. </dl></div></div><a class="anchor" id="af4b328fca11618923a1af6b829a59fe4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IImageCacheMgr::Purge </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>resolution</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>selector</em> = <code>kWildCard</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Purge all caches matching the given imageRef, resolution and selector. <dl class="section return"><dt>Returns<dd>Return amount of memory purged. </dl></div></div><a class="anchor" id="ad42bdcbd8c90085f04e7b3793c8e1ffb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IImageCacheMgr::Purge </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>selector</em> = <code>kWildCard</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Purge all image caches associated with the given imageRef. <dl class="section return"><dt>Returns<dd>Return amount of memory purged. </dl></div></div><a class="anchor" id="afa236aae32c6dcc6367f0754080e99f7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IImageCacheMgr::Purge </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>selector</em> = <code>kWildCard</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Purge all image caches associated with the given db. <dl class="section return"><dt>Returns<dd>Return amount of memory purged. </dl></div></div><a class="anchor" id="a76506f41ce82e0aebb474053f1dcbd6b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IImageCacheMgr::PurgeMemory </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>level</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>inGrowZone</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Purge routine registered with the memory manager which uses heuristics to purge image caches. </div></div><a class="anchor" id="a220f62d53e1b1904a826c20ba33a214a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_image_cache.html">IImageCache</a>* IImageCacheMgr::QueryClosestResolution </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>resolution</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>selector</em> = <code>kRasterImage</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 *&nbsp;</td><td class="paramname"><em>selectorFound</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find the closest resolution which is greater than or equal to the requested resolution. If one cannot be found, then find the first resolution which is less than the requested resolution. If a cache for the given imageRef cannot be found, then nil is returned. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">imageRef</td><td>- IN: the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item. </td></tr><tr><td class="paramname">resolution</td><td>- IN: the desired resolution. </td></tr><tr><td class="paramname">selector</td><td>- IN: Another key. This key allows the client to store different types of caches. For example, you may have a color managed version, an uncalibrated version, a drop shadow mask and an alpha mask all at the same resolution for a given page item. </td></tr><tr><td class="paramname">selectorFound</td><td>- OUT: Optional. If non-nil and a cache is found, the selector of the cache is returned. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The image cache matching the input parameters or nil if one is not found. </dl></div></div><a class="anchor" id="a1b5daddc863d78af42305b22cabe735d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_image_cache.html">IImageCache</a>* IImageCacheMgr::QueryNextResolution </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_image_cache.html">IImageCache</a> &amp;&nbsp;</td><td class="paramname"><em>currentCache</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>selector</em> = <code>kRasterImage</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 *&nbsp;</td><td class="paramname"><em>selectorFound</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given an imageRef and an image cache, find the next largest resolution cache for the same image <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">imageRef</td><td>- IN: the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item. </td></tr><tr><td class="paramname">currentCache</td><td>- IN: tells the <a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a> to look relative to this cache. </td></tr><tr><td class="paramname">selector</td><td>- IN: Another key. This key allows the client to store different types of caches. For example, you may have a color managed version, an uncalibrated version, a drop shadow mask and an alpha mask all at the same resolution for a given page item. </td></tr><tr><td class="paramname">selectorFound</td><td>- OUT: Optional. If non-nil and a cache is found, the selector of the cache is returned. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The image cache matching the input parameters or nil if one is not found. </dl></div></div><a class="anchor" id="a1edd53d1a2b4d3124e89d14c52826e0a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_image_cache.html">IImageCache</a>* IImageCacheMgr::QueryPreviousResolution </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_image_cache.html">IImageCache</a> &amp;&nbsp;</td><td class="paramname"><em>currentCache</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>selector</em> = <code>kRasterImage</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 *&nbsp;</td><td class="paramname"><em>selectorFound</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given an imageRef and an image cache, find the next smallest resolution cache for the same image <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">imageRef</td><td>- IN: the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item. </td></tr><tr><td class="paramname">currentCache</td><td>- IN: tells the <a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a> to look relative to this cache. </td></tr><tr><td class="paramname">selector</td><td>- IN: Another key. This key allows the client to store different types of caches. For example, you may have a color managed version, an uncalibrated version, a drop shadow mask and an alpha mask all at the same resolution for a given page item. </td></tr><tr><td class="paramname">selectorFound</td><td>- OUT: Optional. If non-nil and a cache is found, the selector of the cache is returned. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The image cache matching the input parameters or nil if one is not found. </dl></div></div><a class="anchor" id="a0675403738cdf6f017a091a973e1c653"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_image_cache.html">IImageCache</a>* IImageCacheMgr::Resample </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>imageRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>srcSelector</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>dstSelector</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>resToResampleFrom</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>resToResampleTo</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_image_stream_manager.html#a929088088e9b1ee01ce083dff8924ead">IImageStreamManager::ResamplingType</a> &amp;&nbsp;</td><td class="paramname"><em>sampleType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool32&nbsp;</td><td class="paramname"><em>bForceNonVirtual</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Resample an existing cache to create a lower resolution cache. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">imageRef</td><td>- IN: the <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the page item. </td></tr><tr><td class="paramname">srcSelector</td><td>- IN: Another key. This key allows the client to store different types of caches. For example, you may have a color managed version, an uncalibrated version, a drop shadow mask and an alpha mask all at the same resolution for a given page item. The srcSelector is used to help identify the source image from which we will resample. </td></tr><tr><td class="paramname">dstSelector</td><td>- IN: The resulting cache will be added to the ImageCacheMgr using dstSelector as a key. Typically, the dstSelector is the same as the srcSelector. </td></tr><tr><td class="paramname">resToResampleFrom</td><td>- IN: The source resolution. This parameter is used as another key for identifying the source image cache. </td></tr><tr><td class="paramname">resToResampleTo</td><td>- IN: The destination resolution. </td></tr><tr><td class="paramname">sampleType</td><td>- IN/OUT: On input, the desired resampling type. For non-virtual images, AGM does the resampling and they support 2 kinds: Bicubic and Dowsampling (averaging). Therefore, on if AGM is used to resample the image and Subsampling is chosen, Downsampling will be used instead (which is of higher quality than Subsampling but slower). On return, therefore, this parameter will be set to the actual sampling method used. </td></tr><tr><td class="paramname">bForceNonVirtual</td><td>- IN: If the source image is virtual, the typical result of downsampling is another virtual image which will downsample from the original EVERY time it is drawn. If this cache is going to be used to draw to the screen and will be drawn multiple times, then assuming you have enough memory, it is more optimal to convert the image to a non-virtual image. If after conversion the application gets low on memory, the ImageCacheMgr will serialize the image to disk. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The resampled image cache matching the input parameters. Note that the resulting cache will automatically be added to the ImageCacheMgr. </dl></div></div><a class="anchor" id="ad5d627c5da410ceab9bb9c66b014240e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IImageCacheMgr::SetMaxSize </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>kiloBytes</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>OBSOLETE Set a maximum amount of memory which can be used by IImageCaches in kilobytes. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_image_cache_mgr.html">IImageCacheMgr</a><li class="footer">Generated on Sat Sep 22 2018 10:54:18 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
