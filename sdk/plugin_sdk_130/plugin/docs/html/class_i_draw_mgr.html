<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_draw_mgr</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_draw_mgr.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#nested-classes">Classes</a> | <a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_draw_mgr-members.html">List of all members</a></div><div class="headertitle"><div class="title">IDrawMgr Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_draw_mgr_8h_source.html">IDrawMgr.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IDrawMgr:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_draw_mgr.png" usemap="#IDrawMgr_map" /><map id="IDrawMgr_map" name="IDrawMgr_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> Classes</h2></td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr_1_1_clipping_or_filtering_disabler.html">ClippingOrFilteringDisabler</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_draw_mgr_1_1_filter_info.html">FilterInfo</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:afb3ed7469f004ceb8bc013af76f09b2c"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IDRAWMGR }</td></tr><tr class="separator:afb3ed7469f004ceb8bc013af76f09b2c"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a56a26c949681437ea1abd12d8825dd4c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a56a26c949681437ea1abd12d8825dd4c">BeginInterruptableDraw</a> (DrawInterrupter *interruptChecker=nil)=0</td></tr><tr class="separator:a56a26c949681437ea1abd12d8825dd4c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aba7d2bbb2a7d619e284880123fc89d67"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#aba7d2bbb2a7d619e284880123fc89d67">EndInterruptableDraw</a> ()=0</td></tr><tr class="separator:aba7d2bbb2a7d619e284880123fc89d67"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5620b001746070571c5bec5464872e6b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a5620b001746070571c5bec5464872e6b">EnableInterruptableDraw</a> (bool16 enable=kTrue)=0</td></tr><tr class="separator:a5620b001746070571c5bec5464872e6b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6386f41e2e75bff54464c006680e840d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a6386f41e2e75bff54464c006680e840d">DisableInterruptableDraw</a> ()=0</td></tr><tr class="separator:a6386f41e2e75bff54464c006680e840d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a52abe88534fff94161296020f8f472bb"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a52abe88534fff94161296020f8f472bb">IsDrawingInterruptable</a> ()=0</td></tr><tr class="separator:a52abe88534fff94161296020f8f472bb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6c57d9162a33e974934d37b180b9a6fd"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a6c57d9162a33e974934d37b180b9a6fd">Abort</a> ()=0</td></tr><tr class="separator:a6c57d9162a33e974934d37b180b9a6fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af2ab6a0f41aff9c98df25203df2c2ecb"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#af2ab6a0f41aff9c98df25203df2c2ecb">DrawAtOnce</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;thing, int32 flags)=0</td></tr><tr class="separator:af2ab6a0f41aff9c98df25203df2c2ecb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a60d17e4c7886cd002ed65a8b293b4d7f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a60d17e4c7886cd002ed65a8b293b4d7f">DrawIncrementallyUsingDrawbot</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;thing, int32 flags, <a class="el" href="class_i_d_v_platform_offscreen.html">IDVPlatformOffscreen</a> *srcOffscreen, dvaui::drawbot::Drawbot *dstDrawbot, <a class="el" href="struct_sys_rect.html">SysRect</a> updateBounds, int32 tickCount)=0</td></tr><tr class="separator:a60d17e4c7886cd002ed65a8b293b4d7f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4460856ebdcb470e84b0a9919e76d433"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a4460856ebdcb470e84b0a9919e76d433">BeginCullToViewRect</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;r)=0</td></tr><tr class="separator:a4460856ebdcb470e84b0a9919e76d433"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a852ec97a91d2617f614ef31467b5a4ad"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a852ec97a91d2617f614ef31467b5a4ad">BeginCullToViewRegion</a> (const SysRgn &amp;rgn)=0</td></tr><tr class="separator:a852ec97a91d2617f614ef31467b5a4ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a461f6e6d0c77cbe69db63f874d6cd8df"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a461f6e6d0c77cbe69db63f874d6cd8df">EndLatestViewSpaceCulling</a> ()=0</td></tr><tr class="separator:a461f6e6d0c77cbe69db63f874d6cd8df"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af69440c731f5fd88813aae2bf5e789d6"><td align="right" class="memItemLeft" valign="top">virtual SysRgn&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#af69440c731f5fd88813aae2bf5e789d6">GetViewCullRegion</a> () const =0</td></tr><tr class="separator:af69440c731f5fd88813aae2bf5e789d6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4cdaf9ffee6d8dcc3ef6bb4e063da2b4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4cdaf9ffee6d8dcc3ef6bb4e063da2b4"></a> virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSpreadFilterCount</b> () const =0</td></tr><tr class="separator:a4cdaf9ffee6d8dcc3ef6bb4e063da2b4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae1f230a2c6aed1967e9ea9b07f5378ad"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#ae1f230a2c6aed1967e9ea9b07f5378ad">BeginFilterToSpreadRect</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;r, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m=<a class="el" href="class_p_m_matrix.html">PMMatrix</a>(1., 0., 0., 1., 0., 0.), const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;rest=<a class="el" href="class_p_m_matrix.html">PMMatrix</a>(0., 0., 0., 0., 0., 0.))=0</td></tr><tr class="separator:ae1f230a2c6aed1967e9ea9b07f5378ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88290ac20755313f8aac32ecb2dedfbb"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a88290ac20755313f8aac32ecb2dedfbb">EndFilterToSpreadRect</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> *r=nil, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *m=nil, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *rest=nil)=0</td></tr><tr class="separator:a88290ac20755313f8aac32ecb2dedfbb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a791dbd42ddf118fddadffd254aae2a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5a791dbd42ddf118fddadffd254aae2a"></a> virtual <a class="el" href="struct_i_draw_mgr_1_1_filter_info.html">FilterInfo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNthSpreadFilter</b> (uint32 which) const =0</td></tr><tr class="separator:a5a791dbd42ddf118fddadffd254aae2a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af3ae4737eff6e1e2eb512544460b10b9"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#af3ae4737eff6e1e2eb512544460b10b9">IsDrawAborted</a> ()=0</td></tr><tr class="separator:af3ae4737eff6e1e2eb512544460b10b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acf82e08d6dbcd3c83c5148a90f49a2d4"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#acf82e08d6dbcd3c83c5148a90f49a2d4">IsDrawClipped</a> (<a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *thing, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *pb2view)=0</td></tr><tr class="separator:acf82e08d6dbcd3c83c5148a90f49a2d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7cb7ff1f9ff76c3862812f590a96f64f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a7cb7ff1f9ff76c3862812f590a96f64f">BeginShape</a> (<a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *theShape)=0</td></tr><tr class="separator:a7cb7ff1f9ff76c3862812f590a96f64f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a435a8ad4668de1e22bf03f80af317624"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a435a8ad4668de1e22bf03f80af317624">EndShape</a> (<a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *theShape)=0</td></tr><tr class="separator:a435a8ad4668de1e22bf03f80af317624"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a78a7762b21defdae3e63ad3da50429ec"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a78a7762b21defdae3e63ad3da50429ec">FlushOffscreenIfNecessary</a> ()=0</td></tr><tr class="separator:a78a7762b21defdae3e63ad3da50429ec"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1932a0a587bc536ae2b18ff2542477e7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a1932a0a587bc536ae2b18ff2542477e7">Disable</a> (<a class="el" href="class_i_d_type.html">UID</a> item, bool16 disable)=0</td></tr><tr class="separator:a1932a0a587bc536ae2b18ff2542477e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a46e3f2dc6dd11c24a69392ea8cdb6d1d"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a46e3f2dc6dd11c24a69392ea8cdb6d1d">IsItemDisabled</a> (<a class="el" href="class_i_d_type.html">UID</a> item) const =0</td></tr><tr class="separator:a46e3f2dc6dd11c24a69392ea8cdb6d1d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1ca9a3da14bb0141d9e34bea61172983"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a1ca9a3da14bb0141d9e34bea61172983">WasDrawAborted</a> () const =0</td></tr><tr class="separator:a1ca9a3da14bb0141d9e34bea61172983"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a999a02c3105537446d3c9136d93283fa"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a999a02c3105537446d3c9136d93283fa">ClearAborted</a> ()=0</td></tr><tr class="separator:a999a02c3105537446d3c9136d93283fa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a45d552456998d221b1a9dafb803a0dfe"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a45d552456998d221b1a9dafb803a0dfe">IterateDrawOrder_</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xform, const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;thing, <a class="el" href="class_i_callback.html">ICallback</a> *callbackInfo, int32 flags)=0</td></tr><tr class="separator:a45d552456998d221b1a9dafb803a0dfe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abbbf3c7336cc53cc4dc6430ba2ad942e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abbbf3c7336cc53cc4dc6430ba2ad942e"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>IterateDrawOrder</b> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;thing, <a class="el" href="class_i_callback.html">ICallback</a> *callbackInfo, int32 flags)</td></tr><tr class="separator:abbbf3c7336cc53cc4dc6430ba2ad942e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad18ae830f7929b3a43e6ce766d87c8db"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#ad18ae830f7929b3a43e6ce766d87c8db">DisableClippingOrFiltering</a> ()=0</td></tr><tr class="separator:ad18ae830f7929b3a43e6ce766d87c8db"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a529b857e955a62b1e0fafb01b78dd0ae"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_draw_mgr.html#a529b857e955a62b1e0fafb01b78dd0ae">EnableClippingOrFiltering</a> ()=0</td></tr><tr class="separator:a529b857e955a62b1e0fafb01b78dd0ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>The DrawMgr is a class that exists on each port and is used to set clipping areas as well as to initiate the drawing of any page element and its children. Optionally, this class can be used to iterate the draw order, calling a client provided callback routine for every page item in the hierarchy. </div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="afb3ed7469f004ceb8bc013af76f09b2c"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">anonymous enum</td></tr></table></div><div class="memdoc"><p>default enum </div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a6c57d9162a33e974934d37b180b9a6fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::Abort </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Interrupts drawing, with the side effect that the current update area will be invalidated, causing an update/paint event to occur such that the drawing will start again in the future. </div></div><a class="anchor" id="a4460856ebdcb470e84b0a9919e76d433"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::BeginCullToViewRect </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>r</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set &quot;clipping&quot; region. Draw not called for items that fall outside the clip rect Beginning a new clip while a clip is already installed will push the new clip onto the draw mgr stack. The new clip does not union or intersect with the previous clip, it simply supercedes it. When endclip is called the clip is popped off the stack and the old clip takes over. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">r</td><td>IN specifies clipping rect </td></tr></table></dl></div></div><a class="anchor" id="a852ec97a91d2617f614ef31467b5a4ad"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::BeginCullToViewRegion </td><td>(</td><td class="paramtype">const SysRgn &amp;&nbsp;</td><td class="paramname"><em>rgn</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set &quot;clipping&quot; region. Draw not called for items that fall outside the clip rect Beginning a new clip while a clip is already installed will push the new clip onto the draw mgr stack. The new clip does not union or intersect with the previous clip, it simply supercedes it. When endclip is called the clip is popped off the stack and the old clip takes over. Makes a copy of rgn. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rgn</td><td>IN specifies clipping region </td></tr></table></dl></div></div><a class="anchor" id="ae1f230a2c6aed1967e9ea9b07f5378ad"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IDrawMgr::BeginFilterToSpreadRect </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>r</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em> = <code><a class="el" href="class_p_m_matrix.html">PMMatrix</a>(1.,&nbsp;0.,&nbsp;0.,&nbsp;1.,&nbsp;0.,&nbsp;0.)</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>rest</em> = <code><a class="el" href="class_p_m_matrix.html">PMMatrix</a>(0.,&nbsp;0.,&nbsp;0.,&nbsp;0.,&nbsp;0.,&nbsp;0.)</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>A filter is a <a class="el" href="class_p_m_rect.html">PMRect</a> which specifies an area which must be intersected by a page item before it will be drawn. This filter does not affect how the page item is drawn (i.e. it does not clip). To clip the page item, use BeginClip. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">r</td><td>IN the filter rect </td></tr></table></dl></div></div><a class="anchor" id="a56a26c949681437ea1abd12d8825dd4c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::BeginInterruptableDraw </td><td>(</td><td class="paramtype">DrawInterrupter *&nbsp;</td><td class="paramname"><em>interruptChecker</em> = <code>nil</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets an interrupt checker before drawing to a port. If this method is called before calling Draw(), then the interrupt checker will periodically (usually before each page item in the hierarchy is drawn) be called to see if the draw should be aborted. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">interruptChecker</td><td>IN the DrawInterrupter </td></tr></table></dl></div></div><a class="anchor" id="a7cb7ff1f9ff76c3862812f590a96f64f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::BeginShape </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>theShape</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Do not use, this method is called by the Draw Event Handler at the beginning of every IShape::Draw implementation. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">theShape</td><td>IN the shape being drawn </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the <a class="el" href="class_i_shape.html">IShape</a> implementation should not continue with the drawing of this page item </dl></div></div><a class="anchor" id="a999a02c3105537446d3c9136d93283fa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::ClearAborted </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clears flag if Draw was aborted during the last Begin/End Interruptable draw sequence. </div></div><a class="anchor" id="a1932a0a587bc536ae2b18ff2542477e7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::Disable </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>item</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>disable</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Disable an item. It is up to the page item to call back and ask if it is in fact disabled. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">item</td><td>IN UID of the page item to disable </td></tr><tr><td class="paramname">disable</td><td>IN specifies whether to disable item </td></tr></table></dl></div></div><a class="anchor" id="ad18ae830f7929b3a43e6ce766d87c8db"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::DisableClippingOrFiltering </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Does a &quot;global&quot; disabling of any clipping or filtering. This method is useful for situations where a piece of content, such as a PageItem child or even Text content knows that it needs to draw but by the rules of the hierarchy it will get either clipped or filtered out. <dl class="section return"><dt>Returns<dd>kTrue if Clipping or Filtering was enabled, kFalse otherwise. </dl></div></div><a class="anchor" id="a6386f41e2e75bff54464c006680e840d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::DisableInterruptableDraw </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Same as EnableInterruptableDraw(kFalse). </div></div><a class="anchor" id="af2ab6a0f41aff9c98df25203df2c2ecb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::DrawAtOnce </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>thing</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Main entry point - if kFalse is returned, any loops (ie hierarchy loops) should immediately abort. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>IN the graphics context. Contains info about the port. </td></tr><tr><td class="paramname">thing</td><td>IN the page item to draw </td></tr><tr><td class="paramname">flags</td><td>IN see <a class="el" href="_i_shape_8h_source.html">IShape.h</a> for the drawing flags </td></tr></table></dl><dl class="section return"><dt>Returns<dd>if kFalse, any loops (ie hierarchy loops) should immediately abort </dl></div></div><a class="anchor" id="a60d17e4c7886cd002ed65a8b293b4d7f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::DrawIncrementallyUsingDrawbot </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>thing</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_v_platform_offscreen.html">IDVPlatformOffscreen</a> *&nbsp;</td><td class="paramname"><em>srcOffscreen</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">dvaui::drawbot::Drawbot *&nbsp;</td><td class="paramname"><em>dstDrawbot</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="struct_sys_rect.html">SysRect</a>&nbsp;</td><td class="paramname"><em>updateBounds</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>tickCount</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draw with timed updates to the screen. The client passes in a droverized platform offscreen and a pointer to the screen. Make sure the update bounds encompasses the entire region that will be painted by thing and its children. tickCount is the update interval. Too small and the screen is updated far too often. Too large and the benefit is minimal. Suggested value is 1/2 second (500 ticks). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>IN the graphics context. Contains info about the port. </td></tr><tr><td class="paramname">thing</td><td>IN the page item to draw </td></tr><tr><td class="paramname">flags</td><td>IN see <a class="el" href="_i_shape_8h_source.html">IShape.h</a> for the drawing flags </td></tr><tr><td class="paramname">srcOffscreen</td><td>IN a pointer to the droverized offscreen we are drawing to </td></tr><tr><td class="paramname">dstDrawbot</td><td>IN a pointer to the destination drawbot we are drawing to </td></tr><tr><td class="paramname">updateBounds</td><td>IN the area of the port or offscreen we are updating </td></tr><tr><td class="paramname">tickCount</td><td>IN how frequently to update the port using the srcOffscreen </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if drawing was successful </dl></div></div><a class="anchor" id="a529b857e955a62b1e0fafb01b78dd0ae"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::EnableClippingOrFiltering </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Re-enables clipping or filtering disabled by a call to the previous method. </div></div><a class="anchor" id="a5620b001746070571c5bec5464872e6b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::EnableInterruptableDraw </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>enable</em> = <code>kTrue</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Enables/disables the ability to interrupt drawing. When enabled, <a class="el" href="class_i_draw_mgr.html#a56a26c949681437ea1abd12d8825dd4c">BeginInterruptableDraw()</a> has no effect. Useful in some tracking situations. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">enable</td><td>IN whether to enable drawing interrupt </td></tr></table></dl></div></div><a class="anchor" id="a88290ac20755313f8aac32ecb2dedfbb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IDrawMgr::EndFilterToSpreadRect </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>r</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>m</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>rest</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>End the current filter. </div></div><a class="anchor" id="aba7d2bbb2a7d619e284880123fc89d67"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::EndInterruptableDraw </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Removes the interrupt checker set by BeginInterruptableDraw. </div></div><a class="anchor" id="a461f6e6d0c77cbe69db63f874d6cd8df"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::EndLatestViewSpaceCulling </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Removes the current clipping from the stack. <dl class="section return"><dt>Returns<dd>kTrue if there are still clips on the draw mgr stack, kFalse otherwise </dl></div></div><a class="anchor" id="a435a8ad4668de1e22bf03f80af317624"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::EndShape </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>theShape</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Do not use, this method is called by the Draw Event Handler at the end of every IShape::Draw implementation. Every call to BeginShape should be paired with a call to EndShape, even if the drawing was aborted. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">theShape</td><td>IN the shape being drawn </td></tr></table></dl></div></div><a class="anchor" id="a78a7762b21defdae3e63ad3da50429ec"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::FlushOffscreenIfNecessary </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>IsDrawAborted flushes the offscreen to the screen every few seconds. Sometimes, you want to flush the offscreen, but you don&#39;t want to set the aborted flag, even if the user has done something to abort. This will accomplish that. You can call it alot, it will only have an effect every few seconds or so, just like IsDrawAborted. </div></div><a class="anchor" id="af69440c731f5fd88813aae2bf5e789d6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual SysRgn IDrawMgr::GetViewCullRegion </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns a copy of the current clipping region. If there is no clipping region, then nil is returned. Caller is responsible for disposing of the result if non-nil. <dl class="section return"><dt>Returns<dd>SysRgn of the current clipping region </dl></div></div><a class="anchor" id="af3ae4737eff6e1e2eb512544460b10b9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::IsDrawAborted </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Do not use, use ProcessEvent() with the kAbortCheckMessage event to check for interruption. </div></div><a class="anchor" id="acf82e08d6dbcd3c83c5148a90f49a2d4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::IsDrawClipped </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>thing</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>pb2view</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Do not use, use ProcessEvent() with the kFilterCheckMessage event to check for clipping. </div></div><a class="anchor" id="a52abe88534fff94161296020f8f472bb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::IsDrawingInterruptable </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Used to determine whether or not interruptable drawing has been disabled via a call to <a class="el" href="class_i_draw_mgr.html#a5620b001746070571c5bec5464872e6b">EnableInterruptableDraw()</a> or <a class="el" href="class_i_draw_mgr.html#a6386f41e2e75bff54464c006680e840d">DisableInterruptableDraw()</a>. <dl class="section return"><dt>Returns<dd>kTrue if interrupts are allowed, kFalse if interrupts have been disabled </dl></div></div><a class="anchor" id="a46e3f2dc6dd11c24a69392ea8cdb6d1d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::IsItemDisabled </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>item</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns whether page item is disabled. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">item</td><td>UID of the page item </td></tr></table></dl></div></div><a class="anchor" id="a45d552456998d221b1a9dafb803a0dfe"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IDrawMgr::IterateDrawOrder_ </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xform</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>thing</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_callback.html">ICallback</a> *&nbsp;</td><td class="paramname"><em>callbackInfo</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>To walk the display hierarchy in the same order as Draw, use this. the transform matrix is passed instead of a graphics context (which may not exist); callees can modify the transform for their own purposes (e.g. master pages will concatenate a translation). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xform</td><td>IN specifies transform matrix. </td></tr><tr><td class="paramname">thing</td><td>IN <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the shape to iterate from. </td></tr><tr><td class="paramname">callbackInfo</td><td>IN the <a class="el" href="class_i_callback.html">ICallback</a> interface to use to for callback. </td></tr><tr><td class="paramname">flags</td><td>IN see <a class="el" href="_i_shape_8h_source.html">IShape.h</a> for the drawing flags </td></tr></table></dl></div></div><a class="anchor" id="a1ca9a3da14bb0141d9e34bea61172983"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IDrawMgr::WasDrawAborted </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns whether draw was aborted or not during the last Begin/End Interruptable draw sequence. The flag is cleared either by a successful Begin/End Interruptable draw or by calling <a class="el" href="class_i_draw_mgr.html#a999a02c3105537446d3c9136d93283fa">ClearAborted()</a><dl class="section return"><dt>Returns<dd>kTrue if the draw was aborted, kFalse otherwise. </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_draw_mgr.html">IDrawMgr</a><li class="footer">Generated on Sat Sep 22 2018 10:54:10 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
