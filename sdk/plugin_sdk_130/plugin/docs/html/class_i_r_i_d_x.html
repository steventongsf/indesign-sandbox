<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_r_i_d_x</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_r_i_d_x.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_r_i_d_x-members.html">List of all members</a></div><div class="headertitle"><div class="title">IRIDX Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_r_i_d_x_8h_source.html">IRIDX.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IRIDX:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_r_i_d_x.png" usemap="#IRIDX_map" /><map id="IRIDX_map" name="IRIDX_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a2a2598e3cd8c361945d063930b1f3deb"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IRIDX }</td></tr><tr class="separator:a2a2598e3cd8c361945d063930b1f3deb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9372564f79a53edf4e098b0cf1f810b3"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#a9372564f79a53edf4e098b0cf1f810b3">QueryType</a> { <a class="el" href="class_i_r_i_d_x.html#a9372564f79a53edf4e098b0cf1f810b3a64caba6d8114b2427b364a185dd3bd31">kDynamicQuery</a> = 0, <a class="el" href="class_i_r_i_d_x.html#a9372564f79a53edf4e098b0cf1f810b3a25cbfb311fcf403b9d9aacd2c0f254f4">kLockedQuery</a> = 1 }</td></tr><tr class="separator:a9372564f79a53edf4e098b0cf1f810b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad7047c1bf4ef4017844f9dd8618bc393"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#ad7047c1bf4ef4017844f9dd8618bc393">CoherencyType</a> { <a class="el" href="class_i_r_i_d_x.html#ad7047c1bf4ef4017844f9dd8618bc393a68610da598268765206f661ec9e5bc2c">kCoherentAtOutermostQueryCreation</a> = 0, <a class="el" href="class_i_r_i_d_x.html#ad7047c1bf4ef4017844f9dd8618bc393a7f687f51692501914a4a62ffc747dd7c">kCoherentAtThisQueryCreation</a> = 1 }</td></tr><tr class="separator:ad7047c1bf4ef4017844f9dd8618bc393"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae3c6d6cf5ec171ad2c25fedb983b969c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae3c6d6cf5ec171ad2c25fedb983b969c"></a> typedef std::vector&lt; <a class="el" href="class_r_i_d_x_target.html">RIDXTarget</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Targets</b></td></tr><tr class="separator:ae3c6d6cf5ec171ad2c25fedb983b969c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ace600a14bcfecdea60a6332361d8378d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ace600a14bcfecdea60a6332361d8378d"></a> typedef std::vector&lt; <a class="el" href="class_r_i_d_x_source.html">RIDXSource</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Sources</b></td></tr><tr class="separator:ace600a14bcfecdea60a6332361d8378d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8d8fae3d7b59f82a7c4d39eeffa7fc20"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8d8fae3d7b59f82a7c4d39eeffa7fc20"></a> typedef std::vector<br class="typebreak" /> &lt; <a class="el" href="class_r_i_d_x_reference.html">RIDXReference</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>References</b></td></tr><tr class="separator:a8d8fae3d7b59f82a7c4d39eeffa7fc20"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a17c5c1c6d5d146ad8515a8ad902524ce"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#a17c5c1c6d5d146ad8515a8ad902524ce">Initialize</a> ()=0</td></tr><tr class="separator:a17c5c1c6d5d146ad8515a8ad902524ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a792b761ec2e9b3b4705c1af4e7dbb06b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#a792b761ec2e9b3b4705c1af4e7dbb06b">ProcessScheduledIndexing</a> ()=0</td></tr><tr class="separator:a792b761ec2e9b3b4705c1af4e7dbb06b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa027b7b3e3ceb6ff0d1b491354677ef6"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_r_i_d_x_query.html">IRIDXQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#aa027b7b3e3ceb6ff0d1b491354677ef6">CreateQuery</a> (<a class="el" href="class_i_r_i_d_x.html#a9372564f79a53edf4e098b0cf1f810b3">QueryType</a> queryType, <a class="el" href="class_i_r_i_d_x.html#ad7047c1bf4ef4017844f9dd8618bc393">CoherencyType</a> coherencyType) const =0</td></tr><tr class="separator:aa027b7b3e3ceb6ff0d1b491354677ef6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a74eed8871cc6eee3d533797b43c349c9"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#a74eed8871cc6eee3d533797b43c349c9">HasOutstandingQuery</a> () const =0</td></tr><tr class="separator:a74eed8871cc6eee3d533797b43c349c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac4b7460e43bdf9231f5515c8c5489edd"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#ac4b7460e43bdf9231f5515c8c5489edd">HasOutstandingLockedQuery</a> () const =0</td></tr><tr class="separator:ac4b7460e43bdf9231f5515c8c5489edd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a64d02c659ea8e216326efffafac1e880"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#a64d02c659ea8e216326efffafac1e880">WontProcessScheduledIndexing</a> ()=0</td></tr><tr class="separator:a64d02c659ea8e216326efffafac1e880"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa3266ab11c71cba8b4d3fd02020691f9"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_r_i_d_x.html#aa3266ab11c71cba8b4d3fd02020691f9">UpdateInProgress</a> () const =0</td></tr><tr class="separator:aa3266ab11c71cba8b4d3fd02020691f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><pre class="fragment">The public interface of the reference index.



&lt;pre&gt;

    One index to hold them all

    One query to find them

    One interface to observe them all

    And during persistence bind them

&lt;/pre&gt;



Particular database types (e.g. documents) are reference indexed, which means

that the object model automatically tracks which UIDs in the database are referred

to by which other UIDs, and you may query for this information instead of iterating

the database somehow to obtain it.  A particular database has a reference index if the

IRIDXAccess interface is available off of the root object of the database (e.g. kDocBoss in

the case of documents).  You can check a reference index as follows:



&lt;pre&gt;

    InterfacePtr&lt;IRIDX&gt; ridx (RIDXAccess::QueryRIDX());

    if (ridx) ridx-&gt;UseSomeFunction();

&lt;/pre&gt;



If you are only interested in querying the reference index, you may safely stop reading

further here and refer to CreateQuery().



While the presence of IRIDXAccess on the database&#39;s root object means that type of

database is reference indexed, that fact alone does not _create_ the reference

index itself in the database.  This is something that must be done when

new databases are created, or when existing ones are opened that could have

been created before reference indexing was performed on that type of database.

Also, each time a database is opened, you must request that the reference index 

process any pending indexing that was deferred due to missing plug-ins.  For example, 

imagine the OpenDoc() function for some database type that is reference indexed.

It should have logic that looks something like the following:



&lt;pre&gt;

    InterfacePtr&lt;IRIDX&gt; ridx (RIDXAccess::QueryRIDX());

    ridx-&gt;Intialize ();

</pre><p> Call Converison Manager HERE if necessary ridx-&gt;ProcessScheduledIndexing (); <p>In the NewDoc() function, handling would be largely identical except there would never be need to call the conversion manager. </div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="ad7047c1bf4ef4017844f9dd8618bc393"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_r_i_d_x.html#ad7047c1bf4ef4017844f9dd8618bc393">IRIDX::CoherencyType</a></td></tr></table></div><div class="memdoc"><p>Specifies whether a query requires the reference index to be brought up to date always, or only if it is outmost query <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad7047c1bf4ef4017844f9dd8618bc393a68610da598268765206f661ec9e5bc2c"></a>kCoherentAtOutermostQueryCreation</em>&nbsp;</td><td class="fielddoc"><p>Reference index is updated to reflect model state only at start of the of outermost query </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ad7047c1bf4ef4017844f9dd8618bc393a7f687f51692501914a4a62ffc747dd7c"></a>kCoherentAtThisQueryCreation</em>&nbsp;</td><td class="fielddoc"><p>Reference index is updated to reflect model state at the start of this query </td></tr></table></div></div><a class="anchor" id="a9372564f79a53edf4e098b0cf1f810b3"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_r_i_d_x.html#a9372564f79a53edf4e098b0cf1f810b3">IRIDX::QueryType</a></td></tr></table></div><div class="memdoc"><p>Specifies whether changes made to the model are reflected in the reference index state during the lifetime of a query <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9372564f79a53edf4e098b0cf1f810b3a64caba6d8114b2427b364a185dd3bd31"></a>kDynamicQuery</em>&nbsp;</td><td class="fielddoc"><p>None, some, or all of the model changes made during the query lifetime are visible to the query </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a9372564f79a53edf4e098b0cf1f810b3a25cbfb311fcf403b9d9aacd2c0f254f4"></a>kLockedQuery</em>&nbsp;</td><td class="fielddoc"><p>No model changes made during the query lifetime are visible to the query </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="aa027b7b3e3ceb6ff0d1b491354677ef6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_r_i_d_x_query.html">IRIDXQuery</a>* IRIDX::CreateQuery </td><td>(</td><td class="paramtype"><a class="el" href="class_i_r_i_d_x.html#a9372564f79a53edf4e098b0cf1f810b3">QueryType</a>&nbsp;</td><td class="paramname"><em>queryType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_r_i_d_x.html#ad7047c1bf4ef4017844f9dd8618bc393">CoherencyType</a>&nbsp;</td><td class="paramname"><em>coherencyType</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Starts a query operation on the reference index.<p>To query the reference index, call this function. It creates a query and returns a query object that can subsequently be used to interrogate the reference index. The lifetime of the query is the lifetime of the <a class="el" href="class_i_r_i_d_x_query.html">IRIDXQuery</a> object - when the reference count of that object drops to zero the query ends. It is acceptable to aquire one or more additional query objects before the first one is destroyed.<p>There are two considerations when creating a query: The first is where to require coherency (the reference index is said to be coherent when its state reflects exactly that state of the object model). The second is whether object model changes made during a query may be reflected in the reference index state during the query lifetime (a dynamic query) or not (a locked query).<p>When you begin to interrogate the reference index by creating the first outstanding query object, the reference index state must be made coherent by forcing all dirty objects in the database to persist themselves. This is a non-trivial amount of work. After this persistence completes, not all dirty objects may be considered &quot;clean,&quot; and thus the next time you require coherency (even if the model has not changed in between) you will still force some objects to persist themselves - again a non-trivial overhead.<p>When you create a query object, you must specify whether to force the reference index coherent only if this query is the outermost query, or whether to always force it consistent. Prefer usage patterns that only require coherency at the outmost query context. If you need to interrogate the reference index multiple times within a small scope, prefer usage patterns that re-use a query object or keep an active query versus creating a single query, releasing it, create a single query, releasing it, etc..., which adds substantial overhead by repeatedly forcing coherency.<p>If you create a dynamic query, then during the query lifetime if you make changes to the model you may see none, some, or all of your changes reflected in the state of the reference index. This may require some defensive programming to properly handle, but this type of query is the most efficient and permits an arbitrary number of model changes during the query lifetime. Prefer usage patterns that can utilize dynamic queries.<p>If you create a locked query, then any changes you make to the model during the query lifetime are not reflected in the reference index during the query lifetime. The state of the reference index is frozen when the first locked query is created, and remains frozen until the last outstanding locked query is released. However, because an outstanding locked query freezes its state, changing the model will cause change records for the reference index to be queued up in memory and not applied until later no locked queries are actuve. An arbitrarily large number of model changes during a locked query could exhaust memory and cause failure. Future implementations may be capable of spilling change records to disk to avoid this problem.<p>There is no such thing as a &quot;coherent query&quot; - i.e. where the reference index constantly reflects the exact state of the model.<p>It is best to to keep a query object around over a small scope of repeated use, but certainly not much longer than necessary. It is not permissible to keep a query active beyond the end of the outermost executing command or sequence, for example, and this restriction will be enforced via protective shutdown by the architecture.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">queryType</td><td>specifies a locked or dynamic query </td></tr><tr><td class="paramname">coherencyType</td><td>specifies the coherency constraints at the start of the query </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A new query object boss with a reference count of 1. </dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_r_i_d_x_query.html">IRIDXQuery</a></dl></div></div><a class="anchor" id="ac4b7460e43bdf9231f5515c8c5489edd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool IRIDX::HasOutstandingLockedQuery </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determines if there are any outstanding locked queries. <dl class="section return"><dt>Returns<dd>true if locked queries are currently outstanding on the reference index. </dl></div></div><a class="anchor" id="a74eed8871cc6eee3d533797b43c349c9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool IRIDX::HasOutstandingQuery </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determines if there are any outstanding queries (either dynamic or locked). <dl class="section return"><dt>Returns<dd>true if queries of any type are currently outstanding on the reference index. </dl></div></div><a class="anchor" id="a17c5c1c6d5d146ad8515a8ad902524ce"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRIDX::Initialize </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Initalize the reference index for the database. This will create the reference index storage if necessary. This function must be called EVERY TIME a reference indexed database is created or opened (but BEFORE conversion). </div></div><a class="anchor" id="a792b761ec2e9b3b4705c1af4e7dbb06b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRIDX::ProcessScheduledIndexing </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Processes any pending indexing that has been scheduled. This function must be called EVERY TIME a reference indexed database is created or opened (but AFTER conversion). </div></div><a class="anchor" id="aa3266ab11c71cba8b4d3fd02020691f9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool IRIDX::UpdateInProgress </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find out if update is in progress. <dl class="section return"><dt>Returns<dd>true if reference index is updating. Calls like CreateQuery will cause protective shutdown if this is true. </dl></div></div><a class="anchor" id="a64d02c659ea8e216326efffafac1e880"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IRIDX::WontProcessScheduledIndexing </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tells the reference index that we are closing a reference indexed database very early (it&#39;s not going to be saved), that we won&#39;t actually call <a class="el" href="class_i_r_i_d_x.html#a792b761ec2e9b3b4705c1af4e7dbb06b">ProcessScheduledIndexing()</a>, and to suppress the assert it would normally give in that case telling you you forgot the call to <a class="el" href="class_i_r_i_d_x.html#a792b761ec2e9b3b4705c1af4e7dbb06b">ProcessScheduledIndexing()</a>. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_r_i_d_x.html">IRIDX</a><li class="footer">Generated on Sat Sep 22 2018 10:54:26 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
