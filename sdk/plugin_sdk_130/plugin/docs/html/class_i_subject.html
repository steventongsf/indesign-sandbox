<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_subject</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_subject.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_subject-members.html">List of all members</a></div><div class="headertitle"><div class="title">ISubject Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_subject_8h_source.html">ISubject.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ISubject:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_subject.png" usemap="#ISubject_map" /><map id="ISubject_map" name="ISubject_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /><area alt="CSubject" coords="0,112,85,136" href="class_c_subject.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a0da9d5a32c57244782f1762628b68419"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ISUBJECT }</td></tr><tr class="separator:a0da9d5a32c57244782f1762628b68419"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aff58e55279f9282c13a3f27815592723"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723">AttachmentType</a> { <a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723a67f2a539ccf162c5288c70fd7579cad8">kRegularAttachment</a> = 0, <a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723aebafd3a5da76cbb90de71e690ce37c6b">kLazyAttachment</a>, <a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723abb158a6ad810b6b234bddfd0d6a61574">kBothAttachments</a> }</td></tr><tr class="separator:aff58e55279f9282c13a3f27815592723"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a6187c6b3ed20a4b6480cb9a8032f71a1"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a6187c6b3ed20a4b6480cb9a8032f71a1">IsAttached</a> (<a class="el" href="class_i_observer.html">IObserver</a> *observer, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;asObserver=IID_IOBSERVER)=0</td></tr><tr class="separator:a6187c6b3ed20a4b6480cb9a8032f71a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4ef07306ece5c3f2f0f28b56b78ada57"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a4ef07306ece5c3f2f0f28b56b78ada57">AttachObserver</a> (<a class="el" href="class_i_observer.html">IObserver</a> *observer, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;asObserver=IID_IOBSERVER)=0</td></tr><tr class="separator:a4ef07306ece5c3f2f0f28b56b78ada57"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a571b03a9b739fe969d73a235664927fa"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a571b03a9b739fe969d73a235664927fa">DetachObserver</a> (<a class="el" href="class_i_observer.html">IObserver</a> *observer, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;asObserver=IID_IOBSERVER)=0</td></tr><tr class="separator:a571b03a9b739fe969d73a235664927fa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a31c9c940770e9a9a1b286e5a7f48d057"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a31c9c940770e9a9a1b286e5a7f48d057">Change</a> (<a class="el" href="class_i_d_type.html">ClassID</a> theChange, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn=IID_IUNKNOWN, void *changedBy=nil)=0</td></tr><tr class="separator:a31c9c940770e9a9a1b286e5a7f48d057"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a78159f2eaacc485c1207bc007f70d394"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a78159f2eaacc485c1207bc007f70d394">Change</a> (<a class="el" href="class_i_subject.html">ISubject</a> *originalSubject, <a class="el" href="class_i_d_type.html">ClassID</a> theChange, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn=IID_IUNKNOWN, void *changedBy=nil)=0</td></tr><tr class="separator:a78159f2eaacc485c1207bc007f70d394"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a72f3b2da2df0ae1cdf06a072e6dcf4cd"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a72f3b2da2df0ae1cdf06a072e6dcf4cd">Mute</a> (bool16 muteOn)=0</td></tr><tr class="separator:a72f3b2da2df0ae1cdf06a072e6dcf4cd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae6d9753e6cf275601f78ab17dffa0575"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#ae6d9753e6cf275601f78ab17dffa0575">IsMuted</a> () const =0</td></tr><tr class="separator:ae6d9753e6cf275601f78ab17dffa0575"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad398c0fe36d00bd04c80cbadce8393b0"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_change_manager.html">IChangeManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#ad398c0fe36d00bd04c80cbadce8393b0">GetChangeManager</a> () const =0</td></tr><tr class="separator:ad398c0fe36d00bd04c80cbadce8393b0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4a418b40c50b705616b2fb2d84b10e6a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ModelChange</a> (<a class="el" href="class_i_d_type.html">ClassID</a> theChange, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, void *changedBy=nil, <a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> *data=nil)=0</td></tr><tr class="separator:a4a418b40c50b705616b2fb2d84b10e6a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9a5e70fecd537a5d6988bd25891df402"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a9a5e70fecd537a5d6988bd25891df402">ModelChange</a> (<a class="el" href="class_i_subject.html">ISubject</a> *originalSubject, <a class="el" href="class_i_d_type.html">ClassID</a> theChange, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, void *changedBy=nil, <a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> *data=nil)=0</td></tr><tr class="separator:a9a5e70fecd537a5d6988bd25891df402"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a269d736d5b4270d382b57e27fb403d18"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a269d736d5b4270d382b57e27fb403d18">ModelChange</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *model, <a class="el" href="class_i_d_type.html">ClassID</a> theChange, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, void *changedBy=nil, <a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> *data=nil)=0</td></tr><tr class="separator:a269d736d5b4270d382b57e27fb403d18"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8546c7faf5c5ff93c0f6fcfd6a96f0b8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a8546c7faf5c5ff93c0f6fcfd6a96f0b8">IsAttached</a> (<a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723">AttachmentType</a> attachType, <a class="el" href="class_i_observer.html">IObserver</a> *observer, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;asObserver)=0</td></tr><tr class="separator:a8546c7faf5c5ff93c0f6fcfd6a96f0b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a48b81e166bef546189c69ef0beec8504"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#a48b81e166bef546189c69ef0beec8504">AttachObserver</a> (<a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723">AttachmentType</a> attachType, <a class="el" href="class_i_observer.html">IObserver</a> *observer, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;asObserver)=0</td></tr><tr class="separator:a48b81e166bef546189c69ef0beec8504"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:add5a6ae39ebb8b71682e1f46e6e457fd"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_subject.html#add5a6ae39ebb8b71682e1f46e6e457fd">DetachObserver</a> (<a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723">AttachmentType</a> attachType, <a class="el" href="class_i_observer.html">IObserver</a> *observer, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;interestedIn, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;asObserver)=0</td></tr><tr class="separator:add5a6ae39ebb8b71682e1f46e6e457fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><pre class="fragment">This interface provides a notification mechanism for objects that need to be informed 

</pre><p> of changes made to another object; the object being changed is known as the subject, the object being notified is known as the observer (see <a class="el" href="class_i_observer.html">IObserver</a>). When an object is modified, its <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a> or <a class="el" href="class_i_subject.html#a31c9c940770e9a9a1b286e5a7f48d057">ISubject::Change</a> method is called to notify attached observers. There are two kinds of notification, regular notification and lazy notification.<p>Regular notification is initiated by calling <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a> or <a class="el" href="class_i_subject.html#a31c9c940770e9a9a1b286e5a7f48d057">ISubject::Change</a>. This causes <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> methods to be called for observers that are attached to this subject using regular attachment. These observers are called within the scope of change method.<p>Lazy notification is initiated by calling <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a>. In addition to the regular notification described above this also causes <a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a> methods to be called for observers that are attached to this subject using lazy attachment. These observers are not called within the scope of the <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a> method. Instead, a message is queued and these observers are called later on, when the application is idle.<p>Changes to objects which persist in InDesign databases that support undo must be notified using <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a>. For example, if an object in an InDesign document (<a class="el" href="classk_doc_boss.html">kDocBoss</a>) is modified, then <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a> must be called to notify observers. Changes to objects stored in InDesign databases that don&#39;t support undo, or to objects that are not persistent, must be notified using <a class="el" href="class_i_subject.html#a31c9c940770e9a9a1b286e5a7f48d057">ISubject::Change</a>. For example, if a widget object changes state, then <a class="el" href="class_i_subject.html#a31c9c940770e9a9a1b286e5a7f48d057">ISubject::Change</a> is called to notify observers.<p>Consider a typical notification use case for a change to an object stored in an InDesign database that supports undo. A command (<a class="el" href="class_i_command.html">ICommand</a>) modifies the object when its <a class="el" href="class_command.html#a42808d588c09a77a366a26d6cab12138">Command::Do</a> method is called. When the <a class="el" href="class_command.html#ad47e9dc44faf0bd18f3eb73ca8fd04da">Command::DoNotify</a> method is called it calls <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a> which calls observers attached to the object using regular attachment via their <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> method (regular notification). Additionally, the <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a> method queues a message so that observers attached to the subject using lazy attachment get called later on when the application is idle via their <a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a> method (lazy notification). Note: <ul><li> If the object being modified is persists in an InDesign database that supports undo then <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange</a> must be used to notify observers of the change. <li> Lazy notification is also broadcast on undo or redo, therefore, observers must use lazy attachment in order to be called on undo or redo. On subsequent undo or redo of the change the <a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a> method gets called. Note that <b>the <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> method is not called on undo or redo</b>. <li> Lazy notification is the most efficient form of notification to use for updating objects in the user interface. <a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a> gets called once per transaction on the InDesign database since the notification is broadcast after all the changes have been made and the transaction is complete. Contrastingly, <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> may get called several times within a transaction, since the notification is broadcast immediately after the change is made. </ul><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_observer.html">IObserver</a></dl></div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="aff58e55279f9282c13a3f27815592723"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723">ISubject::AttachmentType</a></td></tr></table></div><div class="memdoc"><p>Type of attachment. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aff58e55279f9282c13a3f27815592723a67f2a539ccf162c5288c70fd7579cad8"></a>kRegularAttachment</em>&nbsp;</td><td class="fielddoc"><p>For observers that want regular notification via <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a>. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aff58e55279f9282c13a3f27815592723aebafd3a5da76cbb90de71e690ce37c6b"></a>kLazyAttachment</em>&nbsp;</td><td class="fielddoc"><p>For observers that want lazy notification via <a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a>. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="aff58e55279f9282c13a3f27815592723abb158a6ad810b6b234bddfd0d6a61574"></a>kBothAttachments</em>&nbsp;</td><td class="fielddoc"><p>For observers that want both regular and lazy notification. </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a4ef07306ece5c3f2f0f28b56b78ada57"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::AttachObserver </td><td>(</td><td class="paramtype"><a class="el" href="class_i_observer.html">IObserver</a> *&nbsp;</td><td class="paramname"><em>observer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>asObserver</em> = <code>IID_IOBSERVER</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Attach an observer that uses regular attachment to this subject.<p>Note: this method is equivalent to calling <a class="el" href="class_i_subject.html#a48b81e166bef546189c69ef0beec8504">ISubject::AttachObserver(AttachmentType, IObserver*, const PMIID&amp; interestedIn, const PMIID&amp; asObserver)</a> specifying an attachment type of kRegularAttachment.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">observer</td><td>the observer to be attached </td></tr><tr><td class="paramname">interestedIn</td><td>may be used to narrow the scope of interested changes </td></tr><tr><td class="paramname">asObserver</td><td>must be used if the observer has an interface id that is different than IID_IOBSERVER </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_subject.html#ab968246af34a9c8666970765e3c0deae">CSubject</a>.</div></div><a class="anchor" id="a48b81e166bef546189c69ef0beec8504"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::AttachObserver </td><td>(</td><td class="paramtype"><a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723">AttachmentType</a>&nbsp;</td><td class="paramname"><em>attachType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_observer.html">IObserver</a> *&nbsp;</td><td class="paramname"><em>observer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>asObserver</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Attach the observer using the given attachment type (regular, lazy or both) to this subject. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">attachType</td><td>specifies the type of attachment the observer uses and controls the type of notification it receives, for example regular notification or lazy notification. </td></tr><tr><td class="paramname">observer</td><td>is the observer to be attached </td></tr><tr><td class="paramname">interestedIn</td><td>specifies the scope of interested changes; for example if you are interested in a specific interface on this subject pass the interface id here. </td></tr><tr><td class="paramname">asObserver</td><td>the interface id of the observer </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_subject.html#aa8eb826c09aad0575b1d0c48621e6831">CSubject</a>.</div></div><a class="anchor" id="a31c9c940770e9a9a1b286e5a7f48d057"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::Change </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>theChange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em> = <code>IID_IUNKNOWN</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">void *&nbsp;</td><td class="paramname"><em>changedBy</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Notify observers that are attached to this subject via regular attachment that the object this subject is part of has been changed.<p>This method iterates over the observers that are attached to this subject using regular attachment and calls their <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> method (regular notification).<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">theChange</td><td>is the actual change, often the ClassID of a command </td></tr><tr><td class="paramname">interestedIn</td><td>specifies the interface of the object that was modified </td></tr><tr><td class="paramname">changedBy</td><td>is generic pointer to the object that caused the change, usually a pointer to a command object </td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a></dl><p>Implemented in <a class="el" href="class_c_subject.html#ab5654aaac2dfe68afee8a70a0730a814">CSubject</a>.</div></div><a class="anchor" id="a78159f2eaacc485c1207bc007f70d394"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::Change </td><td>(</td><td class="paramtype"><a class="el" href="class_i_subject.html">ISubject</a> *&nbsp;</td><td class="paramname"><em>originalSubject</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>theChange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em> = <code>IID_IUNKNOWN</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">void *&nbsp;</td><td class="paramname"><em>changedBy</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Notify observers that are attached to this subject via regular attachment that the object this subject is part of has been changed.<p>This method iterates over the observers that are attached to this subject using regular attachment and calls their <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> method (regular notification).<p>The difference between this method and the other Change method is that the object given by the originalSubject parameter is passed into <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> as the subject that was changed, rather than this subject.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">originalSubject</td><td>is the original subject of the object that was changed </td></tr><tr><td class="paramname">theChange</td><td>is the actual change, often the ClassID of a command </td></tr><tr><td class="paramname">interestedIn</td><td>identifies the interface of the object that was modified </td></tr><tr><td class="paramname">changedBy</td><td>is generic pointer to the object that caused the change, usually a pointer to a command object </td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a></dl><p>Implemented in <a class="el" href="class_c_subject.html#a004dee87ffce27d5cc9e7b82d9bec3bc">CSubject</a>.</div></div><a class="anchor" id="a571b03a9b739fe969d73a235664927fa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::DetachObserver </td><td>(</td><td class="paramtype"><a class="el" href="class_i_observer.html">IObserver</a> *&nbsp;</td><td class="paramname"><em>observer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>asObserver</em> = <code>IID_IOBSERVER</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Detach an observer that uses regular attachment from this subject.<p>Note: this method is equivalent to calling <a class="el" href="class_i_subject.html#add5a6ae39ebb8b71682e1f46e6e457fd">ISubject::DetachObserver(AttachmentType, IObserver*, const PMIID&amp; interestedIn, const PMIID&amp; asObserver)</a> specifying an attachment type of kRegularAttachment.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">observer</td><td>the observer to be detached </td></tr><tr><td class="paramname">interestedIn</td><td>identifies the interface in this subject that the observer is attached to </td></tr><tr><td class="paramname">asObserver</td><td>is the interface id of the observer </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_subject.html#a468a6ced4ecea5ee39bfcd3992b322b6">CSubject</a>.</div></div><a class="anchor" id="add5a6ae39ebb8b71682e1f46e6e457fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::DetachObserver </td><td>(</td><td class="paramtype"><a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723">AttachmentType</a>&nbsp;</td><td class="paramname"><em>attachType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_observer.html">IObserver</a> *&nbsp;</td><td class="paramname"><em>observer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>asObserver</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Detach the observer using the given attachment type (regular, lazy or both) from this subject. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">attachType</td><td>specifies the type of attachment </td></tr><tr><td class="paramname">observer</td><td>is the observer to be detached </td></tr><tr><td class="paramname">interestedIn</td><td>identifies the interface in this subject that the observer is attached to </td></tr><tr><td class="paramname">asObserver</td><td>the interface id of the observer </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_subject.html#a20741cdcedeaef829ce2e1a9f16a0485">CSubject</a>.</div></div><a class="anchor" id="ad398c0fe36d00bd04c80cbadce8393b0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_change_manager.html">IChangeManager</a>* ISubject::GetChangeManager </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Access the internal implementation of the notification mechanism. <dl class="section return"><dt>Returns<dd>the change manager interface pointer </dl><p>Implemented in <a class="el" href="class_c_subject.html#a5e2cdf70e9e4ab66bd25296528846d9e">CSubject</a>.</div></div><a class="anchor" id="a6187c6b3ed20a4b6480cb9a8032f71a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISubject::IsAttached </td><td>(</td><td class="paramtype"><a class="el" href="class_i_observer.html">IObserver</a> *&nbsp;</td><td class="paramname"><em>observer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>asObserver</em> = <code>IID_IOBSERVER</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Check whether an observer that uses regular attachment is attached to this subject.<p>Note: this method is equivalent to calling <a class="el" href="class_i_subject.html#a8546c7faf5c5ff93c0f6fcfd6a96f0b8">ISubject::IsAttached(AttachmentType, IObserver*, const PMIID&amp; interestedIn, const PMIID&amp; asObserver)</a> specifying and attachment type of kRegularAttachment.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">observer</td><td>the observer to be checked </td></tr><tr><td class="paramname">interestedIn</td><td>identifies the interface in this subject that the observer is attached to </td></tr><tr><td class="paramname">asObserver</td><td>the interface id of the observer </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the specified observer has been attached </dl><p>Implemented in <a class="el" href="class_c_subject.html#a9282a6db5f14956fa9fcccb4ccb47d28">CSubject</a>.</div></div><a class="anchor" id="a8546c7faf5c5ff93c0f6fcfd6a96f0b8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISubject::IsAttached </td><td>(</td><td class="paramtype"><a class="el" href="class_i_subject.html#aff58e55279f9282c13a3f27815592723">AttachmentType</a>&nbsp;</td><td class="paramname"><em>attachType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_observer.html">IObserver</a> *&nbsp;</td><td class="paramname"><em>observer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>asObserver</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Check whether the observer is attached to this subject. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">attachType</td><td>specifies the type of attachment </td></tr><tr><td class="paramname">observer</td><td>is the observer to be checked </td></tr><tr><td class="paramname">interestedIn</td><td>identifies the interface in this subject that the observer is attached to </td></tr><tr><td class="paramname">asObserver</td><td>the interface id of the observer </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the specified observer is attached, kFalse otherwise </dl><p>Implemented in <a class="el" href="class_c_subject.html#a75ab45cf4de760b43547054b5fefd702">CSubject</a>.</div></div><a class="anchor" id="ae6d9753e6cf275601f78ab17dffa0575"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISubject::IsMuted </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue if this subject is muted. <p>Implemented in <a class="el" href="class_c_subject.html#ac294b65f0352044d1db05272b061ed2e">CSubject</a>.</div></div><a class="anchor" id="a4a418b40c50b705616b2fb2d84b10e6a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::ModelChange </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>theChange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">void *&nbsp;</td><td class="paramname"><em>changedBy</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> *&nbsp;</td><td class="paramname"><em>data</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Notify observers that are attached to this subject via regular or lazy attachment that the object this subject is part of has been changed; this is the ModelChange method you probably want to call.<p>This method iterates over the observers that are attached to this subject using regular attachment and calls their <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> method (regular notification). Additionally, this method queues a message so that observers that are attached to the subject using lazy attachment get called later on when the application is idle via their <a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a> method (lazy notification).<dl class="section pre"><dt>Precondition<dd>this subject must be part of an InDesign database that supports undo </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">theChange</td><td>is the actual change, often the ClassID of a command </td></tr><tr><td class="paramname">interestedIn</td><td>identifies the interface of the object that was modified </td></tr><tr><td class="paramname">changedBy</td><td>pointer to the object that caused the change, usually a pointer to a command object </td></tr><tr><td class="paramname">data</td><td>contains additional information about the change, nil otherwise; see <a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> for documentation. </td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a><dd><a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a></dl><p>Implemented in <a class="el" href="class_c_subject.html#a5189589d3a23367a1ccfd999b3799984">CSubject</a>.</div></div><a class="anchor" id="a9a5e70fecd537a5d6988bd25891df402"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::ModelChange </td><td>(</td><td class="paramtype"><a class="el" href="class_i_subject.html">ISubject</a> *&nbsp;</td><td class="paramname"><em>originalSubject</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>theChange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">void *&nbsp;</td><td class="paramname"><em>changedBy</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> *&nbsp;</td><td class="paramname"><em>data</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Notify observers that are attached to this subject via regular or lazy attachment that the object this subject is part of has been changed. Only use this method if you are sure you cannot use <a class="el" href="class_i_subject.html#a4a418b40c50b705616b2fb2d84b10e6a">ISubject::ModelChange(ClassID, const PMIID&amp;, void*, LazyNotificationData*)</a>.<p>This method passes the object given by the originalSubject parameter to <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> as the subject that was changed, rather than this subject. However, the originalSubject is not available when <a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a> is called. When the lazy notification occurs, this subject is passed to <a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a>. If you need access to originalSubject, do so in the <a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a> method.<dl class="section pre"><dt>Precondition<dd>this subject must be part of an InDesign database that supports undo </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">originalSubject</td><td>is the original subject of the object that was changed </td></tr><tr><td class="paramname">theChange</td><td>is the actual change, often the ClassID of a command </td></tr><tr><td class="paramname">interestedIn</td><td>identifies the interface of the object that was modified </td></tr><tr><td class="paramname">changedBy</td><td>is generic pointer to the object that caused the change, usually a pointer to a command object </td></tr><tr><td class="paramname">data</td><td>contains additional information about the change, nil otherwise; see <a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> for documentation. </td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_observer.html#aa0c8392d926684cf1000b2e902aa7a6e">IObserver::Update</a><dd><a class="el" href="class_i_observer.html#a60b1c9b1dcb9bc7d31083d7a7e840e72">IObserver::LazyUpdate</a></dl><p>Implemented in <a class="el" href="class_c_subject.html#a6f4d6d21141285d148041f0abb458a5a">CSubject</a>.</div></div><a class="anchor" id="a269d736d5b4270d382b57e27fb403d18"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::ModelChange </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>theChange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>interestedIn</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">void *&nbsp;</td><td class="paramname"><em>changedBy</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> *&nbsp;</td><td class="paramname"><em>data</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Use of this method is very rare. Call one of the other ModelChange methods unless you are sure this one is the right one for your use case. It is used to notify that a &quot;snapshot view interface&quot; has changed. For example, the layout widget uses this method to notify that <a class="el" href="class_i_layout_control_data.html">ILayoutControlData</a> has changed. <a class="el" href="class_i_layout_control_data.html">ILayoutControlData</a> is implemented as a &quot;snapshot view interface&quot; and change to this interface must get undone and redone as changes to the document being viewed get undone and redone.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">model</td><td>pointer to an InDesign database that supports undo </td></tr><tr><td class="paramname">theChange</td><td>is the actual change, often the ClassID of a command </td></tr><tr><td class="paramname">interestedIn</td><td>identifies the interface of the object that was modified </td></tr><tr><td class="paramname">changedBy</td><td>is generic pointer to the object that caused the change, usually a pointer to a command object </td></tr><tr><td class="paramname">data</td><td>contains additional information about the change, nil otherwise; see <a class="el" href="class_lazy_notification_data.html">LazyNotificationData</a> for documentation.</td></tr></table></dl><dl class="section see"><dt>See Also<dd>CREATE_VIEW_PMINTERFACE in &quot;InterfaceFactory.h&quot;. <dd> &quot;Snapshot view interface&quot; extension pattern documentation in the Programming Guide </dl><p>Implemented in <a class="el" href="class_c_subject.html#a1756378470cba6ced9656be42c02d2fc">CSubject</a>.</div></div><a class="anchor" id="a72f3b2da2df0ae1cdf06a072e6dcf4cd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISubject::Mute </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>muteOn</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Mutes all messages from this object. Muting a subject allows you to make changes to the object without notifying its observers. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">muteOn</td><td>if kTrue, turns mute on; if kFalse, turns mute off </td></tr></table></dl><p>Implemented in <a class="el" href="class_c_subject.html#a06f3979d3b403dc31f3e8dc52c911f17">CSubject</a>.</div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_subject.html">ISubject</a><li class="footer">Generated on Sat Sep 22 2018 10:54:29 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
