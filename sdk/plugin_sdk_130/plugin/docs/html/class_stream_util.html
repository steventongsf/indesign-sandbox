<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_stream_util</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_stream_util.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-static-methods">Static Public Member Functions</a> | <a href="class_stream_util-members.html">List of all members</a></div><div class="headertitle"><div class="title">StreamUtil Class Reference</div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_stream_util_8h_source.html">StreamUtil.h</a>&gt;</code><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a> Static Public Member Functions</h2></td></tr><tr class="memitem:ac2aa8f9ca2f53089f702b7492fee8c26"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#ac2aa8f9ca2f53089f702b7492fee8c26">CreateDBStreamRead</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, <a class="el" href="class_i_d_type.html">UID</a> id)</td></tr><tr class="separator:ac2aa8f9ca2f53089f702b7492fee8c26"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a789f09811c984f5f818d829ba2154e69"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#a789f09811c984f5f818d829ba2154e69">CreateDBStreamWrite</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, <a class="el" href="class_i_d_type.html">UID</a> id)</td></tr><tr class="separator:a789f09811c984f5f818d829ba2154e69"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a61333af93828093f1c6c3a4f29844a14"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#a61333af93828093f1c6c3a4f29844a14">CreateCopyStream</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *src, <a class="el" href="class_i_data_base.html">IDataBase</a> *dest, <a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> *xfer=nil)</td></tr><tr class="separator:a61333af93828093f1c6c3a4f29844a14"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad7eca167c485f5c0bcaa32176442e9eb"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#ad7eca167c485f5c0bcaa32176442e9eb">CreateDBStreamCopy</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *src, <a class="el" href="class_i_data_base.html">IDataBase</a> *dest, <a class="el" href="class_i_d_type.html">UID</a> id, <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *pmobject=nil)</td></tr><tr class="separator:ad7eca167c485f5c0bcaa32176442e9eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a143eae941e19ccb63bb917e4ba844302"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#a143eae941e19ccb63bb917e4ba844302">CreateFileStreamRead</a> (const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;sysFile, uint32 mode=kOpenIn, OSType fileType=0x3f3f3f3f, OSType creator=0x3f3f3f3f)</td></tr><tr class="separator:a143eae941e19ccb63bb917e4ba844302"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab2bce1400b762d2405989c18945088bd"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#ab2bce1400b762d2405989c18945088bd">CreateFileStreamWrite</a> (const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;sysFile, uint32 mode=kOpenOut, OSType fileType=0x3f3f3f3f, OSType creator=0x3f3f3f3f)</td></tr><tr class="separator:ab2bce1400b762d2405989c18945088bd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac135f17a394892d585b8b827cb6bf7ff"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#ac135f17a394892d585b8b827cb6bf7ff">CreateFileStreamReadLazy</a> (const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;sysFile, uint32 mode=kOpenIn, OSType fileType=0x3f3f3f3f, OSType creator=0x3f3f3f3f)</td></tr><tr class="separator:ac135f17a394892d585b8b827cb6bf7ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1564777241a891e7420b4551838704d1"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#a1564777241a891e7420b4551838704d1">CreateFileStreamWriteLazy</a> (const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;sysFile, uint32 mode=kOpenOut|kOpenTrunc, OSType fileType=0x3f3f3f3f, OSType creator=0x3f3f3f3f)</td></tr><tr class="separator:a1564777241a891e7420b4551838704d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab97b0b688cc03fb3e143307762e21a8b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab97b0b688cc03fb3e143307762e21a8b"></a> static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>CreateObjectTextFileStreamWrite</b> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;sysFile, uint32 mode=kOpenOut, OSType fileType=0x3f3f3f3f, OSType creator=0x3f3f3f3f)</td></tr><tr class="separator:ab97b0b688cc03fb3e143307762e21a8b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab35cc1a8fa18119dfb8dbbd6bd08210e"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#ab35cc1a8fa18119dfb8dbbd6bd08210e">CreateResourceStreamRead</a> (const <a class="el" href="class_rsrc_spec.html">RsrcSpec</a> &amp;spec, bool16 useLocaleIndexResource=kTrue)</td></tr><tr class="separator:ab35cc1a8fa18119dfb8dbbd6bd08210e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5c9c561677caf681f64234f58ddd08e0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5c9c561677caf681f64234f58ddd08e0"></a> static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>CreateObjectResourceStreamRead</b> (const <a class="el" href="class_rsrc_spec.html">RsrcSpec</a> &amp;spec, <a class="el" href="class_i_data_base.html">IDataBase</a> *db)</td></tr><tr class="separator:a5c9c561677caf681f64234f58ddd08e0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aee9cfd3b23d6bb62d0dec8f369a53095"><td align="right" class="memItemLeft" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#aee9cfd3b23d6bb62d0dec8f369a53095">ResetStreamContentsChanged</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *)</td></tr><tr class="separator:aee9cfd3b23d6bb62d0dec8f369a53095"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1c6ab347505324031af10525be776b6a"><td align="right" class="memItemLeft" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#a1c6ab347505324031af10525be776b6a">SetStreamContentsChanged</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *)</td></tr><tr class="separator:a1c6ab347505324031af10525be776b6a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aba7860b12b6c8942d649cc67cc7216ce"><td align="right" class="memItemLeft" valign="top">static bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#aba7860b12b6c8942d649cc67cc7216ce">StreamContentsChanged</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *)</td></tr><tr class="separator:aba7860b12b6c8942d649cc67cc7216ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Bauhaus managed streams</div></td></tr><tr class="memitem:aa0799c2ea9a40c6ef6c71ece4666de83"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#aa0799c2ea9a40c6ef6c71ece4666de83">CreateManagedFileStreamRead</a> (const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;sysFile, uint32 mode=kOpenIn, OSType fileType=0x3f3f3f3f, OSType creator=0x3f3f3f3f)</td></tr><tr class="separator:aa0799c2ea9a40c6ef6c71ece4666de83"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aebc6b5f09d0bd719f752ba871d7dacb5"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#aebc6b5f09d0bd719f752ba871d7dacb5">CreateManagedFileStreamReadLazy</a> (const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;sysFile, uint32 mode=kOpenIn, OSType fileType=0x3f3f3f3f, OSType creator=0x3f3f3f3f)</td></tr><tr class="separator:aebc6b5f09d0bd719f752ba871d7dacb5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Memory-based streams</div></td></tr><tr class="memitem:ab253b4bd8b29599e0d65ea0a7f4a01fe"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#ab253b4bd8b29599e0d65ea0a7f4a01fe">CreatePointerStreamRead</a> (char *buffer, size_t len)</td></tr><tr class="separator:ab253b4bd8b29599e0d65ea0a7f4a01fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a62c35a16ba9c3f5922fa9af6ca442954"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#a62c35a16ba9c3f5922fa9af6ca442954">CreatePointerStreamWrite</a> (char *buffer, size_t len)</td></tr><tr class="separator:a62c35a16ba9c3f5922fa9af6ca442954"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac7c73ca1adb27cd4193bd95a7290c38e"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#ac7c73ca1adb27cd4193bd95a7290c38e">CreateMemoryStreamRead</a> (<a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> *underlyingXferBytes, bool16 takeOwnership=kFalse, bool16 recycleBoss=kTrue)</td></tr><tr class="separator:ac7c73ca1adb27cd4193bd95a7290c38e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a950d543b564db1498237bcbfd962f40c"><td align="right" class="memItemLeft" valign="top">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_stream_util.html#a950d543b564db1498237bcbfd962f40c">CreateMemoryStreamWrite</a> (<a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> *underlyingXferBytes, bool16 takeOwnership=kFalse, bool16 recycleBoss=kTrue)</td></tr><tr class="separator:a950d543b564db1498237bcbfd962f40c"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><pre class="fragment">StreamUtil is a class of static functions that create and manipulate InDesign streams.

It is provided for convenience and ease of use.



Note that any of the create stream methods will return nil if there is an error 

creating a stream (e.g., file cannot be opened, etc.). So client code should check

for nil on return.



Example Code:

</pre> <pre>

        <a class="el" href="class_interface_ptr.html">InterfacePtr&lt;IPMStream&gt;</a> s(StreamUtil::CreateFileStreamRead(myFile));

        if (s)  {

            // read from file

        }

        else {

            // handle error

</pre> <pre class="fragment">Also, in all cases, the stream returned is a referenced object, and the caller is

responsible for releasing it. Typically this is handled via InterfacePtr, as in 

the example above.</pre></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a61333af93828093f1c6c3a4f29844a14"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateCopyStream </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>src</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> *&nbsp;</td><td class="paramname"><em>xfer</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>For internal use only. Open a stream for copying a database record.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">src</td><td>database to copy from </td></tr><tr><td class="paramname">dest</td><td>database to copy to </td></tr><tr><td class="paramname">IXerBytes*</td><td>the handler to use for the copy </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the stream cannot be opened. </dl></div></div><a class="anchor" id="ad7eca167c485f5c0bcaa32176442e9eb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateDBStreamCopy </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>src</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>dest</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>id</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>pmobject</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>For internal use only. Copy a uid from the src database into a new object in the destination database.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">src</td><td>database to copy from </td></tr><tr><td class="paramname">dest</td><td>database to copy to </td></tr><tr><td class="paramname">dest</td><td>object to copy to </td></tr><tr><td class="paramname">pmobject</td><td>used in translating UIDs during the copy (for internal use only) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the stream cannot be opened. </dl></div></div><a class="anchor" id="ac2aa8f9ca2f53089f702b7492fee8c26"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateDBStreamRead </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>id</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for reading a database object<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">db</td><td>what database the object is in </td></tr><tr><td class="paramname">UID</td><td>the object in the database to access </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the stream cannot be opened. </dl></div></div><a class="anchor" id="a789f09811c984f5f818d829ba2154e69"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateDBStreamWrite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>id</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for writing a database record.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">db</td><td>what database the object is in </td></tr><tr><td class="paramname">UID</td><td>the object in the database to access </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the stream cannot be opened. </dl></div></div><a class="anchor" id="a143eae941e19ccb63bb917e4ba844302"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateFileStreamRead </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;&nbsp;</td><td class="paramname"><em>sysFile</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>mode</em> = <code>kOpenIn</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>fileType</em> = <code>0x3f3f3f3f</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>creator</em> = <code>0x3f3f3f3f</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for reading from a file.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sysFile</td><td>the file to read from </td></tr><tr><td class="paramname">mode</td><td>mode for opening the file (open for read, read/write, etc.) </td></tr><tr><td class="paramname">fileType</td><td>on Macintosh, this is the Finder file type </td></tr><tr><td class="paramname">creator</td><td>on Macintosh, this the Finder creator type </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the file couldn&#39;t be opened. </dl></div></div><a class="anchor" id="ac135f17a394892d585b8b827cb6bf7ff"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateFileStreamReadLazy </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;&nbsp;</td><td class="paramname"><em>sysFile</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>mode</em> = <code>kOpenIn</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>fileType</em> = <code>0x3f3f3f3f</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>creator</em> = <code>0x3f3f3f3f</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for reading from a file. The file is opened on demand, the first time a read is requested. Note that in this case, you may get back a valid stream from the CreateFileStreamReadLazy method, but the file hasn&#39;t yet been opened. It will be opened as the result of a subsequent read request. If the open fails, the stream will go into an error state<dl class="section see"><dt>See Also<dd>GetStreamState. Client code should check for this.</dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sysFile</td><td>the file to read from </td></tr><tr><td class="paramname">mode</td><td>mode for opening the file (open for read, read/write, etc.) </td></tr><tr><td class="paramname">fileType</td><td>on Macintosh, this is the Finder file type </td></tr><tr><td class="paramname">creator</td><td>on Macintosh, this the Finder creator type </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the file couldn&#39;t be opened. </dl></div></div><a class="anchor" id="ab2bce1400b762d2405989c18945088bd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateFileStreamWrite </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;&nbsp;</td><td class="paramname"><em>sysFile</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>mode</em> = <code>kOpenOut</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>fileType</em> = <code>0x3f3f3f3f</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>creator</em> = <code>0x3f3f3f3f</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for writing to a file.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sysFile</td><td>the file to read from </td></tr><tr><td class="paramname">mode</td><td>mode for opening the file (open for read, read/write, etc.) </td></tr><tr><td class="paramname">fileType</td><td>on Macintosh, this is the Finder file type </td></tr><tr><td class="paramname">creator</td><td>on Macintosh, this the Finder creator type </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the file couldn&#39;t be opened. </dl></div></div><a class="anchor" id="a1564777241a891e7420b4551838704d1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateFileStreamWriteLazy </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;&nbsp;</td><td class="paramname"><em>sysFile</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>mode</em> = <code>kOpenOut|kOpenTrunc</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>fileType</em> = <code>0x3f3f3f3f</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>creator</em> = <code>0x3f3f3f3f</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for writing to a file. The file is opened on demand, the first time a write is requested. Note that in this case, you may get back a valid stream from the CreateFileStreamWriteLazy method, but the file hasn&#39;t yet been opened. It will be opened as the result of a subsequent write request. If the open fails, the stream will go into an error state<dl class="section see"><dt>See Also<dd>GetStreamState. Client code should check for this.</dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sysFile</td><td>the file to read from </td></tr><tr><td class="paramname">mode</td><td>mode for opening the file (open for read, read/write, etc.) </td></tr><tr><td class="paramname">fileType</td><td>on Macintosh, this is the Finder file type </td></tr><tr><td class="paramname">creator</td><td>on Macintosh, this the Finder creator type </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the file couldn&#39;t be opened. </dl></div></div><a class="anchor" id="aa0799c2ea9a40c6ef6c71ece4666de83"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateManagedFileStreamRead </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;&nbsp;</td><td class="paramname"><em>sysFile</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>mode</em> = <code>kOpenIn</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>fileType</em> = <code>0x3f3f3f3f</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>creator</em> = <code>0x3f3f3f3f</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for reading from a file, downloads the file if it&#39;s not already in local repository. Returns nil if file cannot be opened. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sysFile</td><td>the file to read from </td></tr><tr><td class="paramname">mode</td><td>mode for opening the file (open for read, read/write, etc.) </td></tr><tr><td class="paramname">fileType</td><td>on Macintosh, this is the Finder file type </td></tr><tr><td class="paramname">creator</td><td>on Macintosh, this the Finder creator type </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the file couldn&#39;t be opened. </dl></div></div><a class="anchor" id="aebc6b5f09d0bd719f752ba871d7dacb5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateManagedFileStreamReadLazy </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_d_file.html">IDFile</a> &amp;&nbsp;</td><td class="paramname"><em>sysFile</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>mode</em> = <code>kOpenIn</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>fileType</em> = <code>0x3f3f3f3f</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">OSType&nbsp;</td><td class="paramname"><em>creator</em> = <code>0x3f3f3f3f</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for reading from a file. File is actually opened on demand, the first time a read is requested. Downloads the file if it&#39;s not already in local repository. Returns nil if file cannot be opened. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">sysFile</td><td>the file to read from </td></tr><tr><td class="paramname">mode</td><td>mode for opening the file (open for read, read/write, etc.) </td></tr><tr><td class="paramname">fileType</td><td>on Macintosh, this is the Finder file type </td></tr><tr><td class="paramname">creator</td><td>on Macintosh, this the Finder creator type </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream, or nil if the file couldn&#39;t be opened. </dl></div></div><a class="anchor" id="ac7c73ca1adb27cd4193bd95a7290c38e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateMemoryStreamRead </td><td>(</td><td class="paramtype"><a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> *&nbsp;</td><td class="paramname"><em>underlyingXferBytes</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>takeOwnership</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>recycleBoss</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for reading from memory. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">underlyingXferBytes</td><td><a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> instance the memory stream will read from. </td></tr><tr><td class="paramname">takeOwnership</td><td>Denotes whether the stream is to be the sole owner of the given <a class="el" href="class_i_xfer_bytes.html">IXferBytes</a>. </td></tr><tr><td class="paramname">recycleBoss</td><td>Denotes whether to utilize a recycle boss for the stream.\ If the underlying <a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> must be released to free up resources, a file for instance, it is recommended to not use a recycle boss since the <a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> might not be released until the stream boss is reused. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new read stream </dl></div></div><a class="anchor" id="a950d543b564db1498237bcbfd962f40c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateMemoryStreamWrite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> *&nbsp;</td><td class="paramname"><em>underlyingXferBytes</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>takeOwnership</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>recycleBoss</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for writing to memory. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">underlyingXferBytes</td><td><a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> instance the memory stream will write to. </td></tr><tr><td class="paramname">takeOwnership</td><td>Denotes whether the stream is to be the sole owner of the given <a class="el" href="class_i_xfer_bytes.html">IXferBytes</a>. </td></tr><tr><td class="paramname">recycleBoss</td><td>Denotes whether to utilize a recycle boss for the stream.\ If the underlying <a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> must be released to free up resources, a file for instance, it is recommended to not use a recycle boss since the <a class="el" href="class_i_xfer_bytes.html">IXferBytes</a> might not be released until the stream boss is reused. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new write stream </dl></div></div><a class="anchor" id="ab253b4bd8b29599e0d65ea0a7f4a01fe"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreatePointerStreamRead </td><td>(</td><td class="paramtype">char *&nbsp;</td><td class="paramname"><em>buffer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">size_t&nbsp;</td><td class="paramname"><em>len</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for reading from memory.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">buffer</td><td>memory address to start reading from </td></tr><tr><td class="paramname">len</td><td>number of bytes to read</td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream. </dl></div></div><a class="anchor" id="a62c35a16ba9c3f5922fa9af6ca442954"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreatePointerStreamWrite </td><td>(</td><td class="paramtype">char *&nbsp;</td><td class="paramname"><em>buffer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">size_t&nbsp;</td><td class="paramname"><em>len</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for writing to memory.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">buffer</td><td>memory address to start writing to </td></tr><tr><td class="paramname">len</td><td>number of bytes that can be written before end of stream</td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream </dl></div></div><a class="anchor" id="ab35cc1a8fa18119dfb8dbbd6bd08210e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static <a class="el" href="class_i_p_m_stream.html">IPMStream</a>* StreamUtil::CreateResourceStreamRead </td><td>(</td><td class="paramtype">const <a class="el" href="class_rsrc_spec.html">RsrcSpec</a> &amp;&nbsp;</td><td class="paramname"><em>spec</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>useLocaleIndexResource</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Open a stream for reading from a resource.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">spec</td><td>a descriptor of the resource to read </td></tr><tr><td class="paramname">useLocaleIndexResource</td><td>kTrue to use a localized resource</td></tr></table></dl><dl class="section return"><dt>Returns<dd>IPMStream* the new stream </dl></div></div><a class="anchor" id="aee9cfd3b23d6bb62d0dec8f369a53095"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static void StreamUtil::ResetStreamContentsChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>The following functions are used for verifying stream contents. They is debugging only because they are used to control assertions. There&#39;s an assert that comes up if an object has been modified, but Dirty() was never called on it (&quot;object changed but not marked dirty&quot;). The assert is for early detection of cases which could cause document corruption, but it does come up in some situations that are actually OK. For example, if your code does dynamic conversion of data, so that it gets converted when its read in, it would get this assert but be OK. Or if it writes out the current time. In any case, you can set a flag on the stream that causes the assert not to fire. From your ReadWrite, in the case where you&#39;re writing out, call SetStreamContentsChanged, and the assert will not come up.Set the stream back to normal after a call to SetStreamContentsChanged. Does nothing in Release target.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>the stream to set </td></tr></table></dl></div></div><a class="anchor" id="a1c6ab347505324031af10525be776b6a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static void StreamUtil::SetStreamContentsChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Set the stream to &quot;changes expected&quot; to prevent the assert from firing. Does nothing in Release target.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>the stream to set </td></tr></table></dl></div></div><a class="anchor" id="aba7860b12b6c8942d649cc67cc7216ce"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static bool16 StreamUtil::StreamContentsChanged </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span></td></tr></table></div><div class="memdoc"><p>Get the stream to &quot;changes expected&quot; to see if the assert should fire. Does nothing in Release target. Internal Use Only.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>the stream to set </td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 return true if the stream has changes expected </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_stream_util.html">StreamUtil</a><li class="footer">Generated on Sat Sep 22 2018 10:56:31 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
