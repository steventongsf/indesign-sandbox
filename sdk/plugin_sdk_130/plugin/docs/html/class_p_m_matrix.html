<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_p_m_matrix</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_p_m_matrix.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="#pub-static-attribs">Static Public Attributes</a> | <a href="#friends">Friends</a> | <a href="class_p_m_matrix-members.html">List of all members</a></div><div class="headertitle"><div class="title">PMMatrix Class Reference</div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_p_m_matrix_8h_source.html">PMMatrix.h</a>&gt;</code><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a6bc67284847f231f0afff84232091854"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>TransformFactorOrder</b> { <b>kFactorOrder_SKRT</b> = 0, <b>kFactorOrder_RKST</b> = 14, <b>kFactorOrder_End</b> }</td></tr><tr class="separator:a6bc67284847f231f0afff84232091854"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab41f32b4d76421d870ecc437c3d71972"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab41f32b4d76421d870ecc437c3d71972"></a> typedef <a class="el" href="structbase__type.html">base_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>data_type</b></td></tr><tr class="separator:ab41f32b4d76421d870ecc437c3d71972"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a9950e2990b39e2f3116897130a0a0bf5"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a9950e2990b39e2f3116897130a0a0bf5">ReadWrite</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *s)</td></tr><tr class="separator:a9950e2990b39e2f3116897130a0a0bf5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a33e6b99f17ab5deb287122f2d57fe01d"><td align="right" class="memItemLeft" valign="top">constexpr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a33e6b99f17ab5deb287122f2d57fe01d">PMMatrix</a> () noexcept</td></tr><tr class="separator:a33e6b99f17ab5deb287122f2d57fe01d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5d2200e5be0e97653639dbc77c73081c"><td align="right" class="memItemLeft" valign="top">constexpr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a5d2200e5be0e97653639dbc77c73081c">PMMatrix</a> (<a class="el" href="class_p_m_real.html">PMReal</a> a, <a class="el" href="class_p_m_real.html">PMReal</a> b, <a class="el" href="class_p_m_real.html">PMReal</a> c, <a class="el" href="class_p_m_real.html">PMReal</a> d, <a class="el" href="class_p_m_real.html">PMReal</a> e, <a class="el" href="class_p_m_real.html">PMReal</a> f) noexcept</td></tr><tr class="separator:a5d2200e5be0e97653639dbc77c73081c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a339e3e81c89924288e40ae686ad13c70"><td align="right" class="memItemLeft" valign="top">constexpr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a339e3e81c89924288e40ae686ad13c70">PMMatrix</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m) noexcept=default</td></tr><tr class="separator:a339e3e81c89924288e40ae686ad13c70"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1cc39d6c67e8efc2920b1bd482cfbc9f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1cc39d6c67e8efc2920b1bd482cfbc9f"></a> constexpr&nbsp;</td><td class="memItemRight" valign="bottom"><b>PMMatrix</b> (<a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&amp;m) noexcept=default</td></tr><tr class="separator:a1cc39d6c67e8efc2920b1bd482cfbc9f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a353cdb26f9dd13ad490e04010d344acd"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a353cdb26f9dd13ad490e04010d344acd">PMMatrix</a> (const BRVCoordMatrix &amp;m)</td></tr><tr class="separator:a353cdb26f9dd13ad490e04010d344acd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a70c1b8c43d819025eb24c8a06069c5ee"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a70c1b8c43d819025eb24c8a06069c5ee">operator=</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m) noexcept=default</td></tr><tr class="separator:a70c1b8c43d819025eb24c8a06069c5ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afa80ae445cfc9e5bb4a38e8fac1600b0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="afa80ae445cfc9e5bb4a38e8fac1600b0"></a> <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&amp;m) noexcept=default</td></tr><tr class="separator:afa80ae445cfc9e5bb4a38e8fac1600b0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a310ce9fa9260b72a0ac4045305a8ce8e"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a310ce9fa9260b72a0ac4045305a8ce8e">SetMatrix</a> (const BRVCoordMatrix &amp;m)</td></tr><tr class="separator:a310ce9fa9260b72a0ac4045305a8ce8e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aadd86cbebdb255243b2d834087dae9d5"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#aadd86cbebdb255243b2d834087dae9d5">SetMatrix</a> (const _t_BRVFixedMatrix &amp;m)</td></tr><tr class="separator:aadd86cbebdb255243b2d834087dae9d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a219e43750bd313cacf3c269d46054221"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a219e43750bd313cacf3c269d46054221">SetMatrix</a> (const <a class="el" href="classdvacore_1_1geom_1_1_scale_matrix_t.html">dvacore::geom::ScaleMatrixT</a>&lt; float &gt; &amp;m)</td></tr><tr class="separator:a219e43750bd313cacf3c269d46054221"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1509d9e1caed9b02e5744ca07e7cdb0f"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a1509d9e1caed9b02e5744ca07e7cdb0f">GetAGMFixedMatrix</a> (_t_BRVFixedMatrix *retMatrix) const </td></tr><tr class="separator:a1509d9e1caed9b02e5744ca07e7cdb0f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a74df435da95339e34eb8d691f2e76bc3"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a74df435da95339e34eb8d691f2e76bc3">GetAGMFloatMatrix</a> (BRVCoordMatrix *retMatrix) const </td></tr><tr class="separator:a74df435da95339e34eb8d691f2e76bc3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa82a72f7d0c4e6ef9319d93255ffd8fe"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#aa82a72f7d0c4e6ef9319d93255ffd8fe">GetUIMatrixF32</a> (<a class="el" href="classdvacore_1_1geom_1_1_scale_matrix_t.html">dvacore::geom::ScaleMatrixT</a>&lt; float &gt; *retMatrix) const </td></tr><tr class="separator:aa82a72f7d0c4e6ef9319d93255ffd8fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac47e66ae3a6a85eee6c97452ef800369"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#ac47e66ae3a6a85eee6c97452ef800369">operator==</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;other) const </td></tr><tr class="separator:ac47e66ae3a6a85eee6c97452ef800369"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7d85b297b44b07d833bdee3ea36c6e2a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7d85b297b44b07d833bdee3ea36c6e2a"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;other) const </td></tr><tr class="separator:a7d85b297b44b07d833bdee3ea36c6e2a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af39f3ad78f00fc07561b5d8bbb2ba866"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#af39f3ad78f00fc07561b5d8bbb2ba866">operator&lt;</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;other) const </td></tr><tr class="separator:af39f3ad78f00fc07561b5d8bbb2ba866"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3eeb6b60c78c39697a66ceaaa529b480"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a3eeb6b60c78c39697a66ceaaa529b480">Transform</a> (<a class="el" href="class_p_m_real.html">PMReal</a> *x, <a class="el" href="class_p_m_real.html">PMReal</a> *y) const </td></tr><tr class="separator:a3eeb6b60c78c39697a66ceaaa529b480"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:add83f701bd0fd3894cd7c3e7362a0234"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="add83f701bd0fd3894cd7c3e7362a0234"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Transform</b> (<a class="el" href="class_p_m_point.html">PMPoint</a> *p) const </td></tr><tr class="separator:add83f701bd0fd3894cd7c3e7362a0234"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a55eb15ad8910c13f59e4f0272df9344e"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a55eb15ad8910c13f59e4f0272df9344e">Transform</a> (<a class="el" href="class_p_m_polygon4.html">PMPolygon4</a> *fourPoints) const </td></tr><tr class="separator:a55eb15ad8910c13f59e4f0272df9344e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab3d63da867ea66cd44e5a95674982bc0"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#ab3d63da867ea66cd44e5a95674982bc0">Transform</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> *rect) const </td></tr><tr class="separator:ab3d63da867ea66cd44e5a95674982bc0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a514aa8381c6011ab281315e24acb095a"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a514aa8381c6011ab281315e24acb095a">Transform</a> (<a class="el" href="class_p_m_line_seg.html">PMLineSeg</a> *segment) const </td></tr><tr class="separator:a514aa8381c6011ab281315e24acb095a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3a0bc0429323a3cd4d17bbe45aeabf71"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a3a0bc0429323a3cd4d17bbe45aeabf71">operator[]</a> (int index) const </td></tr><tr class="separator:a3a0bc0429323a3cd4d17bbe45aeabf71"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a79afadcc9a314d3fc310a8fd577f75f1"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a79afadcc9a314d3fc310a8fd577f75f1">IsIdentity</a> () const noexcept</td></tr><tr class="separator:a79afadcc9a314d3fc310a8fd577f75f1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7d9cd466c8c4e3c98c6aafaec24d3ef4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7d9cd466c8c4e3c98c6aafaec24d3ef4"></a> bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>exactly_identity</b> () const noexcept</td></tr><tr class="separator:a7d9cd466c8c4e3c98c6aafaec24d3ef4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1463e7fb3d8e84f29bffa1a54829c20a"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a1463e7fb3d8e84f29bffa1a54829c20a">ResetToIdentity</a> () noexcept</td></tr><tr class="separator:a1463e7fb3d8e84f29bffa1a54829c20a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad19bd2b9086825a86d2aa5d74731ebd0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#ad19bd2b9086825a86d2aa5d74731ebd0">Determinant</a> () const </td></tr><tr class="separator:ad19bd2b9086825a86d2aa5d74731ebd0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a33f21177a5bbbb14d88a3f58fb8db080"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a33f21177a5bbbb14d88a3f58fb8db080">IsSingular</a> () const </td></tr><tr class="separator:a33f21177a5bbbb14d88a3f58fb8db080"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9f08c5d0e50bb6930a60e84a386c12c8"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a9f08c5d0e50bb6930a60e84a386c12c8">PreservesBoxes</a> () const </td></tr><tr class="separator:a9f08c5d0e50bb6930a60e84a386c12c8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0c89605222f684d30808a801c244ffb2"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a0c89605222f684d30808a801c244ffb2">Invert</a> ()</td></tr><tr class="separator:a0c89605222f684d30808a801c244ffb2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acca71b68a9ee4b3d6877e9f8438cf310"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#acca71b68a9ee4b3d6877e9f8438cf310">Inverse</a> () const </td></tr><tr class="separator:acca71b68a9ee4b3d6877e9f8438cf310"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae8bde5864311cd824b97bd080dbc1d3c"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#ae8bde5864311cd824b97bd080dbc1d3c">PreConcat</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)</td></tr><tr class="separator:ae8bde5864311cd824b97bd080dbc1d3c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2f027e8bde18fb9bdcac34f07edb866a"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a2f027e8bde18fb9bdcac34f07edb866a">PostConcat</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)</td></tr><tr class="separator:a2f027e8bde18fb9bdcac34f07edb866a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a87f94296258f1d040e691c934b3cf8c0"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a87f94296258f1d040e691c934b3cf8c0">PermuteLeftPast</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)</td></tr><tr class="separator:a87f94296258f1d040e691c934b3cf8c0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab346842aa173b3614b2496d034e10baa"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#ab346842aa173b3614b2496d034e10baa">PermuteRightPast</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m)</td></tr><tr class="separator:ab346842aa173b3614b2496d034e10baa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a94c591e8580438159febcfd82b9b5656"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a94c591e8580438159febcfd82b9b5656">PreScale</a> (<a class="el" href="class_p_m_real.html">PMReal</a> xScale, <a class="el" href="class_p_m_real.html">PMReal</a> yScale)</td></tr><tr class="separator:a94c591e8580438159febcfd82b9b5656"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afc779a566c4e6091a2d3a468db4b9321"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#afc779a566c4e6091a2d3a468db4b9321">Scale</a> (<a class="el" href="class_p_m_real.html">PMReal</a> xScale, <a class="el" href="class_p_m_real.html">PMReal</a> yScale)</td></tr><tr class="separator:afc779a566c4e6091a2d3a468db4b9321"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad4889bcfd34de45aa89304a16cfce150"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad4889bcfd34de45aa89304a16cfce150"></a> const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ScaleFrom</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;stationaryPoint, <a class="el" href="class_p_m_real.html">PMReal</a> xScale, <a class="el" href="class_p_m_real.html">PMReal</a> yScale)</td></tr><tr class="separator:ad4889bcfd34de45aa89304a16cfce150"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a67f79c07ae2c12ac0871c2c78dcbee2f"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a67f79c07ae2c12ac0871c2c78dcbee2f">SkewHorizontal</a> (<a class="el" href="class_p_m_real.html">PMReal</a> xSkewAngleInDegrees)</td></tr><tr class="separator:a67f79c07ae2c12ac0871c2c78dcbee2f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a208cad4c296d74b1e671c72a9d16958f"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a208cad4c296d74b1e671c72a9d16958f">SkewVertical</a> (<a class="el" href="class_p_m_real.html">PMReal</a> ySkewAngleInDegrees)</td></tr><tr class="separator:a208cad4c296d74b1e671c72a9d16958f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3dd4f7c9f90decc342dc68e8ca688535"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3dd4f7c9f90decc342dc68e8ca688535"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SkewFrom</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;stationaryPoint, <a class="el" href="class_p_m_real.html">PMReal</a> skewAngle, <a class="el" href="class_p_m_real.html">PMReal</a> noSkewDirectionAngle)</td></tr><tr class="separator:a3dd4f7c9f90decc342dc68e8ca688535"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:add028d18978d249d816bbea0e7013fee"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#add028d18978d249d816bbea0e7013fee">PreRotate</a> (<a class="el" href="class_p_m_real.html">PMReal</a> angleInDegrees)</td></tr><tr class="separator:add028d18978d249d816bbea0e7013fee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac7777479531a9daf65019abdf9913e49"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#ac7777479531a9daf65019abdf9913e49">Rotate</a> (<a class="el" href="class_p_m_real.html">PMReal</a> angleInDegrees)</td></tr><tr class="separator:ac7777479531a9daf65019abdf9913e49"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a70e84a4709b54e10b65c39a6d48c3ad0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a70e84a4709b54e10b65c39a6d48c3ad0"></a> const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>RotateAbout</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;center, <a class="el" href="class_p_m_real.html">PMReal</a> angle)</td></tr><tr class="separator:a70e84a4709b54e10b65c39a6d48c3ad0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa020fd40c5a8739daa30740ca8435421"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#aa020fd40c5a8739daa30740ca8435421">PreTranslate</a> (<a class="el" href="class_p_m_real.html">PMReal</a> x, <a class="el" href="class_p_m_real.html">PMReal</a> y)</td></tr><tr class="separator:aa020fd40c5a8739daa30740ca8435421"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aee2d70d6af64d7a48d1a086729f36a74"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aee2d70d6af64d7a48d1a086729f36a74"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PreTranslate</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;offset)</td></tr><tr class="separator:aee2d70d6af64d7a48d1a086729f36a74"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a08273c4386448639835dbde575cece57"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a08273c4386448639835dbde575cece57">Translate</a> (<a class="el" href="class_p_m_real.html">PMReal</a> x, <a class="el" href="class_p_m_real.html">PMReal</a> y)</td></tr><tr class="separator:a08273c4386448639835dbde575cece57"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a924fa4b98daa644d7d19669225ec7f09"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a924fa4b98daa644d7d19669225ec7f09"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Translate</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;offset)</td></tr><tr class="separator:a924fa4b98daa644d7d19669225ec7f09"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae6ed9f9a628ac9f3c7edb2397d27d415"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#ae6ed9f9a628ac9f3c7edb2397d27d415">ScaleTo</a> (<a class="el" href="class_p_m_real.html">PMReal</a> xScale, <a class="el" href="class_p_m_real.html">PMReal</a> yScale)</td></tr><tr class="separator:ae6ed9f9a628ac9f3c7edb2397d27d415"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4831bf8c4c691ce558f9cc49a01f788d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4831bf8c4c691ce558f9cc49a01f788d"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ScaleTo</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;stationaryPoint, <a class="el" href="class_p_m_real.html">PMReal</a> xScale, <a class="el" href="class_p_m_real.html">PMReal</a> yScale)</td></tr><tr class="separator:a4831bf8c4c691ce558f9cc49a01f788d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aecf82a1ebebacd720662ea7fed8ce547"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#aecf82a1ebebacd720662ea7fed8ce547">SkewTo</a> (<a class="el" href="class_p_m_real.html">PMReal</a> xSkewAngleInDegrees)</td></tr><tr class="separator:aecf82a1ebebacd720662ea7fed8ce547"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae332be9b0bb040191f1530a422960c3a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae332be9b0bb040191f1530a422960c3a"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SkewTo</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;stationaryPoint, <a class="el" href="class_p_m_real.html">PMReal</a> xSkewAngleInDegrees)</td></tr><tr class="separator:ae332be9b0bb040191f1530a422960c3a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0979fb1e23dd3e6274960eb7018b43e7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0979fb1e23dd3e6274960eb7018b43e7"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SkewToSlope</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;stationaryPoint, <a class="el" href="class_p_m_real.html">PMReal</a> skewSlope)</td></tr><tr class="separator:a0979fb1e23dd3e6274960eb7018b43e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a31cbb5bd9f7921699922d1c2b97d77e2"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a31cbb5bd9f7921699922d1c2b97d77e2">RotateTo</a> (<a class="el" href="class_p_m_real.html">PMReal</a> thetaInDegrees)</td></tr><tr class="separator:a31cbb5bd9f7921699922d1c2b97d77e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acd577f3f248f41f8cd17278a5ccfe5cf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="acd577f3f248f41f8cd17278a5ccfe5cf"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>RotateTo</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;stationaryPoint, <a class="el" href="class_p_m_real.html">PMReal</a> thetaInDegrees)</td></tr><tr class="separator:acd577f3f248f41f8cd17278a5ccfe5cf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a87b8dd620bbe8f4fed8285f5ec1ddf2d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a87b8dd620bbe8f4fed8285f5ec1ddf2d"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>RotateTo</b> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;stationaryPoint, <a class="el" href="class_p_m_real.html">PMReal</a> cosineAngle, <a class="el" href="class_p_m_real.html">PMReal</a> sineAngle)</td></tr><tr class="separator:a87b8dd620bbe8f4fed8285f5ec1ddf2d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a51631e1d6f8fc6328b9e7e8f13519495"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a51631e1d6f8fc6328b9e7e8f13519495">TranslateTo</a> (<a class="el" href="class_p_m_real.html">PMReal</a> x, <a class="el" href="class_p_m_real.html">PMReal</a> y)</td></tr><tr class="separator:a51631e1d6f8fc6328b9e7e8f13519495"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afb4faf083305d88dd6cd7fb9a80edc27"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="afb4faf083305d88dd6cd7fb9a80edc27"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetOrigin</b> (<a class="el" href="class_p_m_real.html">PMReal</a> x, <a class="el" href="class_p_m_real.html">PMReal</a> y)</td></tr><tr class="separator:afb4faf083305d88dd6cd7fb9a80edc27"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a797641fa699c1bd163f3d1004efac9ae"><td align="right" class="memItemLeft" valign="top">uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a797641fa699c1bd163f3d1004efac9ae">GetMatrixFactors</a> (<a class="el" href="class_p_m_matrix.html">PMMatrix</a> *scale, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *skew, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *rotate, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *translate, TransformFactorOrder factorOrder=kFactorOrder_SKRT) const </td></tr><tr class="separator:a797641fa699c1bd163f3d1004efac9ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6f04f5deb1e33625c787c7fe56cf4079"><td align="right" class="memItemLeft" valign="top">uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a6f04f5deb1e33625c787c7fe56cf4079">GetTransformValues</a> (<a class="el" href="class_p_m_real.html">PMReal</a> *xscale, <a class="el" href="class_p_m_real.html">PMReal</a> *yscale, <a class="el" href="class_p_m_real.html">PMReal</a> *skewslope, <a class="el" href="class_p_m_real.html">PMReal</a> *costheta, <a class="el" href="class_p_m_real.html">PMReal</a> *sintheta, <a class="el" href="class_p_m_real.html">PMReal</a> *xtranslation, <a class="el" href="class_p_m_real.html">PMReal</a> *ytranslation, TransformFactorOrder factorOrder=kFactorOrder_SKRT) const </td></tr><tr class="separator:a6f04f5deb1e33625c787c7fe56cf4079"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a940f3190610e635a85df4b53b5eb0474"><td align="right" class="memItemLeft" valign="top">uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a940f3190610e635a85df4b53b5eb0474">GetMatrixContent</a> () const </td></tr><tr class="separator:a940f3190610e635a85df4b53b5eb0474"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6148f21d1b505b7c23e335d7a03011f9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a6148f21d1b505b7c23e335d7a03011f9">GetXScale</a> () const </td></tr><tr class="separator:a6148f21d1b505b7c23e335d7a03011f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8d987deb9307745069f94324a82dcd0f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a8d987deb9307745069f94324a82dcd0f">GetYScale</a> () const </td></tr><tr class="separator:a8d987deb9307745069f94324a82dcd0f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1958bf2e3354ce99d9c0f38f2e7ad145"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a1958bf2e3354ce99d9c0f38f2e7ad145">GetXSkewAngle</a> () const </td></tr><tr class="separator:a1958bf2e3354ce99d9c0f38f2e7ad145"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab2b360262ea86b47ac02f99a375b937e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#ab2b360262ea86b47ac02f99a375b937e">GetRotationAngle</a> (bool16 zeroCentered=kFalse) const </td></tr><tr class="separator:ab2b360262ea86b47ac02f99a375b937e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1471dc8be1226455fcce755da51dbdb2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a1471dc8be1226455fcce755da51dbdb2">GetXTranslation</a> () const noexcept</td></tr><tr class="separator:a1471dc8be1226455fcce755da51dbdb2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a04ee2b0c23e9820c5267110f96ccd6a8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a04ee2b0c23e9820c5267110f96ccd6a8">GetYTranslation</a> () const noexcept</td></tr><tr class="separator:a04ee2b0c23e9820c5267110f96ccd6a8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a664d931f61ec3010459ce6c98adcbff8"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a664d931f61ec3010459ce6c98adcbff8">GetMatrixInfo</a> (<a class="el" href="class_p_m_real.html">PMReal</a> *rotAngle, <a class="el" href="class_p_m_real.html">PMReal</a> *xSkewAngle, <a class="el" href="class_p_m_real.html">PMReal</a> *xScale, <a class="el" href="class_p_m_real.html">PMReal</a> *yScale) const </td></tr><tr class="separator:a664d931f61ec3010459ce6c98adcbff8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7988373c8d7094679ec51143d05e4d94"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7988373c8d7094679ec51143d05e4d94"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SanityCheck</b> () const </td></tr><tr class="separator:a7988373c8d7094679ec51143d05e4d94"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a> Static Public Attributes</h2></td></tr><tr class="memitem:ae507505019525f5b75284706605ce9c2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae507505019525f5b75284706605ce9c2"></a> static const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>kHasNoTransformContent</b> = 0</td></tr><tr class="separator:ae507505019525f5b75284706605ce9c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac1599aaa227cad8544af9dccfe04b75e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac1599aaa227cad8544af9dccfe04b75e"></a> static const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>kHasScaleContent</b> = 1</td></tr><tr class="separator:ac1599aaa227cad8544af9dccfe04b75e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a268af13b53f5db18d9f06eb28f431ca3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a268af13b53f5db18d9f06eb28f431ca3"></a> static const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>kHasSkewContent</b> = 2</td></tr><tr class="separator:a268af13b53f5db18d9f06eb28f431ca3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0ebcd074ad6fa5271a971ba0c661d1bf"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a0ebcd074ad6fa5271a971ba0c661d1bf"></a> static const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>kHasRotateContent</b> = 4</td></tr><tr class="separator:a0ebcd074ad6fa5271a971ba0c661d1bf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a63d1eef924833ff5061c9c567cab80b6"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a63d1eef924833ff5061c9c567cab80b6"></a> static const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>kHasTranslateContent</b> = 8</td></tr><tr class="separator:a63d1eef924833ff5061c9c567cab80b6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abfebec3b9fd35735dda8c64e9e55640f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abfebec3b9fd35735dda8c64e9e55640f"></a> static const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><b>kHasAllTransformContent</b> = (kHasScaleContent | kHasSkewContent | kHasRotateContent | kHasTranslateContent)</td></tr><tr class="separator:abfebec3b9fd35735dda8c64e9e55640f"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a> Friends</h2></td></tr><tr class="memitem:a77e2ee64fc797c5b69e02fa38ea7d0d3"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_matrix.html#a77e2ee64fc797c5b69e02fa38ea7d0d3">operator*</a> (const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m1, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;m2)</td></tr><tr class="separator:a77e2ee64fc797c5b69e02fa38ea7d0d3"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>C++ class for dealing with matrix operations. </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2><a class="anchor" id="a33e6b99f17ab5deb287122f2d57fe01d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">constexpr PMMatrix::PMMatrix </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><p>Contruct an identity matrix: [ 1 0 0] [ 0 1 0] [ 0 0 1] </div></div><a class="anchor" id="a5d2200e5be0e97653639dbc77c73081c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">constexpr PMMatrix::PMMatrix </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>a</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>b</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>c</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>d</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>e</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>f</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><p>Contruct a matrix with a, b, c, d, e, f as initial values: [ a b 0] [ c d 0] [ e f 1] </div></div><a class="anchor" id="a339e3e81c89924288e40ae686ad13c70"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">constexpr PMMatrix::PMMatrix </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><p>Construct a matrix with the same perceptible value as m. </div></div><a class="anchor" id="a353cdb26f9dd13ad490e04010d344acd"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">PMMatrix::PMMatrix </td><td>(</td><td class="paramtype">const BRVCoordMatrix &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Construct a <a class="el" href="class_p_m_matrix.html">PMMatrix</a> from an AGM fixed or float matrix. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">m</td><td>is the AGM matrix. </td></tr></table></dl></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="ad19bd2b9086825a86d2aa5d74731ebd0"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_real.html">PMReal</a> PMMatrix::Determinant </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>the product of x and y scaling. I.e., given m = *this, return m[0]*m[3] - m[1]*m[2] where operator[] is as described above. </dl></div></div><a class="anchor" id="a1509d9e1caed9b02e5744ca07e7cdb0f"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::GetAGMFixedMatrix </td><td>(</td><td class="paramtype">_t_BRVFixedMatrix *&nbsp;</td><td class="paramname"><em>retMatrix</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Create and return an equivalent AGM matrix from this <a class="el" href="class_p_m_matrix.html">PMMatrix</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">retMatrix</td><td>is the AGM matrix created. </td></tr></table></dl></div></div><a class="anchor" id="a74df435da95339e34eb8d691f2e76bc3"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::GetAGMFloatMatrix </td><td>(</td><td class="paramtype">BRVCoordMatrix *&nbsp;</td><td class="paramname"><em>retMatrix</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Create and return an equivalent AGM float matrix from this <a class="el" href="class_p_m_matrix.html">PMMatrix</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">retMatrix</td><td>is the AGM matrix created. </td></tr></table></dl></div></div><a class="anchor" id="a940f3190610e635a85df4b53b5eb0474"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">uint32 PMMatrix::GetMatrixContent </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>GetMatrixContent returns the value that would have been returned from a call to either GetMatrixFactors or GetTransformValues with all non-nil parameters and TransformFactorOrder == kFactorOrder_SKRT. This function is simply more efficient and perhaps more convenient. </div></div><a class="anchor" id="a797641fa699c1bd163f3d1004efac9ae"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">uint32 PMMatrix::GetMatrixFactors </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>scale</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>skew</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>rotate</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>translate</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TransformFactorOrder&nbsp;</td><td class="paramname"><em>factorOrder</em> = <code>kFactorOrder_SKRT</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>GetMatrixFactors asserts if *this is singular. Otherwise, if scale, skew, rotate, and translate are non-nil pointers, then GetMatrixFactors writes matrices to the specified locations such that: <pre class="fragment">1) scale * skew * rotate * translate == *this if factorOrder == kFactorOrder_SKRT

   otherwise rotate * skew * scale * translate == *this if factorORder == kFactorOrder_RKST

2) scale[1] == scale[2] == scale[4] == scale[5] == 0.0

3) skew[1] == scale[4] == scale[5] == 0.0

   skew[0] == skew[3] == 1.0

4) rotate[0] == rotate[3]

   rotate[1] == -rotate[2]

   determinant(rotate) == 1.0

5) translate[0] == translate[3] == 1.0

   translate[1] == translate[2] == 0.0

</pre><p>Any nil-pointer passed makes GetMatrixFactors skip writing the corresponding matrix, but this does not change the factorization nor have any effect on the matrices whose values are written.<p>The return value of GetMatrixFactors is a combination of the above constants OR&#39;d together as one unsigned value. If scale[0] or scale[3] differ from 1.0, then (result &amp; kHasScaleContent). If skew[2] differs from 0.0 then (result &amp; kHasSkewContent). If rotate[0] differs from 1.0 then (result &amp; kHasRotateContent). And if either translate[4] or translate[5] differ from 0.0 then (result &amp; kHasTranslateContent). Note the return value from GetMatrixFactors will not have any bits set for transform components whose factor was not requested. For example, GetMatrixFactors( nil, nil, &amp;rotate, nil) will return either kHasNoTransformContent or kHasRotateContent even if the matrix has other transform components.<p>Note that the factorization returned from GetMatrixFactors, as described above, is not unique. In particular, for kFactorOrder_SKRT, if one changed the algebraic sign of scale[0], scale[3], rotate[0], rotate[1], rotate[2], and rotate[3], then the set of factors would still meet all the conditions above. Currently it is unspecified which of the two factorizations is returned. Code that relies on one or the other is incorrect. </div></div><a class="anchor" id="a664d931f61ec3010459ce6c98adcbff8"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::GetMatrixInfo </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>rotAngle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>xSkewAngle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>xScale</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>yScale</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Returns the rotation angle, x skew angle, x and y scale factors represented by this matrix. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rotAngle</td><td>is the rotation angle of the matrx in the range [0, 360). </td></tr><tr><td class="paramname">xSkewAngle</td><td>is the x skew angle of the matrx in the range (-90, 90). </td></tr><tr><td class="paramname">xScale</td><td>is the x scale factor. </td></tr><tr><td class="paramname">yScale</td><td>is the y scale factor. </td></tr></table></dl></div></div><a class="anchor" id="ab2b360262ea86b47ac02f99a375b937e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_real.html">PMReal</a> PMMatrix::GetRotationAngle </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>zeroCentered</em> = <code>kFalse</code></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>one of the angles whose sine and cosine would be returned in the fourth and fifth parameters to GetTransformValues with TransformFactorOrder == kFactorOrder_SKRT. Note the angle measurement returned is in degrees. The return value will be in the range (-180, 180] if zeroCentered is kTrue, otherwise it will be in the range [0, 360). </dl></div></div><a class="anchor" id="a6f04f5deb1e33625c787c7fe56cf4079"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">uint32 PMMatrix::GetTransformValues </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>xscale</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>yscale</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>skewslope</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>costheta</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>sintheta</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>xtranslation</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>ytranslation</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TransformFactorOrder&nbsp;</td><td class="paramname"><em>factorOrder</em> = <code>kFactorOrder_SKRT</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>GetTransformValues writes to its non-nil parameters the free values in the matrices that would have been returned in a call to GetMatrixFactors. In particular, *xscale == scale[0], *yscale == scale[3], *skewslope == skew[2], *costheta == rotate[0], *sintheta == rotate[1], *xtranslation == translate[4], and *ytranslation == translate[5]. Any nil pointers cause GetTransformValues to skip writing the corresponding return value, with the restriction that the pair of parameters (xscale, yscale) must be both nil or both non-nil. Likewise for the the pair (costheta, sintheta) and the pair (xtranslation, ytranslation). Callers are not allowed to be &quot;interested in&quot; only one of the pair. GetTransformValues will assert on such a call.<p>The return value has the same meaning as the return value of GetMatrixFactors. And like GetMatrixFactors, the only bits set will be those whose corresponding transform values were requested with non-nil pointers.<p>And, as described for GetMatrixFactors, the 7-tuple returned from GetTransformValues, is not unique. In particular, for kFactorOrder_SKRT, if one changed the algebraic sign of xscale, yscale, costheta, and sintheta, then the set of values would still correctly characterize the matrix. Currently it is unspecified which of the two 7-tuples is returned. Code that relies on one or the other is incorrect. </div></div><a class="anchor" id="aa82a72f7d0c4e6ef9319d93255ffd8fe"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::GetUIMatrixF32 </td><td>(</td><td class="paramtype"><a class="el" href="classdvacore_1_1geom_1_1_scale_matrix_t.html">dvacore::geom::ScaleMatrixT</a>&lt; float &gt; *&nbsp;</td><td class="paramname"><em>retMatrix</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Return an equivalent Drover dvaui::ui::UI_MatrixF32 matrix from this <a class="el" href="class_p_m_matrix.html">PMMatrix</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">retMatrix</td><td>is the Drover matrix created. </td></tr></table></dl></div></div><a class="anchor" id="a6148f21d1b505b7c23e335d7a03011f9"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_real.html">PMReal</a> PMMatrix::GetXScale </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>the x scale factor that would be returned in the first parameter to GetTransformValues with TransformFactorOrder == kFactorOrder_SKRT. </dl></div></div><a class="anchor" id="a1958bf2e3354ce99d9c0f38f2e7ad145"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_real.html">PMReal</a> PMMatrix::GetXSkewAngle </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>the x skew angle in degrees in the range (-90, 90) whose tangent would be returned in the third parameter to GetTransformValues with TransformFactorOrder == kFactorOrder_SKRT. </dl></div></div><a class="anchor" id="a1471dc8be1226455fcce755da51dbdb2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_real.html">PMReal</a> PMMatrix::GetXTranslation </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>the x translation amount that would be returned in the sixth parameter to GetTransformValues with TransformFactorOrder == kFactorOrder_SKRT. </dl></div></div><a class="anchor" id="a8d987deb9307745069f94324a82dcd0f"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_real.html">PMReal</a> PMMatrix::GetYScale </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>the y scale factor that would be returned in the second parameter to GetTransformValues with TransformFactorOrder == kFactorOrder_SKRT. </dl></div></div><a class="anchor" id="a04ee2b0c23e9820c5267110f96ccd6a8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_real.html">PMReal</a> PMMatrix::GetYTranslation </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>the y translation amount that would be returned in the seventh parameter to GetTransformValues with TransformFactorOrder == kFactorOrder_SKRT. </dl></div></div><a class="anchor" id="acca71b68a9ee4b3d6877e9f8438cf310"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> PMMatrix::Inverse </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>the inverse matrix of this matrix. Original matrix is unchanged. </dl></div></div><a class="anchor" id="a0c89605222f684d30808a801c244ffb2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::Invert </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Replace the value of this matrix with its inverse discarding its previous value. </div></div><a class="anchor" id="a79afadcc9a314d3fc310a8fd577f75f1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 PMMatrix::IsIdentity </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>kTrue if m * (*this) == m for all m. Otherwise return kFalse; </dl></div></div><a class="anchor" id="a33f21177a5bbbb14d88a3f58fb8db080"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 PMMatrix::IsSingular </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>whether the product of x and y scaling is zero. Note if m.IsSingular() then m has no inverse and m.Invert() will assert. </dl></div></div><a class="anchor" id="af39f3ad78f00fc07561b5d8bbb2ba866"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMMatrix::operator&lt; </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>other</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>A partial ordering on matrices for use in sorted containers </div></div><a class="anchor" id="a70c1b8c43d819025eb24c8a06069c5ee"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_matrix.html">PMMatrix</a>&amp; PMMatrix::operator= </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><p>Make *this have the same perceptible value as m. Returns *this. </div></div><a class="anchor" id="ac47e66ae3a6a85eee6c97452ef800369"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMMatrix::operator== </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>other</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Return kTrue if *this and other have the same perceptible value. Otherwise returns kFalse; </div></div><a class="anchor" id="a3a0bc0429323a3cd4d17bbe45aeabf71"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">const <a class="el" href="class_p_m_real.html">PMReal</a> PMMatrix::operator[] </td><td>(</td><td class="paramtype">int&nbsp;</td><td class="paramname"><em>index</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Extract the nth free value of *this as a <a class="el" href="class_p_m_real.html">PMReal</a>. The index must be &gt;= 0 and &lt;= 5. In other words consider the following code: <pre class="fragment">PMReal a,b,c,d,e,f,x,y;



x = y = 0;

m.Transform( &amp;x, &amp;y);

e = x;

f = y;



x = 1; y = 0;

m.Transform( &amp;x, &amp;y);

a = x - e;

b = y - f;



x = 0; y = 1;

m.Transform( &amp;x, &amp;y);

c = x - e;

d = y - f;

</pre><p>Then m[0] returns a m[1] returns b m[2] returns c m[3] returns d m[4] returns e m[5] returns f<p>operator[] is simply more convenient and perhaps more efficient than using the above code. Note that the implementation of <a class="el" href="class_p_m_matrix.html">PMMatrix</a> need not be an array of 6 PMReals even though this operator gives it that appearance. </div></div><a class="anchor" id="a87f94296258f1d040e691c934b3cf8c0"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::PermuteLeftPast </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>PermuteLeftPast computes m * (*this) * inverse(m) and assigns the result to *this. I.e. computes the new value of this such that m * oldthis == newthis * m </div></div><a class="anchor" id="ab346842aa173b3614b2496d034e10baa"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::PermuteRightPast </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>PermuteRigthPast computes inverse(m) * (*this) * m and assigns the result to *this. I.e. computes the new value of this such that oldthis * m == m * newthis </div></div><a class="anchor" id="a2f027e8bde18fb9bdcac34f07edb866a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::PostConcat </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set *this = (*this) * m. </div></div><a class="anchor" id="ae8bde5864311cd824b97bd080dbc1d3c"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::PreConcat </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set *this = m * (*this). </div></div><a class="anchor" id="add028d18978d249d816bbea0e7013fee"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::PreRotate </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>angleInDegrees</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set *this = <a class="el" href="class_p_m_matrix.html">PMMatrix</a>( cosine(angleInDegrees), sine(angleInDegrees), -sine(angleInDegrees), cosine(angleInDegrees), 0, 0) * (*this); </div></div><a class="anchor" id="a94c591e8580438159febcfd82b9b5656"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::PreScale </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>xScale</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>yScale</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set *this = PMMatrix(xScale, 0, 0, yScale, 0, 0) * (*this) </div></div><a class="anchor" id="a9f08c5d0e50bb6930a60e84a386c12c8"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMMatrix::PreservesBoxes </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>kTrue if an axes aligned rectangle (like <a class="el" href="class_p_m_rect.html">PMRect</a>) remains an axes aligned rectangle when transformed by *this. That is, *this contains no skew component and at most a 90-degree multiple rotation. This is equivalent to calling GetTransformValues and checking if skewslope == zero and (costheta == 0 || sintheta == 0) but is perhaps more efficient or more convenient. </dl></div></div><a class="anchor" id="aa020fd40c5a8739daa30740ca8435421"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::PreTranslate </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set *this = PMMatrix( 1, 0, 0, 1, x, y) * (*this); </div></div><a class="anchor" id="a9950e2990b39e2f3116897130a0a0bf5"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::ReadWrite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Read/Write this matrix. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>is the stream to read from and write to. </td></tr></table></dl></div></div><a class="anchor" id="a1463e7fb3d8e84f29bffa1a54829c20a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void PMMatrix::ResetToIdentity </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><p>Set this matrix to the identity matrix discarding its previous value. </div></div><a class="anchor" id="ac7777479531a9daf65019abdf9913e49"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::Rotate </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>angleInDegrees</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set *this = (*this) * <a class="el" href="class_p_m_matrix.html">PMMatrix</a>( cosine(angleInDegrees), sine(angleInDegrees), -sine(angleInDegrees), cosine(angleInDegrees), 0, 0); </div></div><a class="anchor" id="a31cbb5bd9f7921699922d1c2b97d77e2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::RotateTo </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>thetaInDegrees</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Rotate the matrix to the specified angle. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">theta</td><td>is the x skew angle. </td></tr></table></dl></div></div><a class="anchor" id="afc779a566c4e6091a2d3a468db4b9321"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::Scale </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>xScale</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>yScale</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set *this = (*this) * PMMatrix(xScale, 0, 0, yScale, 0, 0) </div></div><a class="anchor" id="ae6ed9f9a628ac9f3c7edb2397d27d415"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::ScaleTo </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>xScale</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>yScale</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Scale the matrix to the specified x and y scale factors. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xScale</td><td>is the x scale factor to scale to. yScale is the y scale factor to scale to. </td></tr></table></dl></div></div><a class="anchor" id="a310ce9fa9260b72a0ac4045305a8ce8e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::SetMatrix </td><td>(</td><td class="paramtype">const BRVCoordMatrix &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set the <a class="el" href="class_p_m_matrix.html">PMMatrix</a> with an AGM float matrix. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">m</td><td>is the AGM matrix. </td></tr></table></dl></div></div><a class="anchor" id="aadd86cbebdb255243b2d834087dae9d5"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::SetMatrix </td><td>(</td><td class="paramtype">const _t_BRVFixedMatrix &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set the <a class="el" href="class_p_m_matrix.html">PMMatrix</a> with an AGM fixed matrix. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">m</td><td>is the AGM matrix. </td></tr></table></dl></div></div><a class="anchor" id="a219e43750bd313cacf3c269d46054221"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::SetMatrix </td><td>(</td><td class="paramtype">const <a class="el" href="classdvacore_1_1geom_1_1_scale_matrix_t.html">dvacore::geom::ScaleMatrixT</a>&lt; float &gt; &amp;&nbsp;</td><td class="paramname"><em>m</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set the <a class="el" href="class_p_m_matrix.html">PMMatrix</a> with a Drover dvaui::ui::UI_MatrixF32 matrix. (which is a typedef of dvacore::geom::ScaleMatrixT&lt;float&gt;) <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">m</td><td>is the Drover matrix. </td></tr></table></dl></div></div><a class="anchor" id="a67f79c07ae2c12ac0871c2c78dcbee2f"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::SkewHorizontal </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>xSkewAngleInDegrees</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set *this = (*this) * <a class="el" href="class_p_m_matrix.html">PMMatrix</a>(1, 0, tangent(xSkewAngleInDegrees), 1, 0, 0); </div></div><a class="anchor" id="aecf82a1ebebacd720662ea7fed8ce547"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::SkewTo </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>xSkewAngleInDegrees</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Skew the matrix to the specified x skew angle. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xSkewAngle</td><td>is the x skew angle. </td></tr></table></dl></div></div><a class="anchor" id="a208cad4c296d74b1e671c72a9d16958f"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::SkewVertical </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>ySkewAngleInDegrees</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set *this = (*this) * <a class="el" href="class_p_m_matrix.html">PMMatrix</a>(1, tangent(ySkewAngleInDegrees), 0, 1, 0, 0); </div></div><a class="anchor" id="a3eeb6b60c78c39697a66ceaaa529b480"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::Transform </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> *&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Compute the matrix product [ *x *y 1] * (*this) producing the result [ x&#39; y&#39; 1]. Then write x&#39; back into *x and y&#39; back into *y. </div></div><a class="anchor" id="a55eb15ad8910c13f59e4f0272df9344e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::Transform </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_polygon4.html">PMPolygon4</a> *&nbsp;</td><td class="paramname"><em>fourPoints</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Transforms each of the four points specified in fourPoints independently and writes the results back into the corresponding slots of the same <a class="el" href="class_p_m_polygon4.html">PMPolygon4</a>. </div></div><a class="anchor" id="ab3d63da867ea66cd44e5a95674982bc0"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::Transform </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>rect</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Transforms rect and return (back in *rect) the smallest axes-aligned rectangle that contains the transformed rectangle. </div></div><a class="anchor" id="a514aa8381c6011ab281315e24acb095a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::Transform </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_line_seg.html">PMLineSeg</a> *&nbsp;</td><td class="paramname"><em>segment</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Transform each of the two points specified in the segment independently, and write the results back into the <a class="el" href="class_p_m_line_seg.html">PMLineSeg</a> perhaps in reverse order if required to satisfy the invariant of <a class="el" href="class_p_m_line_seg.html">PMLineSeg</a> that segment.Top().Y() be no larger than segment.Bottom().Y(). </div></div><a class="anchor" id="a08273c4386448639835dbde575cece57"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::Translate </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set *this = (*this) * PMMatrix( 1, 0, 0, 1, x, y); </div></div><a class="anchor" id="a51631e1d6f8fc6328b9e7e8f13519495"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMMatrix::TranslateTo </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set the origin to x and y. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">x</td><td>is the origin to set to on the x-axis. </td></tr><tr><td class="paramname">y</td><td>is the origin to set to on the y-axis . </td></tr></table></dl></div></div><h2 class="groupheader">Friends And Related Function Documentation</h2><a class="anchor" id="a77e2ee64fc797c5b69e02fa38ea7d0d3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> operator* </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m1</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &amp;&nbsp;</td><td class="paramname"><em>m2</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">friend</span></span></td></tr></table></div><div class="memdoc"><dl class="section return"><dt>Returns<dd>the matrix product m1.m2 without affecting the value of m1 or m2. </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_p_m_matrix.html">PMMatrix</a><li class="footer">Generated on Sat Sep 22 2018 10:56:24 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
