<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_preflight_process_manager</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_preflight_process_manager.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_preflight_process_manager-members.html">List of all members</a></div><div class="headertitle"><div class="title">IPreflightProcessManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_preflight_process_manager_8h_source.html">IPreflightProcessManager.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IPreflightProcessManager:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_preflight_process_manager.png" usemap="#IPreflightProcessManager_map" /><map id="IPreflightProcessManager_map" name="IPreflightProcessManager_map"><area alt="IPMUnknown" coords="0,0,159,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:affeebd66521073c57260852acfa9b2d8"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IPREFLIGHTPROCESSMANAGER }</td></tr><tr class="separator:affeebd66521073c57260852acfa9b2d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:afe8ece20bf98177e3d4cb61a390dae26"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#afe8ece20bf98177e3d4cb61a390dae26">Startup</a> ()=0</td></tr><tr class="separator:afe8ece20bf98177e3d4cb61a390dae26"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a198c914320dc4b58bd0bc5267d915760"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a198c914320dc4b58bd0bc5267d915760">Shutdown</a> ()=0</td></tr><tr class="separator:a198c914320dc4b58bd0bc5267d915760"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab19da553ca64265690d7646c1bf9fa6a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#ab19da553ca64265690d7646c1bf9fa6a">OnCloseDocument</a> (<a class="el" href="class_i_document.html">IDocument</a> *iDoc)=0</td></tr><tr class="separator:ab19da553ca64265690d7646c1bf9fa6a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a10fdcbcbe5518921443d56f43e0a909d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a10fdcbcbe5518921443d56f43e0a909d">OnCloseBook</a> (<a class="el" href="class_i_book.html">IBook</a> *iBook)=0</td></tr><tr class="separator:a10fdcbcbe5518921443d56f43e0a909d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a33b3645ee5c337906ef67aa287e057b0"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a33b3645ee5c337906ef67aa287e057b0">GetProcessCount</a> () const =0</td></tr><tr class="separator:a33b3645ee5c337906ef67aa287e057b0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a19e40c9195fdcdaaf230ae7c1cf8e4ed"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a19e40c9195fdcdaaf230ae7c1cf8e4ed">GetActiveProcessCount</a> () const =0</td></tr><tr class="separator:a19e40c9195fdcdaaf230ae7c1cf8e4ed"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4f84991a5906a1bce76d9ee2b8c627f5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a4f84991a5906a1bce76d9ee2b8c627f5">QueryNthProcess</a> (int32 n) const =0</td></tr><tr class="separator:a4f84991a5906a1bce76d9ee2b8c627f5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adec924af794581a43848fe55921904b6"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#adec924af794581a43848fe55921904b6">QueryProcessByUniqueID</a> (uint32 uniqueID) const =0</td></tr><tr class="separator:adec924af794581a43848fe55921904b6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aecfeeff4079c948973a9ca5ed72841e6"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#aecfeeff4079c948973a9ca5ed72841e6">FindProcess</a> (<a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *iProcess) const =0</td></tr><tr class="separator:aecfeeff4079c948973a9ca5ed72841e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4cda48206df3834b2624acebd48445d5"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a4cda48206df3834b2624acebd48445d5">FindProcess</a> (uint32 uniqueID) const =0</td></tr><tr class="separator:a4cda48206df3834b2624acebd48445d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a30c0dff29f82fa8b424273705ce3c2f1"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a30c0dff29f82fa8b424273705ce3c2f1">FindProcess</a> (<a class="el" href="class_i_d_type.html">ClassID</a> selectorID, const PreflightDocumentID &amp;docID) const =0</td></tr><tr class="separator:a30c0dff29f82fa8b424273705ce3c2f1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7c250e53b0c42a1215bb70662adefd20"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a7c250e53b0c42a1215bb70662adefd20">GetProcessesForDocument</a> (const <a class="el" href="class_i_document.html">IDocument</a> *iDoc, <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; *indices) const =0</td></tr><tr class="separator:a7c250e53b0c42a1215bb70662adefd20"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a389c955af035b23d30c516620ea0fde7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a389c955af035b23d30c516620ea0fde7">RemoveNthProcess</a> (int32 n)=0</td></tr><tr class="separator:a389c955af035b23d30c516620ea0fde7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1d61cca179b570e6b0f5e317063308f5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a1d61cca179b570e6b0f5e317063308f5">CreateProcess</a> ()=0</td></tr><tr class="separator:a1d61cca179b570e6b0f5e317063308f5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afccf1bc4b2377d70c6e91861730455bb"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#afccf1bc4b2377d70c6e91861730455bb">AdvanceState</a> (<a class="el" href="class_idle_timer.html">IdleTimer</a> *timer, bool synchronous, uint32 *pNextCallback=nil)=0</td></tr><tr class="separator:afccf1bc4b2377d70c6e91861730455bb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a947aaf625b9bc689129add28ed59a80c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a947aaf625b9bc689129add28ed59a80c">AddTimeStandoff</a> (double seconds, <a class="el" href="class_i_document.html">IDocument</a> *iDoc=nil)=0</td></tr><tr class="separator:a947aaf625b9bc689129add28ed59a80c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a52eb7ced1036c27601adaba09891377e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a52eb7ced1036c27601adaba09891377e">InvalidateObject</a> (const <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;objID)=0</td></tr><tr class="separator:a52eb7ced1036c27601adaba09891377e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8ab958cbe77f51ddb08241518afeefe6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#a8ab958cbe77f51ddb08241518afeefe6">OnSettingsChange</a> (const IPreflightSettingsChangeInfo *iInfo)=0</td></tr><tr class="separator:a8ab958cbe77f51ddb08241518afeefe6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abf53b84789b6ac2f51896397f2fc1c1f"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#abf53b84789b6ac2f51896397f2fc1c1f">NewProcessUniqueID</a> ()=0</td></tr><tr class="separator:abf53b84789b6ac2f51896397f2fc1c1f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af8bad21f8901cec6fc4ebad5feec3623"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_process_manager.html#af8bad21f8901cec6fc4ebad5feec3623">NewProcessTaskUniqueID</a> ()=0</td></tr><tr class="separator:af8bad21f8901cec6fc4ebad5feec3623"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>The preflight process manager keeps track of the active (and inactive) preflight processes. It sits on the session boss, but probably the best way is to get it from <a class="el" href="class_i_preflight_manager.html">IPreflightManager</a> or using <a class="el" href="class_i_preflight_utils.html#a5ccb16fb05479c42dbb13f7d37a1ade7">IPreflightUtils::QueryProcessManager()</a>.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_manager.html">IPreflightManager</a><dd><a class="el" href="class_i_preflight_utils.html">IPreflightUtils</a></dl></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a947aaf625b9bc689129add28ed59a80c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::AddTimeStandoff </td><td>(</td><td class="paramtype">double&nbsp;</td><td class="paramname"><em>seconds</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_document.html">IDocument</a> *&nbsp;</td><td class="paramname"><em>iDoc</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method adjusts the idle behavior to establish a &quot;time standoff&quot; window where the idle task will simple early-out (ie, exit without doing anything) until the time window is exhausted. This standoff is applied at key points, such as application switch-in (resume), new or open document, and invalidation, to avoid preflight being too aggressive. For example if you are nudging a page item or typing we don&#39;t want to jump in RIGHTAWAY and start checking again, as this can have a subtle effect on user responsiveness. Thus we wait a short while before resuming preflight.<p>Preflight maintains a per-document standoff and a global standoff. These are essentially wall-clock times when the &quot;green light&quot; comes on for a given document. A document must have its green light <em>and</em> the global green light to get preflight cycles.<p>Note that this standoff DOES NOT apply to synchronous preflight requests, ie AdvanceState when synchronous=true or timer=nil. It only applies to the idle/background preflight slices.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">seconds</td><td>IN The number of seconds of standoff (from this moment) to wait before resuming preflight. </td></tr><tr><td class="paramname">iDoc</td><td>IN The document to apply the standoff to, or nil to apply it globally (ie, it affects all documents). </td></tr></table></dl></div></div><a class="anchor" id="afccf1bc4b2377d70c6e91861730455bb"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::AdvanceState </td><td>(</td><td class="paramtype"><a class="el" href="class_idle_timer.html">IdleTimer</a> *&nbsp;</td><td class="paramname"><em>timer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>synchronous</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32 *&nbsp;</td><td class="paramname"><em>pNextCallback</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Provide time for processes to work, normally during the idle callback. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">timer</td><td>IN The timer function that lets the process manager know how much time remains. If nil, the process manager works until all tasks are completed, but that&#39;s kind of dangerous since no progress feedback is provided at this level. </td></tr><tr><td class="paramname">synchronous</td><td>IN Set this to true if you are calling this in a tight loop where (for example) the text composer will not be given any time to work; otherwise the process will never (or only extremely slowly) complete. When true, text composition will be forced synchronously prior to preflight expansion and visitation. Set this parameter to false if you&#39;re calling it from an idle loop where the text composer has a chance to operate efficiently. </td></tr><tr><td class="paramname">pNextCallback</td><td>OUT If not nil, receives the number of milliseconds until the next desired callback, based on the priorities and states of all of the processes after it has distributed work to the list of processes. </td></tr></table></dl></div></div><a class="anchor" id="a1d61cca179b570e6b0f5e317063308f5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a>* IPreflightProcessManager::CreateProcess </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Create a new process. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">docID</td><td>IN The document ID the process is bound to (</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_manager.html">IPreflightManager</a>) </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iOptions</td><td>IN The options to use for the process, or nil to leave them at ctor defaults. </td></tr><tr><td class="paramname">iBook</td><td>IN If not nil, the book this process is associated with. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A new process (with refcount = 2, one for being in the list, one for the caller). </dl></div></div><a class="anchor" id="aecfeeff4079c948973a9ca5ed72841e6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IPreflightProcessManager::FindProcess </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="paramname"><em>iProcess</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find a process in the list of processes. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProcess</td><td>The process you&#39;re looking for. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The index of the process in the list, or -1 if not found. </dl></div></div><a class="anchor" id="a4cda48206df3834b2624acebd48445d5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IPreflightProcessManager::FindProcess </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>uniqueID</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find a process in the list of processes by its unique ID. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">id</td><td>The ID of the process you&#39;re looking for. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The index of the process in the list, or -1 if not found. </dl></div></div><a class="anchor" id="a30c0dff29f82fa8b424273705ce3c2f1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IPreflightProcessManager::FindProcess </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>selectorID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const PreflightDocumentID &amp;&nbsp;</td><td class="paramname"><em>docID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find a process in the list of processes by its selector/database pair. These are used to &#39;tag&#39; a process as important for a particular reason, such as the current profile for continuous preflight for a given document.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">selectorID</td><td>The selector ID of the process you&#39;re looking for. </td></tr><tr><td class="paramname">docID</td><td>The document associated with the process. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The index of the process in the list, or -1 if not found. </dl></div></div><a class="anchor" id="a19e40c9195fdcdaaf230ae7c1cf8e4ed"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IPreflightProcessManager::GetActiveProcessCount </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the number of active processes (ie those with something to do). <dl class="section return"><dt>Returns<dd>Number of processes. </dl></div></div><a class="anchor" id="a33b3645ee5c337906ef67aa287e057b0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IPreflightProcessManager::GetProcessCount </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Get the total number of processes, active and inactive.

</pre><dl class="section return"><dt>Returns<dd>Number of processes. </dl></div></div><a class="anchor" id="a7c250e53b0c42a1215bb70662adefd20"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool IPreflightProcessManager::GetProcessesForDocument </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_document.html">IDocument</a> *&nbsp;</td><td class="paramname"><em>iDoc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; *&nbsp;</td><td class="paramname"><em>indices</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the indices of the processes that are examining a particular document (if any). Can also be used to simply indicate <em>whether</em> there are any by passing nil for &#39;indices.&#39; <dl class="section note"><dt>Note<dd>&quot;Examining&quot; simply means that there is a task with a root object that comes from the document. It doesn&#39;t matter what state the task is in.</dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iDoc</td><td>IN The document you&#39;re interested in. </td></tr><tr><td class="paramname">indices</td><td>OUT Receives the indices of the processes that are examining the document (note that these processes can also be examining other documents, if the tasks are set up that way). If nil, the only check is for the presence of an open process for the document (in the return value). </td></tr></table></dl><dl class="section return"><dt>Returns<dd>True if there are any processes examining the document. </dl></div></div><a class="anchor" id="a52eb7ced1036c27601adaba09891377e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::InvalidateObject </td><td>(</td><td class="paramtype">const <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;&nbsp;</td><td class="paramname"><em>objID</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Invalidation (this API will probably need to be more sophisticated eventually). This forwards the invalidation request to all applicable processes.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">objID</td><td>The object needing invalidation. </td></tr></table></dl></div></div><a class="anchor" id="af8bad21f8901cec6fc4ebad5feec3623"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IPreflightProcessManager::NewProcessTaskUniqueID </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Obtain a new process task unique ID. </div></div><a class="anchor" id="abf53b84789b6ac2f51896397f2fc1c1f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IPreflightProcessManager::NewProcessUniqueID </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Obtain a new process unique ID. </div></div><a class="anchor" id="a10fdcbcbe5518921443d56f43e0a909d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::OnCloseBook </td><td>(</td><td class="paramtype"><a class="el" href="class_i_book.html">IBook</a> *&nbsp;</td><td class="paramname"><em>iBook</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by the preflight manager; you shouldn&#39;t call this. Closes all the processes associated with the book preflight. </div></div><a class="anchor" id="ab19da553ca64265690d7646c1bf9fa6a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::OnCloseDocument </td><td>(</td><td class="paramtype"><a class="el" href="class_i_document.html">IDocument</a> *&nbsp;</td><td class="paramname"><em>iDoc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by the preflight manager; you shouldn&#39;t call this. Deletes any processes that are still active on the document (if not preserved by being part of a book preflight). </div></div><a class="anchor" id="a8ab958cbe77f51ddb08241518afeefe6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::OnSettingsChange </td><td>(</td><td class="paramtype">const IPreflightSettingsChangeInfo *&nbsp;</td><td class="paramname"><em>iInfo</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Change of settings, either at the app or doc levels. This is forwarded on to each process to determine whether that change affects that process.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iInfo</td><td>The settings change info to respond to. </td></tr></table></dl></div></div><a class="anchor" id="a4f84991a5906a1bce76d9ee2b8c627f5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a>* IPreflightProcessManager::QueryNthProcess </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a particular process for further inspection. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>The index of the process you&#39;re interested in, between 0 and GetProcessCont() - 1. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted interface to the preflight process. </dl></div></div><a class="anchor" id="adec924af794581a43848fe55921904b6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a>* IPreflightProcessManager::QueryProcessByUniqueID </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>uniqueID</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a particular process for further inspection. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">uniqueID</td><td>The unique ID of the process you&#39;re interested in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted interface to the preflight process, or nil if the unique ID does not exist. </dl></div></div><a class="anchor" id="a389c955af035b23d30c516620ea0fde7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::RemoveNthProcess </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Remove a process from the list. This dereferences the process, so if nobody else has a handle on it, it will delete the process. In any case, once the process manager doesn&#39;t know about the process, it won&#39;t get cycles via the master idle callback.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>IN The index of the process you want to remove from the list. </td></tr></table></dl></div></div><a class="anchor" id="a198c914320dc4b58bd0bc5267d915760"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::Shutdown </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by the preflight manager at application shutdown; do not call. </div></div><a class="anchor" id="afe8ece20bf98177e3d4cb61a390dae26"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightProcessManager::Startup </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by the preflight manager at application startup; do not call. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_preflight_process_manager.html">IPreflightProcessManager</a><li class="footer">Generated on Sat Sep 22 2018 10:54:25 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
