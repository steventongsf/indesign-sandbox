<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_spread</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_spread.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_spread-members.html">List of all members</a></div><div class="headertitle"><div class="title">ISpread Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_spread_8h_source.html">ISpread.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ISpread:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_spread.png" usemap="#ISpread_map" /><map id="ISpread_map" name="ISpread_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a72955acda1bb3d66d7c43b84ba429abe"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ISPREAD }</td></tr><tr class="separator:a72955acda1bb3d66d7c43b84ba429abe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae4930d8d80f113487fd04240552f12eb"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>BindingLocation</b> { <b>kDefaultBinding</b> = -1, <b>kBindingAtBeginning</b> = 0, <b>kBindingAtEnd</b> = -2 }</td></tr><tr class="separator:ae4930d8d80f113487fd04240552f12eb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a634aef54ef6019d91de6e02f8a33e79f"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>BindingSide</b> { <b>kDefaultBindingSide</b> = -1, <b>kLeftSideOfBinding</b> = 0, <b>kRightSideOfBinding</b> = -2 }</td></tr><tr class="separator:a634aef54ef6019d91de6e02f8a33e79f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa3a2939d71dc961522215235bcf78a45"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>PageColorLabel</b> { <b>kFollowMasterColorUID</b> = 1 }</td></tr><tr class="separator:aa3a2939d71dc961522215235bcf78a45"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a47e6dd329072555729ec9e7c7b4a53f6"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kAtTheEnd</b> = -1 }</td></tr><tr class="separator:a47e6dd329072555729ec9e7c7b4a53f6"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a48e0c4d322acbd18f94ad694709630c0"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_spread_layer.html">ISpreadLayer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a48e0c4d322acbd18f94ad694709630c0">QueryLayer</a> (const <a class="el" href="class_i_document_layer.html">IDocumentLayer</a> *docLayer, int32 *pPos=nil, bool16 wantGuideLayer=kFalse) const =0</td></tr><tr class="separator:a48e0c4d322acbd18f94ad694709630c0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6b0fcfedb46eb057a6d85aaedd7d9f49"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_hierarchy.html">IHierarchy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a6b0fcfedb46eb057a6d85aaedd7d9f49">QueryPagesLayer</a> () const =0</td></tr><tr class="separator:a6b0fcfedb46eb057a6d85aaedd7d9f49"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a90f32503a5e8d43fc8088a1eafe6acaa"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a90f32503a5e8d43fc8088a1eafe6acaa">GetItemsOnPage</a> (int32 pgPos, <a class="el" href="class_u_i_d_list.html">UIDList</a> *items, bool16 bIncludePage=kTrue, bool16 bIncludePasteboard=kFalse, bool16 bIncludeBleedAndSlug=kTrue) const =0</td></tr><tr class="separator:a90f32503a5e8d43fc8088a1eafe6acaa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a68258d00dfb431602827624fa73b8ab3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a68258d00dfb431602827624fa73b8ab3">PartitionPageItems</a> (<a class="el" href="class_u_i_d_list.html">UIDList</a> *partition[], bool16 bIncludePage, int32 pasteboardIndex, bool16 bIncludeBleedAndSlug) const =0</td></tr><tr class="separator:a68258d00dfb431602827624fa73b8ab3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a759fc699c95be36e51d100dc86a67712"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a759fc699c95be36e51d100dc86a67712"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PartitionPageItems</b> (const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_p_m_rect.html">PMRect</a> &gt; &amp;rects, const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_p_m_matrix.html">PMMatrix</a> &gt; &amp;rect2SpreadTransforms, <a class="el" href="class_u_i_d_list.html">UIDList</a> *partition_[], int32 pasteboardIndex) const =0</td></tr><tr class="separator:a759fc699c95be36e51d100dc86a67712"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aba1381e79ceec19ce133854241bcb949"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#aba1381e79ceec19ce133854241bcb949">GetNumPages</a> () const =0</td></tr><tr class="separator:aba1381e79ceec19ce133854241bcb949"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afe996b07fabeec374f49af34c4f3aec3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_geometry.html">IGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#afe996b07fabeec374f49af34c4f3aec3">QueryNthPage</a> (int32 n) const =0</td></tr><tr class="separator:afe996b07fabeec374f49af34c4f3aec3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9b62e506756b79643190031d0cf221ed"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a9b62e506756b79643190031d0cf221ed">GetNthPageUID</a> (int32 n) const =0</td></tr><tr class="separator:a9b62e506756b79643190031d0cf221ed"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2980be26d29ff084ab81a4242ae47e84"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_geometry.html">IGeometry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a2980be26d29ff084ab81a4242ae47e84">QueryNearestPage</a> (const <a class="el" href="class_p_m_point.html">PBPMPoint</a> &amp;pt, int32 *pageIndex) const =0</td></tr><tr class="separator:a2980be26d29ff084ab81a4242ae47e84"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad9ac7f4b916ca1f78cf99cadfd0a6fc5"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#ad9ac7f4b916ca1f78cf99cadfd0a6fc5">GetPageIndex</a> (<a class="el" href="class_i_d_type.html">UID</a> pageID) const =0</td></tr><tr class="separator:ad9ac7f4b916ca1f78cf99cadfd0a6fc5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4d3650e68a73c6d6eced21e3a27144b1"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a4d3650e68a73c6d6eced21e3a27144b1">ForEachItem</a> (<a class="el" href="class_item_manipulator.html">ItemManipulator</a> *manipulator, <a class="el" href="class_layer_mask.html">LayerMask</a> *layerMask=nil) const =0</td></tr><tr class="separator:a4d3650e68a73c6d6eced21e3a27144b1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a95dfe3f87013467558eba3c06d86badf"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a95dfe3f87013467558eba3c06d86badf">GetPagesBounds</a> (const <a class="el" href="struct_transform_1_1_coordinate_space.html">Transform::CoordinateSpace</a> &amp;coordinateSpace) const =0</td></tr><tr class="separator:a95dfe3f87013467558eba3c06d86badf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa1c53d111d23fa334a19c4deaaeda37a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#aa1c53d111d23fa334a19c4deaaeda37a">GetPagesAndItemsBounds</a> (const <a class="el" href="struct_transform_1_1_coordinate_space.html">Transform::CoordinateSpace</a> &amp;coordinateSpace, bool16 includeGuides=kFalse) const =0</td></tr><tr class="separator:aa1c53d111d23fa334a19c4deaaeda37a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a32390f821a16c1335562406a54c438df"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_point.html">PMPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a32390f821a16c1335562406a54c438df">GetSpreadZeroPoint</a> () const =0</td></tr><tr class="separator:a32390f821a16c1335562406a54c438df"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3cb29422fa1712976bf5bdb9ac503e8b"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_columns.html">IColumns</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_spread.html#a3cb29422fa1712976bf5bdb9ac503e8b">QueryNearestColumnBounds</a> (const <a class="el" href="class_p_m_point.html">PBPMPoint</a> &amp;pt, bool16 bIsVertical, <a class="el" href="class_p_m_rect.html">PMRect</a> *pColumnBounds=nil, int32 *pPageIndex=nil, int32 *pColumnIndex=nil) const =0</td></tr><tr class="separator:a3cb29422fa1712976bf5bdb9ac503e8b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Abstract interface that represents a spread, a container for pages (<a class="el" href="classk_page_boss.html">kPageBoss</a>) and page items. The list of spreads (<a class="el" href="classk_spread_boss.html">kSpreadBoss</a>) is kept in the <a class="el" href="class_i_spread_list.html">ISpreadList</a> off the document (<a class="el" href="classk_doc_boss.html">kDocBoss</a>). A spread (<a class="el" href="classk_spread_boss.html">kSpreadBoss</a>) is the root of all drawable page item&#39;s IHierarchies (except for inlines) - pages are just elements in one layer of the spread&#39;s hierarchy, pages are not parents of other page items.<dl class="section see"><dt>See Also<dd><a class="el" href="classk_spread_boss.html">kSpreadBoss</a><dd><a class="el" href="class_i_spread_list.html">ISpreadList</a><dd><a class="el" href="classk_doc_boss.html">kDocBoss</a><dd><a class="el" href="classk_page_boss.html">kPageBoss</a></dl></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a4d3650e68a73c6d6eced21e3a27144b1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ISpread::ForEachItem </td><td>(</td><td class="paramtype"><a class="el" href="class_item_manipulator.html">ItemManipulator</a> *&nbsp;</td><td class="paramname"><em>manipulator</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_layer_mask.html">LayerMask</a> *&nbsp;</td><td class="paramname"><em>layerMask</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>ForEachItem - Iterates over all items in the spread. The &quot;manipulator&quot; is called for each item. Groups are not traversed into. All layers are transversed (including hidden, non-printing, etc.), unless a <a class="el" href="class_layer_mask.html">LayerMask</a> is provided.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">IN</td><td>manipulator - the object called back with each item on the spread </td></tr><tr><td class="paramname">IN</td><td>layerMask - a filter call back (see <a class="el" href="class_layer_mask.html">LayerMask</a>) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 - Returns kFalse, if iteration was terminated due to the manipulator returning kFalse. Returns kTrue if all items on all layers satisfying the <a class="el" href="class_layer_mask.html">LayerMask</a> were traversed. </dl></div></div><a class="anchor" id="a90f32503a5e8d43fc8088a1eafe6acaa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISpread::GetItemsOnPage </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>pgPos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>items</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIncludePage</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIncludePasteboard</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIncludeBleedAndSlug</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetItemsOnPage - return a list of all items in this spread&#39;s hierarchy that are &quot;owned&quot; by the given page. An item that overlaps more than one page is &quot;owned&quot; by the one its spread aligned bounding box intersects the most with by area (or the one with the smallest page index in case of a tie). This is used to decide what page items should be moved when a page is moved to another sppread. Note this does <em>not</em> include master items (because they aren&#39;t in the same hierarchy), and it may contain the page shape itself, if bIncludePage is kTrue.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">IN</td><td>pgPos - zero based index, which page in the spread </td></tr><tr><td class="paramname">OUT</td><td>items - <a class="el" href="class_u_i_d_list.html">UIDList</a> of items owned by the given page </td></tr><tr><td class="paramname">IN</td><td>bIncludePage - kTrue == include the page shape itself; kFalse == don&#39;t </td></tr><tr><td class="paramname">IN</td><td>bIncludePasteboard - kTrue == include items that are owned by the pasteboard in the returned list also </td></tr><tr><td class="paramname">IN</td><td>bIncludeBleedAndSlug - kTrue == include items that are within the bleed/slug area for this page. </td></tr></table></dl></div></div><a class="anchor" id="a9b62e506756b79643190031d0cf221ed"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ISpread::GetNthPageUID </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetNthPageUID - return the UID of the indexed page (kInvalidUID if out of range)<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>- zero based page index </td></tr></table></dl><dl class="section return"><dt>Returns<dd>UID - the UID of the indexed page (kInvalidUID if out of range) </dl></div></div><a class="anchor" id="aba1381e79ceec19ce133854241bcb949"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ISpread::GetNumPages </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetNumPages - return the number of pages in this spread<dl class="section return"><dt>Returns<dd>int32 - the number of pages in this spread </dl></div></div><a class="anchor" id="ad9ac7f4b916ca1f78cf99cadfd0a6fc5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ISpread::GetPageIndex </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>pageID</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetPageIndex - return the index of the page corresponding to the passed UID (or -1 if not in this spread) this is the inverse of GetNthPageUID<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pageID</td><td>- UID of page </td></tr></table></dl><dl class="section return"><dt>Returns<dd>int32 - index of page with UID pageUID </dl></div></div><a class="anchor" id="aa1c53d111d23fa334a19c4deaaeda37a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> ISpread::GetPagesAndItemsBounds </td><td>(</td><td class="paramtype">const <a class="el" href="struct_transform_1_1_coordinate_space.html">Transform::CoordinateSpace</a> &amp;&nbsp;</td><td class="paramname"><em>coordinateSpace</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>includeGuides</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetPagesAndItemsBounds - Returns a bounding box that tightly encloses (in the given coordinate system) all the pages on the spread plus any page items sitting on the pasteboard.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">IN</td><td>coordinateSpace - either Transform::PasteboardCoordinates() or Transform::SpreadCoordinates() </td></tr><tr><td class="paramname">includeGuides</td><td>- kTrue == include enough space vertically to include horizontal guides and enough space horizontally to include vertical guides; kFalse = ignore guides </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_p_m_rect.html">PMRect</a></dl></div></div><a class="anchor" id="a95dfe3f87013467558eba3c06d86badf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> ISpread::GetPagesBounds </td><td>(</td><td class="paramtype">const <a class="el" href="struct_transform_1_1_coordinate_space.html">Transform::CoordinateSpace</a> &amp;&nbsp;</td><td class="paramname"><em>coordinateSpace</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetPagesBounds - Returns the bounding box that tightly encloses all the pages on the spread in the given coordinate system.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">IN</td><td>coordinateSpace - either Transform::PasteboardCoordinates() or Transform::SpreadCoordinates() </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_p_m_rect.html">PMRect</a> - bounding box that tightly encloses all the pages on the spread. </dl></div></div><a class="anchor" id="a32390f821a16c1335562406a54c438df"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_point.html">PMPoint</a> ISpread::GetSpreadZeroPoint </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>GetSpreadZeroPoint - Returns the zero point for this spread by getting zero point pref for the pub and calculating where that spread-relative point falls on this spread.<dl class="section return"><dt>Returns<dd><a class="el" href="class_p_m_point.html">PMPoint</a></dl></div></div><a class="anchor" id="a68258d00dfb431602827624fa73b8ab3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ISpread::PartitionPageItems </td><td>(</td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>partition</em>[], </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIncludePage</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>pasteboardIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIncludeBleedAndSlug</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>PartitionPageItems - returns lists of all the items on this spread&#39;s layers that are &quot;owned&quot; by each page. An item that overlaps more than one page is &quot;owned&quot; by the one that its item-aligned bounding box intersects the most with by area (or the one with the smallest page index in case of a tie). This is used to decide what page items should be moved when a page is moved to another sppread. Note this does <em>not</em> include master items (because they aren&#39;t in the same hierarchy), and it may contain the page shape itself, if bIncludePage is kTrue. The partition parameter is a C array of (numPages + 1) pointers to UIDLists that the caller must allocate. The last <a class="el" href="class_u_i_d_list.html">UIDList</a> is for returning items that are not owned by any page but are completely in the pasteboard margins. Individual pointers themselves may be nil if you are not interested in items on certain pages. Or individual pointers may be equal if you want to pile together items on more than one page into a single list maintaining their z-order. For example, you may make every UIDList* before a page index (say i) point to one <a class="el" href="class_u_i_d_list.html">UIDList</a>, the UIDList* at index i paoint to a second <a class="el" href="class_u_i_d_list.html">UIDList</a>, and every UIDList* after i point to a third <a class="el" href="class_u_i_d_list.html">UIDList</a>. If pasteboardIndex &gt;= 0 or less than numPages, the pasteboard items will be added to that page&#39;s <a class="el" href="class_u_i_d_list.html">UIDList</a> in addition to adding them to partition[numPages]. (Note passing numPages for pasteboardIndex does not mean add pasteboard items to the last <a class="el" href="class_u_i_d_list.html">UIDList</a> twice, it means don&#39;t add pasteboard items to any other <a class="el" href="class_u_i_d_list.html">UIDList</a> other than the last.) Note that every item on every layer is logically added to exactly one of the UIDLists in partition[]. If some UIDList* pointers are nil, or if pasteboardIndex &gt;= 0 and &lt; numPages, or if bIncludePage is false, this won&#39;t be strictly true in the obvious ways.<p>Note that PartitionPageItems is a generalization of GetItemsOnPage and is more efficient, more convenient, and more informative than calling GetItemsOnPage several times. PartitionPageItems is no less efficient than GetItemsOnPage even if you require only a one <a class="el" href="class_u_i_d_list.html">UIDList</a> answer.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">OUT</td><td>partition - an array of numPages + 1 pointers to UIDLists that the caller must allocate </td></tr><tr><td class="paramname">IN</td><td>bIncludePage - kTrue == include the page shape itself; kFalse == don&#39;t </td></tr><tr><td class="paramname">IN</td><td>pasteboardIndex - 0-based index into partition for which <a class="el" href="class_u_i_d_list.html">UIDList</a> to add pasteboard items to in addition to adding them to *partion[numPages] </td></tr><tr><td class="paramname">IN</td><td>bIncludeBleedAndSlug - kTrue == include items that are within the bleed/slug area of each page. </td></tr></table></dl></div></div><a class="anchor" id="a48e0c4d322acbd18f94ad694709630c0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_spread_layer.html">ISpreadLayer</a>* ISpread::QueryLayer </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_document_layer.html">IDocumentLayer</a> *&nbsp;</td><td class="paramname"><em>docLayer</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pPos</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>wantGuideLayer</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>QueryLayer - Return the spread layer associated with the given document layer; adds a ref count to the interface<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">IN</td><td>docLayer - document layer whose corresponding SpreadLayer you want </td></tr><tr><td class="paramname">OUT</td><td>pPos - returned position of the spread layer within the spread (may be nil) </td></tr><tr><td class="paramname">IN</td><td>wantGuideLayer - kTrue == return the corresponding spread guide layer; kFalse == return the normal spread layer (default = kFalse) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>ISpreadLayer* - spread layer corresponding to the supplied document layer </dl></div></div><a class="anchor" id="a3cb29422fa1712976bf5bdb9ac503e8b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_columns.html">IColumns</a>* ISpread::QueryNearestColumnBounds </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PBPMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>pt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bIsVertical</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>pColumnBounds</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pPageIndex</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pColumnIndex</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>QueryNearestColumnBounds - Used to locate the column nearest a point. In calculating the ColumnBounds we take into account whether we are interested in a horizontal or vertical perspective For example, a vertical text frame in a horizontal column layout will be interested in aligning the right edge if pColumnBounds to pt.X(), while a horizontal text frame will want to align top with pt.Y().<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">IN</td><td>pt - point in question </td></tr><tr><td class="paramname">bIsVertical</td><td></td></tr><tr><td class="paramname">OUT</td><td>pColumnBounds - rectangle in spread coordinates for the size of the column </td></tr><tr><td class="paramname">OUT</td><td>pPageIndex - the index of the page containing the columns </td></tr><tr><td class="paramname">OUT</td><td>pColumnIndex - the column index </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IColumns* - the column interface for the columns; adds a reference to this interface </dl></div></div><a class="anchor" id="a2980be26d29ff084ab81a4242ae47e84"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_geometry.html">IGeometry</a>* ISpread::QueryNearestPage </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PBPMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>pt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>pageIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>QueryNearestPage - return the <a class="el" href="class_i_geometry.html">IGeometry</a> of the nearest page to the given point in Pasteboard coordinates. Adds a reference to the returned interface.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pt</td><td>- [IN] - pt in Pasteboard coordinates </td></tr><tr><td class="paramname">pageIndex</td><td>- [OUT] - page index of nearest page </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IGeometry* - n&#39;th page&#39;s <a class="el" href="class_i_geometry.html">IGeometry</a></dl></div></div><a class="anchor" id="afe996b07fabeec374f49af34c4f3aec3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_geometry.html">IGeometry</a>* ISpread::QueryNthPage </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>QueryNthPage - return the <a class="el" href="class_i_geometry.html">IGeometry</a> of the n&#39;th page. Adds a reference to the returned interface.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">n</td><td>- zero based page index </td></tr></table></dl><dl class="section return"><dt>Returns<dd>IGeometry* - n&#39;th page&#39;s <a class="el" href="class_i_geometry.html">IGeometry</a></dl></div></div><a class="anchor" id="a6b0fcfedb46eb057a6d85aaedd7d9f49"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_hierarchy.html">IHierarchy</a>* ISpread::QueryPagesLayer </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>QueryPagesLayer - return the special &quot;Pages&quot; layer - the non-editable, non-UI layer containing the page shapes<dl class="section return"><dt>Returns<dd>IHierarchy* of the pages layer </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_spread.html">ISpread</a><li class="footer">Generated on Sat Sep 22 2018 10:54:28 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
