<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_table_attr_accessor</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_table_attr_accessor.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#nested-classes">Classes</a> | <a href="#pub-types">Public Types</a> | <a href="class_i_table_attr_accessor-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITableAttrAccessor Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_table_attr_accessor_8h_source.html">ITableAttrAccessor.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ITableAttrAccessor:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_table_attr_accessor.png" usemap="#ITableAttrAccessor_map" /><map id="ITableAttrAccessor_map" name="ITableAttrAccessor_map"><area alt="IPMUnknown" coords="0,0,120,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> Classes</h2></td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor_1_1_cell_overrides_callback.html">CellOverridesCallback</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor_1_1_cell_stroke_overrides_callback.html">CellStrokeOverridesCallback</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a67bb058bf7ff69160b16506d00ed652a"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITABLEATTRACCESSOR }</td></tr><tr class="memdesc:a67bb058bf7ff69160b16506d00ed652a"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">kDefaultIID <br /></td></tr><tr class="separator:a67bb058bf7ff69160b16506d00ed652a"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr><td colspan="2"><div class="groupHeader">Cell Styles.</div></td></tr><tr class="memitem:aafddf07d9f517d0b96ab08ecf9433c41"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#aafddf07d9f517d0b96ab08ecf9433c41">GetAttributesFromCellStyle</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:aafddf07d9f517d0b96ab08ecf9433c41"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acc3759b22b992e13db617774d9f9ed5a"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#acc3759b22b992e13db617774d9f9ed5a">GetAttributesFromRegionalCellStyle</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:acc3759b22b992e13db617774d9f9ed5a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a36d8d6ea27b61b0ea1b8de9594f1e37a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a36d8d6ea27b61b0ea1b8de9594f1e37a">GetCellStyle</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, int32 *priority=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:a36d8d6ea27b61b0ea1b8de9594f1e37a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a872d8f6c4639dd417a551cb764543fe8"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a872d8f6c4639dd417a551cb764543fe8">GetRegionalCellStyle</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:a872d8f6c4639dd417a551cb764543fe8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab60c08901e4a9e80763de4fff0294aa4"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#ab60c08901e4a9e80763de4fff0294aa4">QueryCellStyleForAttr</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, const <a class="el" href="class_i_d_type.html">ClassID</a> &amp;whichAttr, const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;iid, <a class="el" href="class_grid_area.html">GridArea</a> *surroundingRun=nil) const =0</td></tr><tr class="separator:ab60c08901e4a9e80763de4fff0294aa4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Row attributes.</div></td></tr><tr class="memitem:a767f33744919e0b1114b490bb3ba127b"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a767f33744919e0b1114b490bb3ba127b">QueryRowAttribute</a> (int32 row, <a class="el" href="class_i_d_type.html">ClassID</a> whichAttr, <a class="el" href="class_i_d_type.html">PMIID</a> iid) const =0</td></tr><tr class="separator:a767f33744919e0b1114b490bb3ba127b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0b6a61b6ab16439ee1aeb2c55ddd9ea3"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a0b6a61b6ab16439ee1aeb2c55ddd9ea3">QueryRowOverride</a> (int32 row, <a class="el" href="class_i_d_type.html">ClassID</a> whichAttr, <a class="el" href="class_i_d_type.html">PMIID</a> id) const =0</td></tr><tr class="separator:a0b6a61b6ab16439ee1aeb2c55ddd9ea3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a17c199ac20e33b26cc694a53afb5e6f8"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_data_wrapper.html">DataWrapper</a><br class="typebreak" /> &lt; <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a17c199ac20e33b26cc694a53afb5e6f8">QueryRowOverrides</a> (int32 row, int32 *runLength=nil) const =0</td></tr><tr class="separator:a17c199ac20e33b26cc694a53afb5e6f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Column attributes.</div></td></tr><tr class="memitem:a9fa45a12c3d70c6e1a23cfd909144ca6"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a9fa45a12c3d70c6e1a23cfd909144ca6">QueryColAttribute</a> (int32 col, <a class="el" href="class_i_d_type.html">ClassID</a> whichAttr, <a class="el" href="class_i_d_type.html">PMIID</a> id) const =0</td></tr><tr class="separator:a9fa45a12c3d70c6e1a23cfd909144ca6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0a96b980a834cbe5f7201b707599bdd5"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a0a96b980a834cbe5f7201b707599bdd5">QueryColOverride</a> (int32 col, <a class="el" href="class_i_d_type.html">ClassID</a> whichAttr, <a class="el" href="class_i_d_type.html">PMIID</a> id) const =0</td></tr><tr class="separator:a0a96b980a834cbe5f7201b707599bdd5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acbad5eda229e6be27a1e27fbf5ada53c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_data_wrapper.html">DataWrapper</a><br class="typebreak" /> &lt; <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#acbad5eda229e6be27a1e27fbf5ada53c">QueryColOverrides</a> (int32 col, int32 *runLength=nil) const =0</td></tr><tr class="separator:acbad5eda229e6be27a1e27fbf5ada53c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Cell attributes.</div></td></tr><tr class="memitem:afa4bfda8f01ceeaa0cdbfc9de234d785"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#afa4bfda8f01ceeaa0cdbfc9de234d785">QueryCellAttribute</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, <a class="el" href="class_i_d_type.html">ClassID</a> whichAttr, <a class="el" href="class_i_d_type.html">PMIID</a> iid, <a class="el" href="class_grid_area.html">GridArea</a> *surroundingRun=nil, bool16 isPreserveOverride=kTrue) const =0</td></tr><tr class="separator:afa4bfda8f01ceeaa0cdbfc9de234d785"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae09b898a333daede987dbfa7a499275d"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#ae09b898a333daede987dbfa7a499275d">QueryCellOverride</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, <a class="el" href="class_i_d_type.html">ClassID</a> whichAttr, <a class="el" href="class_i_d_type.html">PMIID</a> iid, <a class="el" href="class_grid_area.html">GridArea</a> *surroundingRun=nil) const =0</td></tr><tr class="separator:ae09b898a333daede987dbfa7a499275d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a60533e838449552683d65570fbf545fd"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_data_wrapper.html">DataWrapper</a><br class="typebreak" /> &lt; <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a60533e838449552683d65570fbf545fd">QueryCellOverrides</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, <a class="el" href="class_grid_area.html">GridArea</a> *surroundingRun=nil) const =0</td></tr><tr class="separator:a60533e838449552683d65570fbf545fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a34dba9078567eec3ff492bd60e6a7234"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a34dba9078567eec3ff492bd60e6a7234">IterateCellOverrides</a> (<a class="el" href="class_i_table_attr_accessor_1_1_cell_overrides_callback.html">CellOverridesCallback</a> &amp;callBack) const =0</td></tr><tr class="separator:a34dba9078567eec3ff492bd60e6a7234"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abaf1d572b998af00abd80479b6ef8462"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#abaf1d572b998af00abd80479b6ef8462">IterateCellStrokeOverrides</a> (Tables::ERowColumn patternType, <a class="el" href="class_i_table_attr_accessor_1_1_cell_stroke_overrides_callback.html">CellStrokeOverridesCallback</a> &amp;callBack) const =0</td></tr><tr class="separator:abaf1d572b998af00abd80479b6ef8462"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Table attributes.</div></td></tr><tr class="memitem:ad8e26a934ea8337273c4e1bb4ef5597c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#ad8e26a934ea8337273c4e1bb4ef5597c">GetTableStyle</a> (void) const =0</td></tr><tr class="separator:ad8e26a934ea8337273c4e1bb4ef5597c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a066cee2cde1afd26d002470492126b24"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a066cee2cde1afd26d002470492126b24">QueryTableAttribute</a> (<a class="el" href="class_i_d_type.html">ClassID</a> whichAttr, <a class="el" href="class_i_d_type.html">PMIID</a> iid) const =0</td></tr><tr class="separator:a066cee2cde1afd26d002470492126b24"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c49b1f622907df20ef1482c900860e5"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a9c49b1f622907df20ef1482c900860e5">GetTableAttributesResolved</a> (void) const =0</td></tr><tr class="separator:a9c49b1f622907df20ef1482c900860e5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaae255dc267e08e87961ce52b1b1f1cd"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_i_table_attributes.html">ITableAttributes</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#aaae255dc267e08e87961ce52b1b1f1cd">QueryTableOverrides</a> (void) const =0</td></tr><tr class="separator:aaae255dc267e08e87961ce52b1b1f1cd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Cell content type attributes.</div></td></tr><tr class="memitem:a059e611a4abf5e6fa3b1a142d4388f10"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a059e611a4abf5e6fa3b1a142d4388f10">GetCellType</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor) const =0</td></tr><tr class="separator:a059e611a4abf5e6fa3b1a142d4388f10"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a794143ba923bd1fe5756b7da770e2bf3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">CellType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a794143ba923bd1fe5756b7da770e2bf3">GetDefaultCellType</a> (void) const =0</td></tr><tr class="separator:a794143ba923bd1fe5756b7da770e2bf3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr><td colspan="2"><div class="groupHeader">Caches.</div></td></tr><tr class="memitem:acc54504ba078db8a8d92d4677da5cbcf"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#acc54504ba078db8a8d92d4677da5cbcf">ClearCaches</a> (void)=0</td></tr><tr class="separator:acc54504ba078db8a8d92d4677da5cbcf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4d7e642e7e60b42f30a5a40c4a6b96ab"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a4d7e642e7e60b42f30a5a40c4a6b96ab">FirstColLeftStrokeChanged</a> ()=0</td></tr><tr class="separator:a4d7e642e7e60b42f30a5a40c4a6b96ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abbc9b250d135cb05fa6493bb2a0b5a23"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abbc9b250d135cb05fa6493bb2a0b5a23"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LastColRightStrokeChanged</b> ()=0</td></tr><tr class="separator:abbc9b250d135cb05fa6493bb2a0b5a23"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a> Stroke &amp; fill attributes.</h2></td></tr><tr class="memitem:aaf69cbfd7ad89e973d606bbbe9b7a1d1"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kLowestPriority</b> = 0 }</td></tr><tr class="separator:aaf69cbfd7ad89e973d606bbbe9b7a1d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a45025086637aaa837ad5eb3c163601d9"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a45025086637aaa837ad5eb3c163601d9">GetElementStrokeWeight</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge, bool16 *isOverride=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:a45025086637aaa837ad5eb3c163601d9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a17d6dc4169fa1acc5764d40d46a6e8f3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="struct_i_table_line_type_1_1_s_type.html">ITableLineType::SType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a17d6dc4169fa1acc5764d40d46a6e8f3">GetElementStrokeType</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge, bool16 *isOverride=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:a17d6dc4169fa1acc5764d40d46a6e8f3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aafcad1d1dcb22939eb1c8a3b7c7d0697"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#aafcad1d1dcb22939eb1c8a3b7c7d0697">GetElementStrokeColor</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge, bool16 *isOverride=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:aafcad1d1dcb22939eb1c8a3b7c7d0697"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a27acacd7718ea4018488ffb76f90934c"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a27acacd7718ea4018488ffb76f90934c">GetElementStrokeTint</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge, bool16 *isOverride=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:a27acacd7718ea4018488ffb76f90934c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa327b8afaa4b697c6bb89bbf43af7d75"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#aa327b8afaa4b697c6bb89bbf43af7d75">GetElementStrokeOverprint</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge, bool16 *isOverride=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:aa327b8afaa4b697c6bb89bbf43af7d75"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a123d49c8dd2407fe92b6e9d5d4086c06"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a123d49c8dd2407fe92b6e9d5d4086c06">GetElementStrokeGapColor</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge, bool16 *isOverride=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:a123d49c8dd2407fe92b6e9d5d4086c06"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aeb065fcce4a87ad8e8275114f1f1a166"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#aeb065fcce4a87ad8e8275114f1f1a166">GetElementStrokeGapTint</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge, bool16 *isOverride=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:aeb065fcce4a87ad8e8275114f1f1a166"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af19e30a52111f13dfcba7ecadb738678"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#af19e30a52111f13dfcba7ecadb738678">GetElementStrokeGapOverprint</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge, bool16 *isOverride=nil, <a class="el" href="class_grid_area.html">GridArea</a> *runArea=nil) const =0</td></tr><tr class="separator:af19e30a52111f13dfcba7ecadb738678"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aeddc399c3946e674379f0c15794752c6"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#aeddc399c3946e674379f0c15794752c6">GetElementStrokePriority</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;element, Tables::ECellEdge edge) const =0</td></tr><tr class="separator:aeddc399c3946e674379f0c15794752c6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afcc2770a88cb96b6254960311bd482d5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#afcc2770a88cb96b6254960311bd482d5">GetCellMaxStrokeWeight</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor, Tables::ECellEdge edge) const =0</td></tr><tr class="separator:afcc2770a88cb96b6254960311bd482d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5a9446780e6cf678101c327c76f0ec9b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a5a9446780e6cf678101c327c76f0ec9b">GetCellStrokeWeightAndType</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor, Tables::ECellEdge edge, <a class="el" href="class_k2_vector.html">TableAttrStrokeWeightAndTypeList</a> *swtList) const =0</td></tr><tr class="separator:a5a9446780e6cf678101c327c76f0ec9b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1e1e81549b2934f854d4454f83b14b6f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a1e1e81549b2934f854d4454f83b14b6f">GetFirstColMaxLeftStrokeWeight</a> () const =0</td></tr><tr class="separator:a1e1e81549b2934f854d4454f83b14b6f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1d42a2abcb84765edf814a34c9aae789"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a1d42a2abcb84765edf814a34c9aae789">GetLastColMaxRightStrokeWeight</a> () const =0</td></tr><tr class="separator:a1d42a2abcb84765edf814a34c9aae789"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a34859eab1ad60d332c0ff67243b804da"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a34859eab1ad60d332c0ff67243b804da">GetFillColor</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor) const =0</td></tr><tr class="separator:a34859eab1ad60d332c0ff67243b804da"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9ea8a064d399ec5317df8376254cf486"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a9ea8a064d399ec5317df8376254cf486">GetFillTint</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor) const =0</td></tr><tr class="separator:a9ea8a064d399ec5317df8376254cf486"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2d470bc5a723a93819eba4c5520f490b"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_table_attr_accessor.html#a2d470bc5a723a93819eba4c5520f490b">GetFillOverprint</a> (const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;anchor) const =0</td></tr><tr class="separator:a2d470bc5a723a93819eba4c5520f490b"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Interface to access attributes in the table model.<dl class="section author"><dt>Author<dd>Joe Shankar </dl></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="acc54504ba078db8a8d92d4677da5cbcf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableAttrAccessor::ClearCaches </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For internal use by table model. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">cols</td><td></td></tr></table></dl></div></div><a class="anchor" id="a4d7e642e7e60b42f30a5a40c4a6b96ab"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableAttrAccessor::FirstColLeftStrokeChanged </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For internal use by table model. </div></div><a class="anchor" id="aafddf07d9f517d0b96ab08ecf9433c41"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a>* ITableAttrAccessor::GetAttributesFromCellStyle </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the attributes for a given cell that are from the cell style applied to the cell. Its not sufficient to simply get the attributes of the cell style to determine which attributes are actually being shown because for a given cell its cell strokes may come from the cell style applied to the cell, or its neighbor. The attributes returned by this function are not necessarily the attributes used in the cell. To get what is actually used you can call <code>GetAttributesFromRegionalCellStyle</code>, this function, and <code>QueryCellOverrides</code> to get all the cell attributes applied to a single cell.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>[IN] the address of the cell to get the cell style attributes from </td></tr><tr><td class="paramname">runArea</td><td>[OUT] optional, the run area for the cell style attributes </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a list containing the cell style attributes for the given cell, with its stroke attributes resolved with the stroke attributes of cell styles from adjacent cells. </dl></div></div><a class="anchor" id="acc3759b22b992e13db617774d9f9ed5a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a>* ITableAttrAccessor::GetAttributesFromRegionalCellStyle </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the attributes for a given cell that are from the regional cell style that is applied through the table style. Its not sufficient to simply get the attributes of the regional cell style to determine which attributes are actually being shown because for a given cell its cell strokes may come from the regional cell style applied to the cell, or its neighbor. The attributes returned by this function are not necessarily the attributes used in the cell. To get what is actually used you can call this function, <code>GetAttributesFromCellStyle</code>, and <code>QueryCellOverrides</code> to get all the cell attributes applied to a single cell.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>[IN] the address of the cell to get the regional cell style attributes from </td></tr><tr><td class="paramname">runArea</td><td>[OUT] optional, the run area for the regional cell style attributes </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a list containing the regional cell style attributes for the given cell, with its stroke attributes resolved with the stroke attributes of regional cell styles from adjacent cells. </dl></div></div><a class="anchor" id="afcc2770a88cb96b6254960311bd482d5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableAttrAccessor::GetCellMaxStrokeWeight </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine the max <em>effective</em> stroke weight for a cell&#39;s specified edge. For an edge to have an effective stroke it must have a non-zero stroke weight and a valid stroke type. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor,anchor</td><td>location of the anchor (top-left of cell) in underlying table grid. see <a class="el" href="class_grid_address.html">GridAddress</a> for more information on anchors versus elements. </td></tr><tr><td class="paramname">edge,specifies</td><td>whether left, top right or bottom edge. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>max stroke weight for edge of cell. </dl></div></div><a class="anchor" id="a5a9446780e6cf678101c327c76f0ec9b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableAttrAccessor::GetCellStrokeWeightAndType </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">TableAttrStrokeWeightAndTypeList</a> *&nbsp;</td><td class="paramname"><em>swtList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Fills in the swtList with <em>effective</em> stroke weight and line type for all elements along the specified edge of the cell. For an edge to have an effective stroke it must have a non-zero stroke weight and a valid stroke type. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor,anchor</td><td>location of the anchor (top-left of cell) in underlying table grid. see <a class="el" href="class_grid_address.html">GridAddress</a> for more information on anchors versus elements. </td></tr><tr><td class="paramname">edge,specifies</td><td>whether left, top right or bottom edge. </td></tr><tr><td class="paramname">swtList,the</td><td>list to be filled in with Stroke Weight and LineType. </td></tr></table></dl></div></div><a class="anchor" id="a36d8d6ea27b61b0ea1b8de9594f1e37a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITableAttrAccessor::GetCellStyle </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>priority</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the cell style for the given <code><a class="el" href="class_grid_address.html">GridAddress</a></code>. Because cells do not necessarily have a style, this function can return <code>kInvalidUID</code>, which is treated the same as the root cell style.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>[IN] the <code><a class="el" href="class_grid_address.html">GridAddress</a></code> of the cell to retrieve the style from, this should be a valid grid address of the table </td></tr><tr><td class="paramname">priority</td><td>[OUT] optional, the cell style priority </td></tr><tr><td class="paramname">runArea</td><td>[OUT] optional, the run area </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the <code>UID</code> of the applied cell style, may be <code>kInvalidUID</code></dl></div></div><a class="anchor" id="a059e611a4abf5e6fa3b1a142d4388f10"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">CellType</a> ITableAttrAccessor::GetCellType </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Might be removed. Returns the CellType associated with anchor.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>Cell whose type is to be returned. </td></tr></table></dl></div></div><a class="anchor" id="a794143ba923bd1fe5756b7da770e2bf3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">CellType</a> ITableAttrAccessor::GetDefaultCellType </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Query to determine what the default cell-type

</pre><dl class="section return"><dt>Returns<dd>default type of new cells that are created in this table. </dl></div></div><a class="anchor" id="aafcad1d1dcb22939eb1c8a3b7c7d0697"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITableAttrAccessor::GetElementStrokeColor </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>isOverride</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine the stroke color for the specified element on the given edge. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>specifies a location within underlying grid </td></tr></table></dl><dl class="section return"><dt>Returns<dd>stroke color as a UID for given edge </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">OUT,:</td><td>isOverride whether result is an override attribute </td></tr><tr><td class="paramname">OUT,:</td><td>Only Valid is isOverride is true, it is the runArea area over the attribute if it is an override </td></tr></table></dl></div></div><a class="anchor" id="a123d49c8dd2407fe92b6e9d5d4086c06"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITableAttrAccessor::GetElementStrokeGapColor </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>isOverride</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine the stroke gap color for the specified element on the given edge. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>specifies a location within underlying grid </td></tr></table></dl><dl class="section return"><dt>Returns<dd>stroke gap color as a UID for given edge </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">OUT,:</td><td>isOverride whether result is an override attribute </td></tr><tr><td class="paramname">OUT,:</td><td>Only Valid is isOverride is true, it is the runArea area over the attribute if it is an override </td></tr></table></dl></div></div><a class="anchor" id="af19e30a52111f13dfcba7ecadb738678"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableAttrAccessor::GetElementStrokeGapOverprint </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>isOverride</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine whether the grid-element at the given address has an associated stroke gap overprint. This will use inheritance resolution to take account of any overrides applied. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>co-ordinate of cell of interest </td></tr><tr><td class="paramname">edge</td><td>specifies which edge of the cell are to be considered </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the stroke associated with given location has gap overprint, kFalse otherwise </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">OUT,:</td><td>isOverride whether result is an override attribute </td></tr><tr><td class="paramname">OUT,:</td><td>Only Valid is isOverride is true, it is the runArea area over the attribute if it is an override </td></tr></table></dl></div></div><a class="anchor" id="aeb065fcce4a87ad8e8275114f1f1a166"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableAttrAccessor::GetElementStrokeGapTint </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>isOverride</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine for stroke gap tint associated with a grid-element. This will use inheritance resolution to take account of any overrides applied. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>specifies a location within underlying grid </td></tr><tr><td class="paramname">edge</td><td>specifies whether left, top right or bottom </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the stroke-gap-tint as real-numbered value </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">OUT,:</td><td>isOverride whether result is an override attribute </td></tr><tr><td class="paramname">OUT,:</td><td>Only Valid is isOverride is true, it is the runArea area over the attribute if it is an override </td></tr></table></dl></div></div><a class="anchor" id="aa327b8afaa4b697c6bb89bbf43af7d75"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableAttrAccessor::GetElementStrokeOverprint </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>isOverride</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine whether the grid-element at the given address has an associated stroke overprint. This will use inheritance resolution to take account of any overrides applied. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>co-ordinate of cell of interest </td></tr><tr><td class="paramname">edge</td><td>specifies which edge of the cell are to be considered </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the stroke associated with given location has overprint, kFalse otherwise </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">OUT,:</td><td>isOverride whether result is an override attribute </td></tr><tr><td class="paramname">OUT,:</td><td>Only Valid is isOverride is true, it is the runArea area over the attribute if it is an override </td></tr></table></dl></div></div><a class="anchor" id="aeddc399c3946e674379f0c15794752c6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITableAttrAccessor::GetElementStrokePriority </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the stroke draw priority. Larger number draws on top of smaller ones. <dl class="section return"><dt>Returns<dd>stroke-draw priority. </dl></div></div><a class="anchor" id="a27acacd7718ea4018488ffb76f90934c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableAttrAccessor::GetElementStrokeTint </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>isOverride</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine for stroke tint associated with a grid-element. This will use inheritance resolution to take account of any overrides applied. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>specifies a location within underlying grid </td></tr><tr><td class="paramname">edge</td><td>specifies whether left, top right or bottom </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the stroke-tint as real-numbered value </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">OUT,:</td><td>isOverride whether result is an override attribute </td></tr><tr><td class="paramname">OUT,:</td><td>Only Valid is isOverride is true, it is the runArea area over the attribute if it is an override </td></tr></table></dl></div></div><a class="anchor" id="a17d6dc4169fa1acc5764d40d46a6e8f3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="struct_i_table_line_type_1_1_s_type.html">ITableLineType::SType</a> ITableAttrAccessor::GetElementStrokeType </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>isOverride</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine the stroke type associated with specified element and given edge. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>specifies location within underlying grid </td></tr><tr><td class="paramname">edge</td><td>specifies whether left, top right or bottom </td></tr></table></dl><dl class="section return"><dt>Returns<dd>line type as one of enumerated values on <a class="el" href="class_i_table_line_type.html">ITableLineType</a> interface </dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">OUT,:</td><td>isOverride whether result is an override attribute </td></tr><tr><td class="paramname">OUT,:</td><td>Only Valid is isOverride is true, it is the runArea area over the attribute if it is an override </td></tr></table></dl></div></div><a class="anchor" id="a45025086637aaa837ad5eb3c163601d9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableAttrAccessor::GetElementStrokeWeight </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">Tables::ECellEdge&nbsp;</td><td class="paramname"><em>edge</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16 *&nbsp;</td><td class="paramname"><em>isOverride</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine the stroke weight at a given location for specified edge. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>specifies location within underlying grid </td></tr><tr><td class="paramname">edge</td><td>specifies whether left, top right or bottom </td></tr><tr><td class="paramname">OUT,:</td><td>isOverride whether result is an override attribute </td></tr><tr><td class="paramname">OUT,:</td><td>Only Valid is isOverride is true, it is the runArea area over the attribute if it is an override </td></tr></table></dl></div></div><a class="anchor" id="a34859eab1ad60d332c0ff67243b804da"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITableAttrAccessor::GetFillColor </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine the fill of the given anchor; see <a class="el" href="class_grid_address.html">GridAddress</a> for more information on anchors versus elements. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>location of the anchor (top-left of cell) in underlying table grid </td></tr></table></dl><dl class="section return"><dt>Returns<dd>fill color as UID </dl></div></div><a class="anchor" id="a2d470bc5a723a93819eba4c5520f490b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITableAttrAccessor::GetFillOverprint </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the overprint of the fill for anchor.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>location of the anchor (top-left of cell) within the underlying grid </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if there is an overprint associated with the fill at the given location, kFalse otherwise </dl></div></div><a class="anchor" id="a9ea8a064d399ec5317df8376254cf486"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableAttrAccessor::GetFillTint </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>anchor</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Returns the tint of the fill for anchor.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">anchor</td><td>location of the anchor (top-left of cell) in underlying table grid </td></tr></table></dl><dl class="section return"><dt>Returns<dd>fill-tint as real-valued number </dl></div></div><a class="anchor" id="a1e1e81549b2934f854d4454f83b14b6f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableAttrAccessor::GetFirstColMaxLeftStrokeWeight </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine the max <em>effective</em> stroke weight for the left edge of the table. For an edge to have an effective stroke it must have a non-zero stroke weight and a valid stroke type. <dl class="section return"><dt>Returns<dd>maximum stroke weight for the left edge of the first column </dl></div></div><a class="anchor" id="a1d42a2abcb84765edf814a34c9aae789"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITableAttrAccessor::GetLastColMaxRightStrokeWeight </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Determine the max <em>effective</em> stroke weight for the right edge of the table. For an edge to have an effective stroke it must have a non-zero stroke weight and a valid stroke type. <dl class="section return"><dt>Returns<dd>maximum stroke weight for the right edge of the last column </dl></div></div><a class="anchor" id="a872d8f6c4639dd417a551cb764543fe8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITableAttrAccessor::GetRegionalCellStyle </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>runArea</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets the regional cell style for the given <code><a class="el" href="class_grid_address.html">GridAddress</a></code>.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>[IN] the address of the cell </td></tr><tr><td class="paramname">runArea</td><td>[OUT] optional, the regional style&#39;s area </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the regional cell style for the given cell </dl></div></div><a class="anchor" id="a9c49b1f622907df20ef1482c900860e5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_attribute_boss_list.html">AttributeBossList</a>* ITableAttrAccessor::GetTableAttributesResolved </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Acquire the list of table attributes after resolving table style and overrides. Caller does <b>not</b> own the storage here and should not attempt to release as this is not a reference-bumped ptr that would be returned from a query. <dl class="section return"><dt>Returns<dd>reference to list of table attributes fully resolved. </dl></div></div><a class="anchor" id="ad8e26a934ea8337273c4e1bb4ef5597c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_d_type.html">UID</a> ITableAttrAccessor::GetTableStyle </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the table style of this table </div></div><a class="anchor" id="a34dba9078567eec3ff492bd60e6a7234"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableAttrAccessor::IterateCellOverrides </td><td>(</td><td class="paramtype"><a class="el" href="class_i_table_attr_accessor_1_1_cell_overrides_callback.html">CellOverridesCallback</a> &amp;&nbsp;</td><td class="paramname"><em>callBack</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Function to walk all cell overrides efficiently. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">callBack</td><td>Callback for iterating cell overrides. callBack.VisitRun is called for each run area See <a class="el" href="class_i_table_attr_accessor_1_1_cell_overrides_callback.html">CellOverridesCallback</a> for more info. </td></tr></table></dl></div></div><a class="anchor" id="abaf1d572b998af00abd80479b6ef8462"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITableAttrAccessor::IterateCellStrokeOverrides </td><td>(</td><td class="paramtype">Tables::ERowColumn&nbsp;</td><td class="paramname"><em>patternType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_table_attr_accessor_1_1_cell_stroke_overrides_callback.html">CellStrokeOverridesCallback</a> &amp;&nbsp;</td><td class="paramname"><em>callBack</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Function to walk all cell stroke overrides efficiently. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">patternType</td><td>Whether we are searching or a row or a column override </td></tr><tr><td class="paramname">callBack</td><td>Callback for iterating cell overrides. callBack.VisitRun is called for each run area See <a class="el" href="class_i_table_attr_accessor_1_1_cell_overrides_callback.html">CellOverridesCallback</a> for more info. </td></tr></table></dl></div></div><a class="anchor" id="afa4bfda8f01ceeaa0cdbfc9de234d785"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableAttrAccessor::QueryCellAttribute </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>iid</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>surroundingRun</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isPreserveOverride</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns cell attribute fully resolving inheritance of table style, table attribute overrides.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>Grid element for which attribute is to be returned. </td></tr><tr><td class="paramname">whicAttr</td><td>ClassID of the attribute boss. </td></tr><tr><td class="paramname">iid</td><td>Interface ID of interface on attribute boss to be returned. The result may be cast to the &#39;type&#39; identified by iid. </td></tr><tr><td class="paramname">surroundingRun</td><td>Value will be returned if non nil. Return value is the absolute value of the run that the element is in. All elements in this range have the same value for whichAttr. This can be used for optimizations. </td></tr><tr><td class="paramname">isPreserveOverride</td><td>Preserve local overrides ON or OFF. This is used to govern whether cell overrides are to be taken into consideration or not (required in EPUB/HTML export.) </td></tr></table></dl></div></div><a class="anchor" id="ae09b898a333daede987dbfa7a499275d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableAttrAccessor::QueryCellOverride </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>iid</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>surroundingRun</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns cell override WITHOUT any inheritance resolution. Returns nil if the attribute is not overriden.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>Grid element for which attribute is to be returned. </td></tr><tr><td class="paramname">whicAttr</td><td>ClassID of the attribute boss. </td></tr><tr><td class="paramname">iid</td><td>Interface ID of interface on attribute boss to be returned. The result may be cast to the &#39;type&#39; identified by iid. </td></tr><tr><td class="paramname">surroundingRun</td><td>Will be set if non nil. Is the absolute value of the run that the element is in. All elements in this range have the same value for whichAttr. This can be used for optimizations. </td></tr></table></dl></div></div><a class="anchor" id="a60533e838449552683d65570fbf545fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_data_wrapper.html">DataWrapper</a>&lt;<a class="el" href="class_attribute_boss_list.html">AttributeBossList</a>&gt; ITableAttrAccessor::QueryCellOverrides </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>surroundingRun</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns all cell overrides WITHOUT any inheritance resolution.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">element</td><td>Grid element for which attribute is to be returned. </td></tr><tr><td class="paramname">surroundingRun</td><td>Value will be returned if non nil. Return value is the absolute value of the run that the element is in. All elements in this range have the same value for whichAttr. This can be used for optimizations. </td></tr></table></dl></div></div><a class="anchor" id="ab60c08901e4a9e80763de4fff0294aa4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableAttrAccessor::QueryCellStyleForAttr </td><td>(</td><td class="paramtype">const <a class="el" href="class_grid_address.html">GridAddress</a> &amp;&nbsp;</td><td class="paramname"><em>element</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">ClassID</a> &amp;&nbsp;</td><td class="paramname"><em>whichAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_d_type.html">PMIID</a> &amp;&nbsp;</td><td class="paramname"><em>iid</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_grid_area.html">GridArea</a> *&nbsp;</td><td class="paramname"><em>surroundingRun</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Queries the cell style and regional cell style for a particular attribute. The attriubte returned by this function may not be the attribute that is visible, an override may be applied to the cell.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">[IN]</td><td>the cell to get the attribute for </td></tr><tr><td class="paramname">whichAttr</td><td>[IN] the cell attribute to retrieve </td></tr><tr><td class="paramname">iid</td><td>[IN] the attribute&#39;s <code>PMIID</code></td></tr><tr><td class="paramname">surroundingRun</td><td>[IN] optional, the surrounding run </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the attribute for the cell after resolving the cell and regional cell style hierarchies, may be nil if the attribute is not defined </dl></div></div><a class="anchor" id="a9fa45a12c3d70c6e1a23cfd909144ca6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableAttrAccessor::QueryColAttribute </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>col</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>id</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query for column attribute, fully resolving inheritance of table style, table attribute overrides and rules. Returns interface ptr that has reference count incremented.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">col</td><td>Column for which attribute is to be returned. </td></tr><tr><td class="paramname">whicAttr</td><td>ClassID of the attribute boss of interest </td></tr><tr><td class="paramname">iid</td><td>Interface ID of interface on attribute boss to be returned. The result may be cast to the &#39;type&#39; identified by iid. </td></tr></table></dl></div></div><a class="anchor" id="a0a96b980a834cbe5f7201b707599bdd5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableAttrAccessor::QueryColOverride </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>col</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>id</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query for a column override WITHOUT any inheritance resolution. Returns interface ptr that has reference count incremented<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">col</td><td>Column for which attribute is to be returned. </td></tr><tr><td class="paramname">whicAttr</td><td>ClassID of the attribute boss. </td></tr><tr><td class="paramname">iid</td><td>Interface ID of interface on attribute boss to be returned. The result may be cast to the &#39;type&#39; identified by iid. </td></tr></table></dl></div></div><a class="anchor" id="acbad5eda229e6be27a1e27fbf5ada53c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_data_wrapper.html">DataWrapper</a>&lt;<a class="el" href="class_attribute_boss_list.html">AttributeBossList</a>&gt; ITableAttrAccessor::QueryColOverrides </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>col</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>runLength</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns all column overrides WITHOUT any inheritance resolution.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">col</td><td>Column for which attribute is to be returned. </td></tr><tr><td class="paramname">runLength</td><td>Value will be returned if non nil. Return value is the count of the columns starting with &#39;col&#39; that have the same attribute. This can be used for optimizations. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>collection of attribute boss ClassIDs </dl></div></div><a class="anchor" id="a767f33744919e0b1114b490bb3ba127b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableAttrAccessor::QueryRowAttribute </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>row</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>iid</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns row attribute fully resolving inheritance of table style, table attribute overrides and rules.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">row</td><td>Row for which attribute is to be returned. </td></tr><tr><td class="paramname">whicAttr</td><td>ClassID of the attribute boss of interest </td></tr><tr><td class="paramname">iid</td><td>Interface ID of interface on attribute boss to be returned. The result may be cast to the &#39;type&#39; identified by iid. </td></tr></table></dl></div></div><a class="anchor" id="a0b6a61b6ab16439ee1aeb2c55ddd9ea3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableAttrAccessor::QueryRowOverride </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>row</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>id</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query for a row override WITHOUT any inheritance resolution. Returns interface ptr that has reference count incremented.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">row</td><td>row for which attribute is to be returned. </td></tr><tr><td class="paramname">whicAttr</td><td>ClassID of the attribute boss. </td></tr><tr><td class="paramname">iid</td><td>Interface ID of interface on attribute boss to be returned. The result may be cast to the &#39;type&#39; identified by iid. </td></tr></table></dl></div></div><a class="anchor" id="a17c199ac20e33b26cc694a53afb5e6f8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_data_wrapper.html">DataWrapper</a>&lt;<a class="el" href="class_attribute_boss_list.html">AttributeBossList</a>&gt; ITableAttrAccessor::QueryRowOverrides </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>row</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>runLength</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns all row overrides WITHOUT any inheritance resolution.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">row</td><td>Row for which attribute is to be returned. </td></tr><tr><td class="paramname">runLength</td><td>Value will be returned if non nil. Return value is the count of the rows starting with &#39;row&#39; that have the same attribute. This can be used for optimizations. </td></tr></table></dl></div></div><a class="anchor" id="a066cee2cde1afd26d002470492126b24"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a>* ITableAttrAccessor::QueryTableAttribute </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>whichAttr</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>iid</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query for table attribute fully resolving inheritance of table style and table attribute overrides. Get back interface ptr which has reference count incremented.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">whicAttr</td><td>ClassID of the attribute boss. </td></tr><tr><td class="paramname">iid</td><td>Interface ID of interface on attribute boss to be returned. The result may be cast to the &#39;type&#39; identified by iid. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>reference-count incremented interface ptr </dl></div></div><a class="anchor" id="aaae255dc267e08e87961ce52b1b1f1cd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_table_attributes.html">ITableAttributes</a>* ITableAttrAccessor::QueryTableOverrides </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query for the list of table attribute overrides. Caller should call release. <dl class="section return"><dt>Returns<dd>reference-count incremented pointer. </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_table_attr_accessor.html">ITableAttrAccessor</a><li class="footer">Generated on Sat Sep 22 2018 10:54:29 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
