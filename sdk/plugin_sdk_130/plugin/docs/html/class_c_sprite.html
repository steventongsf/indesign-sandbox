<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_c_sprite</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_c_sprite.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-methods">Public Member Functions</a> | <a href="#pro-methods">Protected Member Functions</a> | <a href="#pro-static-methods">Static Protected Member Functions</a> | <a href="#pro-attribs">Protected Attributes</a> | <a href="class_c_sprite-members.html">List of all members</a></div><div class="headertitle"><div class="title">CSprite Class Reference</div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_c_sprite_8h_source.html">CSprite.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for CSprite:</div><div class="dyncontent"><div class="center"><img alt="" src="class_c_sprite.png" usemap="#CSprite_map" /><map id="CSprite_map" name="CSprite_map"><area alt="ISprite" coords="0,56,101,80" href="class_i_sprite.html" shape="rect" /><area alt="IPMUnknown" coords="0,0,101,24" href="class_i_p_m_unknown.html" shape="rect" /><area alt="NoHandleSprite" coords="0,168,101,192" href="class_no_handle_sprite.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:acefea20e3d4375e8e5a1ae9b35f20d51"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#acefea20e3d4375e8e5a1ae9b35f20d51">CSprite</a> (<a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *boss)</td></tr><tr class="separator:acefea20e3d4375e8e5a1ae9b35f20d51"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3a089d3eff94606fb3a43cc4fc9242fe"><td align="right" class="memItemLeft" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a3a089d3eff94606fb3a43cc4fc9242fe">~CSprite</a> ()</td></tr><tr class="separator:a3a089d3eff94606fb3a43cc4fc9242fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a325ab7ff8b5168e5b38669ae4ece8bad"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a325ab7ff8b5168e5b38669ae4ece8bad">CreateSprite</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, <a class="el" href="class_u_i_d_list.html">UIDList</a> *itemList, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;startPt, bool16 bDrawItemList)</td></tr><tr class="separator:a325ab7ff8b5168e5b38669ae4ece8bad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5f2de4868130dfdadf2c1bfacfcdffb7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a5f2de4868130dfdadf2c1bfacfcdffb7">DestroySprite</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc)</td></tr><tr class="separator:a5f2de4868130dfdadf2c1bfacfcdffb7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae135af197fac3175483bc4326d6949ce"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#ae135af197fac3175483bc4326d6949ce">Show</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:ae135af197fac3175483bc4326d6949ce"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a076563d0bcdaf842373e224350e3e672"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a076563d0bcdaf842373e224350e3e672">Scroll</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;delta, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a076563d0bcdaf842373e224350e3e672"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a1badbea1740b6001fe5c9a141538d5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a1a1badbea1740b6001fe5c9a141538d5">Erase</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a1a1badbea1740b6001fe5c9a141538d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a07aaa66e4af4e2e69b3feaf5913d81fe"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a07aaa66e4af4e2e69b3feaf5913d81fe">Hide</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, bool16 bForceRedraw, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *extraXform)</td></tr><tr class="separator:a07aaa66e4af4e2e69b3feaf5913d81fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afb2ab306c6a120c08d6683523c8e015a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#afb2ab306c6a120c08d6683523c8e015a">InvalidateBBox</a> ()</td></tr><tr class="separator:afb2ab306c6a120c08d6683523c8e015a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88eff37710477bce0538d1263acf0971"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a88eff37710477bce0538d1263acf0971">DisableShapes</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, bool16 disable)</td></tr><tr class="separator:a88eff37710477bce0538d1263acf0971"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa48c2385b364f59c09a726d92f7de2c9"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="struct_sys_rect.html">SysRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#aa48c2385b364f59c09a726d92f7de2c9">GetDeviceBounds</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:aa48c2385b364f59c09a726d92f7de2c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa6c1d3e7699cac4c2f519526556083d6"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#aa6c1d3e7699cac4c2f519526556083d6">ValidSprite</a> () const </td></tr><tr class="separator:aa6c1d3e7699cac4c2f519526556083d6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6f83faed4887c7f389bc942c51fbaee0"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a6f83faed4887c7f389bc942c51fbaee0">NeedsUpdate</a> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags) const </td></tr><tr class="separator:a6f83faed4887c7f389bc942c51fbaee0"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a> Protected Member Functions</h2></td></tr><tr class="memitem:ad0f5c3ce14189a069cc15ad75c04dbf0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#ad0f5c3ce14189a069cc15ad75c04dbf0">DisableHandleShapes</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, bool16 disable)</td></tr><tr class="separator:ad0f5c3ce14189a069cc15ad75c04dbf0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a324c71009743d05c9129ed3185e0d853"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a324c71009743d05c9129ed3185e0d853">GetShapeDeviceBounds</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags)</td></tr><tr class="separator:a324c71009743d05c9129ed3185e0d853"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4ee45ef0f4bc38f6100ecbaa82596558"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a4ee45ef0f4bc38f6100ecbaa82596558">GetHandleDeviceBounds</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a4ee45ef0f4bc38f6100ecbaa82596558"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a36c35f800e919cc0ac05663501644244"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a36c35f800e919cc0ac05663501644244">GetTrackerBounds</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags)</td></tr><tr class="separator:a36c35f800e919cc0ac05663501644244"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0e961c3ba94af19acca5352ec8b56204"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a0e961c3ba94af19acca5352ec8b56204">GetSelectionBounds</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc)</td></tr><tr class="separator:a0e961c3ba94af19acca5352ec8b56204"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afe36912d3776f67b06f49ed87e05f33a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#afe36912d3776f67b06f49ed87e05f33a">DrawTrackerExtra</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags)</td></tr><tr class="separator:afe36912d3776f67b06f49ed87e05f33a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a716fb39e90e3bd74685a6d562309e19c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a716fb39e90e3bd74685a6d562309e19c">ShowFirstTime</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a716fb39e90e3bd74685a6d562309e19c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abd76f58d8ca7fb1b8a7a7f3d6619a65e"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#abd76f58d8ca7fb1b8a7a7f3d6619a65e">ShowSprite</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:abd76f58d8ca7fb1b8a7a7f3d6619a65e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a19b06b7579d6b345994b7b64aaa61612"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a19b06b7579d6b345994b7b64aaa61612">ScrollSprite</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;delta, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a19b06b7579d6b345994b7b64aaa61612"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a052b1db8a735415f6dd61fe6427dbbfc"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a052b1db8a735415f6dd61fe6427dbbfc">ShowLowMemory</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a052b1db8a735415f6dd61fe6427dbbfc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a87e7ad534f9fbacddf69dcb3baba6542"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a87e7ad534f9fbacddf69dcb3baba6542">ShowLowMemoryFirstTime</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a87e7ad534f9fbacddf69dcb3baba6542"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a52cee495bcaece83019e249865d6cfd6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a52cee495bcaece83019e249865d6cfd6">ScrollLowMemory</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;delta, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a52cee495bcaece83019e249865d6cfd6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2b24c23bde20fdffe2155b289d22a267"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a2b24c23bde20fdffe2155b289d22a267">HideSprite</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, bool16 bForceRedraw, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *extraXform)</td></tr><tr class="separator:a2b24c23bde20fdffe2155b289d22a267"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae4f1a6c0abed855705712394b8b17a59"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#ae4f1a6c0abed855705712394b8b17a59">HideLowMemory</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, bool16 bForceRedraw, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *extraXform)</td></tr><tr class="separator:ae4f1a6c0abed855705712394b8b17a59"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7c16c9d7b21374d758aa52037783e094"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a7c16c9d7b21374d758aa52037783e094">EraseAndRedrawShapes</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;where, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a7c16c9d7b21374d758aa52037783e094"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af12f1e421b24037bff253ba664f19cab"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#af12f1e421b24037bff253ba664f19cab">SetHiliteColor</a> (<a class="el" href="class_i_d_type.html">UID</a> layerUID)</td></tr><tr class="separator:af12f1e421b24037bff253ba664f19cab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac214098b31ef1eeefde7e12f90d06d50"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#ac214098b31ef1eeefde7e12f90d06d50">DrawShapes</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, SysRgn clipRgn=nil, bool16 bDisable=kFalse)</td></tr><tr class="separator:ac214098b31ef1eeefde7e12f90d06d50"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a620b13a001b6c92e4d3f583bc83079b0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a620b13a001b6c92e4d3f583bc83079b0">DrawSelection</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc)</td></tr><tr class="separator:a620b13a001b6c92e4d3f583bc83079b0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adde8be3e67d0580411526199e679f08b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#adde8be3e67d0580411526199e679f08b">DrawSpriteShapes</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags)</td></tr><tr class="separator:adde8be3e67d0580411526199e679f08b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a74ee356a9734b8bcbab870321d9c52a0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a74ee356a9734b8bcbab870321d9c52a0">DrawSpriteHandles</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags, <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a74ee356a9734b8bcbab870321d9c52a0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1614e7d1037c0f97a6c960fdaa739584"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a1614e7d1037c0f97a6c960fdaa739584">CreateTrackerPaths</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc)</td></tr><tr class="separator:a1614e7d1037c0f97a6c960fdaa739584"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a59653898e8d2c0285ff80b49186da1c3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a59653898e8d2c0285ff80b49186da1c3">CreateHandlePaths</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, bool16 bDoDirectionHandles=kTrue)</td></tr><tr class="separator:a59653898e8d2c0285ff80b49186da1c3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9202f34f7c523a1e9c42e03f45223a7b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a9202f34f7c523a1e9c42e03f45223a7b">ClipToView</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, <a class="el" href="struct_sys_rect.html">SysRect</a> *bounds)</td></tr><tr class="separator:a9202f34f7c523a1e9c42e03f45223a7b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af93372b73a0d3695cab1c3c6eb173ead"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#af93372b73a0d3695cab1c3c6eb173ead">ClipToView</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;bounds)</td></tr><tr class="separator:af93372b73a0d3695cab1c3c6eb173ead"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab9f9edc085a925b824bda51ed721f342"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#ab9f9edc085a925b824bda51ed721f342">GetStandOffBBox</a> (<a class="el" href="class_i_shape.html">IShape</a> *pShape, <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, int32 flags, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;bBox)</td></tr><tr class="separator:ab9f9edc085a925b824bda51ed721f342"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1e3fcc429ebf8219b769b91c5ce68bd5"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a1e3fcc429ebf8219b769b91c5ce68bd5">GetDrawFlags</a> () const </td></tr><tr class="separator:a1e3fcc429ebf8219b769b91c5ce68bd5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a09c5143ed94b98af4326ccbf755c2ca8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a09c5143ed94b98af4326ccbf755c2ca8">UseDisplayList</a> (int32 flags)</td></tr><tr class="separator:a09c5143ed94b98af4326ccbf755c2ca8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aac4d8be92dcdb0708d246f1cb9b67db4"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#aac4d8be92dcdb0708d246f1cb9b67db4">AddInvalidOffscreenBounds</a> (<a class="el" href="class_i_control_view.html">IControlView</a> *iView, <a class="el" href="class_p_m_rect.html">PMRect</a> *invalidBounds)</td></tr><tr class="separator:aac4d8be92dcdb0708d246f1cb9b67db4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a61fda22f8e81f446322e5fd18c4501c4"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a61fda22f8e81f446322e5fd18c4501c4">AddInvalidLayoutBounds</a> (<a class="el" href="class_i_control_view.html">IControlView</a> *iView, <a class="el" href="class_p_m_rect.html">PMRect</a> *invalidBounds)</td></tr><tr class="separator:a61fda22f8e81f446322e5fd18c4501c4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a400285ddb0416477348c73d762deea71"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a400285ddb0416477348c73d762deea71">DrawSmartGuides</a> (<a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *gc, const <a class="el" href="class_p_m_point.html">PBPMPoint</a> where, const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *xForm)</td></tr><tr class="separator:a400285ddb0416477348c73d762deea71"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a> Static Protected Member Functions</h2></td></tr><tr class="memitem:a35965107333b905954a4e51644b17c0a"><td align="right" class="memItemLeft" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_sprite.html#a35965107333b905954a4e51644b17c0a">DrawCenterX</a> (<a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *gPort, const <a class="el" href="class_p_m_point.html">PBPMPoint</a> &amp;center)</td></tr><tr class="separator:a35965107333b905954a4e51644b17c0a"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a> Protected Attributes</h2></td></tr><tr class="memitem:a6416abbad2eebbb8aba19ae12ec1512b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6416abbad2eebbb8aba19ae12ec1512b"></a> <a class="el" href="class_p_m_matrix.html">PMMatrix</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fXformFromLastShow</b></td></tr><tr class="separator:a6416abbad2eebbb8aba19ae12ec1512b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a70c027c7f3cb4b186b9428b7cd0e24ee"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a70c027c7f3cb4b186b9428b7cd0e24ee"></a> <a class="el" href="struct_sys_rect.html">SysRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fLastBounds</b></td></tr><tr class="separator:a70c027c7f3cb4b186b9428b7cd0e24ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad3b8c1fbabf6633d36ebe1cf13f11084"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad3b8c1fbabf6633d36ebe1cf13f11084"></a> <a class="el" href="class_k2_vector.html">ColorArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fRGBColorValue</b></td></tr><tr class="separator:ad3b8c1fbabf6633d36ebe1cf13f11084"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abeab136193a452b4d73f7309b052d57c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abeab136193a452b4d73f7309b052d57c"></a> <a class="el" href="class_p_m_point.html">PMPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fStartPoint</b></td></tr><tr class="separator:abeab136193a452b4d73f7309b052d57c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a33b70e9b803c1d093696125b3feed4bb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a33b70e9b803c1d093696125b3feed4bb"></a> <a class="el" href="class_p_m_point.html">PMPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fCurrentPoint</b></td></tr><tr class="separator:a33b70e9b803c1d093696125b3feed4bb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9c80d6bb267f6baeb31d6e5e285bbf72"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9c80d6bb267f6baeb31d6e5e285bbf72"></a> <a class="el" href="struct_sys_point.html">SysPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>fLastMouseLoc</b></td></tr><tr class="separator:a9c80d6bb267f6baeb31d6e5e285bbf72"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac752b421b977dae00fbf06a71f694673"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac752b421b977dae00fbf06a71f694673"></a> <a class="el" href="class_i_control_view.html">IControlView</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fControlView</b></td></tr><tr class="separator:ac752b421b977dae00fbf06a71f694673"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a103e568e9172ff5862f3cc49d3b41aaa"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a103e568e9172ff5862f3cc49d3b41aaa"></a> <a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fItemList</b></td></tr><tr class="separator:a103e568e9172ff5862f3cc49d3b41aaa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7375f22fcb52147ec4bcfe9ec0941ed4"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7375f22fcb52147ec4bcfe9ec0941ed4"></a> <a class="el" href="class_i_d_v_offscreen_port_data.html">IDVOffscreenPortData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fBackgroundVP</b></td></tr><tr class="separator:a7375f22fcb52147ec4bcfe9ec0941ed4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5008d82d2d7b2af153de03c635bb0ee2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5008d82d2d7b2af153de03c635bb0ee2"></a> <a class="el" href="class_i_d_v_offscreen_port_data.html">IDVOffscreenPortData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fForegroundVP</b></td></tr><tr class="separator:a5008d82d2d7b2af153de03c635bb0ee2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ade9bffd5577a1944a9f3a297b46d770b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ade9bffd5577a1944a9f3a297b46d770b"></a> <a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fDataBase</b></td></tr><tr class="separator:ade9bffd5577a1944a9f3a297b46d770b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a596ad876261a76bd67ca7858e2ebd52a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a596ad876261a76bd67ca7858e2ebd52a"></a> int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>fDrawFlags</b></td></tr><tr class="separator:a596ad876261a76bd67ca7858e2ebd52a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7c241c3eb1e13c646de90b5aa75ced27"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7c241c3eb1e13c646de90b5aa75ced27"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fValidDeviceBounds</b></td></tr><tr class="separator:a7c241c3eb1e13c646de90b5aa75ced27"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a29dacdf6ec0cd6811913ee5441d4b752"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a29dacdf6ec0cd6811913ee5441d4b752"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fFirstTime</b></td></tr><tr class="separator:a29dacdf6ec0cd6811913ee5441d4b752"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a89e6e3fcb408ac795ccfc1cda2e57973"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a89e6e3fcb408ac795ccfc1cda2e57973"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fValidSprite</b></td></tr><tr class="separator:a89e6e3fcb408ac795ccfc1cda2e57973"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa77b39860bf878cba14d46760250bd9e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa77b39860bf878cba14d46760250bd9e"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fLowMemory</b></td></tr><tr class="separator:aa77b39860bf878cba14d46760250bd9e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab43fc19e0deef29514649ebc19f763c2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab43fc19e0deef29514649ebc19f763c2"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fIsFrontView</b></td></tr><tr class="separator:ab43fc19e0deef29514649ebc19f763c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2f1377fcdb468e62d15ac02984a9ebe9"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2f1377fcdb468e62d15ac02984a9ebe9"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fDrawItemList</b></td></tr><tr class="separator:a2f1377fcdb468e62d15ac02984a9ebe9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aae4d85356d05225772c5482293b49612"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aae4d85356d05225772c5482293b49612"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fIsPathSelection</b></td></tr><tr class="separator:aae4d85356d05225772c5482293b49612"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a836a25ffb824ce7e7e397e337333f6af"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a836a25ffb824ce7e7e397e337333f6af"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fHandlesDisabled</b></td></tr><tr class="separator:a836a25ffb824ce7e7e397e337333f6af"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6268147dc66c57ddca8b4ff5b571e7b5"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6268147dc66c57ddca8b4ff5b571e7b5"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fDoRevealAllImageData</b></td></tr><tr class="separator:a6268147dc66c57ddca8b4ff5b571e7b5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af860ac4321710744dacb4d76a5ed9655"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af860ac4321710744dacb4d76a5ed9655"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fSmartGuidesDrawn</b></td></tr><tr class="separator:af860ac4321710744dacb4d76a5ed9655"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a697328b9c8807ca48fa84562b8296d10"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a697328b9c8807ca48fa84562b8296d10"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>fDrawSmartGuides</b></td></tr><tr class="separator:a697328b9c8807ca48fa84562b8296d10"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a> Additional Inherited Members</h2></td></tr><tr class="inherit_header pub_types_class_i_sprite"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_types_class_i_sprite&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Types inherited from <a class="el" href="class_i_sprite.html">ISprite</a></td></tr><tr class="memitem:a1724404df8ce8ef1ff1359ee38eb854f inherit pub_types_class_i_sprite"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ISPRITE }</td></tr><tr class="separator:a1724404df8ce8ef1ff1359ee38eb854f inherit pub_types_class_i_sprite"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p><a class="el" href="class_c_sprite.html">CSprite</a> is an implementation of <a class="el" href="class_i_sprite.html">ISprite</a> used by trackers to update the screen while tracking. For example, when resizing a page item, a resize tracker will create a sprite. The sprite represents the page item that is being resized and is called by the tracker to &quot;Show&quot; every time the mouse is moved. Sprites can draw in wire frame mode or in &quot;patient user&quot; mode. When in wire frame mode, the original page item continues to draw unchanged while an outline of the page item is dynamically updated to show the effect of the change made by the tracker. In patient-user mode, the layout is continually redrawn to show the full effect of the change made by the tracker, as if the user released the mouse after each step. </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2><a class="anchor" id="acefea20e3d4375e8e5a1ae9b35f20d51"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">CSprite::CSprite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>boss</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Constructor </div></div><a class="anchor" id="a3a089d3eff94606fb3a43cc4fc9242fe"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual CSprite::~CSprite </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Destructor </div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a61fda22f8e81f446322e5fd18c4501c4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void CSprite::AddInvalidLayoutBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_control_view.html">IControlView</a> *&nbsp;</td><td class="paramname"><em>iView</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>invalidBounds</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span></span></td></tr></table></div><div class="memdoc"><p>Called when we are setting up our offscreens to obtain any additional area to be updated. Only used in offscreen mode (i.e., not in low memory mode). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iView</td><td>- IN: Used to obtain pending invals for the offscreen. </td></tr><tr><td class="paramname">invalidBounds</td><td>- OUT: Pending invals for the provided view are unioned with invalidBounds. </td></tr></table></dl></div></div><a class="anchor" id="aac4d8be92dcdb0708d246f1cb9b67db4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void CSprite::AddInvalidOffscreenBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_control_view.html">IControlView</a> *&nbsp;</td><td class="paramname"><em>iView</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="paramname"><em>invalidBounds</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span></span></td></tr></table></div><div class="memdoc"><p>Called when we are setting up our offscreens to obtain pending invals for the offscreen. Only used in offscreen mode (i.e., not in low memory mode). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iView</td><td>- IN: Used to obtain offscreen&#39;s pending inval areas. </td></tr><tr><td class="paramname">invalidBounds</td><td>- OUT: Pending invals for the provided offscreen are unioned with invalidBounds. </td></tr></table></dl></div></div><a class="anchor" id="a9202f34f7c523a1e9c42e03f45223a7b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::ClipToView </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="struct_sys_rect.html">SysRect</a> *&nbsp;</td><td class="paramname"><em>bounds</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a rectangle, clip it to the view referenced by the provided <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">bounds</td><td>- IN/OUT: The rectangle to intersect with the view bounds. </td></tr></table></dl></div></div><a class="anchor" id="af93372b73a0d3695cab1c3c6eb173ead"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::ClipToView </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>bounds</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a rectangle, clip it to the view referenced by the provided <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">bounds</td><td>- IN/OUT: The rectangle to intersect with the view bounds. </td></tr></table></dl></div></div><a class="anchor" id="a59653898e8d2c0285ff80b49186da1c3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::CreateHandlePaths </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bDoDirectionHandles</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Helpers to draw the handles and paths <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: The <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a>. </td></tr><tr><td class="paramname">bDoDirectionHandles</td><td>- IN: Include the control handles for each point? </td></tr></table></dl><p>Reimplemented in <a class="el" href="class_no_handle_sprite.html#a979c6de4e658a2a3baee46a977ee6e1b">NoHandleSprite</a>.</div></div><a class="anchor" id="a325ab7ff8b5168e5b38669ae4ece8bad"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 CSprite::CreateSprite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="paramname"><em>itemList</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>startPt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bDrawItemList</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Create sprite. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device that the sprite will draw to. </td></tr><tr><td class="paramname">itemList</td><td>- IN: The uidlist indicates those items that the sprite is rendering. It uses those items to compute the offscreen bounding box. If drawItemList is kTrue then the sprite will draw the items in the uid list during show. If itemList is nil that means the sprite should draw its own paths (if any) and ignore the item list related drawing. The path creation trackers use a nil item list because the actual page item isn&#39;t created until the end of dynamics. </td></tr><tr><td class="paramname">startPt</td><td>- IN: start point. </td></tr><tr><td class="paramname">bDrawItems</td><td>- IN: tells the sprite whether or not to draw the uid items during show. Set to kFalse only if the sprite implementation has another way that it draws the updated paths/shapes (such as spline editting). </td></tr></table></dl><dl class="section return"><dt>Returns<dd>returns kFalse if low memory. In that case, the sprite might do nothing or use XOR in <a class="el" href="class_i_sprite.html#a91708449b9bd6e415bdb52d0d326b127">ISprite::Show()</a>. If returns kTrue the sprite succeed in creating offscreens. </dl><p>Implements <a class="el" href="class_i_sprite.html#a699fbdd2b8c0b75d97354c8376dc2063">ISprite</a>.</div></div><a class="anchor" id="a1614e7d1037c0f97a6c960fdaa739584"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::CreateTrackerPaths </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Override CreateTrackerPaths to do something special such as the reference line in the rotate sprite. <a class="el" href="class_c_sprite.html">CSprite</a>&#39;s implementation walks/draws the path stored in the <a class="el" href="class_i_path_geometry.html">IPathGeometry</a> of the sprite&#39;s boss and then draws the handle vectors. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: The <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a>. </td></tr></table></dl><p>Reimplemented in <a class="el" href="class_no_handle_sprite.html#a4e241f2695f677993eef4620d2038e3b">NoHandleSprite</a>.</div></div><a class="anchor" id="a5f2de4868130dfdadf2c1bfacfcdffb7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::DestroySprite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Releases references to offscreens and cleans up. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. Used to issue an draw invalidations or screen redraws that may be necessary as part of the cleanup process. </td></tr></table></dl><p>Implements <a class="el" href="class_i_sprite.html#af5a02c65fc5491ae34b4fdf5c0a84f19">ISprite</a>.</div></div><a class="anchor" id="ad0f5c3ce14189a069cc15ad75c04dbf0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::DisableHandleShapes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>disable</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Obsolete. </div></div><a class="anchor" id="a88eff37710477bce0538d1263acf0971"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::DisableShapes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>disable</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>If called, this will disable the shapes in the uidlist from drawing in the background offscreen. This is different than the bDrawItems flag in CreateSprite. DisableShapes specifically affects only the items drawing during the creation of the background. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. Necessary to obtain the <a class="el" href="class_i_draw_mgr.html">IDrawMgr</a> for the port in order to tell the <a class="el" href="class_i_draw_mgr.html">IDrawMgr</a> to Disable the shape. </td></tr><tr><td class="paramname">disable</td><td>- IN: kTrue to disable the drawing of the shape. kFalse to enable the drawing. </td></tr></table></dl><p>Implements <a class="el" href="class_i_sprite.html#a909ad7206e88153e0a4acccd56c1dfa3">ISprite</a>.</div></div><a class="anchor" id="a35965107333b905954a4e51644b17c0a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">static void CSprite::DrawCenterX </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *&nbsp;</td><td class="paramname"><em>gPort</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PBPMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>center</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span></td></tr></table></div><div class="memdoc"><p>Draws dragging a wire frame sprite, a small X is drawn in XOr mode at the center of each page item. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gPort</td><td>- IN: The port to draw into. </td></tr><tr><td class="paramname">center</td><td>- IN: Where, in pasteboard coordinates, to draw the X. </td></tr></table></dl></div></div><a class="anchor" id="a620b13a001b6c92e4d3f583bc83079b0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::DrawSelection </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draw any selection highlighting. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> to draw into. </td></tr></table></dl></div></div><a class="anchor" id="ac214098b31ef1eeefde7e12f90d06d50"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::DrawShapes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">SysRgn&nbsp;</td><td class="paramname"><em>clipRgn</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bDisable</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draw the shapes intersecting the union of the clipRgn and any pending invalidation areas for the view represented by the provided GraphicsContext. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> to draw into. </td></tr><tr><td class="paramname">clipRgn</td><td>- IN: May be nil. Actually represents any additional area to update. This region gets unioned with any pending invalidations for the view represented by the gc. </td></tr><tr><td class="paramname">bDisable</td><td>- IN: indicates whether to allow the sprite uid list objects to draw or not. </td></tr></table></dl></div></div><a class="anchor" id="a400285ddb0416477348c73d762deea71"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void CSprite::DrawSmartGuides </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PBPMPoint</a>&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span></span></td></tr></table></div><div class="memdoc"><p>Draw smart alignment guides. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="a74ee356a9734b8bcbab870321d9c52a0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::DrawSpriteHandles </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Calls DrawCenterX in XOr mode for each of the items in the itemList passed into CreateSprite. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><p>Reimplemented in <a class="el" href="class_no_handle_sprite.html#a10177214680e976072b73b318c1cd63e">NoHandleSprite</a>.</div></div><a class="anchor" id="adde8be3e67d0580411526199e679f08b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::DrawSpriteShapes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draws the itemList passed into CreateSprite to the provided gc, using the IShape::flags <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> to draw into. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl></div></div><a class="anchor" id="afe36912d3776f67b06f49ed87e05f33a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::DrawTrackerExtra </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draws the dynamic part of the changes when not in patient-user mode. Draws the paths in xor mode. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl></div></div><a class="anchor" id="a1a1badbea1740b6001fe5c9a141538d5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::Erase </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>For the case when the sprite fails to create an offscreen, you can still use it for dynamics. But to do so requires the user to call erase so the old drawing is cleaned up. Erase should be called with the previous position. i.e., if the object is moving call show, then erase, then move the object, then show, then erase, then move the object, then show, etc. Of course erase should only be called immediately before moving the object (and only if the object is to move). flags are IShape::flags <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><p>Implements <a class="el" href="class_i_sprite.html#a5d28989e2344e1e9f64cf2548c687c63">ISprite</a>.</div></div><a class="anchor" id="a7c16c9d7b21374d758aa52037783e094"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::EraseAndRedrawShapes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>In the provided gc, erases and redraws the update area defined by GetDeviceBounds. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="aa48c2385b364f59c09a726d92f7de2c9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="struct_sys_rect.html">SysRect</a> CSprite::GetDeviceBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets device bounds <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Returns the bounds used by the sprite. The bounds includes everything the sprite would draw during show given the same flags and matrix. For <a class="el" href="class_c_sprite.html">CSprite</a>, this bounds is the union of GetShapeDeviceBounds, GetHandleDeviceBounds and GetTrackerBounds, all clipped to the view. </dl><p>Implements <a class="el" href="class_i_sprite.html#a21f0e3ed096c70bb63ac007de0a63aa8">ISprite</a>.</div></div><a class="anchor" id="a1e3fcc429ebf8219b769b91c5ce68bd5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 CSprite::GetDrawFlags </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the draw flags to use when when calling DrawMgr::Draw. For standard sprites this value is cached during CreateSprite. However, some sprites (TextOffscreen) may need to calculate the draw flags more often than that </div></div><a class="anchor" id="a4ee45ef0f4bc38f6100ecbaa82596558"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> CSprite::GetHandleDeviceBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets handle device bounds <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Returns the union of the IHandleShape::GetPaintedBBox of each of the items in the itemList passed to CreateSprite. </dl></div></div><a class="anchor" id="a0e961c3ba94af19acca5352ec8b56204"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> CSprite::GetSelectionBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets selection bounds <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. Used to obtain the view that is passed into the GetSelectionRgn call. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Returns bounds of the current selection. Bounds are obtained by asking the <a class="el" href="class_i_selection_manager.html">ISelectionManager</a> for the <a class="el" href="class_i_selection_data_suite.html">ISelectionDataSuite</a> and then computing the bounds on its GetSelectionRgn. </dl></div></div><a class="anchor" id="a324c71009743d05c9129ed3185e0d853"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> CSprite::GetShapeDeviceBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets shape device bounds <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="section return"><dt>Returns<dd>Returns the union of the <a class="el" href="class_i_shape.html#afba35af65bf27c0075d3a05d22cff2a7">IShape::GetPaintedBBox</a> of each of the items in the itemList passed to CreateSprite. </dl></div></div><a class="anchor" id="ab9f9edc085a925b824bda51ed721f342"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> CSprite::GetStandOffBBox </td><td>(</td><td class="paramtype"><a class="el" href="class_i_shape.html">IShape</a> *&nbsp;</td><td class="paramname"><em>pShape</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>bBox</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets standOff bounding box <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pShape</td><td>- IN: The page item whose text wrap we are interested in. </td></tr><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">bBox</td><td>- IN: The rect to return if there is no text wrap. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>If the provided page item has a text wrap, return the wrap&#39;s bounding box in the coordinates of the provided <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> (i.e. in screen coordinates). Otherwise, return the provided bBox. </dl></div></div><a class="anchor" id="a36c35f800e919cc0ac05663501644244"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> CSprite::GetTrackerBounds </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Allows the tracker to dynamically change the update area used by the sprite. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="section return"><dt>Returns<dd>If the boss containing this sprite has an <a class="el" href="class_i_path_geometry.html">IPathGeometry</a>, then grab that <a class="el" href="class_i_path_geometry.html">IPathGeometry</a> and return its GetCtrlPointsBoundingBox. </dl><p>Reimplemented in <a class="el" href="class_no_handle_sprite.html#aece50c0f295612b8af67a44812613c06">NoHandleSprite</a>.</div></div><a class="anchor" id="a07aaa66e4af4e2e69b3feaf5913d81fe"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::Hide </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bForceRedraw</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>extraXform</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Removes any sprite-related extra drawing. Restores the screen to reflect what is in the spread. This function is somewhat implementation dependent. For instance, in path creation it may be used to update with the newly created segment, or for rotation getting rid of the tracker line <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">bForceRedraw</td><td>- IN: Whether or not to force the gc to redraw before returning. </td></tr><tr><td class="paramname">extraXform</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><p>Implements <a class="el" href="class_i_sprite.html#a5b703ff30dca4461dd6cd477bf2fbe85">ISprite</a>.</div></div><a class="anchor" id="ae4f1a6c0abed855705712394b8b17a59"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::HideLowMemory </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bForceRedraw</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>extraXform</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by Hide to do all the work when in a low memory state and offscreens cannot be used. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">bForceRedraw</td><td>- IN: Whether or not to force the gc to redraw before returning. </td></tr><tr><td class="paramname">extraXform</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="a2b24c23bde20fdffe2155b289d22a267"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::HideSprite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bForceRedraw</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>extraXform</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by Hide to do all the work when not in a low memory state. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">bForceRedraw</td><td>- IN: Whether or not to force the gc to redraw before returning. </td></tr><tr><td class="paramname">extraXform</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="afb2ab306c6a120c08d6683523c8e015a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::InvalidateBBox </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tells the sprite that the objects bbox has changed and to recalculate the cached version in the sprite. <p>Implements <a class="el" href="class_i_sprite.html#aff61630fcbf9ba628e4535591316aaf1">ISprite</a>.</div></div><a class="anchor" id="a6f83faed4887c7f389bc942c51fbaee0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 CSprite::NeedsUpdate </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns kTrue when sprite needs to update, kFalse otherwise. <p>Implements <a class="el" href="class_i_sprite.html#a3b35c7b35ca18203c4f02f61f0d241e8">ISprite</a>.</div></div><a class="anchor" id="a076563d0bcdaf842373e224350e3e672"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 CSprite::Scroll </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>delta</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Scroll the sprite. In general, this recreates the background and repaints. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">delta</td><td>- IN: The amount to scroll. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse means the sprite is in low memory and that it drew the objects directly to gc. </dl><p>Implements <a class="el" href="class_i_sprite.html#ac037d0a8b214b898db5fa6337e92f110">ISprite</a>.</div></div><a class="anchor" id="a52cee495bcaece83019e249865d6cfd6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::ScrollLowMemory </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>delta</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by Scroll when in a low memory situation and offscreens cannot be used. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">delta</td><td>- IN: The amount to scroll. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="a19b06b7579d6b345994b7b64aaa61612"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::ScrollSprite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>delta</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by Scroll when we are not in a low memory situation. When in a low memory situation, Scroll will call ScrollLowMemory. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">delta</td><td>- IN: The amount to scroll. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="af12f1e421b24037bff253ba664f19cab"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::SetHiliteColor </td><td>(</td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>layerUID</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Override this method if the client wants a different tracker hilite color. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">layerUID</td><td>- IN: The UID of the layer whose layer color to use for hilighting. </td></tr></table></dl></div></div><a class="anchor" id="ae135af197fac3175483bc4326d6949ce"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 CSprite::Show </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Show the sprite. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kFalse means the sprite is in low memory and that it drew the objects directly to gc. </dl><p>Implements <a class="el" href="class_i_sprite.html#a91708449b9bd6e415bdb52d0d326b127">ISprite</a>.</div></div><a class="anchor" id="a716fb39e90e3bd74685a6d562309e19c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::ShowFirstTime </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>The first time that Show is called, ShowFirstTime will be called to set up its offscreens. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="a052b1db8a735415f6dd61fe6427dbbfc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::ShowLowMemory </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Called by Show when in a low memory state. Draws in XOr mode. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="a87e7ad534f9fbacddf69dcb3baba6542"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::ShowLowMemoryFirstTime </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Same as ShowLowMemory, except that it erases and redraws the gc first. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="abd76f58d8ca7fb1b8a7a7f3d6619a65e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void CSprite::ShowSprite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> *&nbsp;</td><td class="paramname"><em>gc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>where</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_matrix.html">PMMatrix</a> *&nbsp;</td><td class="paramname"><em>xForm</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Show calls ShowSprite every time except the first time, where it calls ShowFirstTime. ShowSprite uses the offscreens set up by ShowFirstTime. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">gc</td><td>- IN: A pointer to the <a class="el" href="class_i_graphics_context.html">IGraphicsContext</a> representing the device to which the sprite draws. </td></tr><tr><td class="paramname">where</td><td>- IN: Obsolete. Not used. </td></tr><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">xForm</td><td>- IN: The matrix represents the transformation that is passed into all the IHandleShapes in the item list (See CreateSprite). The matrix is a pasteboard relative transformation. </td></tr></table></dl></div></div><a class="anchor" id="a09c5143ed94b98af4326ccbf755c2ca8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 CSprite::UseDisplayList </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>flags</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Obsolete. <a class="el" href="class_c_sprite.html">CSprite</a> does not currently use display lists for drawing. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">flags</td><td>- IN: flags are IShape::flags.</td></tr></table></dl><dl class="section see"><dt>See Also<dd><a class="el" href="_i_shape_8h_source.html">IShape.h</a></dl><dl class="section return"><dt>Returns<dd>Returns whether to use a display list or not </dl><p>Reimplemented in <a class="el" href="class_no_handle_sprite.html#a7696b2561e96994a78099e672053e7e1">NoHandleSprite</a>.</div></div><a class="anchor" id="aa6c1d3e7699cac4c2f519526556083d6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 CSprite::ValidSprite </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns whether the sprite has been initialized &ndash; that is, that CreateSprite has been called. <p>Implements <a class="el" href="class_i_sprite.html#a459ad8a74749435caffbec8133e81f76">ISprite</a>.</div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_c_sprite.html">CSprite</a><li class="footer">Generated on Sat Sep 22 2018 10:53:27 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
