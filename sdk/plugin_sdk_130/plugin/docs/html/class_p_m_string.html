<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_p_m_string</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_p_m_string.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#nested-classes">Classes</a> | <a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="#pro-methods">Protected Member Functions</a> | <a href="#friends">Friends</a> | <a href="class_p_m_string-members.html">List of all members</a></div><div class="headertitle"><div class="title">PMString Class Reference</div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_p_m_string_8h_source.html">PMString.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for PMString:</div><div class="dyncontent"><div class="center"><img alt="" src="class_p_m_string.png" usemap="#PMString_map" /><map id="PMString_map" name="PMString_map"><area alt="UnicodeSavvyString" coords="0,0,127,24" href="class_unicode_savvy_string.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> Classes</h2></td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_m_string_1_1wchar__size.html">wchar_size</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a420d221adc4f7081bc56b588f90aefac"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefac">TranslateDuringCall</a> { <a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefaca224537655986f04b0b52ee30de7a45d1">kDontTranslateDuringCall</a>, <a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefaca7f2c6533d14a4582ab18142013d5502e">kTranslateDuringCall</a> }</td></tr><tr class="separator:a420d221adc4f7081bc56b588f90aefac"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a630154dc6d7c6114f44bf735966fdd89"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89">WhitespaceType</a> { <a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89adef634b900ace25306a07eca759259d9">kLeadingWhiteSpace</a> = 0, <a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89a03b38eeeadafdc20525ecf2ea2b742e9">kTrailingWhiteSpace</a>, <a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89aab71705d843bf510296bb9c58d815f4d">kLeadingAndTrailingWhiteSpace</a>, <a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89a090f3539c26b8559353849e71ba4d6cf">kAllWhiteSpace</a> }</td></tr><tr class="separator:a630154dc6d7c6114f44bf735966fdd89"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a786a4e9adac26492dbd7d5e64d1b6b"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6b">ConversionError</a> { <a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6ba44f095b16bc893b6fc599bf2bf056296">kNoError</a> = 0, <a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6ba24466cf52dd94c8c903cbfc60db27100">kNoNumber</a>, <a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6ba63ce79e8103bb3ef889639ae6dc110ad">kNotJustNumber</a> }</td></tr><tr class="separator:a1a786a4e9adac26492dbd7d5e64d1b6b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abeade53c5dc3aef7b31c89ca2d0c33e5"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5">StringPlatformEncoding</a> { <a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5a44fdd91f3e1ce352a259e392193cc8df">kPlatformEncodingWin</a>, <a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5ab4ab2a28657fbba67e529722c8266add">kPlatformEncodingMac</a>, <a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5aa98159f58b1f3d971f4160e2cf61d8db">kPlatformEncodingOther</a>, <a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5aec76f24dd5951d2c362d7ad5efe76e75">kUTF8Encoding</a> }</td></tr><tr class="separator:abeade53c5dc3aef7b31c89ca2d0c33e5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab7e2189ce8f077c74e234cf4312088ba"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">StringEncoding</a> { <br /> &nbsp;&nbsp;<a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baae760e9e8363eef4c98a21224b70e2a90">kEncodingASCII</a>, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baa9267c80dfc8bb3c90359898d1451346c">kEncodingShiftJIS</a>, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baa9927f470ea13ce94dc77758a33e6f27c">kEncodingChineseBig5</a>, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baaa80f3a04f3b2df2617745259bd4b5524">kEncodingKorean</a>, <br /> &nbsp;&nbsp;<a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baac8891d1d79dc365197bded521337de77">kEncodingArabic</a>, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baaabc3a26b1fff667d553775550dc3bea6">kEncodingHebrew</a>, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baa89d25e5c0ed3a53e55becc594c6cd731">kEncodingGreek</a>, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baa560b56a6ebe4c39644f2cef55ec9cc69">kEncodingCyrillic</a>, <br /> &nbsp;&nbsp;<a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baa2f4b47fa86b075d694868bb5cae9b763">kEncodingThai</a> = 21, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baaefe231ca57358776c8ae68f7ddeef198">kEncodingChineseGBK</a> = 25, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baac79ea32ace4b0f1c925ef80e1192d06a">kEncodingEastEuropean</a> = 29, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088baa4d2fc4e25bf97c4038695d63811f9064">kEncodingVietnamese</a>, <br /> &nbsp;&nbsp;<b>kUnknownEncoding</b> = -1 <br /> }</td></tr><tr class="separator:ab7e2189ce8f077c74e234cf4312088ba"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab310e71034da354606a939ad7e258659"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ab310e71034da354606a939ad7e258659"></a> typedef <a class="el" href="structobject__type.html">object_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>data_type</b></td></tr><tr class="separator:ab310e71034da354606a939ad7e258659"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_types_class_unicode_savvy_string"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_types_class_unicode_savvy_string&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Types inherited from <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a></td></tr><tr class="memitem:aa16e4c8eee8c1dd0ed823b98d8c9a839 inherit pub_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="aa16e4c8eee8c1dd0ed823b98d8c9a839"></a> typedef int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr><tr class="separator:aa16e4c8eee8c1dd0ed823b98d8c9a839 inherit pub_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2e8a16ca5f4d329a96e12409e31ecd8f inherit pub_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2e8a16ca5f4d329a96e12409e31ecd8f"></a> typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr><tr class="separator:a2e8a16ca5f4d329a96e12409e31ecd8f inherit pub_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a81ddd8b64d88f58a010b9d8be4b7162c inherit pub_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a81ddd8b64d88f58a010b9d8be4b7162c"></a> typedef UTF16TextChar&nbsp;</td><td class="memItemRight" valign="bottom"><b>code_value</b></td></tr><tr class="separator:a81ddd8b64d88f58a010b9d8be4b7162c inherit pub_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abffad26b10d7f4ffc453085784b7f814 inherit pub_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abffad26b10d7f4ffc453085784b7f814"></a> typedef <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>code_point</b></td></tr><tr class="separator:abffad26b10d7f4ffc453085784b7f814 inherit pub_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a64f0f517cecdf86d1e1c4d1209174415 inherit pub_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a64f0f517cecdf86d1e1c4d1209174415"></a> typedef code_value *&nbsp;</td><td class="memItemRight" valign="bottom"><b>code_value_iterator</b></td></tr><tr class="separator:a64f0f517cecdf86d1e1c4d1209174415 inherit pub_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afaca96e1ac20cc14d4f1f629a3ff0233 inherit pub_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="afaca96e1ac20cc14d4f1f629a3ff0233"></a> typedef code_value const *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_code_value_iterator</b></td></tr><tr class="separator:afaca96e1ac20cc14d4f1f629a3ff0233 inherit pub_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a088803f57f3ec4e52a716d362ae421cb inherit pub_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a088803f57f3ec4e52a716d362ae421cb"></a> typedef const <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr><tr class="separator:a088803f57f3ec4e52a716d362ae421cb inherit pub_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad331b77bf97b1f99df01d2afdfac4ff5 inherit pub_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ad331b77bf97b1f99df01d2afdfac4ff5"></a> typedef UTF16TextChar&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr><tr class="separator:ad331b77bf97b1f99df01d2afdfac4ff5 inherit pub_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:aa75cd6eee8f72c92691c99a6208bd720"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aa75cd6eee8f72c92691c99a6208bd720">PMString</a> (ConstCString key, <a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefac">TranslateDuringCall</a> translate=<a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefaca224537655986f04b0b52ee30de7a45d1">kDontTranslateDuringCall</a>)</td></tr><tr class="separator:aa75cd6eee8f72c92691c99a6208bd720"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae560ac0594c9d9b8f98fd5a7c4ab1aab"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ae560ac0594c9d9b8f98fd5a7c4ab1aab">PMString</a> (const UTF16TextChar *string, int32 nDblBytes)</td></tr><tr class="separator:ae560ac0594c9d9b8f98fd5a7c4ab1aab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a620b5bb40a97d7fe2e7f777037c5e9a1"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a620b5bb40a97d7fe2e7f777037c5e9a1">PMString</a> (const wchar_t *s)</td></tr><tr class="separator:a620b5bb40a97d7fe2e7f777037c5e9a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd5cccb2fb0f27e19f0975cdf0dd0013"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#afd5cccb2fb0f27e19f0975cdf0dd0013">PMString</a> (const wchar_t *s, size_t len)</td></tr><tr class="separator:afd5cccb2fb0f27e19f0975cdf0dd0013"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aefadf020dc6fe4c3363845e678c3fcf3"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aefadf020dc6fe4c3363845e678c3fcf3">PMString</a> (adobe::move_from&lt; <a class="el" href="class_p_m_string.html">PMString</a> &gt; other)</td></tr><tr class="separator:aefadf020dc6fe4c3363845e678c3fcf3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1f5a2d435e8851a55b11b22aafc71b09"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1f5a2d435e8851a55b11b22aafc71b09"></a> &nbsp;</td><td class="memItemRight" valign="bottom"><b>PMString</b> (<a class="el" href="class_p_m_string.html">PMString</a> &amp;&amp;other) noexcept</td></tr><tr class="separator:a1f5a2d435e8851a55b11b22aafc71b09"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a911540ee2ed68c3c5818dfe083474092"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a911540ee2ed68c3c5818dfe083474092"></a> &nbsp;</td><td class="memItemRight" valign="bottom"><b>PMString</b> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s)</td></tr><tr class="separator:a911540ee2ed68c3c5818dfe083474092"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3faa05b637341b5edb5fa6079645590d"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3faa05b637341b5edb5fa6079645590d"></a> &nbsp;</td><td class="memItemRight" valign="bottom"><b>PMString</b> (const <a class="el" href="class_wide_string.html">WideString</a> &amp;s)</td></tr><tr class="separator:a3faa05b637341b5edb5fa6079645590d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a76daea4596a7495456d645be19ab24a3"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a76daea4596a7495456d645be19ab24a3">SetString</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s)</td></tr><tr class="separator:a76daea4596a7495456d645be19ab24a3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a855fd2ce1bd364ecd47a2050a9f6b20f"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a855fd2ce1bd364ecd47a2050a9f6b20f">SetKey</a> (ConstCString key, <a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefac">TranslateDuringCall</a> translate=<a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefaca224537655986f04b0b52ee30de7a45d1">kDontTranslateDuringCall</a>)</td></tr><tr class="separator:a855fd2ce1bd364ecd47a2050a9f6b20f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a383ee876ab8a8b7504fed54e38afd3b9"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a383ee876ab8a8b7504fed54e38afd3b9">GetWChar_tString</a> (wchar_t *wchar_tString, int32 bufferSize) const </td></tr><tr class="separator:a383ee876ab8a8b7504fed54e38afd3b9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a02bc88637c7968dbc9602fd8648d93b2"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a02bc88637c7968dbc9602fd8648d93b2">SetXString</a> (const UTF16TextChar *x, int32 nDblBytes)</td></tr><tr class="separator:a02bc88637c7968dbc9602fd8648d93b2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5b2109c6288ee84fee9b5fd8ba41db03"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a5b2109c6288ee84fee9b5fd8ba41db03">assign</a> (const wchar_t *s, size_t len)</td></tr><tr class="separator:a5b2109c6288ee84fee9b5fd8ba41db03"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aee364755d8969481452ba443ece6b2e8"><td align="right" class="memItemLeft" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aee364755d8969481452ba443ece6b2e8">GetUTF8String</a> () const </td></tr><tr class="separator:aee364755d8969481452ba443ece6b2e8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a013bb08fee62526e3a478f1afd125775"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a013bb08fee62526e3a478f1afd125775">SetUTF8String</a> (const std::string &amp;utf8String)</td></tr><tr class="separator:a013bb08fee62526e3a478f1afd125775"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a65d7cc030d9325b74381aa4779b230bc"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a65d7cc030d9325b74381aa4779b230bc">GetWChar</a> (int32 pos) const </td></tr><tr class="separator:a65d7cc030d9325b74381aa4779b230bc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abbed79c26c6369a51559a28c1602cfdf"><td align="right" class="memItemLeft" valign="top">int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#abbed79c26c6369a51559a28c1602cfdf">WCharLength</a> (void) const </td></tr><tr class="separator:abbed79c26c6369a51559a28c1602cfdf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab35af5ad81173316ba402db349a6ed69"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ab35af5ad81173316ba402db349a6ed69">empty</a> () const </td></tr><tr class="separator:ab35af5ad81173316ba402db349a6ed69"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a87513fd2ee52ec21d46ffcedf84de111"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a87513fd2ee52ec21d46ffcedf84de111">clear</a> ()</td></tr><tr class="separator:a87513fd2ee52ec21d46ffcedf84de111"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7264c4911eea8b17c93c572c808e708f"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a7264c4911eea8b17c93c572c808e708f">Append</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s, CharCounter nCharacters=kMaxInt32)</td></tr><tr class="separator:a7264c4911eea8b17c93c572c808e708f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4bb5a962fbd265877f06f576c2551bf9"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a4bb5a962fbd265877f06f576c2551bf9">Append</a> (const <a class="el" href="class_wide_string.html">WideString</a> &amp;s)</td></tr><tr class="separator:a4bb5a962fbd265877f06f576c2551bf9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac5fcbea2d25a805fec344fd2a7a148ea"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ac5fcbea2d25a805fec344fd2a7a148ea">AppendW</a> (const UTF16TextChar *ws, int32 nDblBytes=kMaxInt32)</td></tr><tr class="separator:ac5fcbea2d25a805fec344fd2a7a148ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a516284ef4bddc6ec9d7d9904ca72d650"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a516284ef4bddc6ec9d7d9904ca72d650">AppendW</a> (<a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> wc)</td></tr><tr class="separator:a516284ef4bddc6ec9d7d9904ca72d650"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4262991a301c2180a7717d5e1921fb20"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a4262991a301c2180a7717d5e1921fb20">append</a> (const wchar_t *s)</td></tr><tr class="separator:a4262991a301c2180a7717d5e1921fb20"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a42cad4af8a629d8a94954da2d5c11e55"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a42cad4af8a629d8a94954da2d5c11e55">Insert</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s, CharCounter pos=0, CharCounter nCharacters=kMaxInt32)</td></tr><tr class="separator:a42cad4af8a629d8a94954da2d5c11e55"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a89f0d1995db9763a2c19ded0f13cfa5b"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a89f0d1995db9763a2c19ded0f13cfa5b">InsertW</a> (const UTF16TextChar *ws, int32 nDblBytes=kMaxInt32, int32 pos=0)</td></tr><tr class="separator:a89f0d1995db9763a2c19ded0f13cfa5b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a215ff6f795b5923cfb82959eae0b4f35"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a215ff6f795b5923cfb82959eae0b4f35">InsertW</a> (<a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> wc, int32 pos=0)</td></tr><tr class="separator:a215ff6f795b5923cfb82959eae0b4f35"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af85bf47c69e5c8814eee4b5054c20f5a"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html">PMString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#af85bf47c69e5c8814eee4b5054c20f5a">Substring</a> (CharCounter pos, CharCounter count=kMaxInt32) const </td></tr><tr class="separator:af85bf47c69e5c8814eee4b5054c20f5a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afdff026c203c07f6bfce0b4c1a323783"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html">PMString</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#afdff026c203c07f6bfce0b4c1a323783">GetItem</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;delimiter, const int32 nItem) const </td></tr><tr class="separator:afdff026c203c07f6bfce0b4c1a323783"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a63c162b020c13ebfe4275d050d989de1"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a63c162b020c13ebfe4275d050d989de1">Remove</a> (CharCounter pos, CharCounter count=1)</td></tr><tr class="separator:a63c162b020c13ebfe4275d050d989de1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8807524efaccfc4d0652b6103de619f7"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a8807524efaccfc4d0652b6103de619f7">Truncate</a> (CharCounter count=1)</td></tr><tr class="separator:a8807524efaccfc4d0652b6103de619f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af6e8954f648d7f1fae0d652638bf26fc"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#af6e8954f648d7f1fae0d652638bf26fc">StripWhiteSpace</a> (<a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89">WhitespaceType</a> wsType=<a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89a090f3539c26b8559353849e71ba4d6cf">kAllWhiteSpace</a>)</td></tr><tr class="separator:af6e8954f648d7f1fae0d652638bf26fc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a19ddab41a91caf1ebee32b50d28d7368"><td align="right" class="memItemLeft" valign="top">CharCounter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a19ddab41a91caf1ebee32b50d28d7368">IndexOfString</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;keyString, CharCounter pos=0) const </td></tr><tr class="separator:a19ddab41a91caf1ebee32b50d28d7368"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a611636793236f5517460f70df978e48e"><td align="right" class="memItemLeft" valign="top">CharCounter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a611636793236f5517460f70df978e48e">LastIndexOfString</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;keyString) const </td></tr><tr class="separator:a611636793236f5517460f70df978e48e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2c6b25ff317ee2ddd315bbf4f929f990"><td align="right" class="memItemLeft" valign="top">CharCounter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a2c6b25ff317ee2ddd315bbf4f929f990">IndexOfWChar</a> (<a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> wc, int32 pos=0) const </td></tr><tr class="separator:a2c6b25ff317ee2ddd315bbf4f929f990"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aeff3db280b8ceaa4bea6bd6b8bffbced"><td align="right" class="memItemLeft" valign="top">CharCounter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aeff3db280b8ceaa4bea6bd6b8bffbced">LastIndexOfWChar</a> (<a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> wc) const </td></tr><tr class="separator:aeff3db280b8ceaa4bea6bd6b8bffbced"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1590aac762c1e033bdee1e2479afd8ab"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a1590aac762c1e033bdee1e2479afd8ab">Contains</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;searchString, CharCounter pos=0) const </td></tr><tr class="separator:a1590aac762c1e033bdee1e2479afd8ab"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2fec9631d88e41a45a9f4095977700b4"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a2fec9631d88e41a45a9f4095977700b4">BeginsWith</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;searchString, CharCounter pos=0) const </td></tr><tr class="separator:a2fec9631d88e41a45a9f4095977700b4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a992b90ef6bf5e6e938316b92175c18a3"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a992b90ef6bf5e6e938316b92175c18a3">ParseForEmbeddedCharacters</a> ()</td></tr><tr class="separator:a992b90ef6bf5e6e938316b92175c18a3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aed8eeaa1ad3e31b9f5c3f5bd35fc1d88"><td align="right" class="memItemLeft" valign="top">int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aed8eeaa1ad3e31b9f5c3f5bd35fc1d88">Compare</a> (bool16 casesensitive, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s) const </td></tr><tr class="separator:aed8eeaa1ad3e31b9f5c3f5bd35fc1d88"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab41ccfb69ce394819cfb01a84ee73504"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ab41ccfb69ce394819cfb01a84ee73504">IsEqual</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s, bool8 casesensitive=kTrue, bool8 limitCompareToShorterLength=kFalse) const </td></tr><tr class="separator:ab41ccfb69ce394819cfb01a84ee73504"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a58820762fde3ab015a5d85ceef5da94c"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a58820762fde3ab015a5d85ceef5da94c">operator==</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s) const </td></tr><tr class="separator:a58820762fde3ab015a5d85ceef5da94c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a25f36a7f78f0a4429e134c0bf2c0255a"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a25f36a7f78f0a4429e134c0bf2c0255a">operator==</a> (ConstCString key) const </td></tr><tr class="separator:a25f36a7f78f0a4429e134c0bf2c0255a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a10df7b4bcd9ec7370653bbadbccfdc49"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a10df7b4bcd9ec7370653bbadbccfdc49">operator!=</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s) const </td></tr><tr class="separator:a10df7b4bcd9ec7370653bbadbccfdc49"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88166a47cc01e84a76754958c223afbf"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a88166a47cc01e84a76754958c223afbf">operator&lt;</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s) const </td></tr><tr class="separator:a88166a47cc01e84a76754958c223afbf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac12e0dd606c82ac60311f3374dc48cf2"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ac12e0dd606c82ac60311f3374dc48cf2">operator&gt;</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s) const </td></tr><tr class="separator:ac12e0dd606c82ac60311f3374dc48cf2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac8831eacdf474730b9609c25571652df"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ac8831eacdf474730b9609c25571652df">operator&lt;=</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s) const </td></tr><tr class="separator:ac8831eacdf474730b9609c25571652df"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a03035c631cc346cf35f3f43e42356258"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a03035c631cc346cf35f3f43e42356258">operator&gt;=</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s) const </td></tr><tr class="separator:a03035c631cc346cf35f3f43e42356258"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab7046411844f4d9b1dff0f9ee1ec21d4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ab7046411844f4d9b1dff0f9ee1ec21d4">operator+=</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s)</td></tr><tr class="separator:ab7046411844f4d9b1dff0f9ee1ec21d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae39b4d350ebc4ce7e8f57bac9de28e0d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ae39b4d350ebc4ce7e8f57bac9de28e0d">operator=</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;other)</td></tr><tr class="separator:ae39b4d350ebc4ce7e8f57bac9de28e0d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aab029d44eaac86fe1463cf477c1fe375"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aab029d44eaac86fe1463cf477c1fe375">operator=</a> (<a class="el" href="class_p_m_string.html">PMString</a> &amp;&amp;other) noexcept</td></tr><tr class="separator:aab029d44eaac86fe1463cf477c1fe375"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5853f7f6e0aba25335ef84d6a3cbe32d"><td align="right" class="memItemLeft" valign="top">uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a5853f7f6e0aba25335ef84d6a3cbe32d">Hash</a> (void) const </td></tr><tr class="separator:a5853f7f6e0aba25335ef84d6a3cbe32d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afcac80f419f18ded9ed40769a3f3655b"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#afcac80f419f18ded9ed40769a3f3655b">AppendNumber</a> (int32 i)</td></tr><tr class="separator:afcac80f419f18ded9ed40769a3f3655b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae26cead9c6b1acc9ecf9521d3db42f03"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ae26cead9c6b1acc9ecf9521d3db42f03">AppendNumber</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;r, int32 digitsPrecision=-1, bool16 round=kFalse, bool16 eliminateTrailingZeros=kFalse)</td></tr><tr class="separator:ae26cead9c6b1acc9ecf9521d3db42f03"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a44fcb36d637197f775cdd6f0e4a1fda9"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a44fcb36d637197f775cdd6f0e4a1fda9">AsNumber</a> (int32 i)</td></tr><tr class="separator:a44fcb36d637197f775cdd6f0e4a1fda9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4d36699e9d2d95049970b6f331839b40"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a4d36699e9d2d95049970b6f331839b40">AsNumber</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;r, int32 digitsPrecision=-1, bool16 round=kFalse, bool16 eliminateTrailingZeros=kFalse)</td></tr><tr class="separator:a4d36699e9d2d95049970b6f331839b40"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad320ddf0302c27d8fd0bdf4fd3364f39"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ad320ddf0302c27d8fd0bdf4fd3364f39">AppendFixed</a> (Fixed f)</td></tr><tr class="separator:ad320ddf0302c27d8fd0bdf4fd3364f39"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8e3b400e0338ad754358189b8e26c3d9"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a8e3b400e0338ad754358189b8e26c3d9">AsFixed</a> (Fixed f)</td></tr><tr class="separator:a8e3b400e0338ad754358189b8e26c3d9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a486ec2ebbeacbbe8997af062edad0aa7"><td align="right" class="memItemLeft" valign="top">int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a486ec2ebbeacbbe8997af062edad0aa7">GetAsNumber</a> (<a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6b">ConversionError</a> *pError=nil, CharCounter *lenNotConverted=nil) const </td></tr><tr class="separator:a486ec2ebbeacbbe8997af062edad0aa7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac6d181a1470592ccf4b672eb2de5690d"><td align="right" class="memItemLeft" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ac6d181a1470592ccf4b672eb2de5690d">GetAsDouble</a> (<a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6b">ConversionError</a> *pError=nil, CharCounter *lenNotConverted=nil) const </td></tr><tr class="separator:ac6d181a1470592ccf4b672eb2de5690d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3acfa9e0bec4dc575bd7ed1dc4bfb9d8"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a3acfa9e0bec4dc575bd7ed1dc4bfb9d8">ToUpper</a> (void)</td></tr><tr class="separator:a3acfa9e0bec4dc575bd7ed1dc4bfb9d8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac521943668a7e88d58c28ea8b880e31b"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ac521943668a7e88d58c28ea8b880e31b">ToLower</a> (void)</td></tr><tr class="separator:ac521943668a7e88d58c28ea8b880e31b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acf3eb36bb0745e30d94962b1ce55481c"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#acf3eb36bb0745e30d94962b1ce55481c">ReadWrite</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *s)</td></tr><tr class="separator:acf3eb36bb0745e30d94962b1ce55481c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa073a79b4c84c593db5fbe27ee325fea"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aa073a79b4c84c593db5fbe27ee325fea">ReadWriteKey</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *s)</td></tr><tr class="separator:aa073a79b4c84c593db5fbe27ee325fea"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a934bb79486e5370330258d3503cd48d4"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a934bb79486e5370330258d3503cd48d4">ReadPlatformWriteUnicode</a> (<a class="el" href="class_i_p_m_stream.html">IPMStream</a> *s, <a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5">PMString::StringPlatformEncoding</a> encoding=<a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5aa98159f58b1f3d971f4160e2cf61d8db">kPlatformEncodingOther</a>, bool16 includeBools=kTrue)</td></tr><tr class="separator:a934bb79486e5370330258d3503cd48d4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa9fb7fb8d90885950ac4ada00e12e1c2"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aa9fb7fb8d90885950ac4ada00e12e1c2">Translate</a> (const <a class="el" href="class_p_m_locale_id.html">PMLocaleId</a> &amp;locale)</td></tr><tr class="separator:aa9fb7fb8d90885950ac4ada00e12e1c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6b68a209a15df93d5c6a4533e8411ac2"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a6b68a209a15df93d5c6a4533e8411ac2">Translate</a> ()</td></tr><tr class="separator:a6b68a209a15df93d5c6a4533e8411ac2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5c601cc1892148c2f3815e0f2dff597a"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a5c601cc1892148c2f3815e0f2dff597a">IsTranslatable</a> () const </td></tr><tr class="separator:a5c601cc1892148c2f3815e0f2dff597a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acdb6160d8d2233331c0f2e43b569706c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#acdb6160d8d2233331c0f2e43b569706c">SetTranslatable</a> (bool16 shouldTranslate)</td></tr><tr class="separator:acdb6160d8d2233331c0f2e43b569706c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2df357d4e6d6d41f880cdda8a15627ba"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a2df357d4e6d6d41f880cdda8a15627ba">HasTranslated</a> () const </td></tr><tr class="separator:a2df357d4e6d6d41f880cdda8a15627ba"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a750d999de6012f7d88cf378eb2a22765"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a750d999de6012f7d88cf378eb2a22765">SetTranslated</a> ()</td></tr><tr class="separator:a750d999de6012f7d88cf378eb2a22765"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1f58e301fd031a5cbb8befdcd31639f1"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a1f58e301fd031a5cbb8befdcd31639f1">PMString</a> (ConstCString string, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding)</td></tr><tr class="separator:a1f58e301fd031a5cbb8befdcd31639f1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae933d92f823a8f631adc95fed1a6d9f7"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ae933d92f823a8f631adc95fed1a6d9f7">SetPString</a> (ConstPString p, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding)</td></tr><tr class="separator:ae933d92f823a8f631adc95fed1a6d9f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a55b402caab8f20bc6c2fb0ab6e652c9a"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a55b402caab8f20bc6c2fb0ab6e652c9a">SetCString</a> (ConstCString C, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding)</td></tr><tr class="separator:a55b402caab8f20bc6c2fb0ab6e652c9a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a385d1c05d0cb2242c3bac4e6c9190c8e"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a385d1c05d0cb2242c3bac4e6c9190c8e">SetXString</a> (const char *x, int32 nBytes, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding)</td></tr><tr class="separator:a385d1c05d0cb2242c3bac4e6c9190c8e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1e7169e31da7b2c63b0b98e017e39742"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a1e7169e31da7b2c63b0b98e017e39742">GetPString</a> (PString p, int32 bufferSize, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding) const </td></tr><tr class="separator:a1e7169e31da7b2c63b0b98e017e39742"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a578bf775225ad8c27830c9c883b010be"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a578bf775225ad8c27830c9c883b010be">GetCString</a> (CString C, int32 bufferSize, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding) const </td></tr><tr class="separator:a578bf775225ad8c27830c9c883b010be"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af9da9d29b084834619137af698fb70ae"><td align="right" class="memItemLeft" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#af9da9d29b084834619137af698fb70ae">GetPlatformString</a> (<a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding) const </td></tr><tr class="separator:af9da9d29b084834619137af698fb70ae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5c10b6c068d1af3a2ca501e71179cd1e"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a5c10b6c068d1af3a2ca501e71179cd1e">Insert</a> (const char *ps, int32 nBytes=kMaxInt32, CharCounter pos=0, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding)</td></tr><tr class="separator:a5c10b6c068d1af3a2ca501e71179cd1e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5edde528b572543db5c577f647d5a0f2"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a5edde528b572543db5c577f647d5a0f2">Insert</a> (char pc, CharCounter pos=0, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding)</td></tr><tr class="separator:a5edde528b572543db5c577f647d5a0f2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac1c42743ba3f44206b2322cc8cf12cd6"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ac1c42743ba3f44206b2322cc8cf12cd6">Insert</a> (const <a class="el" href="class_platform_char.html">PlatformChar</a> &amp;pc, CharCounter pos=0)</td></tr><tr class="separator:ac1c42743ba3f44206b2322cc8cf12cd6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4dd6686ec4a5427ff616b1cecf2a5505"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a4dd6686ec4a5427ff616b1cecf2a5505">Append</a> (const char *ps, int32 nBytes=kMaxInt32, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding)</td></tr><tr class="separator:a4dd6686ec4a5427ff616b1cecf2a5505"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a82da30f546a882e2a63947676787ce82"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a82da30f546a882e2a63947676787ce82">Append</a> (char pc, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding)</td></tr><tr class="separator:a82da30f546a882e2a63947676787ce82"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c8c749b4187f5a9d7f76c1a76558196"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a8c8c749b4187f5a9d7f76c1a76558196">Append</a> (const <a class="el" href="class_platform_char.html">PlatformChar</a> &amp;pc)</td></tr><tr class="separator:a8c8c749b4187f5a9d7f76c1a76558196"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ada30ea59d3bc68f3a522d6acb1837fb2"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="class_platform_char.html">PlatformChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ada30ea59d3bc68f3a522d6acb1837fb2">operator[]</a> (CharCounter index) const </td></tr><tr class="separator:ada30ea59d3bc68f3a522d6acb1837fb2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa0acf66f49a13bfbde1ad16e754d0fa7"><td align="right" class="memItemLeft" valign="top">const <a class="el" href="class_platform_char.html">PlatformChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#aa0acf66f49a13bfbde1ad16e754d0fa7">GetChar</a> (CharCounter pos, <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding=kUnknownEncoding) const </td></tr><tr class="separator:aa0acf66f49a13bfbde1ad16e754d0fa7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad0ca6492a61e97a1333222fec664a0c2"><td align="right" class="memItemLeft" valign="top">CharCounter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ad0ca6492a61e97a1333222fec664a0c2">IndexOfCharacter</a> (const <a class="el" href="class_platform_char.html">PlatformChar</a> &amp;pc, CharCounter pos=0) const </td></tr><tr class="separator:ad0ca6492a61e97a1333222fec664a0c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abf5cdb050c4030afd960f644d612470a"><td align="right" class="memItemLeft" valign="top">CharCounter&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#abf5cdb050c4030afd960f644d612470a">LastIndexOfCharacter</a> (const <a class="el" href="class_platform_char.html">PlatformChar</a> &amp;pc) const </td></tr><tr class="separator:abf5cdb050c4030afd960f644d612470a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2588315ebf9f5cd95493db8266341037"><td align="right" class="memItemLeft" valign="top">uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a2588315ebf9f5cd95493db8266341037">GetScript</a> () const </td></tr><tr class="separator:a2588315ebf9f5cd95493db8266341037"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abb617a5fea8b8e8f3930f5cb24d47b2b"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#abb617a5fea8b8e8f3930f5cb24d47b2b">SetScript</a> (uint8 script)</td></tr><tr class="separator:abb617a5fea8b8e8f3930f5cb24d47b2b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac2f37c60d48722f7a0d12edca7745e22"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#ac2f37c60d48722f7a0d12edca7745e22">GetEncoding</a> () const </td></tr><tr class="separator:ac2f37c60d48722f7a0d12edca7745e22"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0525bc255a1e9504db0b696b24ed1339"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a0525bc255a1e9504db0b696b24ed1339">SetEncoding</a> (<a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> encoding)</td></tr><tr class="separator:a0525bc255a1e9504db0b696b24ed1339"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2f34f29b90ab9ef21f2395254524000a"><td align="right" class="memItemLeft" valign="top">const UTF16TextChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a2f34f29b90ab9ef21f2395254524000a">GrabWString</a> (void) const </td></tr><tr class="separator:a2f34f29b90ab9ef21f2395254524000a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abe884b9dce0764de2651207e49f3a724"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#abe884b9dce0764de2651207e49f3a724">SetCString</a> (ConstCString C)</td></tr><tr class="separator:abe884b9dce0764de2651207e49f3a724"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6053aed859a0752d4ff2865f533f7744"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a6053aed859a0752d4ff2865f533f7744">IsNull</a> (void) const </td></tr><tr class="separator:a6053aed859a0752d4ff2865f533f7744"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a85d2a193dab450186b5bee9c96eab9f8"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a85d2a193dab450186b5bee9c96eab9f8">IsEmpty</a> () const </td></tr><tr class="separator:a85d2a193dab450186b5bee9c96eab9f8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8e0e7fd9eddf7012be5f263db1d3a7cc"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a8e0e7fd9eddf7012be5f263db1d3a7cc">Clear</a> (void)</td></tr><tr class="separator:a8e0e7fd9eddf7012be5f263db1d3a7cc"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_unicode_savvy_string"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_unicode_savvy_string&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a></td></tr><tr class="memitem:ab6bb550d0bb64d9bae4a444a9242a6a2 inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#ab6bb550d0bb64d9bae4a444a9242a6a2">HasMultiWordUnicode</a> () const </td></tr><tr class="separator:ab6bb550d0bb64d9bae4a444a9242a6a2 inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a943512b68899644891f01220d8d29c1f inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a943512b68899644891f01220d8d29c1f">CharCount</a> () const </td></tr><tr class="separator:a943512b68899644891f01220d8d29c1f inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd1a4b8c871f53fdab0a658e07923c19 inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#afd1a4b8c871f53fdab0a658e07923c19">NumUTF16TextChars</a> () const </td></tr><tr class="separator:afd1a4b8c871f53fdab0a658e07923c19 inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab7591ca8370bba53dddbd94fb397b94e inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#ab7591ca8370bba53dddbd94fb397b94e">capacity</a> (void) const </td></tr><tr class="separator:ab7591ca8370bba53dddbd94fb397b94e inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac4bf34165f30bb9246570fbe423ff441 inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#ac4bf34165f30bb9246570fbe423ff441">reserve</a> (size_type newCapacity)</td></tr><tr class="separator:ac4bf34165f30bb9246570fbe423ff441 inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7fc24b17025c6f75d473e962ff8b16d7 inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a7fc24b17025c6f75d473e962ff8b16d7">resize</a> (size_type newSize, code_value fill=code_value())</td></tr><tr class="separator:a7fc24b17025c6f75d473e962ff8b16d7 inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a054f18388da08612e08a08961d811452 inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a054f18388da08612e08a08961d811452">clear</a> ()</td></tr><tr class="separator:a054f18388da08612e08a08961d811452 inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c457f29043d6515ee43652bdbffda6e inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">const UTF16TextChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a8c457f29043d6515ee43652bdbffda6e">GrabUTF16Buffer</a> (int32 *numUTF16s) const </td></tr><tr class="separator:a8c457f29043d6515ee43652bdbffda6e inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abeff689f96fa42bdc3aa650779f75555 inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#abeff689f96fa42bdc3aa650779f75555">CodePointIndexToUTF16Index</a> (int32 index) const </td></tr><tr class="separator:abeff689f96fa42bdc3aa650779f75555 inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aef279d6989df038b14b9fecea5f1c498 inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#aef279d6989df038b14b9fecea5f1c498">Truncate</a> (CharCounter count)</td></tr><tr class="separator:aef279d6989df038b14b9fecea5f1c498 inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4a9749f2687e0d338bd749ff64d986fd inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a4a9749f2687e0d338bd749ff64d986fd">Remove</a> (int32 position, CharCounter count)</td></tr><tr class="separator:a4a9749f2687e0d338bd749ff64d986fd inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab65df97aa1e326f2ffe34c456870772b inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#ab65df97aa1e326f2ffe34c456870772b">GetUTF32TextChar</a> (int32 pos) const </td></tr><tr class="separator:ab65df97aa1e326f2ffe34c456870772b inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a632ad43fc31fb48d7f59a8f57fa109a3 inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">const_code_value_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a632ad43fc31fb48d7f59a8f57fa109a3">begin</a> () const </td></tr><tr class="separator:a632ad43fc31fb48d7f59a8f57fa109a3 inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa85067c36248d182fd5b307fcf33009c inherit pub_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">const_code_value_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#aa85067c36248d182fd5b307fcf33009c">end</a> () const </td></tr><tr class="separator:aa85067c36248d182fd5b307fcf33009c inherit pub_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a> Protected Member Functions</h2></td></tr><tr class="memitem:a6115a144b6170477ad639eb2973c9a37"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6115a144b6170477ad639eb2973c9a37"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AssignToPlatformBuffer</b> (ConstCString src, int32 lengthInBytes)</td></tr><tr class="separator:a6115a144b6170477ad639eb2973c9a37"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pro_methods_class_unicode_savvy_string"><td colspan="2" onclick="javascript:toggleInherit(&#39;pro_methods_class_unicode_savvy_string&#39;)"><img alt="-" src="closed.png" />&nbsp;Protected Member Functions inherited from <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a></td></tr><tr class="memitem:a496070117b24aa5b2d2f48da65301fa6 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a496070117b24aa5b2d2f48da65301fa6">UnicodeSavvyString</a> (adobe::move_from&lt; <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &gt; other)</td></tr><tr class="separator:a496070117b24aa5b2d2f48da65301fa6 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a253f70d20f3b65654b59f20e5d7b0356 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a253f70d20f3b65654b59f20e5d7b0356"></a> &nbsp;</td><td class="memItemRight" valign="bottom"><b>UnicodeSavvyString</b> (<a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &amp;&amp;other) noexcept</td></tr><tr class="separator:a253f70d20f3b65654b59f20e5d7b0356 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0857919a2e4eda2395c4cfe3e9ce733e inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a0857919a2e4eda2395c4cfe3e9ce733e">move_from</a> (<a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &amp;other) noexcept</td></tr><tr class="separator:a0857919a2e4eda2395c4cfe3e9ce733e inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2cfaa10e267e5867f5068b0b7b83651d inherit pro_methods_class_unicode_savvy_string"><td class="memTemplParams" colspan="2">template&lt;class IteratorType &gt; </td></tr><tr class="memitem:a2cfaa10e267e5867f5068b0b7b83651d inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memTemplItemLeft" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a2cfaa10e267e5867f5068b0b7b83651d">UnicodeSavvyString</a> (IteratorType b, IteratorType e, size_type nCodePoints=0)</td></tr><tr class="separator:a2cfaa10e267e5867f5068b0b7b83651d inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1522b6df3e290b483a997d9f62269907 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1522b6df3e290b483a997d9f62269907"></a> int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>CountChars</b> () const </td></tr><tr class="separator:a1522b6df3e290b483a997d9f62269907 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5908004dbc0408b22b61193c4617e83a inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5908004dbc0408b22b61193c4617e83a"></a> int32&nbsp;</td><td class="memItemRight" valign="bottom"><b>CountCharsUtil</b> (const UTF16TextChar *buffer, int32 bufferLength) const </td></tr><tr class="separator:a5908004dbc0408b22b61193c4617e83a inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4e5549e935409b8cdc7092aa735abfb0 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4e5549e935409b8cdc7092aa735abfb0"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InsertGap</b> (uint32 wordWiseIndex, size_type numberOfSpaces)</td></tr><tr class="separator:a4e5549e935409b8cdc7092aa735abfb0 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9a2302acba578fa03ebc124e916a661d inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a9a2302acba578fa03ebc124e916a661d"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoveGap</b> (uint32 wordWiseIndex, size_type numberOfSpaces)</td></tr><tr class="separator:a9a2302acba578fa03ebc124e916a661d inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae32462344784d7d6e75b7aefd73a4f88 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae32462344784d7d6e75b7aefd73a4f88"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InsertUTF32TextChar</b> (<a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> c, int32 pos=0)</td></tr><tr class="separator:ae32462344784d7d6e75b7aefd73a4f88 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac903823d5ec7ed8eaebf4cb865d22959 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac903823d5ec7ed8eaebf4cb865d22959"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>InsertUTF16String</b> (const UTF16TextChar *buf, int32 len, int32 position=0)</td></tr><tr class="separator:ac903823d5ec7ed8eaebf4cb865d22959 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abe4bb92f85d6962883bc29965f8eb33e inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="abe4bb92f85d6962883bc29965f8eb33e"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AppendUTF32TextChar</b> (<a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> c32)</td></tr><tr class="separator:abe4bb92f85d6962883bc29965f8eb33e inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a97ce48d781f64da45401e1e967f2ec29 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a97ce48d781f64da45401e1e967f2ec29"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>CopyFrom</b> (const <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &amp;other)</td></tr><tr class="separator:a97ce48d781f64da45401e1e967f2ec29 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afc2d23ebdbc80e58a35ae616cc1dccc3 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#afc2d23ebdbc80e58a35ae616cc1dccc3">operator==</a> (const <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &amp;s) const </td></tr><tr class="separator:afc2d23ebdbc80e58a35ae616cc1dccc3 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a227db5b8c2c6fbcff8417fefe1ab63f2 inherit pro_methods_class_unicode_savvy_string"><td class="memTemplParams" colspan="2">template&lt;class IteratorType &gt; </td></tr><tr class="memitem:a227db5b8c2c6fbcff8417fefe1ab63f2 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memTemplItemLeft" valign="top"><a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a227db5b8c2c6fbcff8417fefe1ab63f2">assign</a> (IteratorType b, IteratorType e, size_type nCodePoints=0)</td></tr><tr class="separator:a227db5b8c2c6fbcff8417fefe1ab63f2 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7fbff9a422b152e1ef93c97e0c0ebf81 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a7fbff9a422b152e1ef93c97e0c0ebf81">replace</a> (size_type pos, size_type n1, code_value const *s, size_type n2)</td></tr><tr class="separator:a7fbff9a422b152e1ef93c97e0c0ebf81 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a57eda1f1520a842eb19c34098ee49de9 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_unicode_savvy_string.html#a57eda1f1520a842eb19c34098ee49de9">append</a> (code_value const *s, size_type nCodeValues, size_type nCodePoints=0)</td></tr><tr class="separator:a57eda1f1520a842eb19c34098ee49de9 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac2a50a2542dd0792f60133d1a07dab09 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ac2a50a2542dd0792f60133d1a07dab09"></a> <a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>surro_GetUTF32TextChar</b> (int32 pos) const </td></tr><tr class="separator:ac2a50a2542dd0792f60133d1a07dab09 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3d58f35dd0af404a6d4629d76f8c4420 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a3d58f35dd0af404a6d4629d76f8c4420"></a> const UTF16TextChar *&nbsp;</td><td class="memItemRight" valign="bottom"><b>ConstBuffer</b> () const </td></tr><tr class="separator:a3d58f35dd0af404a6d4629d76f8c4420 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae75e4d96ab917d81c817e18c8621ce31 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae75e4d96ab917d81c817e18c8621ce31"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>insert_safe</b> (code_value_iterator i, const_code_value_iterator sb, const_code_value_iterator se)</td></tr><tr class="separator:ae75e4d96ab917d81c817e18c8621ce31 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae883521568e1b9b4387f78364c1b6681 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="ae883521568e1b9b4387f78364c1b6681"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>erase_safe</b> (code_value_iterator b, code_value_iterator e)</td></tr><tr class="separator:ae883521568e1b9b4387f78364c1b6681 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a65325b5f3ea77a47347865b5cfbe439b inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a65325b5f3ea77a47347865b5cfbe439b"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>replace_safe</b> (code_value_iterator b, code_value_iterator e, const_code_value_iterator sb, const_code_value_iterator se)</td></tr><tr class="separator:a65325b5f3ea77a47347865b5cfbe439b inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a67011de1922a8bedbdb740b50a7d4658 inherit pro_methods_class_unicode_savvy_string"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67011de1922a8bedbdb740b50a7d4658"></a> template&lt;class InputIterator &gt; </td></tr><tr class="memitem:a67011de1922a8bedbdb740b50a7d4658 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>assign_impl</b> (InputIterator b, InputIterator e, size_type nCodePoints, std::input_iterator_tag)</td></tr><tr class="separator:a67011de1922a8bedbdb740b50a7d4658 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a53a6cea6150d56f2f5add0e397ac2f1e inherit pro_methods_class_unicode_savvy_string"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53a6cea6150d56f2f5add0e397ac2f1e"></a> template&lt;class FwdIterator &gt; </td></tr><tr class="memitem:a53a6cea6150d56f2f5add0e397ac2f1e inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memTemplItemLeft" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>assign_impl</b> (FwdIterator b, FwdIterator e, size_type nCodePoints, std::forward_iterator_tag)</td></tr><tr class="separator:a53a6cea6150d56f2f5add0e397ac2f1e inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a53a754cdb7d897b288d9191751880338 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a53a754cdb7d897b288d9191751880338"></a> bool16&nbsp;</td><td class="memItemRight" valign="bottom"><b>UnicodeBufferIsValid</b> () const </td></tr><tr class="separator:a53a754cdb7d897b288d9191751880338 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af5846825e3ad924eb1d68c6e03f99840 inherit pro_methods_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="af5846825e3ad924eb1d68c6e03f99840"></a> UTF16TextChar *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetBufferForWriting</b> (size_type size)</td></tr><tr class="separator:af5846825e3ad924eb1d68c6e03f99840 inherit pro_methods_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a> Friends</h2></td></tr><tr class="memitem:a101b157d3bc0fdc06e5fd779950aaa41"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a101b157d3bc0fdc06e5fd779950aaa41">operator+</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s1, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;s2)</td></tr><tr class="separator:a101b157d3bc0fdc06e5fd779950aaa41"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9bfda38e5b5aaed128b34be1ab89f705"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_m_string.html#a9bfda38e5b5aaed128b34be1ab89f705">swap</a> (<a class="el" href="class_p_m_string.html">PMString</a> &amp;left, <a class="el" href="class_p_m_string.html">PMString</a> &amp;right) noexcept</td></tr><tr class="separator:a9bfda38e5b5aaed128b34be1ab89f705"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a> Additional Inherited Members</h2></td></tr><tr class="inherit_header pro_types_class_unicode_savvy_string"><td colspan="2" onclick="javascript:toggleInherit(&#39;pro_types_class_unicode_savvy_string&#39;)"><img alt="-" src="closed.png" />&nbsp;Protected Types inherited from <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a></td></tr><tr class="memitem:a29ac2c4b5e05f792c360fae3f3affa9d inherit pro_types_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kMaxSmallString</b> = 15 }</td></tr><tr class="separator:a29ac2c4b5e05f792c360fae3f3affa9d inherit pro_types_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pro_attribs_class_unicode_savvy_string"><td colspan="2" onclick="javascript:toggleInherit(&#39;pro_attribs_class_unicode_savvy_string&#39;)"><img alt="-" src="closed.png" />&nbsp;Protected Attributes inherited from <a class="el" href="class_unicode_savvy_string.html">UnicodeSavvyString</a></td></tr><tr class="memitem:a2a624d64c4e5f6c1e1e458902d5b45a8 inherit pro_attribs_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a2a624d64c4e5f6c1e1e458902d5b45a8"></a> <a class="el" href="class_string_storage.html">StringStorage</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>fStorage</b></td></tr><tr class="separator:a2a624d64c4e5f6c1e1e458902d5b45a8 inherit pro_attribs_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acf67e3473553683765f7b35c4596cd8c inherit pro_attribs_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="acf67e3473553683765f7b35c4596cd8c"></a> UTF16TextChar&nbsp;</td><td class="memItemRight" valign="bottom"><b>fSmallStorage</b> [kMaxSmallString+1]</td></tr><tr class="separator:acf67e3473553683765f7b35c4596cd8c inherit pro_attribs_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4ce4f3dbe91bd5b5cecbee463b3d9072 inherit pro_attribs_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a4ce4f3dbe91bd5b5cecbee463b3d9072"></a> size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>fUTF16BufferLength</b></td></tr><tr class="separator:a4ce4f3dbe91bd5b5cecbee463b3d9072 inherit pro_attribs_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adc176656120c6894a15d2343e4cd1b7a inherit pro_attribs_class_unicode_savvy_string"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="adc176656120c6894a15d2343e4cd1b7a"></a> size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>fNumChars</b></td></tr><tr class="separator:adc176656120c6894a15d2343e4cd1b7a inherit pro_attribs_class_unicode_savvy_string"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p><a class="el" href="class_p_m_string.html">PMString</a> is used for strings that show in the UI. Given a key then calling Translate will lookup the translation for the key for the current UI locale. This class should not be used for strings that are not in the UI. Please use <a class="el" href="class_wide_string.html">WideString</a> for strings that do not need to be translated. </div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a1a786a4e9adac26492dbd7d5e64d1b6b"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6b">PMString::ConversionError</a></td></tr></table></div><div class="memdoc"><p>Error in converting string to number<dl class="section see"><dt>See Also<dd><a class="el" href="class_p_m_string.html#a486ec2ebbeacbbe8997af062edad0aa7">GetAsNumber</a> and <a class="el" href="class_p_m_string.html#ac6d181a1470592ccf4b672eb2de5690d">GetAsDouble</a></dl><table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a1a786a4e9adac26492dbd7d5e64d1b6ba44f095b16bc893b6fc599bf2bf056296"></a>kNoError</em>&nbsp;</td><td class="fielddoc"><p>No Error. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a1a786a4e9adac26492dbd7d5e64d1b6ba24466cf52dd94c8c903cbfc60db27100"></a>kNoNumber</em>&nbsp;</td><td class="fielddoc"><p>String has no number. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a1a786a4e9adac26492dbd7d5e64d1b6ba63ce79e8103bb3ef889639ae6dc110ad"></a>kNotJustNumber</em>&nbsp;</td><td class="fielddoc"><p>String has more than just number. </td></tr></table></div></div><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088ba"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a></td></tr></table></div><div class="memdoc"><p>What kind of encoding to use to represent the platform string as. These are platform specific. If running on mac this is mac encoding. On windows it is windows encoding. You should persist Unicode if you want to take data cross platform. Comments for encoding list Macintosh script first than Windows codepage. <dl class="section see"><dt>See Also<dd><a class="el" href="class_p_m_string.html#a0525bc255a1e9504db0b696b24ed1339">SetEncoding</a></dl><table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baae760e9e8363eef4c98a21224b70e2a90"></a>kEncodingASCII</em>&nbsp;</td><td class="fielddoc"><p>smRoman, Codepage 1252 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baa9267c80dfc8bb3c90359898d1451346c"></a>kEncodingShiftJIS</em>&nbsp;</td><td class="fielddoc"><p>smJapanese, Codepage 932 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baa9927f470ea13ce94dc77758a33e6f27c"></a>kEncodingChineseBig5</em>&nbsp;</td><td class="fielddoc"><p>smTradChinese, Codepage 950 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baaa80f3a04f3b2df2617745259bd4b5524"></a>kEncodingKorean</em>&nbsp;</td><td class="fielddoc"><p>smKorean, Codepage 949 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baac8891d1d79dc365197bded521337de77"></a>kEncodingArabic</em>&nbsp;</td><td class="fielddoc"><p>smArabic, Codepage 1256 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baaabc3a26b1fff667d553775550dc3bea6"></a>kEncodingHebrew</em>&nbsp;</td><td class="fielddoc"><p>smHebrew, Codepage 1255 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baa89d25e5c0ed3a53e55becc594c6cd731"></a>kEncodingGreek</em>&nbsp;</td><td class="fielddoc"><p>smGreek, Codepage 1253 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baa560b56a6ebe4c39644f2cef55ec9cc69"></a>kEncodingCyrillic</em>&nbsp;</td><td class="fielddoc"><p>smCyrillic, Codepage 1251 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baa2f4b47fa86b075d694868bb5cae9b763"></a>kEncodingThai</em>&nbsp;</td><td class="fielddoc"><p>smThai, Codepage 874 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baaefe231ca57358776c8ae68f7ddeef198"></a>kEncodingChineseGBK</em>&nbsp;</td><td class="fielddoc"><p>smSimpChinese, Codepage 936 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baac79ea32ace4b0f1c925ef80e1192d06a"></a>kEncodingEastEuropean</em>&nbsp;</td><td class="fielddoc"><p>smCentralEuroRoman, Codepage 1250 </td></tr><tr><td class="fieldname"><em><a class="anchor" id="ab7e2189ce8f077c74e234cf4312088baa4d2fc4e25bf97c4038695d63811f9064"></a>kEncodingVietnamese</em>&nbsp;</td><td class="fielddoc"><p>smVietnamese, Codepage 1258 </td></tr></table></div></div><a class="anchor" id="abeade53c5dc3aef7b31c89ca2d0c33e5"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5">PMString::StringPlatformEncoding</a></td></tr></table></div><div class="memdoc"><p>What kind of encoding to use to convert to unicode<dl class="section see"><dt>See Also<dd><a class="el" href="class_p_m_string.html#a934bb79486e5370330258d3503cd48d4">ReadPlatformWriteUnicode</a></dl><table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="abeade53c5dc3aef7b31c89ca2d0c33e5a44fdd91f3e1ce352a259e392193cc8df"></a>kPlatformEncodingWin</em>&nbsp;</td><td class="fielddoc"><p>Roman windows encoding </td></tr><tr><td class="fieldname"><em><a class="anchor" id="abeade53c5dc3aef7b31c89ca2d0c33e5ab4ab2a28657fbba67e529722c8266add"></a>kPlatformEncodingMac</em>&nbsp;</td><td class="fielddoc"><p>Roman mac encoding </td></tr><tr><td class="fieldname"><em><a class="anchor" id="abeade53c5dc3aef7b31c89ca2d0c33e5aa98159f58b1f3d971f4160e2cf61d8db"></a>kPlatformEncodingOther</em>&nbsp;</td><td class="fielddoc"><p>All other platform encodings (uses String encoding to convert) </td></tr><tr><td class="fieldname"><em><a class="anchor" id="abeade53c5dc3aef7b31c89ca2d0c33e5aec76f24dd5951d2c362d7ad5efe76e75"></a>kUTF8Encoding</em>&nbsp;</td><td class="fielddoc"><p>UTF8 encoding </td></tr></table></div></div><a class="anchor" id="a420d221adc4f7081bc56b588f90aefac"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefac">PMString::TranslateDuringCall</a></td></tr></table></div><div class="memdoc"><p>Specify whether to translate during call<dl class="section see"><dt>See Also<dd><a class="el" href="class_p_m_string.html#a855fd2ce1bd364ecd47a2050a9f6b20f">SetKey</a> and Constructor </dl><table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a420d221adc4f7081bc56b588f90aefaca224537655986f04b0b52ee30de7a45d1"></a>kDontTranslateDuringCall</em>&nbsp;</td><td class="fielddoc"><p>Keep as key string. calling Translate will give translation. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a420d221adc4f7081bc56b588f90aefaca7f2c6533d14a4582ab18142013d5502e"></a>kTranslateDuringCall</em>&nbsp;</td><td class="fielddoc"><p>Translate during call </td></tr></table></div></div><a class="anchor" id="a630154dc6d7c6114f44bf735966fdd89"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">enum <a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89">PMString::WhitespaceType</a></td></tr></table></div><div class="memdoc"><p>What kind of white space to strip<dl class="section see"><dt>See Also<dd><a class="el" href="class_p_m_string.html#af6e8954f648d7f1fae0d652638bf26fc">StripWhiteSpace</a></dl><table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a630154dc6d7c6114f44bf735966fdd89adef634b900ace25306a07eca759259d9"></a>kLeadingWhiteSpace</em>&nbsp;</td><td class="fielddoc"><p>Strip white space in the beginning of string </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a630154dc6d7c6114f44bf735966fdd89a03b38eeeadafdc20525ecf2ea2b742e9"></a>kTrailingWhiteSpace</em>&nbsp;</td><td class="fielddoc"><p>Strip white space at the end of string </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a630154dc6d7c6114f44bf735966fdd89aab71705d843bf510296bb9c58d815f4d"></a>kLeadingAndTrailingWhiteSpace</em>&nbsp;</td><td class="fielddoc"><p>Strip both white space at end and beginning of string </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a630154dc6d7c6114f44bf735966fdd89a090f3539c26b8559353849e71ba4d6cf"></a>kAllWhiteSpace</em>&nbsp;</td><td class="fielddoc"><p>Strip all white space </td></tr></table></div></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2><a class="anchor" id="aa75cd6eee8f72c92691c99a6208bd720"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">PMString::PMString </td><td>(</td><td class="paramtype">ConstCString&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefac">TranslateDuringCall</a>&nbsp;</td><td class="paramname"><em>translate</em> = <code><a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefaca224537655986f04b0b52ee30de7a45d1">kDontTranslateDuringCall</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Constuctor Construct <a class="el" href="class_p_m_string.html">PMString</a> using a ascii key. Caller is responsible for the memory of ConstCString key. Keys are the first string of the string pair in a resource StringTable. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>platform C string. Need to be null terminated. </td></tr><tr><td class="paramname">translate</td><td>using kTranslateDuringCall will put the translation in the string. The key will be lost. </td></tr></table></dl></div></div><a class="anchor" id="ae560ac0594c9d9b8f98fd5a7c4ab1aab"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">PMString::PMString </td><td>(</td><td class="paramtype">const UTF16TextChar *&nbsp;</td><td class="paramname"><em>string</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nDblBytes</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Constuctor <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">string</td><td>IN Unicode representation (in UTF-16 encoding) of the string for initialization. This string need not be null-terminated </td></tr><tr><td class="paramname">nDblBytes</td><td>IN The number of 16-bit values in the string buffer. This value may be greater than the number of characters represented since UTF-16 can contain surrogate pairs, each of which represents a single character. Composed characters are not supported </td></tr></table></dl></div></div><a class="anchor" id="a620b5bb40a97d7fe2e7f777037c5e9a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">PMString::PMString </td><td>(</td><td class="paramtype">const wchar_t *&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">explicit</span></span></td></tr></table></div><div class="memdoc"><p>Constructs from Unicode characters. Allows construction of a <a class="el" href="class_p_m_string.html">PMString</a> from L&quot;&quot; constants. On Windows wchar_t matches UTF16, on the Mac they are UTF32s. NOTE: This should be used to set strings that are not keys. Calling Translate on this string will do nothing. If you want to translate the string use SetKey. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>[IN] - buffer containing wchar_t characters. Needs to be null terminated. </td></tr></table></dl></div></div><a class="anchor" id="afd5cccb2fb0f27e19f0975cdf0dd0013"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">PMString::PMString </td><td>(</td><td class="paramtype">const wchar_t *&nbsp;</td><td class="paramname"><em>s</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">size_t&nbsp;</td><td class="paramname"><em>len</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Constructs from Unicode characters. On Windows wchar_t matches UTF16, on the Mac they are UTF32s. NOTE: This should be used to set strings that are not keys. Calling Translate on this string will do nothing. If you want to translate the string use SetKey. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>[IN] - buffer containing wchar_t characters. Doesn&#39;t have to be null terminated since the len parameter is mandatory. </td></tr><tr><td class="paramname">len</td><td>[IN] - number of wchar_t&#39;s in s to be read. </td></tr></table></dl></div></div><a class="anchor" id="aefadf020dc6fe4c3363845e678c3fcf3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">PMString::PMString </td><td>(</td><td class="paramtype">adobe::move_from&lt; <a class="el" href="class_p_m_string.html">PMString</a> &gt;&nbsp;</td><td class="paramname"><em>other</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><p>Movable constructor - assumes ownership of the remote part. </div></div><a class="anchor" id="a1f58e301fd031a5cbb8befdcd31639f1"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">PMString::PMString </td><td>(</td><td class="paramtype">ConstCString&nbsp;</td><td class="paramname"><em>string</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Constuctor<p>Set <a class="el" href="class_p_m_string.html">PMString</a> using a platform string. Same as calling - <a class="el" href="class_p_m_string.html#a55b402caab8f20bc6c2fb0ab6e652c9a">SetCString(ConstCString C, PMString::StringEncoding encoding)</a> This should be used to set strings that are not keys. Calling Translate on this string will do nothing. If you want to translate use the constructor without encoding - <a class="el" href="class_p_m_string.html">PMString</a>(ConstCString key, TranslateDuringCall translate = kDontTranslateDuringCall);<p>If it is not a key first consider using <a class="el" href="class_wide_string.html">WideString</a>. If you are you are using a string you don&#39;t want to be the same in all languages consider adding it as a key to the notranslate table.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">string</td><td>C string to set <a class="el" href="class_p_m_string.html">PMString</a> to. Make sure script of passed in C string matchs the script of the <a class="el" href="class_p_m_string.html">PMString</a>. </td></tr><tr><td class="paramname">encoding</td><td>The desired script of the platform representation of this string. The default value creates a <a class="el" href="class_p_m_string.html">PMString</a> with the encoding set appropriately for the current operating environment of the operating system: ASCII for English language systems, ShiftJIS for Japanese systems, etc. It is recommended that this parameter be set explicitly, however. </td></tr></table></dl></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a7264c4911eea8b17c93c572c808e708f"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Append </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>nCharacters</em> = <code>kMaxInt32</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Append the first n characters of s onto this string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to append </td></tr><tr><td class="paramname">nCharacters</td><td>number of characters in s to append </td></tr></table></dl></div></div><a class="anchor" id="a4bb5a962fbd265877f06f576c2551bf9"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Append </td><td>(</td><td class="paramtype">const <a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Append a <a class="el" href="class_wide_string.html">WideString</a><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td><a class="el" href="class_wide_string.html">WideString</a> to append </td></tr></table></dl></div></div><a class="anchor" id="a4262991a301c2180a7717d5e1921fb20"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::append </td><td>(</td><td class="paramtype">const wchar_t *&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Append Unicode characters. Allows appending L&quot;&quot; constants to the <a class="el" href="class_p_m_string.html">PMString</a>. On Windows wchar_t matches UTF16, on the Mac they are UTF32s. This does not change whether the string is translatable or not. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>[IN] - buffer containing wchar_t characters. Needs to be null terminated. </td></tr></table></dl></div></div><a class="anchor" id="a4dd6686ec4a5427ff616b1cecf2a5505"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Append </td><td>(</td><td class="paramtype">const char *&nbsp;</td><td class="paramname"><em>ps</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nBytes</em> = <code>kMaxInt32</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Append a series of characters which may have NO or MULTIPLE nul characters. No length checking is performed <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ps</td><td>platform string. </td></tr><tr><td class="paramname">nBytes</td><td>number of bytes in ps to append </td></tr><tr><td class="paramname">encoding</td><td>encoding of ps </td></tr></table></dl></div></div><a class="anchor" id="a82da30f546a882e2a63947676787ce82"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Append </td><td>(</td><td class="paramtype">char&nbsp;</td><td class="paramname"><em>pc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Append a platform or ascii character [replaces Append(char c)] <pre class="fragment">RECOMMENDATION -

If you are appending a hard coded value look for the value in TextChar.h and call AppendW(UTF32TextChar wc).

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pc</td><td>platform character. </td></tr><tr><td class="paramname">encoding</td><td>encoding of pc </td></tr></table></dl></div></div><a class="anchor" id="a8c8c749b4187f5a9d7f76c1a76558196"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Append </td><td>(</td><td class="paramtype">const <a class="el" href="class_platform_char.html">PlatformChar</a> &amp;&nbsp;</td><td class="paramname"><em>pc</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Append a platform or ascii character [replaces Append(char c)] <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pc</td><td>platform character. </td></tr></table></dl></div></div><a class="anchor" id="ad320ddf0302c27d8fd0bdf4fd3364f39"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void PMString::AppendFixed </td><td>(</td><td class="paramtype">Fixed&nbsp;</td><td class="paramname"><em>f</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><p>Append fixed number as string to existing string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">f</td><td>fixed to to convert to string and append </td></tr></table></dl></div></div><a class="anchor" id="afcac80f419f18ded9ed40769a3f3655b"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::AppendNumber </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>i</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Append number as string to existing string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">i</td><td>number to convert to string and append to existing string. </td></tr></table></dl></div></div><a class="anchor" id="ae26cead9c6b1acc9ecf9521d3db42f03"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::AppendNumber </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>r</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>digitsPrecision</em> = <code>-1</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>round</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>eliminateTrailingZeros</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Append number as string to existing string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">r</td><td>number to convert to string and append to existing string. </td></tr><tr><td class="paramname">digitsPrecision</td><td>how many decimal points to show. -1 means show all </td></tr><tr><td class="paramname">round</td><td>if kTrue value is rounded else value is floored. Only used if digitsPrecision is &gt; -1. </td></tr><tr><td class="paramname">eliminateTrailingZeros</td><td>if kTrue trailing zeros are not in string </td></tr></table></dl></div></div><a class="anchor" id="ac5fcbea2d25a805fec344fd2a7a148ea"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::AppendW </td><td>(</td><td class="paramtype">const UTF16TextChar *&nbsp;</td><td class="paramname"><em>ws</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nDblBytes</em> = <code>kMaxInt32</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Append a Unicode string <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ws</td><td>string to append </td></tr><tr><td class="paramname">nDblBytes</td><td>number of UTF16s to append </td></tr></table></dl></div></div><a class="anchor" id="a516284ef4bddc6ec9d7d9904ca72d650"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::AppendW </td><td>(</td><td class="paramtype"><a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="paramname"><em>wc</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Append a Unicode character <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">wc</td><td>character to append </td></tr></table></dl></div></div><a class="anchor" id="a8e3b400e0338ad754358189b8e26c3d9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void PMString::AsFixed </td><td>(</td><td class="paramtype">Fixed&nbsp;</td><td class="paramname"><em>f</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><p>Set string to fixed value. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">f</td><td>fixed to convert to string. </td></tr></table></dl></div></div><a class="anchor" id="a44fcb36d637197f775cdd6f0e4a1fda9"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::AsNumber </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>i</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set string to value. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">i</td><td>value to convert to string </td></tr></table></dl></div></div><a class="anchor" id="a4d36699e9d2d95049970b6f331839b40"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::AsNumber </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>r</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>digitsPrecision</em> = <code>-1</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>round</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>eliminateTrailingZeros</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set string to value. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">r</td><td><a class="el" href="class_p_m_real.html">PMReal</a> to convert to string </td></tr><tr><td class="paramname">digitsPrecision</td><td>how many decimal points to show. -1 means show all </td></tr><tr><td class="paramname">round</td><td>if kTrue value is rounded else value is floored. Only used if digitsPrecision is &gt; -1. </td></tr><tr><td class="paramname">eliminateTrailingZeros</td><td>if kTrue trailing zeros are not in string </td></tr></table></dl></div></div><a class="anchor" id="a5b2109c6288ee84fee9b5fd8ba41db03"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html">PMString</a>&amp; PMString::assign </td><td>(</td><td class="paramtype">const wchar_t *&nbsp;</td><td class="paramname"><em>s</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">size_t&nbsp;</td><td class="paramname"><em>len</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Sets the content of the PMString using a non-translatable Unicode string.

</pre><p> The string will be marked as non-translatable. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>Unicode buffer. Does not need to be null terminated as len determines how much it will be read. </td></tr><tr><td class="paramname">len</td><td>number of wchar_t in s to be read to set <a class="el" href="class_p_m_string.html">PMString</a>. Do not include count of null terminator. </td></tr></table></dl></div></div><a class="anchor" id="a2fec9631d88e41a45a9f4095977700b4"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::BeginsWith </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>searchString</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Returns true if string starts with searchString <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">searchString</td><td>string to look for </td></tr><tr><td class="paramname">pos</td><td>where to start looking. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 kTrue if string begins with searchString at given pos. </dl></div></div><a class="anchor" id="a87513fd2ee52ec21d46ffcedf84de111"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::clear </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Erases the string making it empty. Capacity stays the same. <dl class="section see"><dt>See Also<dd><a class="el" href="class_unicode_savvy_string.html#ac4bf34165f30bb9246570fbe423ff441">reserve</a>, <a class="el" href="class_unicode_savvy_string.html#ab7591ca8370bba53dddbd94fb397b94e">capacity</a></dl></div></div><a class="anchor" id="a8e0e7fd9eddf7012be5f263db1d3a7cc"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void PMString::Clear </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><p>To be deprecated. Use <a class="el" href="class_p_m_string.html#a87513fd2ee52ec21d46ffcedf84de111">clear()</a> instead.<p>PORTING RECIPE - Call <a class="el" href="class_p_m_string.html#a87513fd2ee52ec21d46ffcedf84de111">clear()</a>. </div></div><a class="anchor" id="aed8eeaa1ad3e31b9f5c3f5bd35fc1d88"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">int32 PMString::Compare </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>casesensitive</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Lexicographically compares strings like strcmp or stricmp, except based on UNICODE values. If both strings are roman encoded then compared based on platform values instead of Unicode. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">casesensitive</td><td>if kTrue use case to compare </td></tr><tr><td class="paramname">s</td><td>string to compare to </td></tr></table></dl><dl class="section return"><dt>Returns<dd>int32 0 strings are equal. -1 string &lt; s. 1 string &gt; s </dl></div></div><a class="anchor" id="a1590aac762c1e033bdee1e2479afd8ab"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::Contains </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>searchString</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Returns true if string contains searchString <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">searchString</td><td>string to look for </td></tr><tr><td class="paramname">pos</td><td>where to start looking. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 kTrue if searchString is contained in string </dl></div></div><a class="anchor" id="ab35af5ad81173316ba402db349a6ed69"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::empty </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Number of characters is 0. <dl class="section return"><dt>Returns<dd>bool16 kTrue if no characters in string </dl></div></div><a class="anchor" id="ac6d181a1470592ccf4b672eb2de5690d"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">double PMString::GetAsDouble </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6b">ConversionError</a> *&nbsp;</td><td class="paramname"><em>pError</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter *&nbsp;</td><td class="paramname"><em>lenNotConverted</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Try to interpert the string as a double. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pError</td><td>sets to a ConversionError if the entire string cannot be converted. </td></tr><tr><td class="paramname">lenNotConverted</td><td>number of characters at the end that were not converted </td></tr></table></dl><dl class="section return"><dt>Returns<dd>double number that string represents </dl></div></div><a class="anchor" id="a486ec2ebbeacbbe8997af062edad0aa7"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">int32 PMString::GetAsNumber </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html#a1a786a4e9adac26492dbd7d5e64d1b6b">ConversionError</a> *&nbsp;</td><td class="paramname"><em>pError</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter *&nbsp;</td><td class="paramname"><em>lenNotConverted</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Try to interpert the string as a number. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pError</td><td>sets to a ConversionError if the entire string cannot be converted. </td></tr><tr><td class="paramname">lenNotConverted</td><td>number of characters at the end that were not converted </td></tr></table></dl><dl class="section return"><dt>Returns<dd>int32 number that string represents </dl></div></div><a class="anchor" id="aa0acf66f49a13bfbde1ad16e754d0fa7"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">const <a class="el" href="class_platform_char.html">PlatformChar</a> PMString::GetChar </td><td>(</td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>returns the platform encoded character (as a <a class="el" href="class_platform_char.html">PlatformChar</a>) at a specific character offset <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pos</td><td>IN The character position (0-based) of the desired character. Note that embedded characters shown in the format &quot;&lt;1234&gt;&quot; returned from GrabCString() count as a single character, which will be returned as an invalid <a class="el" href="class_platform_char.html">PlatformChar</a></td></tr><tr><td class="paramname">encoding</td><td>encoding to get character as </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The platform character object at the given position. Note that a <a class="el" href="class_p_m_string.html">PMString</a> may contain 0 characters other than the terminating character. GetChar will return an invalid <a class="el" href="class_platform_char.html">PlatformChar</a> in this case. </dl></div></div><a class="anchor" id="a578bf775225ad8c27830c9c883b010be"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::GetCString </td><td>(</td><td class="paramtype">CString&nbsp;</td><td class="paramname"><em>C</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>bufferSize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Gets a C string. If bufferSize is not big enough the call returns and does not copy anything to the buffer c. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">C</td><td>OUT A pointer to string of bufferSize which will be filled in with the characters of the string represented in <a class="el" href="class_p_m_string.html#ac2f37c60d48722f7a0d12edca7745e22">GetEncoding()</a> encoding. </td></tr><tr><td class="paramname">bufferSize</td><td>IN the size of the provided buffer measured in bytes, including space for the terminating zero. </td></tr></table></dl></div></div><a class="anchor" id="ac2f37c60d48722f7a0d12edca7745e22"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a> PMString::GetEncoding </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Provide the current encoding of the platform buffer for the string<p>PORTING RECIPE - Encoding (also known as script) should be obtained when calling a routing that gets a platform string. After the encoding if put at the point of the call this API should be removed.<dl class="section return"><dt>Returns<dd>An identifier in the enumeration of String Encodings above </dl></div></div><a class="anchor" id="afdff026c203c07f6bfce0b4c1a323783"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html">PMString</a>* PMString::GetItem </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>delimiter</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const int32&nbsp;</td><td class="paramname"><em>nItem</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Returns the specified token/item of a string, given a single delimiter <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">delimiter</td><td>IN The string to use as a delimiter </td></tr><tr><td class="paramname">nItem</td><td>IN The one based item number for the the desired item </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A pointer to a string you need to deallocate, typically via k2::scoped_ptr. If the item does not exist (i.e. nItem is too low or high) then nil will be returned instead of a valid object. </dl></div></div><a class="anchor" id="af9da9d29b084834619137af698fb70ae"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">std::string PMString::GetPlatformString </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Gets a platform string. Check to make sure the code really wants a plaform encoded string if instead it wants utf8 you can call GetUTF8String<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">encoding</td><td>encoding for string to return. </td></tr></table></dl></div></div><a class="anchor" id="a1e7169e31da7b2c63b0b98e017e39742"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::GetPString </td><td>(</td><td class="paramtype">PString&nbsp;</td><td class="paramname"><em>p</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>bufferSize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Get pascal string. If <a class="el" href="class_p_m_string.html">PMString</a> byte length is greater than 255 all bytes will still be copied to the buffer but the lenght byte will be truncated to 255. If bufferSize is not big enough the call returns and does not copy anything to the buffer p.<p>RECOMMENDATION - See if this API is used for a Macintosh API call see if there is a new version of the API that takes a CFString.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>OUT A pointer to string of bufferSize which will be filled in with the characters of the string represented in <a class="el" href="class_p_m_string.html#ac2f37c60d48722f7a0d12edca7745e22">GetEncoding()</a> encoding. </td></tr><tr><td class="paramname">bufferSize</td><td>IN the size of the provided buffer measured in bytes, including space for the length byte. </td></tr><tr><td class="paramname">encoding</td><td>encoding of pascal string. </td></tr></table></dl></div></div><a class="anchor" id="a2588315ebf9f5cd95493db8266341037"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">uint8 PMString::GetScript </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>OBSOLETE. Use GetEncoding instead<p>PORTING RECIPE - Encoding (also known as script) should be obtained when calling a routing that gets a platform string. After the encoding is put at the point of the call this API should be removed.<dl class="section return"><dt>Returns<dd>uint8 script of string </dl></div></div><a class="anchor" id="aee364755d8969481452ba443ece6b2e8"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">std::string PMString::GetUTF8String </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Gets a std::string encoded as UTF8.<dl class="section return"><dt>Returns<dd>utf8 encoded string </dl></div></div><a class="anchor" id="a65d7cc030d9325b74381aa4779b230bc"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> PMString::GetWChar </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>pos</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>returns the double byte textchar at a specific character offset into the Unicode string representation. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pos</td><td>character offset. O based. </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a> character at index </dl></div></div><a class="anchor" id="a383ee876ab8a8b7504fed54e38afd3b9"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::GetWChar_tString </td><td>(</td><td class="paramtype">wchar_t *&nbsp;</td><td class="paramname"><em>wchar_tString</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>bufferSize</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Get a null terminated wchar_t string.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">wchar_tString</td><td>OUT returns string as wchar_t string </td></tr><tr><td class="paramname">bufferSize</td><td>size of wchar_tString buffer </td></tr></table></dl></div></div><a class="anchor" id="a2f34f29b90ab9ef21f2395254524000a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">const UTF16TextChar* PMString::GrabWString </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>DEPRECATED: Use GrabUTF16Buffer<p>PORTING RECIPE - Use GrabUTF16Buffer(nil)<dl class="section return"><dt>Returns<dd>UTF16TextChar* </dl></div></div><a class="anchor" id="a5853f7f6e0aba25335ef84d6a3cbe32d"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">uint32 PMString::Hash </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Provide a binary hash value based on numeric codes <dl class="section return"><dt>Returns<dd>uint32 hash value </dl></div></div><a class="anchor" id="a2df357d4e6d6d41f880cdda8a15627ba"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::HasTranslated </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>String has been translated. Calling Translate will set this to kTrue if IsTranslatable is kTrue and the string length is greater than 0. Also calling SetTranslated will set this to kTrue. <dl class="section return"><dt>Returns<dd>bool16 kTrue if the string has been translated. </dl></div></div><a class="anchor" id="ad0ca6492a61e97a1333222fec664a0c2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">CharCounter PMString::IndexOfCharacter </td><td>(</td><td class="paramtype">const <a class="el" href="class_platform_char.html">PlatformChar</a> &amp;&nbsp;</td><td class="paramname"><em>pc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>This routine looks for a character within this string. pos is the platform character offset (not byte count) to start looking. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">keyString</td><td>string to look for </td></tr><tr><td class="paramname">pos</td><td>where to start looking. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>CharCounter The character offset (not byte count) at which the character was found, or -1 when not found </dl></div></div><a class="anchor" id="a19ddab41a91caf1ebee32b50d28d7368"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">CharCounter PMString::IndexOfString </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>keyString</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>This routine looks for a substring within this string. pos is the platform character offset (not byte count) to start looking. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">keyString</td><td>string to look for </td></tr><tr><td class="paramname">pos</td><td>where to start looking. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>CharCounter The character offset (not byte count) at which the string was found, or -1 when not found </dl></div></div><a class="anchor" id="a2c6b25ff317ee2ddd315bbf4f929f990"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">CharCounter PMString::IndexOfWChar </td><td>(</td><td class="paramtype"><a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="paramname"><em>wc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Index of Unicode char in Unicode version of string <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">wc</td><td>Unicode character to find index for </td></tr><tr><td class="paramname">pos</td><td>position to start looking </td></tr></table></dl><dl class="section return"><dt>Returns<dd>CharCounter 0 based index. -1 when not found </dl></div></div><a class="anchor" id="a42cad4af8a629d8a94954da2d5c11e55"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Insert </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>nCharacters</em> = <code>kMaxInt32</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Insert the first n characters of s into this string. pos is interpreted as a true platform character offset not as a byte offset. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to insert </td></tr><tr><td class="paramname">pos</td><td>insert at this position. move existing characters to end </td></tr><tr><td class="paramname">nCharacters</td><td>how many characters of s to insert. Default kMaxInt32 means insert all characters. </td></tr></table></dl></div></div><a class="anchor" id="a5c10b6c068d1af3a2ca501e71179cd1e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Insert </td><td>(</td><td class="paramtype">const char *&nbsp;</td><td class="paramname"><em>ps</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nBytes</em> = <code>kMaxInt32</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Insert a platform string <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ps</td><td>platform string to insert </td></tr><tr><td class="paramname">nBytes</td><td>number of bytes to insert. kMaxInt32 means insert ::strlen of ps bytes. </td></tr><tr><td class="paramname">pos</td><td>insert at this position. This is a character position not a byte position. </td></tr><tr><td class="paramname">encoding</td><td>encoding of ps </td></tr></table></dl></div></div><a class="anchor" id="a5edde528b572543db5c577f647d5a0f2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Insert </td><td>(</td><td class="paramtype">char&nbsp;</td><td class="paramname"><em>pc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Insert a platform character <pre class="fragment">RECOMMENDATION -

If you are appending a hard coded value look for the value in TextChar.h and call InsertW(UTF32TextChar wc).

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pc</td><td>platform character </td></tr><tr><td class="paramname">pos</td><td>insert at this position </td></tr><tr><td class="paramname">encoding</td><td>encoding of pc </td></tr></table></dl></div></div><a class="anchor" id="ac1c42743ba3f44206b2322cc8cf12cd6"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Insert </td><td>(</td><td class="paramtype">const <a class="el" href="class_platform_char.html">PlatformChar</a> &amp;&nbsp;</td><td class="paramname"><em>pc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Insert a platform character <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pc</td><td>platform character </td></tr><tr><td class="paramname">pos</td><td>insert at this position </td></tr></table></dl></div></div><a class="anchor" id="a89f0d1995db9763a2c19ded0f13cfa5b"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::InsertW </td><td>(</td><td class="paramtype">const UTF16TextChar *&nbsp;</td><td class="paramname"><em>ws</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nDblBytes</em> = <code>kMaxInt32</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Insert a Unicode string <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ws</td><td>string to insert </td></tr><tr><td class="paramname">nDblBytes</td><td>number of UTF16s to insert </td></tr><tr><td class="paramname">pos</td><td>insert at this position </td></tr></table></dl></div></div><a class="anchor" id="a215ff6f795b5923cfb82959eae0b4f35"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::InsertW </td><td>(</td><td class="paramtype"><a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="paramname"><em>wc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>pos</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Insert a Unicode character <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">wc</td><td>character to insert </td></tr><tr><td class="paramname">pos</td><td>insert at this position </td></tr></table></dl></div></div><a class="anchor" id="a85d2a193dab450186b5bee9c96eab9f8"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::IsEmpty </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Number of character is 0. Same as calling <a class="el" href="class_p_m_string.html#ab35af5ad81173316ba402db349a6ed69">empty()</a>.<p>PORTING RECIPE - Call <a class="el" href="class_p_m_string.html#ab35af5ad81173316ba402db349a6ed69">empty()</a>.<dl class="section return"><dt>Returns<dd>bool16 kTrue if no characters in string </dl></div></div><a class="anchor" id="ab41ccfb69ce394819cfb01a84ee73504"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::IsEqual </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8&nbsp;</td><td class="paramname"><em>casesensitive</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool8&nbsp;</td><td class="paramname"><em>limitCompareToShorterLength</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>If limitCompareToShorterLength is true, you can use IsEqual to compare n characters of 2 strings, where &#39;n&#39; is the length of the shorter string <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to compare </td></tr><tr><td class="paramname">casesensitive</td><td>if kTrue use case to compare </td></tr><tr><td class="paramname">limitCompareToShorterLength</td><td>if kTrue only compare to shortest string </td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 kTrue if equal </dl></div></div><a class="anchor" id="a6053aed859a0752d4ff2865f533f7744"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::IsNull </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Number of character is 0. Same as calling <a class="el" href="class_p_m_string.html#ab35af5ad81173316ba402db349a6ed69">empty()</a>.<p>PORTING RECIPE - Call <a class="el" href="class_p_m_string.html#ab35af5ad81173316ba402db349a6ed69">empty()</a>.<dl class="section return"><dt>Returns<dd>bool16 kTrue if no characters in string </dl></div></div><a class="anchor" id="a5c601cc1892148c2f3815e0f2dff597a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::IsTranslatable </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Find out if string is translatable. This is true when constructed with default parameters. This does not mean there is a translation for the string just that calling Translate will look for a translation. <dl class="section return"><dt>Returns<dd>bool16 kTrue if string is translatable. </dl></div></div><a class="anchor" id="abf5cdb050c4030afd960f644d612470a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">CharCounter PMString::LastIndexOfCharacter </td><td>(</td><td class="paramtype">const <a class="el" href="class_platform_char.html">PlatformChar</a> &amp;&nbsp;</td><td class="paramname"><em>pc</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Last index of platform char in string. Starts looking from end of string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pc</td><td>character to find index for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>CharCounter 0 based index. -1 when not found </dl></div></div><a class="anchor" id="a611636793236f5517460f70df978e48e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">CharCounter PMString::LastIndexOfString </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>keyString</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Last index of substring within this string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">keyString</td><td>string to look for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>CharCounter The character offset (not byte count) at which the string was found, or -1 when not found </dl></div></div><a class="anchor" id="aeff3db280b8ceaa4bea6bd6b8bffbced"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">CharCounter PMString::LastIndexOfWChar </td><td>(</td><td class="paramtype"><a class="el" href="class_u_t_f32_text_char.html">UTF32TextChar</a>&nbsp;</td><td class="paramname"><em>wc</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Last index of Unicode char in Unicode version of string <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">wc</td><td>Unicode character to find index for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>CharCounter 0 based index. -1 when not found </dl></div></div><a class="anchor" id="a10df7b4bcd9ec7370653bbadbccfdc49"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::operator!= </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>This is really just a not of the == operator. Calls !(this==s) <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to compare </td></tr></table></dl></div></div><a class="anchor" id="ab7046411844f4d9b1dff0f9ee1ec21d4"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html">PMString</a>&amp; PMString::operator+= </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Appends <a class="el" href="class_p_m_string.html">PMString</a> s <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to append </td></tr></table></dl></div></div><a class="anchor" id="a88166a47cc01e84a76754958c223afbf"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::operator&lt; </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Lexicographically compares strings like strcmp or stricmp. If both are encoded in roman and neither has embedded unicode then platform compare is done. Otherwise compare is based on UNICODE values. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to compare </td></tr></table></dl></div></div><a class="anchor" id="ac8831eacdf474730b9609c25571652df"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::operator&lt;= </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Lexicographically compares strings like strcmp or stricmp. If both are encoded in roman and neither has embedded unicode then platform compare is done. Otherwise compare is based on UNICODE values. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to compare </td></tr></table></dl></div></div><a class="anchor" id="ae39b4d350ebc4ce7e8f57bac9de28e0d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html">PMString</a>&amp; PMString::operator= </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>other</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><p>operator copy assignment </div></div><a class="anchor" id="aab029d44eaac86fe1463cf477c1fe375"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html">PMString</a>&amp; PMString::operator= </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&amp;&nbsp;</td><td class="paramname"><em>other</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span></td></tr></table></div><div class="memdoc"><p>operator move assignment </div></div><a class="anchor" id="a58820762fde3ab015a5d85ceef5da94c"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::operator== </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Equals. Compares buffers. If either has a unicode buffer these are compared. If both have platform buffers then those are compared. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to compare </td></tr></table></dl></div></div><a class="anchor" id="a25f36a7f78f0a4429e134c0bf2c0255a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::operator== </td><td>(</td><td class="paramtype">ConstCString&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Equals. Compares key. Parameter key must be a key. no translation is done. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>key to compare </td></tr></table></dl></div></div><a class="anchor" id="ac12e0dd606c82ac60311f3374dc48cf2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::operator&gt; </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Lexicographically compares strings like strcmp or stricmp. If both are encoded in roman and neither has embedded unicode then platform compare is done. Otherwise compare is based on UNICODE values. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to compare </td></tr></table></dl></div></div><a class="anchor" id="a03035c631cc346cf35f3f43e42356258"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::operator&gt;= </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Lexicographically compares strings like strcmp or stricmp. If both are encoded in roman and neither has embedded unicode then platform compare is done. Otherwise compare is based on UNICODE values. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to compare </td></tr></table></dl></div></div><a class="anchor" id="ada30ea59d3bc68f3a522d6acb1837fb2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">const <a class="el" href="class_platform_char.html">PlatformChar</a> PMString::operator[] </td><td>(</td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>index</em></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>returns the platform encoded character (as a <a class="el" href="class_platform_char.html">PlatformChar</a>) at a specific character offset into the platform string representation. This routine is multibyte (shift-JIS) character safe. It is read-only </div></div><a class="anchor" id="a992b90ef6bf5e6e938316b92175c18a3"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::ParseForEmbeddedCharacters </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Search the string and replace valid occurences of the form &lt;xxxx&gt; or &lt;xxxxxx&gt; (where &#39;x&#39; is a hex digit) into a single character corresponding to that Unicode value <dl class="section return"><dt>Returns<dd>kTrue if there were embedded characters </dl></div></div><a class="anchor" id="a934bb79486e5370330258d3503cd48d4"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::ReadPlatformWriteUnicode </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"><em>s</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5">PMString::StringPlatformEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code><a class="el" href="class_p_m_string.html#abeade53c5dc3aef7b31c89ca2d0c33e5aa98159f58b1f3d971f4160e2cf61d8db">kPlatformEncodingOther</a></code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>includeBools</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>This will read a platform encoded string from s and store it in unicode (UTF16) in this <a class="el" href="class_p_m_string.html">PMString</a>. We use this to read the Translations saved in .fr files. This is for performance reasons because when they are drawn to screen the OS wants unicode.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>stream to read string from </td></tr><tr><td class="paramname">encodingClass</td><td>how the string being read is encoded </td></tr><tr><td class="paramname">includeBools</td><td>includes format, shouldTranslate, HasTranslated. set kTrue if resource is PlatformPMString. set kFalse if resource is wstring </td></tr></table></dl></div></div><a class="anchor" id="acf3eb36bb0745e30d94962b1ce55481c"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::ReadWrite </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>This writes Unicode representation of string. Encoding, HasTranslated and IsTranslatable are also written. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string to read or write </td></tr></table></dl></div></div><a class="anchor" id="aa073a79b4c84c593db5fbe27ee325fea"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::ReadWriteKey </td><td>(</td><td class="paramtype"><a class="el" href="class_i_p_m_stream.html">IPMStream</a> *&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Reads a key from a resouce that is of type wstring. If it is a write stream wstring type is written out.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">*s</td><td>IN OUT The stream object from which to read. </td></tr></table></dl></div></div><a class="anchor" id="a63c162b020c13ebfe4275d050d989de1"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Remove </td><td>(</td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>count</em> = <code>1</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>This routines removes count characters (not bytes) from this string, starting after the pos&#39;th platform character. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pos</td><td>IN zero-based character counter representing the position for the operation. </td></tr><tr><td class="paramname">count</td><td>IN The number of characters (not bytes). Using kMaxInt32 will remove from pos to end of string. </td></tr></table></dl></div></div><a class="anchor" id="a55b402caab8f20bc6c2fb0ab6e652c9a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetCString </td><td>(</td><td class="paramtype">ConstCString&nbsp;</td><td class="paramname"><em>C</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set <a class="el" href="class_p_m_string.html">PMString</a> using a platform string. Make sure encoding passed in matchs the encoding of C. Caller is responsible for the memory of ConstCString C. This should be used to set strings that are not keys. Calling Translate on this string will do nothing. If you want to translate the string use SetKey. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">C</td><td>platform C string. Need to be null terminated. </td></tr><tr><td class="paramname">encoding</td><td>encoding of C string. </td></tr></table></dl></div></div><a class="anchor" id="abe884b9dce0764de2651207e49f3a724"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetCString </td><td>(</td><td class="paramtype">ConstCString&nbsp;</td><td class="paramname"><em>C</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set <a class="el" href="class_p_m_string.html">PMString</a> using a platform string. Make sure script of passed in string matchs the script of the <a class="el" href="class_p_m_string.html">PMString</a>. This can be changed by calling SetEncoding. Buffer is copied so caller is responsible for the memory of ConstCString C. This is the same as SetKey. defaults to set the string to TRANSLATABLE but not translated.<p>PORTING RECIPE - If the cstring is a key use SetKey. If the cstring is not a key use SetCString with encoding parameter.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">C</td><td>platform C string. Need to be null terminated. </td></tr></table></dl></div></div><a class="anchor" id="a0525bc255a1e9504db0b696b24ed1339"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetEncoding </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Sets to encoding of the string. If there is a platform buffer in the string then this will delete the Unicode buffer so changing the encoding when there is a platform buffer may change the Unicode buffer. However if there is no platform buffer and only a Unicode buffer the unicode will stay the same and calls to get the platform buffer will use the new encoding to convert the unicode to platform. Due to this it is best to call this when your string is empty so you have easy to understand behavior.<p>PORTING RECIPE - Encoding (also known as script) should be set when calling a routine that sets or gets a platform string. After the encoding is put at the point of the call this API should be removed.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">encoding</td><td>new encoding to set for string. </td></tr></table></dl></div></div><a class="anchor" id="a855fd2ce1bd364ecd47a2050a9f6b20f"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetKey </td><td>(</td><td class="paramtype">ConstCString&nbsp;</td><td class="paramname"><em>key</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefac">TranslateDuringCall</a>&nbsp;</td><td class="paramname"><em>translate</em> = <code><a class="el" href="class_p_m_string.html#a420d221adc4f7081bc56b588f90aefaca224537655986f04b0b52ee30de7a45d1">kDontTranslateDuringCall</a></code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set <a class="el" href="class_p_m_string.html">PMString</a> using a ascii key. Caller is responsible for the memory of ConstCString key. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">key</td><td>ascii key string. Need to be null terminated. </td></tr><tr><td class="paramname">translate</td><td>using kTranslateDuringCall will put the translation in the string. The key will be lost. </td></tr></table></dl></div></div><a class="anchor" id="ae933d92f823a8f631adc95fed1a6d9f7"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetPString </td><td>(</td><td class="paramtype">ConstPString&nbsp;</td><td class="paramname"><em>p</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set <a class="el" href="class_p_m_string.html">PMString</a> using a pascal string. Make sure the encoding passed in matchs the encoding of p. Caller is responsible for the memory of ConstPString p. This should be used to set strings that are not keys. Calling Translate on this string will do nothing. If you want to translate the string use SetKey.<p>RECOMMENDATION - See if the ContPString p came from an API for the Macintosh. See if there is a new version of the API that gives a Unicode buffer or CFString.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>string used to set <a class="el" href="class_p_m_string.html">PMString</a></td></tr><tr><td class="paramname">encoding</td><td>encoding of C string. </td></tr></table></dl></div></div><a class="anchor" id="abb617a5fea8b8e8f3930f5cb24d47b2b"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetScript </td><td>(</td><td class="paramtype">uint8&nbsp;</td><td class="paramname"><em>script</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>OBSOLETE. Use SetEncoding instead<p>PORTING RECIPE - Encoding (also known as script) should be set when calling a routing that sets or gets a platform string. After the encoding is put at the point of the call this API should be removed.<dl class="section return"><dt>Returns<dd>uint8 script of string </dl></div></div><a class="anchor" id="a76daea4596a7495456d645be19ab24a3"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetString </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Set string using <a class="el" href="class_p_m_string.html">PMString</a> s <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s</td><td>string used to set this <a class="el" href="class_p_m_string.html">PMString</a>. </td></tr></table></dl></div></div><a class="anchor" id="acdb6160d8d2233331c0f2e43b569706c"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html">PMString</a>&amp; PMString::SetTranslatable </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>shouldTranslate</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Sets weather the string should be translated. If the string was typed by the user often you want to turn off translation.<p>RECOMMENDATION - If you need to turn translation off think about using <a class="el" href="class_wide_string.html">WideString</a> instead. If that cannot be done Try calling constructor with kNoTranslate or SetCString with an encoding (that defaults to an untranslatable string).<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">shouldTranslate</td><td>kFalse to turn off translation </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_p_m_string.html">PMString</a>&amp; returns this </dl></div></div><a class="anchor" id="a750d999de6012f7d88cf378eb2a22765"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetTranslated </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>SetTranslated should not usually be called. It is only used when we get a string the user typed in, so we know it is translated, but it isn&#39;t marked that way.<p>RECOMMENDATION - If you need to turn translation off think about using <a class="el" href="class_wide_string.html">WideString</a> instead. If that cannot be done Try calling constructor with kNoTranslate or SetCString with an encoding (that sets to an untranslatable string). </div></div><a class="anchor" id="a013bb08fee62526e3a478f1afd125775"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetUTF8String </td><td>(</td><td class="paramtype">const std::string &amp;&nbsp;</td><td class="paramname"><em>utf8String</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Sets using a std::string encoded as UTF8. String is marked as not translatable </div></div><a class="anchor" id="a02bc88637c7968dbc9602fd8648d93b2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetXString </td><td>(</td><td class="paramtype">const UTF16TextChar *&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nDblBytes</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set <a class="el" href="class_p_m_string.html">PMString</a> using a Unicode string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">x</td><td>Unicode buffer. Does not need to be null terminated as nDblBytes determines what will be read. </td></tr><tr><td class="paramname">nDblBytes</td><td>number of UTF16TextChars in x to be read to set <a class="el" href="class_p_m_string.html">PMString</a>. Do not include count of null terminator. </td></tr></table></dl></div></div><a class="anchor" id="a385d1c05d0cb2242c3bac4e6c9190c8e"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::SetXString </td><td>(</td><td class="paramtype">const char *&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>nBytes</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html#ab7e2189ce8f077c74e234cf4312088ba">PMString::StringEncoding</a>&nbsp;</td><td class="paramname"><em>encoding</em> = <code>kUnknownEncoding</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></div><div class="memdoc"><p>Set <a class="el" href="class_p_m_string.html">PMString</a> using a platform string. Make sure encoding passed in matchs the encoding of x. Caller is responsible for the memory of char* x. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">x</td><td>platform string. Does not need to be null terminated as nBytes determines what will be read. </td></tr><tr><td class="paramname">nBytes</td><td>number of bytes in x to be read to set <a class="el" href="class_p_m_string.html">PMString</a>. Do not include count of null terminator </td></tr><tr><td class="paramname">encoding</td><td>encoding of C string. </td></tr></table></dl></div></div><a class="anchor" id="af6e8954f648d7f1fae0d652638bf26fc"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::StripWhiteSpace </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89">WhitespaceType</a>&nbsp;</td><td class="paramname"><em>wsType</em> = <code><a class="el" href="class_p_m_string.html#a630154dc6d7c6114f44bf735966fdd89a090f3539c26b8559353849e71ba4d6cf">kAllWhiteSpace</a></code></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Strip white space from string. This routine only strips kTextChar_Space (U+0020). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">wsType</td><td>where to strip white space from </td></tr></table></dl></div></div><a class="anchor" id="af85bf47c69e5c8814eee4b5054c20f5a"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html">PMString</a>* PMString::Substring </td><td>(</td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>pos</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>count</em> = <code>kMaxInt32</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></div><div class="memdoc"><p>Creates a new string based on count characters (not bytes) from this string. The substring begins at pos (0 based). Return nil if selected range is empty. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">pos</td><td>position to get string. 0 based. </td></tr><tr><td class="paramname">count</td><td>number of character to get. kMaxInt32 goes to end of string. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>PMString* substring. return nil if selected range is empty. </dl></div></div><a class="anchor" id="ac521943668a7e88d58c28ea8b880e31b"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::ToLower </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Converts characters to Lower case. </div></div><a class="anchor" id="a3acfa9e0bec4dc575bd7ed1dc4bfb9d8"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::ToUpper </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>Converts characters to Upper case. </div></div><a class="anchor" id="aa9fb7fb8d90885950ac4ada00e12e1c2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::Translate </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_locale_id.html">PMLocaleId</a> &amp;&nbsp;</td><td class="paramname"><em>locale</em></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>translate from key to another locale, over-loaded so that if no locale is specified the current global locale setting is used. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">locale</td><td>locale to translate to </td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 kTrue if translated. Also kTrue if IsTranslatable is kFalse or HasTranslated if kTrue. </dl></div></div><a class="anchor" id="a6b68a209a15df93d5c6a4533e8411ac2"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">bool16 PMString::Translate </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>translate from key using current locale. <dl class="section return"><dt>Returns<dd>bool16 kTrue if translated. Also kTrue if IsTranslatable is kFalse or HasTranslated if kTrue. </dl></div></div><a class="anchor" id="a8807524efaccfc4d0652b6103de619f7"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">void PMString::Truncate </td><td>(</td><td class="paramtype">CharCounter&nbsp;</td><td class="paramname"><em>count</em> = <code>1</code></td><td>)</td><td></td></tr></table></div><div class="memdoc"><p>This routines truncates the final count platform characters (not bytes) from the string. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">count</td><td>number of characters to remove from end </td></tr></table></dl></div></div><a class="anchor" id="abbed79c26c6369a51559a28c1602cfdf"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">int32 PMString::WCharLength </td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></div><div class="memdoc"><p>Get the number of UTF16s required to store this string. Same value as returned in numUTF16s by GrabUTF16Buffer. <dl class="section return"><dt>Returns<dd>int32 number of UTF16s required to store </dl></div></div><h2 class="groupheader">Friends And Related Function Documentation</h2><a class="anchor" id="a101b157d3bc0fdc06e5fd779950aaa41"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_p_m_string.html">PMString</a> operator+ </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s1</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>s2</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">friend</span></span></td></tr></table></div><div class="memdoc"><p>Appends <a class="el" href="class_p_m_string.html">PMString</a> s2 to <a class="el" href="class_p_m_string.html">PMString</a> s1 and returns it as a <a class="el" href="class_p_m_string.html">PMString</a><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">s1</td><td>string to append to </td></tr><tr><td class="paramname">s2</td><td>string to append </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_p_m_string.html">PMString</a> string to set </dl></div></div><a class="anchor" id="a9bfda38e5b5aaed128b34be1ab89f705"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void swap </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>left</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>right</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">friend</span></span></td></tr></table></div><div class="memdoc"><p>Swaps the contents of two strings. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_p_m_string.html">PMString</a><li class="footer">Generated on Sat Sep 22 2018 10:56:25 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
