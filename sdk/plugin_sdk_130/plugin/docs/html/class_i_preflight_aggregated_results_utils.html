<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_preflight_aggregated_results_utils</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_preflight_aggregated_results_utils.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_preflight_aggregated_results_utils-members.html">List of all members</a></div><div class="headertitle"><div class="title">IPreflightAggregatedResultsUtils Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_preflight_aggregated_results_utils_8h_source.html">IPreflightAggregatedResultsUtils.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for IPreflightAggregatedResultsUtils:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_preflight_aggregated_results_utils.png" usemap="#IPreflightAggregatedResultsUtils_map" /><map id="IPreflightAggregatedResultsUtils_map" name="IPreflightAggregatedResultsUtils_map"><area alt="IPMUnknown" coords="0,0,191,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a6c5f610355d9dc6a3c9f1dbf4ff34a30"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IPREFLIGHTAGGREGATEDRESULTSUTILS }</td></tr><tr class="separator:a6c5f610355d9dc6a3c9f1dbf4ff34a30"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a21009448ca2251e2bb98d8cb52b9ade4"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="class_i_preflight_aggregated_results_utils.html#a21009448ca2251e2bb98d8cb52b9ade4a40c475944d1421b12a5433eb9f3fef5c">kAggregateDifferentSubparts</a> = (1L&lt;&lt;0), <a class="el" href="class_i_preflight_aggregated_results_utils.html#a21009448ca2251e2bb98d8cb52b9ade4a359ffdf288477d5a2437c7fb70341f38">kAggregateTextRangesWithDifferentValues</a> = (1L&lt;&lt;1), <a class="el" href="class_i_preflight_aggregated_results_utils.html#a21009448ca2251e2bb98d8cb52b9ade4a5eccd53a8bba4181b34377fbec7ac78c">kAggregateCellsWithDifferentValues</a> = (1L&lt;&lt;2), <a class="el" href="class_i_preflight_aggregated_results_utils.html#a21009448ca2251e2bb98d8cb52b9ade4abcd9d206edd2beaa8f10b232bd2fd6ee">kDoNotAggregateSingluarValueSubparts</a> = (1L&lt;&lt;3) }</td></tr><tr class="separator:a21009448ca2251e2bb98d8cb52b9ade4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a787dc500e8de428a44e32f010d10d39c"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a787dc500e8de428a44e32f010d10d39c"></a> typedef <a class="el" href="class_interface_ptr.html">InterfacePtr</a><br class="typebreak" /> &lt; <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ResultTableIFP</b></td></tr><tr class="separator:a787dc500e8de428a44e32f010d10d39c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6dc4161af6528cf1cb1fe14399d9936e"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6dc4161af6528cf1cb1fe14399d9936e"></a> typedef <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_interface_ptr.html">ResultTableIFP</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>VectorOfTables</b></td></tr><tr class="separator:a6dc4161af6528cf1cb1fe14399d9936e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5bf19c2aa3f343b54e5e5fece5a72cd0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5bf19c2aa3f343b54e5e5fece5a72cd0"></a> typedef <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>VectorOfIndices</b></td></tr><tr class="separator:a5bf19c2aa3f343b54e5e5fece5a72cd0"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a40b0bdfc9caf2c157db79b56f52a4da0"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /><a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a40b0bdfc9caf2c157db79b56f52a4da0">CreateAggregatedResults</a> () const =0</td></tr><tr class="separator:a40b0bdfc9caf2c157db79b56f52a4da0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4afb13ddadcf4830b43d69188606db7e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_result_record.html">IPreflightResultRecord</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a4afb13ddadcf4830b43d69188606db7e">CreatePreflightResultRecord</a> () const =0</td></tr><tr class="separator:a4afb13ddadcf4830b43d69188606db7e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a32a23aaeaabcd937ef7e68136bf81869"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a32a23aaeaabcd937ef7e68136bf81869">CreatePreflightResultRecordTable</a> () const =0</td></tr><tr class="separator:a32a23aaeaabcd937ef7e68136bf81869"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a63592effbfd678b0605f0968b78ea434"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a63592effbfd678b0605f0968b78ea434">CreatePreflightResultNodeInfo</a> () const =0</td></tr><tr class="separator:a63592effbfd678b0605f0968b78ea434"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5ef17a81bfe87009fdc7dc474a258f50"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a5ef17a81bfe87009fdc7dc474a258f50">CreateTableFromNodes</a> (const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *iProcess, const <a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">IPreflightProcess::NodeIDVector</a> &amp;resultNodes) const =0</td></tr><tr class="separator:a5ef17a81bfe87009fdc7dc474a258f50"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac9365c06e0e7b9e1b6a00c3aa95ff14f"><td align="right" class="memItemLeft" valign="top">virtual const <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#ac9365c06e0e7b9e1b6a00c3aa95ff14f">ApplyAllStandardAggregations</a> (const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *iProcess, const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iTable, uint32 aggregationFlags=0) const =0</td></tr><tr class="separator:ac9365c06e0e7b9e1b6a00c3aa95ff14f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8d7696576fb3ce0b31e32177e3040853"><td align="right" class="memItemLeft" valign="top">virtual const <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a8d7696576fb3ce0b31e32177e3040853">AggregateMarkingOperationsToUsefulObjects</a> (const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *iProcess, const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iTable, uint32 aggregationFlags=0) const =0</td></tr><tr class="separator:a8d7696576fb3ce0b31e32177e3040853"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:acbc785d8e45cb2a0f2937c8fcadbbf46"><td align="right" class="memItemLeft" valign="top">virtual const <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#acbc785d8e45cb2a0f2937c8fcadbbf46">AggregateContiguousTextRanges</a> (const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iTable, uint32 aggregationFlags=0) const =0</td></tr><tr class="separator:acbc785d8e45cb2a0f2937c8fcadbbf46"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88a270f99bb5fce11a5644f999e49a0c"><td align="right" class="memItemLeft" valign="top">virtual const <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a88a270f99bb5fce11a5644f999e49a0c">AggregateContiguousCells</a> (const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iTable, bool horizontally, uint32 aggregationFlags) const =0</td></tr><tr class="separator:a88a270f99bb5fce11a5644f999e49a0c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a42c430ab621ff14b3ef1de5617084c8e"><td align="right" class="memItemLeft" valign="top">virtual const <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a42c430ab621ff14b3ef1de5617084c8e">AggregateDifferentSubpartsSameEverythingElse</a> (const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iTable, uint32 aggregationFlags=0) const =0</td></tr><tr class="separator:a42c430ab621ff14b3ef1de5617084c8e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a27917e48beabda7449f3c41081d0662d"><td align="right" class="memItemLeft" valign="top">virtual const <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a27917e48beabda7449f3c41081d0662d">CreateSubTable</a> (const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iSrcTable, const <a class="el" href="class_k2_vector.html">VectorOfIndices</a> &amp;indices) const =0</td></tr><tr class="separator:a27917e48beabda7449f3c41081d0662d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a82eda00f607b46ed463bd042d83cd218"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /><a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a82eda00f607b46ed463bd042d83cd218">CreateSubTableByCriteria</a> (const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iSrc, <a class="el" href="class_i_d_type.html">ClassID</a> criteriaID, bool invertCriteria=kFalse) const =0</td></tr><tr class="separator:a82eda00f607b46ed463bd042d83cd218"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac38588875ebf81b474a6f7ef7744a378"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#ac38588875ebf81b474a6f7ef7744a378">CreateTablesByCriteria</a> (const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iSrcTable, <a class="el" href="class_k2_vector.html">VectorOfTables</a> &amp;tables) const =0</td></tr><tr class="separator:ac38588875ebf81b474a6f7ef7744a378"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b3e96d1de20281f6fe7a1f55b35d263"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a1b3e96d1de20281f6fe7a1f55b35d263">CreateTablesByAuxString</a> (const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iSrcTable, <a class="el" href="class_k2_vector.html">VectorOfTables</a> &amp;tables) const =0</td></tr><tr class="separator:a1b3e96d1de20281f6fe7a1f55b35d263"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aae98b2e7ee4da2061c28d25c04e9a761"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#aae98b2e7ee4da2061c28d25c04e9a761">CreateTablesByObject</a> (const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iSrcTable, <a class="el" href="class_k2_vector.html">VectorOfTables</a> &amp;tables) const =0</td></tr><tr class="separator:aae98b2e7ee4da2061c28d25c04e9a761"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6696df0962338c5b337f4fc7bd140ef9"><td align="right" class="memItemLeft" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a6696df0962338c5b337f4fc7bd140ef9">IsPlacedContent</a> (const <a class="el" href="class_i_preflight_result_record.html">IPreflightResultRecord</a> *iRec) const =0</td></tr><tr class="separator:a6696df0962338c5b337f4fc7bd140ef9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abcd41b798ea6fb58e7c9ebbf1c9e0e35"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#abcd41b798ea6fb58e7c9ebbf1c9e0e35">FormatXMeasure</a> (const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *iProcess, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x) const =0</td></tr><tr class="separator:abcd41b798ea6fb58e7c9ebbf1c9e0e35"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a79f86af9310f6f196180393be571041a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a79f86af9310f6f196180393be571041a">FormatYMeasure</a> (const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *iProcess, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;y) const =0</td></tr><tr class="separator:a79f86af9310f6f196180393be571041a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aea5f66a15a669939e7eda4d82787bf12"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#aea5f66a15a669939e7eda4d82787bf12">FormatLineMeasure</a> (const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *iProcess, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x) const =0</td></tr><tr class="separator:aea5f66a15a669939e7eda4d82787bf12"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa5dc298e7c60762b925d0470ab9c84d3"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#aa5dc298e7c60762b925d0470ab9c84d3">FormatTextSizeMeasure</a> (const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *iProcess, const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x) const =0</td></tr><tr class="separator:aa5dc298e7c60762b925d0470ab9c84d3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ada7dca03ed8a74929fededf4a182b592"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#ada7dca03ed8a74929fededf4a182b592">FormatResolution</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x) const =0</td></tr><tr class="separator:ada7dca03ed8a74929fededf4a182b592"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac721da752aa8df89808af46030061a51"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#ac721da752aa8df89808af46030061a51">FormatAsInteger</a> (const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;x) const =0</td></tr><tr class="separator:ac721da752aa8df89808af46030061a51"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7d2964e23f647e3458a2ec1fb0d505b0"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a7d2964e23f647e3458a2ec1fb0d505b0"></a> virtual <a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSubpartsDescription</b> (const <a class="el" href="class_i_preflight_result_record.html">IPreflightResultRecord</a> *iRec, bool forceTranslation=kTrue) const =0</td></tr><tr class="separator:a7d2964e23f647e3458a2ec1fb0d505b0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a158b059630da48022bbdfac702327151"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /> IPreflightAggregatedResults::NodeID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a158b059630da48022bbdfac702327151">AddCriteriaNode</a> (<a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a> *iResults, IPreflightAggregatedResults::NodeID parentID, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;nodeText, const <a class="el" href="class_wide_string.html">PreflightRuleID</a> &amp;ruleID) const =0</td></tr><tr class="separator:a158b059630da48022bbdfac702327151"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:accf549e1066cc28f030912db8f77d701"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#accf549e1066cc28f030912db8f77d701">CreateViolationNode</a> (const <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;objID) const =0</td></tr><tr class="separator:accf549e1066cc28f030912db8f77d701"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afe334323afbf62dd70e95694c7a2b792"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#afe334323afbf62dd70e95694c7a2b792">CreateCriteriaAndViolationNode</a> (const <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;objID, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;nodeName, const <a class="el" href="class_wide_string.html">PreflightRuleID</a> &amp;ruleID) const =0</td></tr><tr class="separator:afe334323afbf62dd70e95694c7a2b792"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2449b3da9921867bc32999c3b34ed6d5"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a2449b3da9921867bc32999c3b34ed6d5">CreateGenericNode</a> (const <a class="el" href="class_p_m_string.html">PMString</a> &amp;nodeName, const <a class="el" href="class_wide_string.html">PreflightRuleID</a> &amp;ruleID) const =0</td></tr><tr class="separator:a2449b3da9921867bc32999c3b34ed6d5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6878507498c236d28bcf234909634448"><td align="right" class="memItemLeft" valign="top">virtual <br class="typebreak" /> IPreflightAggregatedResults::NodeID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#a6878507498c236d28bcf234909634448">AddResultsNode</a> (<a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a> *iResults, IPreflightAggregatedResults::NodeID parentID, <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a> *iInfo) const =0</td></tr><tr class="separator:a6878507498c236d28bcf234909634448"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afdc7f06115805b13e8f8472f066d0b66"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_preflight_aggregated_results_utils.html#afdc7f06115805b13e8f8472f066d0b66">AddProxyCriteriaAndNodes</a> (<a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a> *iResults, IPreflightAggregatedResults::NodeID parentID, const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *iProxyTable, const <a class="el" href="class_p_m_string.html">PMString</a> &amp;criteriaName, const <a class="el" href="class_wide_string.html">PreflightRuleID</a> &amp;ruleID) const =0</td></tr><tr class="separator:afdc7f06115805b13e8f8472f066d0b66"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>Utilities that rules use to create aggregated results. These are normally called from <a class="el" href="class_i_preflight_rule_visitor.html#aeadf72bc09c5f9ea6de3079f181bfba8">IPreflightRuleVisitor::AggregateResults()</a> but may be appropriate in some other cases too.<dl class="section see"><dt>See Also<dd><a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a><dd><a class="el" href="class_i_preflight_rule_visitor.html">IPreflightRuleVisitor</a></dl></div><h2 class="groupheader">Member Enumeration Documentation</h2><a class="anchor" id="a21009448ca2251e2bb98d8cb52b9ade4"></a><div class="memitem"><div class="memproto"><table class="memname"><tr><td class="memname">anonymous enum</td></tr></table></div><div class="memdoc"><p>Flags for ApplyAllStandardAggregations et al. <table class="fieldtable"><tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a21009448ca2251e2bb98d8cb52b9ade4a40c475944d1421b12a5433eb9f3fef5c"></a>kAggregateDifferentSubparts</em>&nbsp;</td><td class="fielddoc"><p>Aggregate records with the same object, but different subparts, together. Without this flag, different subparts are kept as separate records. Note that with this flag set, if you have a plurality of values and subparts, after aggregation you won&#39;t know which subparts contributed which values, if that&#39;s important to you. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a21009448ca2251e2bb98d8cb52b9ade4a359ffdf288477d5a2437c7fb70341f38"></a>kAggregateTextRangesWithDifferentValues</em>&nbsp;</td><td class="fielddoc"><p>Applies to ApplyAllStandardAggregations and AggregateContiguousTextRanges. Normally text ranges are only aggregated if they have the same criteria, values, subparts, and aux strings. Passing this flag eliminates values as a distinguishing factor. Of course, values will be combined. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a21009448ca2251e2bb98d8cb52b9ade4a5eccd53a8bba4181b34377fbec7ac78c"></a>kAggregateCellsWithDifferentValues</em>&nbsp;</td><td class="fielddoc"><p>Applies to ApplyAllStandardAggregations and AggregateContiguousCells. Normally cells are only aggregated if they have the same criteria, values, subparts, and aux strings. Passing this flag eliminates values as a distinguishing factor. Of course, values will be combined. </td></tr><tr><td class="fieldname"><em><a class="anchor" id="a21009448ca2251e2bb98d8cb52b9ade4abcd9d206edd2beaa8f10b232bd2fd6ee"></a>kDoNotAggregateSingluarValueSubparts</em>&nbsp;</td><td class="fielddoc"><p>Applies to ApplyAllStandardAggregations. Normally at the end of the aggregation process a final pass is made that looks for different subparts but with the same value. For example you might have a stroke and fill that share the same value (eg colorspace). In these cases the final pass merges the two records together to form a single record with a plurality of subpart but single value.<p>By setting this flag you retard the final pass check. </td></tr></table></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a158b059630da48022bbdfac702327151"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual IPreflightAggregatedResults::NodeID IPreflightAggregatedResultsUtils::AddCriteriaNode </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a> *&nbsp;</td><td class="paramname"><em>iResults</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">IPreflightAggregatedResults::NodeID&nbsp;</td><td class="paramname"><em>parentID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>nodeText</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_wide_string.html">PreflightRuleID</a> &amp;&nbsp;</td><td class="paramname"><em>ruleID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates and adds a criteria node, which is just a heading corresponding to the rule or criteria. This node does<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iResults</td><td>IN The results tree pointer. </td></tr><tr><td class="paramname">parentID</td><td>IN The node under which you want to add the new node. </td></tr><tr><td class="paramname">nodeText</td><td>IN The name of the node (appears in the tree). </td></tr><tr><td class="paramname">ruleID</td><td>IN The rule ID to assign to the criteria node. This is needed for node-ordering purposes. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The ID of the newly created node, or 0 on failure. </dl></div></div><a class="anchor" id="afdc7f06115805b13e8f8472f066d0b66"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightAggregatedResultsUtils::AddProxyCriteriaAndNodes </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a> *&nbsp;</td><td class="paramname"><em>iResults</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">IPreflightAggregatedResults::NodeID&nbsp;</td><td class="paramname"><em>parentID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iProxyTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>criteriaName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_wide_string.html">PreflightRuleID</a> &amp;&nbsp;</td><td class="paramname"><em>ruleID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Adds a proxy criteria and proxy nodes. If your rule visits artwork but finds that a proxy is being drawn instead of the placed content, and wants to report it as a proxy violation, you can use this utility to auto-build the generic node and children.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iResults</td><td>IN The results tree to which you want to add the nodes. </td></tr><tr><td class="paramname">parentID</td><td>IN The node that the new nodes should be a child of. </td></tr><tr><td class="paramname">iProxyTable</td><td>IN The table of proxies, typically created via CreateTablesByCriteria or CreateSubTableByCriteria, using kPreflightRC_GraphicProxy as the parameter. </td></tr><tr><td class="paramname">criteriaName</td><td>IN The text to use for the generic node under which the individual proxy nodes are listed. </td></tr><tr><td class="paramname">ruleID</td><td>IN The rule ID to assign to the criteria node. This is needed for node-ordering purposes. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The new Node ID in the tree. </dl></div></div><a class="anchor" id="a6878507498c236d28bcf234909634448"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual IPreflightAggregatedResults::NodeID IPreflightAggregatedResultsUtils::AddResultsNode </td><td>(</td><td class="paramtype"><a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a> *&nbsp;</td><td class="paramname"><em>iResults</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">IPreflightAggregatedResults::NodeID&nbsp;</td><td class="paramname"><em>parentID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a> *&nbsp;</td><td class="paramname"><em>iInfo</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Adds a result node to the aggregated results tree. For now this is simply a wrapper around iResults-&gt;AddNode() but in the future we may add some additional verification or utility, so in general you should work through this API.<p>Note that within the parent, the children are auto-ordered according to their sort values.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iResults</td><td>IN The results tree to which you want to add the node. </td></tr><tr><td class="paramname">parentID</td><td>IN The node that the new node should be a child of. </td></tr><tr><td class="paramname">iInfo</td><td>IN The node info pointer. The results tree addrefs this and holds onto it until the tree is destroyed. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The new Node ID in the tree. </dl></div></div><a class="anchor" id="a88a270f99bb5fce11a5644f999e49a0c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::AggregateContiguousCells </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>horizontally</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>aggregationFlags</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is one of the methods called from ApplyAllStandardAggregations. It finds table cells that are contiguous either horizontally or vertically, AND have the same criteria, values, aux strings, and subparts. If kAggregateCellsWithDifferentValues is passed, values are not considered for aggregation purposes.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iTable</td><td>IN The table to aggregate. </td></tr><tr><td class="paramname">horizontally</td><td>IN If true, aggregates ranges together that share the same rows and are contiguous in columns. If false, aggregates ranges together that share the same columns and are contiguous in rows. </td></tr><tr><td class="paramname">aggregationFlags</td><td>IN Flags; only kAggregateCellsWithDifferentValues applies here. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted aggregated table (the original table is unaffected). Note that if no aggregations occurred, this will be the same as iTable (but still refcounted). </dl></div></div><a class="anchor" id="acbc785d8e45cb2a0f2937c8fcadbbf46"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::AggregateContiguousTextRanges </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>aggregationFlags</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is one of the methods called from ApplyAllStandardAggregations. It finds text runs and ranges that are contiguous and have the same criteria, values, aux strings, and subparts. If kAggregateTextRangesWithDifferentValues is passed, values are not considered for aggregation purposes.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iTable</td><td>IN The table to aggregate. </td></tr><tr><td class="paramname">aggregationFlags</td><td>IN Flags; only kAggregateTextRangesWithDifferentValues applies here. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted aggregated table (the original table is unaffected). Note that if no aggregations occurred, this will be the same as iTable (but still refcounted). </dl></div></div><a class="anchor" id="a42c430ab621ff14b3ef1de5617084c8e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::AggregateDifferentSubpartsSameEverythingElse </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>aggregationFlags</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is one of the methods called from ApplyAllStandardAggregations.<p>It aggregates together all records which differ only in subparts. This is to allow for neater presentation of results when all subparts otherwise share the same failure cases.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iTable</td><td>IN The table to aggregate. </td></tr><tr><td class="paramname">aggregationFlags</td><td>IN Flags. None apply here but leaving for future expansion. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted aggregated table (the original table is unaffected). Note that if no aggregations occurred, this will be the same as iTable (but still refcounted). </dl></div></div><a class="anchor" id="a8d7696576fb3ce0b31e32177e3040853"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::AggregateMarkingOperationsToUsefulObjects </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="paramname"><em>iProcess</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>aggregationFlags</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This is one of the methods called from ApplyAllStandardAggregations. It &quot;uplevels&quot; all marking operation records into their related higher-level selectable objects, namely page items, text runs, and table cells. The subpart for these upleveled entries will be any known subpart (eg kPreflightOSP_NativeStroke).<p>This method will combine unlike values together but will not by default combine unlike subparts. Passing kAggregateDifferentSubparts will allow subpart aggregation but then you won&#39;t be able to tell which subpart a given value came from if there is a plurality of both.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProcess</td><td>IN The process; required in order to walk the process nodes to find the parents of marking operations. </td></tr><tr><td class="paramname">iTable</td><td>IN The table to aggregate. </td></tr><tr><td class="paramname">aggregationFlags</td><td>IN Flags; only kAggregateDifferentSubparts applies here. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted aggregated table (the original table is unaffected). Note that if no aggregations occurred, this will be the same as iTable (but still refcounted). </dl></div></div><a class="anchor" id="ac9365c06e0e7b9e1b6a00c3aa95ff14f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::ApplyAllStandardAggregations </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="paramname"><em>iProcess</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>aggregationFlags</em> = <code>0</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Applies &quot;standard&quot; aggregations and consolidations for a given table. In general the results you get from a preflight visit can be large especially when considering objects like text runs. This method consolidates (aggregates) entries that share common traits, like contiguous text runs with the same criteria and artwork in placed content.<p>Typically this is called immediately after CreateTableFromNodes, but not necessarily. In some cases you may wish to do your own prefiltering into tables and then call this method to avoid aggregation together of entries you do <em>not</em> want to be autogrouped. In general, after calling this method, you will not have process node information (if the nodes have been aggregated there is no longer one unique value), and values and subparts may have been aggregated together.<p>(More explanation to follow.)<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProcess</td><td>IN The process. This is required in order to deal with artwork and other entities where we need to look at the result node hierarchy. </td></tr><tr><td class="paramname">iTable</td><td></td></tr></table></dl></div></div><a class="anchor" id="a40b0bdfc9caf2c157db79b56f52a4da0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_aggregated_results.html">IPreflightAggregatedResults</a>* IPreflightAggregatedResultsUtils::CreateAggregatedResults </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Create an empty preflight aggregated results tree.<dl class="section return"><dt>Returns<dd>A refcounted results tree. </dl></div></div><a class="anchor" id="afe334323afbf62dd70e95694c7a2b792"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a>* IPreflightAggregatedResultsUtils::CreateCriteriaAndViolationNode </td><td>(</td><td class="paramtype">const <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;&nbsp;</td><td class="paramname"><em>objID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>nodeName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_wide_string.html">PreflightRuleID</a> &amp;&nbsp;</td><td class="paramname"><em>ruleID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates a node that is both criteria AND violation. This is used when a rule can have only a single violation node, so we combine criteria and violation together.<p>This does not add the node to the tree. To do that use <a class="el" href="class_i_preflight_aggregated_results_utils.html#a6878507498c236d28bcf234909634448">AddResultsNode()</a> where you can specify the parent.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">objID</td><td>IN The object that represents the violation (typically the document). </td></tr><tr><td class="paramname">nodeName</td><td>IN The name of the node (criteria). </td></tr><tr><td class="paramname">ruleID</td><td>IN The rule ID to assign to the criteria node. This is needed for node-ordering purposes. </td></tr></table></dl></div></div><a class="anchor" id="a2449b3da9921867bc32999c3b34ed6d5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a>* IPreflightAggregatedResultsUtils::CreateGenericNode </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="paramname"><em>nodeName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_wide_string.html">PreflightRuleID</a> &amp;&nbsp;</td><td class="paramname"><em>ruleID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates a generic (just a name) node. This node has no object by default, just a name; so typically it&#39;s used for some kind of grouping.<p>Note that this creates the record but doesn&#39;t add it to the tree. When you&#39;re done setting it up, call <a class="el" href="class_i_preflight_aggregated_results_utils.html#a6878507498c236d28bcf234909634448">AddResultsNode()</a>.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">nodeName</td><td>IN The name of the node (shown in the tree). </td></tr><tr><td class="paramname">ruleID</td><td>IN The rule ID to assign to the node. This is needed for node-ordering purposes. If you know for sure this node will never compete for order, or the name is sufficient, you can pass PreflightRuleID(). Or you can pass PreflightRuleID() and then use IPreflightAggregatedResultData::SetRootSortValue() to have complete control. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted results node from which you can also get <a class="el" href="class_i_preflight_result_node_data.html">IPreflightResultNodeData</a>. </dl></div></div><a class="anchor" id="a63592effbfd678b0605f0968b78ea434"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a>* IPreflightAggregatedResultsUtils::CreatePreflightResultNodeInfo </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Create an empty preflight result node info. This is a <a class="el" href="classk_preflight_result_node_boss.html">kPreflightResultNodeBoss</a> so you can query for <a class="el" href="class_i_preflight_result_node_data.html">IPreflightResultNodeData</a> to fill in the details.<dl class="section return"><dt>Returns<dd>A refcounted <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a> interface. </dl></div></div><a class="anchor" id="a4afb13ddadcf4830b43d69188606db7e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_record.html">IPreflightResultRecord</a>* IPreflightAggregatedResultsUtils::CreatePreflightResultRecord </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Create an empty preflight results record. You&#39;ll need to fill in all the details. This isn&#39;t typically done except private to the utilities, but there&#39;s no reason you can&#39;t create your own.<dl class="section return"><dt>Returns<dd>A refcounted record. </dl></div></div><a class="anchor" id="a32a23aaeaabcd937ef7e68136bf81869"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::CreatePreflightResultRecordTable </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Create an empty preflight results record table. This isn&#39;t typically done except private to the utilities, but there&#39;s no reason you can&#39;t create your own and add records to it.<dl class="section return"><dt>Returns<dd>A refcounted record table interface. </dl></div></div><a class="anchor" id="a27917e48beabda7449f3c41081d0662d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::CreateSubTable </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iSrcTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_k2_vector.html">VectorOfIndices</a> &amp;&nbsp;</td><td class="paramname"><em>indices</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Builds a second table that consists of the specified indices from the first table. This method is pretty fast because it&#39;s only managing refcounts on the records, not actually copying their data.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iSrcTable</td><td>IN The table from which you want to copy records. </td></tr><tr><td class="paramname">indices</td><td>IN The indices from the table you want to copy. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted table, or nil if indices is empty or an error occurs. </dl></div></div><a class="anchor" id="a82eda00f607b46ed463bd042d83cd218"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::CreateSubTableByCriteria </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iSrc</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">ClassID</a>&nbsp;</td><td class="paramname"><em>criteriaID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool&nbsp;</td><td class="paramname"><em>invertCriteria</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Builds a second table by putting in it only records with a particular criteria. This method is pretty fast because it&#39;s only managing refcounts on the records, not actually copying their data.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">invertCriteria</td><td>IN If true, invert the selection; ie put in only entries whose criteria is NOT criteriaID. </td></tr></table></dl></div></div><a class="anchor" id="a5ef17a81bfe87009fdc7dc474a258f50"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a>* IPreflightAggregatedResultsUtils::CreateTableFromNodes </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="paramname"><em>iProcess</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_preflight_process.html#a5dac1140d0305b6b1641facb80db1c91">IPreflightProcess::NodeIDVector</a> &amp;&nbsp;</td><td class="paramname"><em>resultNodes</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a set of result nodes from a process, create a Result Record table. This is usually the starting point for rule result aggregation.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProcess</td><td>IN The process. </td></tr><tr><td class="paramname">resultsNodes</td><td>IN The vector of result node IDs. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted result record table. Will be nil if result node vector is empty or some kind of error occurs. </dl></div></div><a class="anchor" id="a1b3e96d1de20281f6fe7a1f55b35d263"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightAggregatedResultsUtils::CreateTablesByAuxString </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iSrcTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">VectorOfTables</a> &amp;&nbsp;</td><td class="paramname"><em>tables</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Builds a set of derivative tables corresponding to unique values of aux string. This is useful if you want to give parent-child results where the parents are unique aux strings. Eg if you&#39;re presenting results grouped by font name, you can put the font name in the aux string when visiting nodes then use this method to build aggregated results accordingly.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iSrcTable</td><td>IN The source table from which you want to sort records. </td></tr><tr><td class="paramname">tables</td><td>OUT Receives the array of tables, where each table corresponds to all records from iSrcTable with the same aux string. </td></tr></table></dl></div></div><a class="anchor" id="ac38588875ebf81b474a6f7ef7744a378"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightAggregatedResultsUtils::CreateTablesByCriteria </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iSrcTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">VectorOfTables</a> &amp;&nbsp;</td><td class="paramname"><em>tables</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Builds a set of derivative tables corresponding to unique values of criteria. This is useful if you want to give parent-child results where the parents are unique criteria. This is typically done when you have numerous criteria and want to share a common formatting subroutine.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iSrcTable</td><td>IN The source table from which you want to sort records. </td></tr><tr><td class="paramname">tables</td><td>OUT Receives the array of tables, where each table corresponds to all records from iSrcTable with the same criteria. </td></tr></table></dl></div></div><a class="anchor" id="aae98b2e7ee4da2061c28d25c04e9a761"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IPreflightAggregatedResultsUtils::CreateTablesByObject </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record_table.html">IPreflightResultRecordTable</a> *&nbsp;</td><td class="paramname"><em>iSrcTable</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">VectorOfTables</a> &amp;&nbsp;</td><td class="paramname"><em>tables</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Builds a set of derivative tables corresponding to unique object IDs. This is commonly used if you want to guarantee a single node for each object (and if there are multiple violations per object you want to put that information in the info strings as concatenated results).<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iSrcTable</td><td>IN The source table from which you want to sort records. </td></tr><tr><td class="paramname">tables</td><td>OUT Receives the array of tables, where each table corresponds to all records from iSrcTable with the same object ID. </td></tr></table></dl></div></div><a class="anchor" id="accf549e1066cc28f030912db8f77d701"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_preflight_result_node_info.html">IPreflightResultNodeInfo</a>* IPreflightAggregatedResultsUtils::CreateViolationNode </td><td>(</td><td class="paramtype">const <a class="el" href="class_preflight_object_i_d.html">PreflightObjectID</a> &amp;&nbsp;</td><td class="paramname"><em>objID</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Creates a node corresponding to a violating object. The name of the node is automatically generated based on the object, as are the automatic selection capabilities. You can fill in explanatory text by querying <a class="el" href="class_i_preflight_result_node_data.html">IPreflightResultNodeData</a> and adding in additional strings.<p>This does not add the node to the tree. To do that use <a class="el" href="class_i_preflight_aggregated_results_utils.html#a6878507498c236d28bcf234909634448">AddResultsNode()</a> where you can specify the parent.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">objID</td><td>IN The object to use for the node. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A refcounted node. </dl></div></div><a class="anchor" id="ac721da752aa8df89808af46030061a51"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightAggregatedResultsUtils::FormatAsInteger </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Formats the value as an integer. Should generally be used for actual integer values. Will round to the nearest integer. Result is a non-translatable string. </div></div><a class="anchor" id="aea5f66a15a669939e7eda4d82787bf12"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightAggregatedResultsUtils::FormatLineMeasure </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="paramname"><em>iProcess</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Formats the given value (in points) as a line width. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProcess</td><td>IN The process. This is required in order to get the document&#39;s unit of measure settings to use when formatting the given value. </td></tr><tr><td class="paramname">x</td><td>IN The value (in points) to format. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A string formatted as a line width. </dl></div></div><a class="anchor" id="ada7dca03ed8a74929fededf4a182b592"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightAggregatedResultsUtils::FormatResolution </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Formats the given value (in ppi) as a resolution. </div></div><a class="anchor" id="aa5dc298e7c60762b925d0470ab9c84d3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightAggregatedResultsUtils::FormatTextSizeMeasure </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="paramname"><em>iProcess</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Formats the given value (in ppi) as a text size. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProcess</td><td>IN The process. This is required in order to get the document&#39;s unit of measure settings to use when formatting the given value. </td></tr><tr><td class="paramname">x</td><td>IN The value (in ppi) to format. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A string formatted as a text size. </dl></div></div><a class="anchor" id="abcd41b798ea6fb58e7c9ebbf1c9e0e35"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightAggregatedResultsUtils::FormatXMeasure </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="paramname"><em>iProcess</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Formats the given value (in points) as an X measure. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProcess</td><td>IN The process. This is required in order to get the document&#39;s unit of measure settings to use when formatting the given value. </td></tr><tr><td class="paramname">x</td><td>IN The value (in points) to format. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A string formatted as an X measure. </dl></div></div><a class="anchor" id="a79f86af9310f6f196180393be571041a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a> IPreflightAggregatedResultsUtils::FormatYMeasure </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_process.html">IPreflightProcess</a> *&nbsp;</td><td class="paramname"><em>iProcess</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>y</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Formats the given value (in points) as a Y measure. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">iProcess</td><td>IN The process. This is required in order to get the document&#39;s unit of measure settings to use when formatting the given value. </td></tr><tr><td class="paramname">y</td><td>IN The value (in points) to format. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>A string formatted as a Y measure. </dl></div></div><a class="anchor" id="a6696df0962338c5b337f4fc7bd140ef9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool IPreflightAggregatedResultsUtils::IsPlacedContent </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_preflight_result_record.html">IPreflightResultRecord</a> *&nbsp;</td><td class="paramname"><em>iRec</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if the record corresponds to placed content (or child marks). </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_preflight_aggregated_results_utils.html">IPreflightAggregatedResultsUtils</a><li class="footer">Generated on Sat Sep 22 2018 10:54:24 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
