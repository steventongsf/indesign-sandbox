<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_text_runs</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_text_runs.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_text_runs-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITextRuns Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_text_runs_8h_source.html">ITextRuns.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ITextRuns:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_text_runs.png" usemap="#ITextRuns_map" /><map id="ITextRuns_map" name="ITextRuns_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:adad87ecf64b5d39d8a619bf4168791f9"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITEXTRUNS }</td></tr><tr class="separator:adad87ecf64b5d39d8a619bf4168791f9"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:ac6fd70254ed88443f24514d6e8893721"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_text_run.html">ITextRun</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#ac6fd70254ed88443f24514d6e8893721">QueryRunInterface</a> (const <a class="el" href="class_run_description.html">RunDescription</a> &amp;description)=0</td></tr><tr class="separator:ac6fd70254ed88443f24514d6e8893721"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a976b202d327bf7a8a64f2004e9bef259"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_run_description.html">RunDescription</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a976b202d327bf7a8a64f2004e9bef259">GetRun</a> (int32 at, int32 run)=0</td></tr><tr class="separator:a976b202d327bf7a8a64f2004e9bef259"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0d2fbc9f3f35c3c26be617268605f085"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_run_description.html">RunDescription</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a0d2fbc9f3f35c3c26be617268605f085">GetRun</a> (int32 storyIndex, int32 at, int32 run)=0</td></tr><tr class="separator:a0d2fbc9f3f35c3c26be617268605f085"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6de06960d137290c5ed4c1fd65af7f4a"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a6de06960d137290c5ed4c1fd65af7f4a">TextRunsContainedInLine</a> (int32 storyIndex, int32 lineIndex)=0</td></tr><tr class="separator:a6de06960d137290c5ed4c1fd65af7f4a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afd488b8fd359e465ab465f12af05adac"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#afd488b8fd359e465ab465f12af05adac">DrawRuns</a> (int32 at, <a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *gPort, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;clipRect, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;scrollCompensationValue, <a class="el" href="class_i_p_m_font.html">IPMFont</a> *displayFont, <a class="el" href="class_p_m_real.html">PMReal</a> displaySize, const <a class="el" href="class_line_description.html">LineDescription</a> &amp;description, bool16 topLineInDraw)=0</td></tr><tr class="separator:afd488b8fd359e465ab465f12af05adac"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad7a9e37e839d80f813a82b69e36f7aae"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#ad7a9e37e839d80f813a82b69e36f7aae">DrawRuns</a> (int32 storyIndex, int32 at, <a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *gPort, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;clipRect, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;scrollCompensationValue, <a class="el" href="class_i_p_m_font.html">IPMFont</a> *displayFont, <a class="el" href="class_p_m_real.html">PMReal</a> displaySize, const <a class="el" href="class_line_description.html">LineDescription</a> &amp;description, bool16 topLineInDraw)=0</td></tr><tr class="separator:ad7a9e37e839d80f813a82b69e36f7aae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6502ac266ef51e35186292ffd69ef158"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a6502ac266ef51e35186292ffd69ef158">CopyRuns</a> (<a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_run_description.html">RunDescription</a> &gt; *source, <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_run_description.html">RunDescription</a> &gt; *destination)=0</td></tr><tr class="separator:a6502ac266ef51e35186292ffd69ef158"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4482744bcfa5314fb6b75d3df1c59726"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a4482744bcfa5314fb6b75d3df1c59726">AppendRun</a> (<a class="el" href="class_line_description.html">LineDescription</a> &amp;line, <a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339">RunDescription::RunType</a> runType, TextIndex runStartOffset, TextIndex runEndOffset, <a class="el" href="class_u_i_d_ref.html">UIDRef</a> storyThreadRef, <a class="el" href="class_real_a_g_m_color.html">RealAGMColor</a> runColor=<a class="el" href="class_real_a_g_m_color.html">RealAGMColor</a>(1.0, 1.0, 1.0))=0</td></tr><tr class="separator:a4482744bcfa5314fb6b75d3df1c59726"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aafde2540bc82ce5d176409b41f259615"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#aafde2540bc82ce5d176409b41f259615">GetNumRuns</a> (int32 at)=0</td></tr><tr class="separator:aafde2540bc82ce5d176409b41f259615"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a403c525084ff93d691bf2fd52d27ed52"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a403c525084ff93d691bf2fd52d27ed52">GetNumRuns</a> (int32 storyIndex, int32 at)=0</td></tr><tr class="separator:a403c525084ff93d691bf2fd52d27ed52"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab2c7439537fa9214e1735808815bba73"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#ab2c7439537fa9214e1735808815bba73">CalculateRunRect</a> (int32 lineIndex, int32 runIndex)=0</td></tr><tr class="separator:ab2c7439537fa9214e1735808815bba73"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a40f170360daab1728058c324525f696b"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a40f170360daab1728058c324525f696b">FindIndexOfRunAtPoint</a> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;point, int32 *lineIndex)=0</td></tr><tr class="separator:a40f170360daab1728058c324525f696b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0228952ff4a67b35cae8cd06649f7ad7"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a0228952ff4a67b35cae8cd06649f7ad7">FindIndexOfRunAtPoint</a> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;point, int32 lineIndex)=0</td></tr><tr class="separator:a0228952ff4a67b35cae8cd06649f7ad7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1121670eef1448ee1bc16cd44ba63a05"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a1121670eef1448ee1bc16cd44ba63a05">GetLastRunIndex</a> (int32 lineIndex)=0</td></tr><tr class="separator:a1121670eef1448ee1bc16cd44ba63a05"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5ad765352d2838a2335c330f3c8ee7da"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a5ad765352d2838a2335c330f3c8ee7da">GetLastRunIndex</a> (int32 storyIndex, int32 lineIndex)=0</td></tr><tr class="separator:a5ad765352d2838a2335c330f3c8ee7da"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a719bc31ef7e07cc0b7d3b27a8bd5d5ea"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a719bc31ef7e07cc0b7d3b27a8bd5d5ea">ComputeRunWidth</a> (int32 lineIndex, const <a class="el" href="class_run_description.html">RunDescription</a> &amp;runDescription, int32 *runLength)=0</td></tr><tr class="separator:a719bc31ef7e07cc0b7d3b27a8bd5d5ea"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5b22304557c06032d6f3c606f039dfaf"><td align="right" class="memItemLeft" valign="top">virtual bool8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a5b22304557c06032d6f3c606f039dfaf">GetUseTextRuns</a> ()=0</td></tr><tr class="separator:a5b22304557c06032d6f3c606f039dfaf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afa14976c6b3dc031c5497521cf9316d1"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#afa14976c6b3dc031c5497521cf9316d1">GetLineStartOffsetAtRun</a> (int32 lineIndex, int32 runIndex)=0</td></tr><tr class="separator:afa14976c6b3dc031c5497521cf9316d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aabc9c492e085f5145333c5744bee5671"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#aabc9c492e085f5145333c5744bee5671">GetLineEndOffsetAtRun</a> (int32 lineIndex, int32 runIndex)=0</td></tr><tr class="separator:aabc9c492e085f5145333c5744bee5671"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab6f7acda58405a232626ac3fff731580"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#ab6f7acda58405a232626ac3fff731580">FindCharacterAtXPosition</a> (int32 atLineIndex, int32 atRunIndex, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;xPosition, int32 &amp;offsetIntoLine)=0</td></tr><tr class="separator:ab6f7acda58405a232626ac3fff731580"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac499942bbee0ce8a2bfa33706c8c188d"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#ac499942bbee0ce8a2bfa33706c8c188d">FindIndexOfRunAtTextModelOffset</a> (<a class="el" href="class_line_description.html">LineDescription</a> &amp;description, int32 atTextModelOffset)=0</td></tr><tr class="separator:ac499942bbee0ce8a2bfa33706c8c188d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abbdb0a1fdf7571f5c6c2b26ad9260d88"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#abbdb0a1fdf7571f5c6c2b26ad9260d88">FindIndexOfRunAtDisplayOffset</a> (TextIndex offset, int32 &amp;offsetIntoRun, bool16 bUsingEndOfLine=kFalse)=0</td></tr><tr class="separator:abbdb0a1fdf7571f5c6c2b26ad9260d88"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a175b4cffb867a6e6098fdb3913557bea"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a175b4cffb867a6e6098fdb3913557bea">GetNoteContent</a> (<a class="el" href="class_i_text_model.html">ITextModel</a> *model, TextIndex textStart, int32 &amp;textLength, <a class="el" href="class_wide_string.html">WideString</a> &amp;textContent, int32 startIndex=-1)=0</td></tr><tr class="separator:a175b4cffb867a6e6098fdb3913557bea"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a953aa24ed76b657597e12eec26223574"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a953aa24ed76b657597e12eec26223574">FindInitialRunStart</a> (int32 at, int32 runIndex, <a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339">RunDescription::RunType</a> type)=0</td></tr><tr class="separator:a953aa24ed76b657597e12eec26223574"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a357bde4bae3ea32e4e4e5d4fb1ce912d"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a357bde4bae3ea32e4e4e5d4fb1ce912d">FindInitialRunStart</a> (int32 storyIndex, int32 at, int32 runIndex, <a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339">RunDescription::RunType</a> type)=0</td></tr><tr class="separator:a357bde4bae3ea32e4e4e5d4fb1ce912d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a91ddc0acd3247d53165ed095ebe1a1"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_run_description.html">RunDescription</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a1a91ddc0acd3247d53165ed095ebe1a1">FindRunAtDisplayOffset</a> (TextIndex galleyDisplayOffset, int32 lineIndex, int32 *runIndex=nil)=0</td></tr><tr class="separator:a1a91ddc0acd3247d53165ed095ebe1a1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae72f312c3d5bf7a7cfa8209927102d3a"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_run_description.html">RunDescription</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#ae72f312c3d5bf7a7cfa8209927102d3a">FindRunAtDisplayOffset</a> (int32 storyIndex, TextIndex galleyDisplayOffset, int32 lineIndex, int32 *runIndex=nil)=0</td></tr><tr class="separator:ae72f312c3d5bf7a7cfa8209927102d3a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a78f73be4202e2e22437fc7346c2e76e6"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a78f73be4202e2e22437fc7346c2e76e6">GetRunChunk</a> (<a class="el" href="class_i_text_model.html">ITextModel</a> *model, const <a class="el" href="class_run_description.html">RunDescription</a> &amp;description, TextIndex textStart, int32 textLength, <a class="el" href="class_wide_string.html">WideString</a> &amp;textContent, float *widths, bool16 showInvisibles, int32 bufferSize, IFontMgr::FontStyleBits &amp;fontStyle, <a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a> &amp;capMode, int32 lineIndex, int32 runIndex)=0</td></tr><tr class="separator:a78f73be4202e2e22437fc7346c2e76e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4fd93d1aca9c16232b09a23251ebf109"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a4fd93d1aca9c16232b09a23251ebf109">GetRunChunk</a> (int32 storyIndex, <a class="el" href="class_i_text_model.html">ITextModel</a> *model, const <a class="el" href="class_run_description.html">RunDescription</a> &amp;description, TextIndex textStart, int32 textLength, <a class="el" href="class_wide_string.html">WideString</a> &amp;textContent, float *widths, bool16 showInvisibles, int32 bufferSize, IFontMgr::FontStyleBits &amp;fontStyle, <a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a> &amp;capMode, int32 lineIndex, int32 runIndex)=0</td></tr><tr class="separator:a4fd93d1aca9c16232b09a23251ebf109"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1960e065c4693f2051b93474fbd216da"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a1960e065c4693f2051b93474fbd216da">GetRunChunk</a> (int32 storyIndex, <a class="el" href="class_i_text_model.html">ITextModel</a> *model, const <a class="el" href="class_run_description.html">RunDescription</a> &amp;description, TextIndex textStart, int32 textLength, float *widths, bool16 showInvisibles, int32 bufferSize, IFontMgr::FontStyleBits &amp;fontStyle, <a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a> &amp;capMode, int32 lineIndex, int32 runIndex)=0</td></tr><tr class="separator:a1960e065c4693f2051b93474fbd216da"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2295fcf4ad1a4b8713ecf8b224771a57"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a2295fcf4ad1a4b8713ecf8b224771a57">DrawRegularTextRun</a> (int32 at, <a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *gPort, <a class="el" href="class_i_p_m_font.html">IPMFont</a> *displayFont, <a class="el" href="class_p_m_real.html">PMReal</a> displaySize, int32 runIndex, const <a class="el" href="class_real_a_g_m_color.html">RealAGMColor</a> &amp;textColor, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;drawPt, bool16 showInvisibles)=0</td></tr><tr class="separator:a2295fcf4ad1a4b8713ecf8b224771a57"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa13987c7eb252dc256ae373037bbc622"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#aa13987c7eb252dc256ae373037bbc622">FindIndexOfRunAtPoint</a> (int32 storyIndex, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;point, int32 *lineIndex)=0</td></tr><tr class="separator:aa13987c7eb252dc256ae373037bbc622"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3e9a4a2a3b73fba656be7090a83fe644"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a3e9a4a2a3b73fba656be7090a83fe644">FindIndexOfRunAtPoint</a> (int32 storyIndex, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;point, int32 lineIndex)=0</td></tr><tr class="separator:a3e9a4a2a3b73fba656be7090a83fe644"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a95f0fc7dc344ecc2391c740132478df3"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a95f0fc7dc344ecc2391c740132478df3">DrawLineOverlaps</a> (int32 at, <a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *gPort, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;scrollCompensationValue, const <a class="el" href="class_line_description.html">LineDescription</a> &amp;description, bool16 topLineInDraw, int32 storyIndex)=0</td></tr><tr class="separator:a95f0fc7dc344ecc2391c740132478df3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a71a3fe9660f9d25c11e3cc28850c6f69"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_runs.html#a71a3fe9660f9d25c11e3cc28850c6f69">GetExtendedRunSpanInformation</a> (int32 storyIndex, const <a class="el" href="class_run_location.html">RunLocation</a> &amp;runIndex, <a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339">RunDescription::RunType</a> type, <a class="el" href="class_range_data.html">RangeData</a> *displayIndexRange, <a class="el" href="class_run_location.html">RunLocation</a> *extendedRunStart, <a class="el" href="class_run_location.html">RunLocation</a> *extendedRunEnd)=0</td></tr><tr class="separator:a71a3fe9660f9d25c11e3cc28850c6f69"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>The TextRuns interface has methods related to the handling of story/galley text runs. Note that when talking about textruns with regard to this interface these are not character style runs but rather. Runs of a certain text display type like a inline note text run footnote text run or regular text run. Each line displayed in story and galley may contain text runs. It&#39;s possible also that a line may contain no text runs. This would be the case for divider lines although this may change. </div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a4482744bcfa5314fb6b75d3df1c59726"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextRuns::AppendRun </td><td>(</td><td class="paramtype"><a class="el" href="class_line_description.html">LineDescription</a> &amp;&nbsp;</td><td class="paramname"><em>line</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339">RunDescription::RunType</a>&nbsp;</td><td class="paramname"><em>runType</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>runStartOffset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>runEndOffset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_u_i_d_ref.html">UIDRef</a>&nbsp;</td><td class="paramname"><em>storyThreadRef</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_real_a_g_m_color.html">RealAGMColor</a>&nbsp;</td><td class="paramname"><em>runColor</em> = <code><a class="el" href="class_real_a_g_m_color.html">RealAGMColor</a>(1.0,&nbsp;1.0,&nbsp;1.0)</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>depricated do not use <dl class="section return"><dt>Returns<dd>void </dl></div></div><a class="anchor" id="ab2c7439537fa9214e1735808815bba73"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> ITextRuns::CalculateRunRect </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Gets line owned rectangular screen area for a given run <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">lineIndex</td><td>index of line to get rect of </td></tr><tr><td class="paramname">runIndex</td><td>index of run to get rect of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>rectangle describing draw bounds of the run </dl></div></div><a class="anchor" id="a719bc31ef7e07cc0b7d3b27a8bd5d5ea"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextRuns::ComputeRunWidth </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_run_description.html">RunDescription</a> &amp;&nbsp;</td><td class="paramname"><em>runDescription</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>runLength</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>depricated </div></div><a class="anchor" id="a6502ac266ef51e35186292ffd69ef158"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextRuns::CopyRuns </td><td>(</td><td class="paramtype"><a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_run_description.html">RunDescription</a> &gt; *&nbsp;</td><td class="paramname"><em>source</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_run_description.html">RunDescription</a> &gt; *&nbsp;</td><td class="paramname"><em>destination</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Used to copy run information from one <a class="el" href="class_line_description.html">LineDescription</a> to another. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">source</td><td>copy run information from this </td></tr><tr><td class="paramname">source</td><td>item to make a copy of </td></tr><tr><td class="paramname">destination</td><td>item to copy to </td></tr></table></dl><dl class="section return"><dt>Returns<dd>void </dl></div></div><a class="anchor" id="a95f0fc7dc344ecc2391c740132478df3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextRuns::DrawLineOverlaps </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *&nbsp;</td><td class="paramname"><em>gPort</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>scrollCompensationValue</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_line_description.html">LineDescription</a> &amp;&nbsp;</td><td class="paramname"><em>description</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>topLineInDraw</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use for handling lines that draw over other lines. Called by DrawRun(). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to draw overlap portion of </td></tr><tr><td class="paramname">gPort</td><td>port to draw in </td></tr><tr><td class="paramname">scrollCompensationValue</td><td>vertical scroll compensation value </td></tr><tr><td class="paramname">description</td><td>description of line to draw overlap portion of </td></tr><tr><td class="paramname">topLineInDraw</td><td>optimiztion kTrue if this is the first line drawn in a inval </td></tr><tr><td class="paramname">storyIndex</td><td>index of story to draw overlaps in. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>void. </dl></div></div><a class="anchor" id="a2295fcf4ad1a4b8713ecf8b224771a57"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextRuns::DrawRegularTextRun </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *&nbsp;</td><td class="paramname"><em>gPort</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>displayFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>displaySize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_real_a_g_m_color.html">RealAGMColor</a> &amp;&nbsp;</td><td class="paramname"><em>textColor</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>drawPt</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>showInvisibles</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draw a regular text run. That is a run that is part of the primary text model. Called by <a class="el" href="class_i_text_runs.html#afd488b8fd359e465ab465f12af05adac">DrawRuns()</a> and some instances of DrawRun() <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index line to draw text of </td></tr><tr><td class="paramname">gPort</td><td>graphics port to draw text in </td></tr><tr><td class="paramname">displayFont</td><td>font to draw in </td></tr><tr><td class="paramname">displaySize</td><td>size of text to draw </td></tr><tr><td class="paramname">runIndex</td><td>index of the run to draw. </td></tr><tr><td class="paramname">textColor</td><td>color to draw the text </td></tr><tr><td class="paramname">drawPt</td><td>where to draw the text. </td></tr><tr><td class="paramname">showInvisibles</td><td>kTrue if want hidden character information to be filled out. See <a class="el" href="class_i_story_service.html">IStoryService</a>. </td></tr><tr><td class="paramname">showInvisibles</td><td>should it show the invisible character symbols </td></tr></table></dl><dl class="section return"><dt>Returns<dd>returns width of text drawn </dl></div></div><a class="anchor" id="afd488b8fd359e465ab465f12af05adac"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextRuns::DrawRuns </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *&nbsp;</td><td class="paramname"><em>gPort</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>clipRect</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>scrollCompensationValue</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>displayFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>displaySize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_line_description.html">LineDescription</a> &amp;&nbsp;</td><td class="paramname"><em>description</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>topLineInDraw</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Used to draw all of the text runs in a line <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index line to draw runs of </td></tr><tr><td class="paramname">gPort</td><td><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> to draw runs in </td></tr><tr><td class="paramname">clipRect</td><td>area of the graphics port we are allowed to draw in </td></tr><tr><td class="paramname">scrollCompensationValue</td><td>amount scrolled vertically in the view </td></tr><tr><td class="paramname">displayFont</td><td>instance of display font we are using to draw the text may in fact not be used if this font is not appropriate for a run </td></tr><tr><td class="paramname">displaySize</td><td>size of the display font we use to draw text. </td></tr><tr><td class="paramname">description</td><td>description of the line. DrawRuns will draw the runs contained in this line description </td></tr><tr><td class="paramname">topLineInDraw</td><td>a flag to indicate whether this is the first line in this draw sequence (not usually important it is used as an optimization) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>void </dl></div></div><a class="anchor" id="ad7a9e37e839d80f813a82b69e36f7aae"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextRuns::DrawRuns </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *&nbsp;</td><td class="paramname"><em>gPort</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>clipRect</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>scrollCompensationValue</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>displayFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>displaySize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_line_description.html">LineDescription</a> &amp;&nbsp;</td><td class="paramname"><em>description</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>topLineInDraw</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Used to draw all of the text runs in a line <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to draw runs for </td></tr><tr><td class="paramname">at</td><td>index line to draw runs of </td></tr><tr><td class="paramname">gPort</td><td><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> to draw runs in </td></tr><tr><td class="paramname">clipRect</td><td>area of the graphics port we are allowed to draw in </td></tr><tr><td class="paramname">scrollCompensationValue</td><td>amount scrolled vertically in the view </td></tr><tr><td class="paramname">displayFont</td><td>instance of display font we are using to draw the text may in fact not be used if this font is not appropriate for a run </td></tr><tr><td class="paramname">displaySize</td><td>size of the display font we use to draw text. </td></tr><tr><td class="paramname">description</td><td>description of the line. DrawRuns will draw the runs contained in this line description </td></tr><tr><td class="paramname">topLineInDraw</td><td>a flag to indicate whether this is the first line in this draw sequence (not usually important it is used as an optimization) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>void </dl></div></div><a class="anchor" id="ab6f7acda58405a232626ac3fff731580"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextRuns::FindCharacterAtXPosition </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>atLineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>atRunIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>xPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>offsetIntoLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This method assumes that the caller has already determined that a Point is within the run specified by the parameter atLineIndex/atRunIndex and is now asking which character within the run has been hit based on xPosition. The routine will alway return a valid result. xPosition starts at left point of container panel <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">atLineIndex</td><td>index of line to character in </td></tr><tr><td class="paramname">atRunIndex</td><td>index of run to get character in </td></tr><tr><td class="paramname">xPosition</td><td>position of interest </td></tr><tr><td class="paramname">offsetIntoLine</td><td>index into line of the character at the xPosition </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if found a valid character at given xPosition </dl></div></div><a class="anchor" id="abbdb0a1fdf7571f5c6c2b26ad9260d88"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::FindIndexOfRunAtDisplayOffset </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>offset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>offsetIntoRun</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>bUsingEndOfLine</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a galley display index find the run. A galley display index includes runs that are outside of the primary text thread. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">offset</td><td>text display index to find run for </td></tr><tr><td class="paramname">offsetIntoRun</td><td>returns offset into run for the given text display index </td></tr><tr><td class="paramname">bUsingEndOfLine</td><td>if kFalse skip to start of next line if text index is at end of a line </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of run at the display text index </dl></div></div><a class="anchor" id="a40f170360daab1728058c324525f696b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::FindIndexOfRunAtPoint </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>point</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>lineIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the index of a run at a given point on the screen <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">point</td><td>where on the screen is of interest. Given in terms of 0 being first line in view. </td></tr><tr><td class="paramname">lineIndex</td><td>filled in by the routine this is the index of the line the returned run is in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the run (may be -1 if none is found). </dl></div></div><a class="anchor" id="a0228952ff4a67b35cae8cd06649f7ad7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::FindIndexOfRunAtPoint </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>point</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Same as other FindIndexOfRunAtPoint but if you already know the line that was hit use this one because it is faster. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">point</td><td>where on the screen is of interest. Given in terms of 0 being first line in view. </td></tr><tr><td class="paramname">lineIndex</td><td>of the line which was hit. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the run (may be -1 if none is found). </dl></div></div><a class="anchor" id="aa13987c7eb252dc256ae373037bbc622"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::FindIndexOfRunAtPoint </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>point</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>lineIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the index of a run at a given point on the screen <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to use to find point in. </td></tr><tr><td class="paramname">point</td><td>where on the screen is of interest. Given in terms of 0 being first line in view. </td></tr><tr><td class="paramname">lineIndex</td><td>filled in by the routine this is the index of the line the returned run is in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the run (may be -1 if none is found). </dl></div></div><a class="anchor" id="a3e9a4a2a3b73fba656be7090a83fe644"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::FindIndexOfRunAtPoint </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>point</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Same as other FindIndexOfRunAtPoint but if you already know the line that was hit use this one because it is faster. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to use to find point in. </td></tr><tr><td class="paramname">point</td><td>where on the screen is of interest. Given in terms of 0 being first line in view. </td></tr><tr><td class="paramname">lineIndex</td><td>of the line which was hit. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the run (may be -1 if none is found). </dl></div></div><a class="anchor" id="ac499942bbee0ce8a2bfa33706c8c188d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::FindIndexOfRunAtTextModelOffset </td><td>(</td><td class="paramtype"><a class="el" href="class_line_description.html">LineDescription</a> &amp;&nbsp;</td><td class="paramname"><em>description</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>atTextModelOffset</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a text model index find the run. Only works for runs that are part of the primary thread. Use <a class="el" href="class_i_text_runs.html#abbdb0a1fdf7571f5c6c2b26ad9260d88">FindIndexOfRunAtDisplayOffset()</a> to find runs that contain external data (like notes, deleted text). <a class="el" href="class_i_text_runs.html#abbdb0a1fdf7571f5c6c2b26ad9260d88">FindIndexOfRunAtDisplayOffset()</a> is valid for regular text runs too. Mostly for internal use. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">description</td><td>of line this line will look in </td></tr><tr><td class="paramname">atTextModelOffset</td><td>text model index that the run will be found for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of run at the text index </dl></div></div><a class="anchor" id="a953aa24ed76b657597e12eec26223574"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextRuns::FindInitialRunStart </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339">RunDescription::RunType</a>&nbsp;</td><td class="paramname"><em>type</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find the first run display offset for a set of associated runs that span multiple lines. For instance, a note may span many lines and have many associated run this routine will find the line that the note starts in and get the display index of the first character in the note. Useful to find the starting galley display offset of a note or deleted text run that has been split across several lines. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to start searching for run start at </td></tr><tr><td class="paramname">runIndex</td><td>index of run with in line to start searching for run start display index at. </td></tr><tr><td class="paramname">type</td><td>type of run the run group belongs to </td></tr></table></dl><dl class="section return"><dt>Returns<dd>display index of the first run start that heads a run group. </dl></div></div><a class="anchor" id="a357bde4bae3ea32e4e4e5d4fb1ce912d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextRuns::FindInitialRunStart </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339">RunDescription::RunType</a>&nbsp;</td><td class="paramname"><em>type</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find the first run display offset for a set of associated runs that span multiple lines. For instance, a note may span many lines and have many associated run this routine will find the line that the note starts in and get the display index of the first character in the note. Useful to find the starting galley display offset of a note or deleted text run that has been split across several lines. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of line to start searching for run start at </td></tr><tr><td class="paramname">at</td><td>index of line to start searching for run start at </td></tr><tr><td class="paramname">runIndex</td><td>index of run with in line to start searching for run start display index at. </td></tr><tr><td class="paramname">type</td><td>type of run the run group belongs to </td></tr></table></dl><dl class="section return"><dt>Returns<dd>display index of the first run start that heads a run group. </dl></div></div><a class="anchor" id="a1a91ddc0acd3247d53165ed095ebe1a1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_run_description.html">RunDescription</a>* ITextRuns::FindRunAtDisplayOffset </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>galleyDisplayOffset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>runIndex</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find a run in the line that contains a galley display offset <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">galleyDisplayOffset</td><td>display index to search for </td></tr><tr><td class="paramname">lineIndex</td><td>line that we want to search within. </td></tr><tr><td class="paramname">runIndex</td><td>return the index of the run. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>return a discription of the run that is at a given display index. </dl></div></div><a class="anchor" id="ae72f312c3d5bf7a7cfa8209927102d3a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_run_description.html">RunDescription</a>* ITextRuns::FindRunAtDisplayOffset </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>galleyDisplayOffset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>runIndex</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find a run in the line that contains a galley display offset <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to search within. </td></tr><tr><td class="paramname">galleyDisplayOffset</td><td>display index to search for </td></tr><tr><td class="paramname">lineIndex</td><td>line that we want to search within. </td></tr><tr><td class="paramname">runIndex</td><td>return the index of the run. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>return a discription of the run that is at a given display index. </dl></div></div><a class="anchor" id="a71a3fe9660f9d25c11e3cc28850c6f69"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextRuns::GetExtendedRunSpanInformation </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_run_location.html">RunLocation</a> &amp;&nbsp;</td><td class="paramname"><em>runIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339">RunDescription::RunType</a>&nbsp;</td><td class="paramname"><em>type</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_range_data.html">RangeData</a> *&nbsp;</td><td class="paramname"><em>displayIndexRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_run_location.html">RunLocation</a> *&nbsp;</td><td class="paramname"><em>extendedRunStart</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_run_location.html">RunLocation</a> *&nbsp;</td><td class="paramname"><em>extendedRunEnd</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a starting run this routine will give back information on the extent of the whole block of associated runs. For example, a note may span many lines and consist of many individual runs this routine will give information on both where the note begins an ends and what the total text span of the run is in galley/story display indexes. This is useful to know when navigating through text in the order things are displayed rather than the order text is actually stored in the text moded. Return true if succesful and false otherwise <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>TextLines story index of the story we are interested in (see <a class="el" href="class_i_text_lines.html">ITextLines</a> interface) </td></tr><tr><td class="paramname">runIndex</td><td>The location of the start run to begin search at </td></tr><tr><td class="paramname">type</td><td>the type of the start run </td></tr><tr><td class="paramname">displayIndexRange</td><td>returns display index range of the total extended run </td></tr><tr><td class="paramname">extendedRunStart</td><td>returns the lineIndex and runIndex of the first run in the extended run </td></tr><tr><td class="paramname">extendedRunEnd</td><td>return the lineIndex and the runIndex of the last run in the extended run. </td></tr></table></dl></div></div><a class="anchor" id="a1121670eef1448ee1bc16cd44ba63a05"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::GetLastRunIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get index of the last run with in a line. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">lineIndex</td><td>to get run for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the run (may be -1 if none is found). </dl></div></div><a class="anchor" id="a5ad765352d2838a2335c330f3c8ee7da"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::GetLastRunIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get index of the last run with in a line. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get run of </td></tr><tr><td class="paramname">lineIndex</td><td>to get run for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the run (may be -1 if none is found). </dl></div></div><a class="anchor" id="aabc9c492e085f5145333c5744bee5671"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextRuns::GetLineEndOffsetAtRun </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the text index of the end of the line this run is in if this is an inlinenotetext run we return the thread start offset; otherwise, return the run&#39;s line start offset. Not recommended for external use <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">lineIndex</td><td>index of line to get end offset of </td></tr><tr><td class="paramname">runIndex</td><td>index of run to get end offset of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>return a text index of the end of the line associated with given run </dl></div></div><a class="anchor" id="afa14976c6b3dc031c5497521cf9316d1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextRuns::GetLineStartOffsetAtRun </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the text index of the start of line this run is in if this is an inlinenotetext run we return the thread start offset; otherwise, return the run&#39;s line start offset. Not recommended for external use <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">lineIndex</td><td>index of line to get start offset of </td></tr><tr><td class="paramname">runIndex</td><td>index of run to get start offset of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>return a text index of the start of the line associated with given run </dl></div></div><a class="anchor" id="a175b4cffb867a6e6098fdb3913557bea"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_ref.html">UIDRef</a> ITextRuns::GetNoteContent </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>textStart</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>textLength</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>textContent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>startIndex</em> = <code>-1</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the note text content at a given offset. It&#39;s better to use Note related routines in general to get information like this. This routine is not neccessarily efficient. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">model</td><td>the model to find note text in </td></tr><tr><td class="paramname">textStart</td><td>anchor position of the note text </td></tr><tr><td class="paramname">textLength</td><td>returned character length of note text at requested position </td></tr><tr><td class="paramname">textContent</td><td>returned note text characters at requested text position </td></tr><tr><td class="paramname">startIndex</td><td>offset into note text to start getting text at </td></tr></table></dl><dl class="section return"><dt>Returns<dd><a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the note text owned item </dl></div></div><a class="anchor" id="aafde2540bc82ce5d176409b41f259615"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::GetNumRuns </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Used to get text of a run when drawing. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to get text of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>number of runs in line </dl></div></div><a class="anchor" id="a403c525084ff93d691bf2fd52d27ed52"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::GetNumRuns </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get number of runs within a line <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get run information for </td></tr><tr><td class="paramname">at</td><td>index of line to get run information for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>number of runs within the line </dl></div></div><a class="anchor" id="a976b202d327bf7a8a64f2004e9bef259"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_run_description.html">RunDescription</a>&amp; ITextRuns::GetRun </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>run</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a <a class="el" href="class_run_description.html">RunDescription</a> for a given line and run index <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to get <a class="el" href="class_run_description.html">RunDescription</a> of </td></tr><tr><td class="paramname">run</td><td>index of run within line to get <a class="el" href="class_run_description.html">RunDescription</a> of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_run_description.html">RunDescription</a></dl></div></div><a class="anchor" id="a0d2fbc9f3f35c3c26be617268605f085"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_run_description.html">RunDescription</a>&amp; ITextRuns::GetRun </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>run</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a <a class="el" href="class_run_description.html">RunDescription</a> for a given story, line and run index <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get <a class="el" href="class_run_description.html">RunDescription</a> of </td></tr><tr><td class="paramname">at</td><td>index of line to get <a class="el" href="class_run_description.html">RunDescription</a> of </td></tr><tr><td class="paramname">run</td><td>index of run within line to get <a class="el" href="class_run_description.html">RunDescription</a> of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_run_description.html">RunDescription</a></dl></div></div><a class="anchor" id="a78f73be4202e2e22437fc7346c2e76e6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::GetRunChunk </td><td>(</td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_run_description.html">RunDescription</a> &amp;&nbsp;</td><td class="paramname"><em>description</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>textStart</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>textLength</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>textContent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">float *&nbsp;</td><td class="paramname"><em>widths</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>showInvisibles</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>bufferSize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">IFontMgr::FontStyleBits &amp;&nbsp;</td><td class="paramname"><em>fontStyle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a> &amp;&nbsp;</td><td class="paramname"><em>capMode</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This routine gets text in blocks of continuous font styles. Useful when you would like to measure text widths and for drawing. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">model</td><td>textmodel to get text for </td></tr><tr><td class="paramname">description</td><td>desciption of run to get the text of </td></tr><tr><td class="paramname">textStart</td><td>text index to start getting text at. </td></tr><tr><td class="paramname">textLength</td><td>length of text interested in getting maximum. </td></tr><tr><td class="paramname">textContent</td><td>text returned in this parameter. </td></tr><tr><td class="paramname">widths</td><td>an array of glyph widths is filled out by GetRunChunk (array is preallocated by caller). </td></tr><tr><td class="paramname">showInvisibles</td><td>kTrue if want hidden character information to be filled out. See <a class="el" href="class_i_story_service.html">IStoryService</a>. </td></tr><tr><td class="paramname">bufferSize</td><td>max number of characters that preallocated buffers will hold </td></tr><tr><td class="paramname">fontStyle</td><td>returns the font style that the text should draw in </td></tr><tr><td class="paramname">capMode</td><td>return the Capitize mode that the text would draw in </td></tr><tr><td class="paramname">lineIndex</td><td>index of the line to get text for </td></tr><tr><td class="paramname">runIndex</td><td>index of the run to get text for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>return number of characters actually returned </dl></div></div><a class="anchor" id="a4fd93d1aca9c16232b09a23251ebf109"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::GetRunChunk </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_run_description.html">RunDescription</a> &amp;&nbsp;</td><td class="paramname"><em>description</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>textStart</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>textLength</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_wide_string.html">WideString</a> &amp;&nbsp;</td><td class="paramname"><em>textContent</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">float *&nbsp;</td><td class="paramname"><em>widths</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>showInvisibles</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>bufferSize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">IFontMgr::FontStyleBits &amp;&nbsp;</td><td class="paramname"><em>fontStyle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a> &amp;&nbsp;</td><td class="paramname"><em>capMode</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This routine gets text in blocks of continuous font styles. Useful when you would like to measure text widths and for drawing. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get the text of </td></tr><tr><td class="paramname">model</td><td>textmodel to get text for </td></tr><tr><td class="paramname">description</td><td>desciption of run to get the text of </td></tr><tr><td class="paramname">textStart</td><td>text index to start getting text at. </td></tr><tr><td class="paramname">textLength</td><td>length of text interested in getting maximum. </td></tr><tr><td class="paramname">textContent</td><td>text returned in this parameter. </td></tr><tr><td class="paramname">widths</td><td>an array of glyph widths is filled out by GetRunChunk (array is preallocated by caller). </td></tr><tr><td class="paramname">showInvisibles</td><td>kTrue if want hidden character information to be filled out. See <a class="el" href="class_i_story_service.html">IStoryService</a>. </td></tr><tr><td class="paramname">bufferSize</td><td>max number of characters that preallocated buffers will hold </td></tr><tr><td class="paramname">fontStyle</td><td>returns the font style that the text should draw in </td></tr><tr><td class="paramname">capMode</td><td>return the Capitize mode that the text would draw in </td></tr><tr><td class="paramname">lineIndex</td><td>index of the line to get text for </td></tr><tr><td class="paramname">runIndex</td><td>index of the run to get text for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>return number of characters actually returned </dl></div></div><a class="anchor" id="a1960e065c4693f2051b93474fbd216da"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextRuns::GetRunChunk </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_text_model.html">ITextModel</a> *&nbsp;</td><td class="paramname"><em>model</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_run_description.html">RunDescription</a> &amp;&nbsp;</td><td class="paramname"><em>description</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>textStart</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>textLength</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">float *&nbsp;</td><td class="paramname"><em>widths</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>showInvisibles</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>bufferSize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">IFontMgr::FontStyleBits &amp;&nbsp;</td><td class="paramname"><em>fontStyle</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a> &amp;&nbsp;</td><td class="paramname"><em>capMode</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This routine gets text in blocks of continuous font styles. Useful when you would like to measure text widths and for drawing. This version does not get actual text just the glyph data. This is more efficient than the other two versions of this call because the glyph data is cached while the text unicode data is not. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get the text of </td></tr><tr><td class="paramname">model</td><td>textmodel to get text for </td></tr><tr><td class="paramname">description</td><td>desciption of run to get the text of </td></tr><tr><td class="paramname">textStart</td><td>text index to start getting text at. </td></tr><tr><td class="paramname">textLength</td><td>length of text interested in getting maximum. </td></tr><tr><td class="paramname">widths</td><td>an array of glyph widths is filled out by GetRunChunk (array is preallocated by caller). </td></tr><tr><td class="paramname">showInvisibles</td><td>kTrue if want hidden character information to be filled out. See <a class="el" href="class_i_story_service.html">IStoryService</a>. </td></tr><tr><td class="paramname">bufferSize</td><td>max number of characters that preallocated buffers will hold </td></tr><tr><td class="paramname">fontStyle</td><td>returns the font style that the text should draw in </td></tr><tr><td class="paramname">capMode</td><td>return the Capitize mode that the text would draw in </td></tr><tr><td class="paramname">lineIndex</td><td>index of the line to get text for </td></tr><tr><td class="paramname">runIndex</td><td>index of the run to get text for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>return number of characters actually returned </dl></div></div><a class="anchor" id="a5b22304557c06032d6f3c606f039dfaf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool8 ITextRuns::GetUseTextRuns </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns true if we are using runs for the view associated with this interface <dl class="section return"><dt>Returns<dd>kTrue if we are using runs </dl></div></div><a class="anchor" id="ac6fd70254ed88443f24514d6e8893721"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_text_run.html">ITextRun</a>* ITextRuns::QueryRunInterface </td><td>(</td><td class="paramtype">const <a class="el" href="class_run_description.html">RunDescription</a> &amp;&nbsp;</td><td class="paramname"><em>description</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get an <a class="el" href="class_i_text_run.html">ITextRun</a> interface for a given line description <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">description</td><td>a rundescription to get a cooresponding <a class="el" href="class_i_text_run.html">ITextRun</a> for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>An <a class="el" href="class_i_text_run.html">ITextRun</a> interface instance. </dl></div></div><a class="anchor" id="a6de06960d137290c5ed4c1fd65af7f4a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextRuns::TextRunsContainedInLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Tell the caller whether a line has any runs. Some lines don&#39;t for instance divider lines <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story the line is in </td></tr><tr><td class="paramname">lineIndex</td><td>index of line interested in </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the line has runs. kFalse otherwise will return kFalse for invalid line numbers as well. </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_text_runs.html">ITextRuns</a><li class="footer">Generated on Sat Sep 22 2018 10:54:31 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
