<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_parcel_container</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_parcel_container.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#nested-classes">Classes</a> | <a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_i_parcel_container-members.html">List of all members</a></div><div class="headertitle"><div class="title">IParcelContainer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><div class="dynheader"> Inheritance diagram for IParcelContainer:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_parcel_container.png" usemap="#IParcelContainer_map" /><map id="IParcelContainer_map" name="IParcelContainer_map"><area alt="IPMUnknown" coords="0,0,107,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a> Classes</h2></td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i_parcel_container_1_1_parcel_all_data.html">ParcelAllData</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container_1_1_parcel_span_data.html">ParcelSpanData</a></td></tr><tr class="separator:"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a97b423f07ce55974c5fa3af575b2847f"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_IPARCELCONTAINER }</td></tr><tr class="separator:a97b423f07ce55974c5fa3af575b2847f"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a4cb5bc5c6cce8e4e0554a96585dc38a2"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_parcel_list.html">IParcelList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#a4cb5bc5c6cce8e4e0554a96585dc38a2">QueryParcelList</a> () const =0</td></tr><tr class="separator:a4cb5bc5c6cce8e4e0554a96585dc38a2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a650a50a7a7a7839bd0f03fa9c0a9dee6"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#a650a50a7a7a7839bd0f03fa9c0a9dee6">GetBounds</a> () const =0</td></tr><tr class="separator:a650a50a7a7a7839bd0f03fa9c0a9dee6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af29f260743b7b72759ea3f224e8c93b3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#af29f260743b7b72759ea3f224e8c93b3">GetIsRectangular</a> (bool16 checkCornerRadius=kFalse) const =0</td></tr><tr class="separator:af29f260743b7b72759ea3f224e8c93b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8ed9a8ef2aa9206e125bcc85d98ad894"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#a8ed9a8ef2aa9206e125bcc85d98ad894">GetColumnCount</a> () const =0</td></tr><tr class="separator:a8ed9a8ef2aa9206e125bcc85d98ad894"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a23f61792124e1fdfa2c1409ed0a0d65b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a23f61792124e1fdfa2c1409ed0a0d65b"></a> virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNthColumnBBox</b> (uint32 n) const =0</td></tr><tr class="separator:a23f61792124e1fdfa2c1409ed0a0d65b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3fd9f30a50fd109326ea6eb3d14e38db"><td align="right" class="memItemLeft" valign="top">virtual uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#a3fd9f30a50fd109326ea6eb3d14e38db">GetParcelCount</a> () const =0</td></tr><tr class="separator:a3fd9f30a50fd109326ea6eb3d14e38db"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af5514743838a3488e1eeab85c4dcab33"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#af5514743838a3488e1eeab85c4dcab33">GetNthParcelKey</a> (uint32 containerIndex) const =0</td></tr><tr class="separator:af5514743838a3488e1eeab85c4dcab33"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4bc2bc463dd74aaf7da70fa47ec5c285"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#a4bc2bc463dd74aaf7da70fa47ec5c285">GetParcelIndex</a> (<a class="el" href="class_parcel_key.html">ParcelKey</a> key) const =0</td></tr><tr class="separator:a4bc2bc463dd74aaf7da70fa47ec5c285"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a218980502e1234dc19eaa16384aedd57"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#a218980502e1234dc19eaa16384aedd57">GetFirstParcelKey</a> () const =0</td></tr><tr class="separator:a218980502e1234dc19eaa16384aedd57"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aeccd62c4528048a24fe8a32ca180ed6f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#aeccd62c4528048a24fe8a32ca180ed6f">GetLastParcelKey</a> () const =0</td></tr><tr class="separator:aeccd62c4528048a24fe8a32ca180ed6f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5bb50b34425e846d451a5363cf1e29b2"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a5bb50b34425e846d451a5363cf1e29b2"></a> virtual <a class="el" href="class_i_parcel_container_1_1_parcel_span_data.html">ParcelSpanData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNthParcelSpanData</b> (uint32 n) const =0</td></tr><tr class="separator:a5bb50b34425e846d451a5363cf1e29b2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aac785d508285441efe8303154cd39b01"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#aac785d508285441efe8303154cd39b01">GetNthParcelEffectiveTopAdj</a> (uint32 containerParcelIndex) const =0</td></tr><tr class="separator:aac785d508285441efe8303154cd39b01"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a77ee0fa836fdc890c66de8d5261a71e3"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a77ee0fa836fdc890c66de8d5261a71e3"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetNthParcelEffectiveTopAdj</b> (uint32 containerParcelIndex, <a class="el" href="class_p_m_real.html">PMReal</a> effectiveTopAdj)=0</td></tr><tr class="separator:a77ee0fa836fdc890c66de8d5261a71e3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a646fe739251b40f496588b34cf69ac65"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a646fe739251b40f496588b34cf69ac65"></a> virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNthParcelEffectiveBottomAdj</b> (uint32 containerParcelIndex, <a class="el" href="class_p_m_real.html">PMReal</a> *pBalanceOffset) const =0</td></tr><tr class="separator:a646fe739251b40f496588b34cf69ac65"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1fc93865b9609dd9683a754cebb9f30b"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1fc93865b9609dd9683a754cebb9f30b"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SetNthParcelEffectiveBottomAdj</b> (uint32 containerParcelIndex, <a class="el" href="class_p_m_real.html">PMReal</a> effectiveBottomAdj, <a class="el" href="class_p_m_real.html">PMReal</a> balanceOffset)=0</td></tr><tr class="separator:a1fc93865b9609dd9683a754cebb9f30b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aecb6112d70083f2e4514ac2a0b8a66ff"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#aecb6112d70083f2e4514ac2a0b8a66ff">GetNthParcelIsNonConforming</a> (int32 n) const =0</td></tr><tr class="separator:aecb6112d70083f2e4514ac2a0b8a66ff"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8442c66240111833a333c6947e36fdeb"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a8442c66240111833a333c6947e36fdeb"></a> virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetAllParcelData</b> (std::vector&lt; <a class="el" href="struct_i_parcel_container_1_1_parcel_all_data.html">ParcelAllData</a> &gt; &amp;list) const =0</td></tr><tr class="separator:a8442c66240111833a333c6947e36fdeb"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a30ec4b1cbdead2a816d822c5aa5f518b"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#a30ec4b1cbdead2a816d822c5aa5f518b">AppendParcel</a> (const <a class="el" href="class_i_parcel_container_1_1_parcel_span_data.html">ParcelSpanData</a> &amp;spanData)=0</td></tr><tr class="separator:a30ec4b1cbdead2a816d822c5aa5f518b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad4de63d675e4d37199a680cd6a2a42b8"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#ad4de63d675e4d37199a680cd6a2a42b8">ChangeNthParcelTo</a> (uint32 containerParcelIndex, const <a class="el" href="class_i_parcel_container_1_1_parcel_span_data.html">ParcelSpanData</a> &amp;spanData)=0</td></tr><tr class="separator:ad4de63d675e4d37199a680cd6a2a42b8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adcb56625226aa04b79b6bbb54218a260"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_parcel_container.html#adcb56625226aa04b79b6bbb54218a260">RemoveLastParcel</a> ()=0</td></tr><tr class="separator:adcb56625226aa04b79b6bbb54218a260"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a30ec4b1cbdead2a816d822c5aa5f518b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> IParcelContainer::AppendParcel </td><td>(</td><td class="paramtype">const <a class="el" href="class_i_parcel_container_1_1_parcel_span_data.html">ParcelSpanData</a> &amp;&nbsp;</td><td class="paramname"><em>spanData</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Caller is responsible for all damage. The ParcelContainer is free to reject this request by returning an invalid key (eg TextOnPath). </div></div><a class="anchor" id="ad4de63d675e4d37199a680cd6a2a42b8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IParcelContainer::ChangeNthParcelTo </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>containerParcelIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_i_parcel_container_1_1_parcel_span_data.html">ParcelSpanData</a> &amp;&nbsp;</td><td class="paramname"><em>spanData</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Caller is responsible for all damage. <dl class="section return"><dt>Returns<dd>kTrue if the Parcel can accept then change, kFalse otherwise. Currently the only reasons that change will not be accepted if it is a split and the resulting Parcel will be too narrow (~3pt) </dl></div></div><a class="anchor" id="a650a50a7a7a7839bd0f03fa9c0a9dee6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> IParcelContainer::GetBounds </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>All Parcel content bounds will be within the bounds of the Container. </div></div><a class="anchor" id="a8ed9a8ef2aa9206e125bcc85d98ad894"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IParcelContainer::GetColumnCount </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The number of columns in the Container. </div></div><a class="anchor" id="a218980502e1234dc19eaa16384aedd57"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> IParcelContainer::GetFirstParcelKey </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the first <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Container. This is equivalent to calling GetNthParcelKey(0). </div></div><a class="anchor" id="af29f260743b7b72759ea3f224e8c93b3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IParcelContainer::GetIsRectangular </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>checkCornerRadius</em> = <code>kFalse</code></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Callers would like to know if the base tiled shape, separate from the external wraps, of the ParcelContainer is a rectangle.<p>This is an important performance benefit because it means that all the Parcels will thus tile rectangular, unless there are wraps which are known to the <a class="el" href="class_i_text_parcel_list_data.html">ITextParcelListData</a> for the Parcel.<p>Also, note that the Parcel do have a to-(wax)Content-Matrix which might make the <em>effective</em> tileable area non-rectangular even though the Parcel was rectangular.<p>No attempt is made to separate out if individual Parcels are rectangular or not - if the Container is then the ContainerComposer will assume that any of them could be an act accordingly.<dl class="section return"><dt>Returns<dd>kTrue if the tileable shape is rectangular. </dl></div></div><a class="anchor" id="aeccd62c4528048a24fe8a32ca180ed6f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> IParcelContainer::GetLastParcelKey </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the last <a class="el" href="class_parcel_key.html">ParcelKey</a> of the Container. This is equivalent to calling GetNthParcelKey(<a class="el" href="class_i_parcel_container.html#a3fd9f30a50fd109326ea6eb3d14e38db">GetParcelCount()</a> - 1). </div></div><a class="anchor" id="aac785d508285441efe8303154cd39b01"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> IParcelContainer::GetNthParcelEffectiveTopAdj </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>containerParcelIndex</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Sets an effective ceiling and floor to the Parcel which will affect the placement of bottom hung WAEs (such as footnotes). Without any changes this is expected to be the Bottom() of ContentBounds unless we have manipulated them for hard balacing (such as for straddles). </div></div><a class="anchor" id="aecb6112d70083f2e4514ac2a0b8a66ff"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 IParcelContainer::GetNthParcelIsNonConforming </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>n</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>A Parcel is considered non-conforming when as created it does not fully match the values specified in its <a class="el" href="class_i_parcel_container_1_1_parcel_span_data.html">ParcelSpanData</a>.<p>For example, a split which has a large gutter in a small column might result in a physical Parcel width of impossible size, or an implementation such as TextOnPath which does not support more than one column or splits so its single Parcel always takes on whatever is asked of it even though it is not doing what the user wanted.<p>When this occurs the Parcel implementor will typically create a Parcel that it CAN support but it will leave it marked here with the desired results.<dl class="section return"><dt>Returns<dd>kTrue if nth Parcel is nonconforming, kFalse otherwise </dl></div></div><a class="anchor" id="af5514743838a3488e1eeab85c4dcab33"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_parcel_key.html">ParcelKey</a> IParcelContainer::GetNthParcelKey </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>containerIndex</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the <a class="el" href="class_parcel_key.html">ParcelKey</a> of the nTH Parcel in the Container. </div></div><a class="anchor" id="a3fd9f30a50fd109326ea6eb3d14e38db"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual uint32 IParcelContainer::GetParcelCount </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The number of Parcels in the container. </div></div><a class="anchor" id="a4bc2bc463dd74aaf7da70fa47ec5c285"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 IParcelContainer::GetParcelIndex </td><td>(</td><td class="paramtype"><a class="el" href="class_parcel_key.html">ParcelKey</a>&nbsp;</td><td class="paramname"><em>key</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the index of the Parcel in the Container. It is permissable to pass in a key which is NOT in the container which will result in a -1 being returned. This is sometime useful. </div></div><a class="anchor" id="a4cb5bc5c6cce8e4e0554a96585dc38a2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_parcel_list.html">IParcelList</a>* IParcelContainer::QueryParcelList </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>The <a class="el" href="class_i_parcel_list.html">IParcelList</a> our Parcels are associated with. </div></div><a class="anchor" id="adcb56625226aa04b79b6bbb54218a260"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void IParcelContainer::RemoveLastParcel </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Destroys the last Parcel in the Container. The callee needs to be responsible for calling the TextParcelList to properly damage the content. It is an error to attempt to destroy the first Parcel in the Container. </div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_parcel_container.html">IParcelContainer</a><li class="footer">Generated on Sat Sep 22 2018 10:54:22 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
