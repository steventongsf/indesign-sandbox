<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_interface_ptr</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_interface_ptr.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="class_interface_ptr-members.html">List of all members</a></div><div class="headertitle"><div class="title">InterfacePtr&lt; IFace &gt; Class Template Reference</div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_interface_ptr_8h_source.html">InterfacePtr.h</a>&gt;</code><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:abb1ac0eebfba09cc229982c1024b2345"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structobject__type.html">object_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#abb1ac0eebfba09cc229982c1024b2345">data_type</a></td></tr><tr class="separator:abb1ac0eebfba09cc229982c1024b2345"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:a7bcd51d72829f651bfca6d12435ff6d3"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a7bcd51d72829f651bfca6d12435ff6d3">InterfacePtr</a> (IFace *p)</td></tr><tr class="separator:a7bcd51d72829f651bfca6d12435ff6d3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a696ec576bd730c0de4b7eacf4f35c940"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a696ec576bd730c0de4b7eacf4f35c940">InterfacePtr</a> (const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *p, <a class="el" href="class_i_d_type.html">PMIID</a> iid)</td></tr><tr class="separator:a696ec576bd730c0de4b7eacf4f35c940"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abe2870a89a350b973c44b95574516049"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#abe2870a89a350b973c44b95574516049">InterfacePtr</a> (const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *p, const <a class="el" href="class_use_default_i_i_d.html">UseDefaultIID</a> &amp;)</td></tr><tr class="separator:abe2870a89a350b973c44b95574516049"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac29605b98dadcaaa08ce64d1860743e6"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#ac29605b98dadcaaa08ce64d1860743e6">InterfacePtr</a> (void)</td></tr><tr class="separator:ac29605b98dadcaaa08ce64d1860743e6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aec130b23081776d32364aed0c620f6c4"><td class="memTemplParams" colspan="2">template&lt;class OtherType &gt; </td></tr><tr class="memitem:aec130b23081776d32364aed0c620f6c4"><td align="right" class="memTemplItemLeft" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#aec130b23081776d32364aed0c620f6c4">InterfacePtr</a> (const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; OtherType &gt; &amp;p)</td></tr><tr class="separator:aec130b23081776d32364aed0c620f6c4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a2bd31c8c2d4e2f2053880009b303142a"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a2bd31c8c2d4e2f2053880009b303142a">InterfacePtr</a> (const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;p)</td></tr><tr class="separator:a2bd31c8c2d4e2f2053880009b303142a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6efd679ba80408a06a095b33df040994"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a6efd679ba80408a06a095b33df040994"></a> &nbsp;</td><td class="memItemRight" valign="bottom"><b>InterfacePtr</b> (<a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;&amp;p) noexcept</td></tr><tr class="separator:a6efd679ba80408a06a095b33df040994"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae50c178c634740b20be44b6889441dca"><td class="memTemplParams" colspan="2">template&lt;class OtherType &gt; </td></tr><tr class="memitem:ae50c178c634740b20be44b6889441dca"><td align="right" class="memTemplItemLeft" valign="top"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#ae50c178c634740b20be44b6889441dca">operator=</a> (const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; OtherType &gt; &amp;p)</td></tr><tr class="separator:ae50c178c634740b20be44b6889441dca"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0fbc60cd85d9205f2585d13a249fdf00"><td align="right" class="memItemLeft" valign="top"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a0fbc60cd85d9205f2585d13a249fdf00">operator=</a> (const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;p)</td></tr><tr class="separator:a0fbc60cd85d9205f2585d13a249fdf00"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1bba8c07ca7462bcfed6ef008cf2657a"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a1bba8c07ca7462bcfed6ef008cf2657a"></a> <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;&amp;p) noexcept</td></tr><tr class="separator:a1bba8c07ca7462bcfed6ef008cf2657a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aab1f7abebf48ae2cca6f6cedcb345d76"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#aab1f7abebf48ae2cca6f6cedcb345d76">InterfacePtr</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, <a class="el" href="class_i_d_type.html">UID</a> uid, <a class="el" href="class_i_d_type.html">PMIID</a> iid)</td></tr><tr class="separator:aab1f7abebf48ae2cca6f6cedcb345d76"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a74821be871ef0de75dcb35330a95ac9e"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a74821be871ef0de75dcb35330a95ac9e">InterfacePtr</a> (<a class="el" href="class_i_data_base.html">IDataBase</a> *db, <a class="el" href="class_i_d_type.html">UID</a> uid, const <a class="el" href="class_use_default_i_i_d.html">UseDefaultIID</a> &amp;)</td></tr><tr class="separator:a74821be871ef0de75dcb35330a95ac9e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aaed088150f2b6b898bf9b1b5524f4f5a"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#aaed088150f2b6b898bf9b1b5524f4f5a">InterfacePtr</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;ref, <a class="el" href="class_i_d_type.html">PMIID</a> iid)</td></tr><tr class="separator:aaed088150f2b6b898bf9b1b5524f4f5a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abab358e548681496bdbea9d76e1b675e"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#abab358e548681496bdbea9d76e1b675e">InterfacePtr</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;ref, const <a class="el" href="class_use_default_i_i_d.html">UseDefaultIID</a> &amp;)</td></tr><tr class="separator:abab358e548681496bdbea9d76e1b675e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab94f4bb753cc8f7d4de65d27da3e4fe7"><td align="right" class="memItemLeft" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#ab94f4bb753cc8f7d4de65d27da3e4fe7">operator IFace *</a> () const </td></tr><tr class="separator:ab94f4bb753cc8f7d4de65d27da3e4fe7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0aa9a38925979da69a6c1da329187fcd"><td align="right" class="memItemLeft" valign="top">IFace *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a0aa9a38925979da69a6c1da329187fcd">operator-&gt;</a> () const </td></tr><tr class="separator:a0aa9a38925979da69a6c1da329187fcd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a910f212c3a66c9f739aee6884097e9f7"><td align="right" class="memItemLeft" valign="top">bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a910f212c3a66c9f739aee6884097e9f7">operator!</a> () const </td></tr><tr class="separator:a910f212c3a66c9f739aee6884097e9f7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4147735684d9c9512d0d1fc8c61feb96"><td align="right" class="memItemLeft" valign="top">IFace *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a4147735684d9c9512d0d1fc8c61feb96">forget</a> ()</td></tr><tr class="separator:a4147735684d9c9512d0d1fc8c61feb96"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88872126d69820a7a20606abaa144942"><td align="right" class="memItemLeft" valign="top">IFace *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#a88872126d69820a7a20606abaa144942">get</a> () const </td></tr><tr class="separator:a88872126d69820a7a20606abaa144942"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab73edd4918e8b3a105ec3aadedae5220"><td align="right" class="memItemLeft" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_interface_ptr.html#ab73edd4918e8b3a105ec3aadedae5220">reset</a> (IFace *p=0)</td></tr><tr class="separator:ab73edd4918e8b3a105ec3aadedae5220"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a92c35df62666e7e55c6bbd437d8008a7"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="a92c35df62666e7e55c6bbd437d8008a7"></a> void&nbsp;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;other) noexcept</td></tr><tr class="separator:a92c35df62666e7e55c6bbd437d8008a7"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><h3>template&lt;class IFace&gt;<br /> class InterfacePtr&lt; IFace &gt;</h3><p><a class="el" href="class_interface_ptr.html">InterfacePtr</a> is a smart pointer class that simplifies the work with interface pointers. It guarantees that Release() will be called on an acquired interface and AddRef() when sharing the ownership. </div><h2 class="groupheader">Member Typedef Documentation</h2><a class="anchor" id="abb1ac0eebfba09cc229982c1024b2345"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="memname"><tr><td class="memname">typedef <a class="el" href="structobject__type.html">object_type</a> <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html#abb1ac0eebfba09cc229982c1024b2345">data_type</a></td></tr></table></div><div class="memdoc"><p>Allows containment of <a class="el" href="class_interface_ptr.html">InterfacePtr</a> in <a class="el" href="class_k2_vector.html">K2Vector</a>. </div></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2><a class="anchor" id="a7bcd51d72829f651bfca6d12435ff6d3"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype">IFace *&nbsp;</td><td class="paramname"><em>p</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">This constructor will take ownership of the specified interface. AddRef is NOT called, but

</pre><p> Release will be called in the destructor. This functionality is best described as an Attach(). Most of the time, you do not want to use this constructor, but the ones with two parameters which do call AddRef. Do not use p after this call since it may be invalid after the <a class="el" href="class_interface_ptr.html">InterfacePtr</a> goes out of scope. Use this constructor when you&#39;ve called a function that returns an AddRef&#39;d pointer &ndash; e.g., QuerySpread(), QueryApplication(), etc.<dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>[IN] - interface pointer that we attach to. </td></tr></table></dl></div></div><a class="anchor" id="a696ec576bd730c0de4b7eacf4f35c940"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype">const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>p</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>iid</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Use this constructor if you have one interface on a boss and want another one. Addref is called

</pre><p> on the boss, so it is still safe to use the p after the <a class="el" href="class_interface_ptr.html">InterfacePtr</a> goes out of scope. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>[IN] - interface to use for query. </td></tr><tr><td class="paramname">iid</td><td>[IN] - IID of the interface we want. </td></tr></table></dl></div></div><a class="anchor" id="abe2870a89a350b973c44b95574516049"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype">const <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="paramname"><em>p</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_use_default_i_i_d.html">UseDefaultIID</a> &amp;&nbsp;</td><td class="paramname">&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><p>This constructor is similar to the one directly above. It is more convenient but will only compile if IFace::kDefaultIID is defined <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>[IN] - interface to use for query. </td></tr></table></dl></div></div><a class="anchor" id="ac29605b98dadcaaa08ce64d1860743e6"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype">void&nbsp;</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><p>Default constructor: construct a nil <a class="el" href="class_interface_ptr.html">InterfacePtr</a></div></div><a class="anchor" id="aec130b23081776d32364aed0c620f6c4"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><div class="memtemplate"> template&lt;class OtherType &gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype">const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; OtherType &gt; &amp;&nbsp;</td><td class="paramname"><em>p</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><p>Constructor that enables InterfacePtr&lt;const IFoo&gt; to be constructed from an InterfacePtr&lt;IFoo&gt;. </div></div><a class="anchor" id="a2bd31c8c2d4e2f2053880009b303142a"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype">const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;&nbsp;</td><td class="paramname"><em>p</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Copy constructor. Increments the ref count of p by one. We define this to prevent the

</pre><p> compiler from generating a bitwise copying version (template members do not suffice). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>[IN] - <a class="el" href="class_interface_ptr.html">InterfacePtr</a> to be copied. </td></tr></table></dl></div></div><a class="anchor" id="aab1f7abebf48ae2cca6f6cedcb345d76"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>uid</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>iid</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Constructs an InterfacePtr from an object from a database.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">db</td><td>[IN] - Database to instantiate from </td></tr><tr><td class="paramname">uid</td><td>[IN] - UID of the boss. </td></tr><tr><td class="paramname">iid</td><td>[IN] - IID of the desired interface from the boss. </td></tr></table></dl></div></div><a class="anchor" id="a74821be871ef0de75dcb35330a95ac9e"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype"><a class="el" href="class_i_data_base.html">IDataBase</a> *&nbsp;</td><td class="paramname"><em>db</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>uid</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_use_default_i_i_d.html">UseDefaultIID</a> &amp;&nbsp;</td><td class="paramname">&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Constructs an InterfacePtr from an object from a database. This version is more

</pre><p> convenient but will only compile if IFace::kDefaultIID is defined. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">db</td><td>[IN] - Database to instantiate from </td></tr><tr><td class="paramname">uid</td><td>[IN] - UID of the boss. </td></tr></table></dl></div></div><a class="anchor" id="aaed088150f2b6b898bf9b1b5524f4f5a"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>ref</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">PMIID</a>&nbsp;</td><td class="paramname"><em>iid</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Constructs an InterfacePtr from an object from a database.

</pre><dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ref</td><td>[IN] - <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the boss object </td></tr><tr><td class="paramname">iid</td><td>[IN] - IID of the desired interface from the boss. </td></tr></table></dl></div></div><a class="anchor" id="abab358e548681496bdbea9d76e1b675e"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::<a class="el" href="class_interface_ptr.html">InterfacePtr</a></td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>ref</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_use_default_i_i_d.html">UseDefaultIID</a> &amp;&nbsp;</td><td class="paramname">&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Constructs an InterfacePtr from an object from a database.

</pre><p> This version is more convenient but will only compile if IFace::kDefaultIID is defined. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ref</td><td>[IN] - <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the boss object </td></tr><tr><td class="paramname">iid</td><td>[IN] - IID of the desired interface from the boss. </td></tr></table></dl></div></div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a4147735684d9c9512d0d1fc8c61feb96"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">IFace* <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::forget </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Detaches from the owned interface and transfers the ownership to the caller.

</pre><p> Note: The signature of this function makes it error-prone: if the caller doesn&#39;t take ownership of the interface (doesn&#39;t assign the result) the interface will be leaked. <dl class="section return"><dt>Returns<dd>the owned interface </dl></div></div><a class="anchor" id="a88872126d69820a7a20606abaa144942"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">IFace* <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::get </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Accessor for the owned pointer.

</pre><dl class="section return"><dt>Returns<dd>the contained pointer </dl></div></div><a class="anchor" id="ab94f4bb753cc8f7d4de65d27da3e4fe7"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::operator IFace * </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Implicit conversion operator. Allows implicit conversion between InterfacePtr&lt;IFace&gt; and IFace*.

</pre><dl class="section return"><dt>Returns<dd>the contained pointer. </dl></div></div><a class="anchor" id="a910f212c3a66c9f739aee6884097e9f7"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">bool16 <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::operator! </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Boolean test operator (Null test).

</pre><dl class="section return"><dt>Returns<dd>kTrue if the contained pointer is nil. </dl></div></div><a class="anchor" id="a0aa9a38925979da69a6c1da329187fcd"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">IFace* <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::operator-&gt; </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Indirection operator. If the pointer is nil, it will ASSERT in Debug builds and will

</pre><p> have unspecified behavior in the Release builds. <dl class="section return"><dt>Returns<dd>the contained pointer </dl></div></div><a class="anchor" id="ae50c178c634740b20be44b6889441dca"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><div class="memtemplate"> template&lt;class OtherType &gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt;IFace&gt;&amp; <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::operator= </td><td>(</td><td class="paramtype">const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; OtherType &gt; &amp;&nbsp;</td><td class="paramname"><em>p</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Assigment operator. Increments the ref count of p by one.

</pre><p> This one enables InterfacePtr&lt;const IFoo&gt; = InterfacePtr&lt;IFoo&gt; <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>[IN] - <a class="el" href="class_interface_ptr.html">InterfacePtr</a> to be copied. </td></tr></table></dl></div></div><a class="anchor" id="a0fbc60cd85d9205f2585d13a249fdf00"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname"><a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt;IFace&gt;&amp; <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::operator= </td><td>(</td><td class="paramtype">const <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt; &amp;&nbsp;</td><td class="paramname"><em>p</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Assigment operator. Increments the ref count of p by one.

</pre><p> This one enables copying of <a class="el" href="class_interface_ptr.html">InterfacePtr</a> of the same types. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>[IN] - <a class="el" href="class_interface_ptr.html">InterfacePtr</a> to be copied. </td></tr></table></dl></div></div><a class="anchor" id="ab73edd4918e8b3a105ec3aadedae5220"></a><div class="memitem"><div class="memproto"><div class="memtemplate"> template&lt;class IFace&gt; </div><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">void <a class="el" href="class_interface_ptr.html">InterfacePtr</a>&lt; IFace &gt;::reset </td><td>(</td><td class="paramtype">IFace *&nbsp;</td><td class="paramname"><em>p</em> = <code>0</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">inline</span></span></td></tr></table></div><div class="memdoc"><pre class="fragment">Releases the ownership for the current interface and attaches to the new one.

</pre><p> Note: the reference count of p will NOT be changed (AddRef is not called). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">p</td><td>[IN] - new interface pointer to take ownership of </td></tr></table></dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_interface_ptr.html">InterfacePtr</a><li class="footer">Generated on Sat Sep 22 2018 10:54:21 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
