<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/xhtml;charset=UTF-8" http-equiv="Content-Type" /><meta content="IE=9" http-equiv="X-UA-Compatible" /><meta content="Doxygen 1.8.3.1" name="generator" /><title>_i_text_lines</title><link href="tabs.css" rel="stylesheet" type="text/css" /><script src="jquery.js" type="text/javascript"></script><script src="dynsections.js" type="text/javascript"></script><link href="navtree.css" rel="stylesheet" type="text/css" /><script src="resize.js" type="text/javascript"></script><script src="navtree.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(initResizable);

  $(window).load(resizeHeight);

</script><link href="search/search.css" rel="stylesheet" type="text/css" /><script src="search/search.js" type="text/javascript"></script><script type="text/javascript">

  $(document).ready(function() { searchBox.OnSelectItem(0); });

</script><link href="doxygen.css" rel="stylesheet" type="text/css" /></head><body><div id="top"><div id="titlearea"><table cellpadding="0" cellspacing="0"><tbody><tr style="height: 56px;"><td id="projectlogo"><img alt="Logo" src="adobe_logo.png" /></td><td style="padding-left: 0.5em;"><div id="projectname">InDesign SDK &nbsp;<span id="projectnumber">14.0.0</span></div></td></tr></tbody></table></div><script type="text/javascript">

var searchBox = new SearchBox("searchBox", "search",false,'Search');

</script><div class="tabs" id="navrow1"><ul class="tablist"><li><a href="index.html"><span>InDesign&nbsp;SDK</span></a><li><a href="pages.html"><span>Documentation</span></a><li><a href="group__bosses__parent.html"><span>Bosses</span></a><li><a href="group__sdk.html"><span>Sample&nbsp;plug-ins</span></a><li><a href="classes.html"><span>Class&nbsp;Index</span></a><li><div class="MSearchBoxInactive" id="MSearchBox"><span class="left"> <img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png" /> <input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search" /> </span><span class="right"> <a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png" /></a> </span></div></ul></div></div><div class="ui-resizable side-nav-resizable" id="side-nav"><div id="nav-tree"><div id="nav-tree-contents"><div class="sync" id="nav-sync"></div></div></div><div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;"></div></div><script type="text/javascript">

$(document).ready(function(){initNavTree('class_i_text_lines.html','');});

</script><div id="doc-content"><div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()"><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Pages</a></div><div id="MSearchResultsWindow"><iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)"></iframe></div><div class="header"><div class="summary"><a href="#pub-types">Public Types</a> | <a href="#pub-methods">Public Member Functions</a> | <a href="#friends">Friends</a> | <a href="class_i_text_lines-members.html">List of all members</a></div><div class="headertitle"><div class="title">ITextLines Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div></div><div class="contents"><p><code>#include &lt;<a class="el" href="_i_text_lines_8h_source.html">ITextLines.h</a>&gt;</code><div class="dynheader"> Inheritance diagram for ITextLines:</div><div class="dyncontent"><div class="center"><img alt="" src="class_i_text_lines.png" usemap="#ITextLines_map" /><map id="ITextLines_map" name="ITextLines_map"><area alt="IPMUnknown" coords="0,0,85,24" href="class_i_p_m_unknown.html" shape="rect" /></map></div></div><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a> Public Types</h2></td></tr><tr class="memitem:a133dee667d843841461a039266cd4203"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>kDefaultIID</b> = IID_ITEXTLINES }</td></tr><tr class="separator:a133dee667d843841461a039266cd4203"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af7831e5553adceb5d8ae18a059324bf5"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>LinesType</b> { <b>kLayoutLineEnds</b> = 0, <b>kWindowLineEnds</b> }</td></tr><tr class="separator:af7831e5553adceb5d8ae18a059324bf5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a6eac4a76f4201409cb12683051f4ee"><td align="right" class="memItemLeft" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>ExtendType</b> { <b>kDontExtend</b> = 0, <b>kExtendLeft</b>, <b>kExtendRight</b> }</td></tr><tr class="separator:a1a6eac4a76f4201409cb12683051f4ee"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a> Public Member Functions</h2></td></tr><tr class="memitem:aa7b9d21152e85baf10961f17347ce104"><td align="right" class="memItemLeft" valign="top">virtual LinesType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#aa7b9d21152e85baf10961f17347ce104">GetLinesType</a> ()=0</td></tr><tr class="separator:aa7b9d21152e85baf10961f17347ce104"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5992901d871f3d67ab4b0cbcf99a392b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a5992901d871f3d67ab4b0cbcf99a392b">SetLinesType</a> (LinesType lType)=0</td></tr><tr class="separator:a5992901d871f3d67ab4b0cbcf99a392b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5829862a3aeb3e1aa239ca109a7e2575"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a5829862a3aeb3e1aa239ca109a7e2575">UpdateFontInfo</a> (const <a class="el" href="class_p_m_string.html">PMString</a> *fontName, bool16 initializeLines)=0</td></tr><tr class="separator:a5829862a3aeb3e1aa239ca109a7e2575"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a94bd171bb1ba140226beeaca34653dae"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a94bd171bb1ba140226beeaca34653dae">UpdateLeading</a> ()=0</td></tr><tr class="separator:a94bd171bb1ba140226beeaca34653dae"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9fa60083ad53f4cff1cdccd5783a12c9"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_string.html">PMString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a9fa60083ad53f4cff1cdccd5783a12c9">GetDisplayFontName</a> (IFontMgr::FontStyleBits styleBits=IFontMgr::kNormal)=0</td></tr><tr class="separator:a9fa60083ad53f4cff1cdccd5783a12c9"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af41a9601ca23acfa535db0d00a4ac60f"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#af41a9601ca23acfa535db0d00a4ac60f">GetDisplayFontSize</a> (<a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a> capMode=IDrawingStyle::kCapNormal)=0</td></tr><tr class="separator:af41a9601ca23acfa535db0d00a4ac60f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adb712326360f8b97324802ff8431a67b"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#adb712326360f8b97324802ff8431a67b">GetLineHeight</a> (bool16 textOnly=kFalse)=0</td></tr><tr class="separator:adb712326360f8b97324802ff8431a67b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a26b57935bd7c8361186af53f3bdfba1e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_font_instance.html">IFontInstance</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a26b57935bd7c8361186af53f3bdfba1e">QueryDisplayFontInstance</a> (IFontMgr::FontStyleBits styleBits, <a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a> capMode)=0</td></tr><tr class="separator:a26b57935bd7c8361186af53f3bdfba1e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:accdd33ae435473ba23d8e9b60d1cb980"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#accdd33ae435473ba23d8e9b60d1cb980">ComposeLayout</a> ()=0</td></tr><tr class="separator:accdd33ae435473ba23d8e9b60d1cb980"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9f1e079af8f7eb7c44050437a364abd0"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a9f1e079af8f7eb7c44050437a364abd0">SetComposeLayout</a> (bool16 shouldCompose)=0</td></tr><tr class="separator:a9f1e079af8f7eb7c44050437a364abd0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a68a07a31812b5d44b336b0d930180dc7"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a68a07a31812b5d44b336b0d930180dc7">GetLineStartOffsetAtLine</a> (int32 at)=0</td></tr><tr class="separator:a68a07a31812b5d44b336b0d930180dc7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1a40be59ff3a1ecb7b453ef7f6fa4bd1"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a1a40be59ff3a1ecb7b453ef7f6fa4bd1">GetLineEndOffsetAtLine</a> (int32 at)=0</td></tr><tr class="separator:a1a40be59ff3a1ecb7b453ef7f6fa4bd1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6d2ef9f4a2312566bbfdaafb63690623"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a6d2ef9f4a2312566bbfdaafb63690623">GetYPosition</a> (int32 at)=0</td></tr><tr class="separator:a6d2ef9f4a2312566bbfdaafb63690623"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a88bcbb3bb5c085ac2a9f58506f08edc0"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a88bcbb3bb5c085ac2a9f58506f08edc0">GetYPosition</a> (int32 storyIndex, int32 at)=0</td></tr><tr class="separator:a88bcbb3bb5c085ac2a9f58506f08edc0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a610110d066bc96ee0aa4e609225c0502"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a610110d066bc96ee0aa4e609225c0502">GetXPosition</a> (int32 at)=0</td></tr><tr class="separator:a610110d066bc96ee0aa4e609225c0502"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9674cfdae2c2a2012b38144514659a40"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a9674cfdae2c2a2012b38144514659a40">CalculateLineRect</a> (int32 at)=0</td></tr><tr class="separator:a9674cfdae2c2a2012b38144514659a40"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aebf9f77ff330d2c67b3d17aa98d6facf"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#aebf9f77ff330d2c67b3d17aa98d6facf">CalculateLineRect</a> (int32 storyIndex, int32 at)=0</td></tr><tr class="separator:aebf9f77ff330d2c67b3d17aa98d6facf"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a46a05aed481bf225090b8c0a51b37844"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_line_description.html">LineDescription</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a46a05aed481bf225090b8c0a51b37844">GetLine</a> (int32 at, bool16 returnRuns=kFalse)=0</td></tr><tr class="separator:a46a05aed481bf225090b8c0a51b37844"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4d2a115e53a4258aec70b64d10f75018"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_line_description.html">LineDescription</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a4d2a115e53a4258aec70b64d10f75018">GetLine</a> (int32 storyIndex, int32 at, bool16 returnRuns)=0</td></tr><tr class="separator:a4d2a115e53a4258aec70b64d10f75018"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1ebf9fdb7cadad35420bc0bdaf94068c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a1ebf9fdb7cadad35420bc0bdaf94068c">InitializeLines</a> (const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_compose_information.html">ComposeInformation</a> &gt; &amp;composeInformation, bool16 forceInitialization=kFalse, bool16 scrollARangeIntoView=kFalse)=0</td></tr><tr class="separator:a1ebf9fdb7cadad35420bc0bdaf94068c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a11940c03c45da30954792213fd082772"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a11940c03c45da30954792213fd082772">AppendLine</a> (const <a class="el" href="class_line_description.html">LineDescription</a> &amp;line, bool16 autoScroll=kTrue)=0</td></tr><tr class="separator:a11940c03c45da30954792213fd082772"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9ccb9b92c85c9b6e114631e81e2e17b6"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a9ccb9b92c85c9b6e114631e81e2e17b6">InsertLine</a> (int32 beforeIndex, const <a class="el" href="class_line_description.html">LineDescription</a> &amp;line, bool16 autoScroll=kTrue)=0</td></tr><tr class="separator:a9ccb9b92c85c9b6e114631e81e2e17b6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0f1101d30afabde0dc598c52505f5532"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a0f1101d30afabde0dc598c52505f5532">DeleteLine</a> (int32 at)=0</td></tr><tr class="separator:a0f1101d30afabde0dc598c52505f5532"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a21c76f1c3fbc475b327f3602461d5b12"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a21c76f1c3fbc475b327f3602461d5b12">DeleteAllLines</a> ()=0</td></tr><tr class="separator:a21c76f1c3fbc475b327f3602461d5b12"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a397ea2dc745db9ec9c1707563df79558"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a397ea2dc745db9ec9c1707563df79558">ReplaceLine</a> (int32 at, const <a class="el" href="class_line_description.html">LineDescription</a> &amp;line)=0</td></tr><tr class="separator:a397ea2dc745db9ec9c1707563df79558"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a291ae88ee559124cee62a58b6b7b45e3"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a291ae88ee559124cee62a58b6b7b45e3">AddFrameDivider</a> (<a class="el" href="class_i_wax_line.html">IWaxLine</a> *waxLine, int32 at, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;atPosition, <a class="el" href="class_i_d_type.html">UID</a> previousLineFrameUID, bool16 isFrontMost)=0</td></tr><tr class="separator:a291ae88ee559124cee62a58b6b7b45e3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac5c414dbccfb2324c49112b5743cb2d1"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ac5c414dbccfb2324c49112b5743cb2d1">AddLineFromLayoutLine</a> (<a class="el" href="class_i_wax_line.html">IWaxLine</a> *waxLine, int32 at, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;atPosition, int32 lineNumber, uint32 lineID, bool16 isFrontMost)=0</td></tr><tr class="separator:ac5c414dbccfb2324c49112b5743cb2d1"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a101f218e48e8aa9e04245c3fefb76ac4"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a101f218e48e8aa9e04245c3fefb76ac4">RemoveExcessLines</a> (int32 startIndex, bool16 isFrontMost, bool16 autoScroll=kTrue)=0</td></tr><tr class="separator:a101f218e48e8aa9e04245c3fefb76ac4"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac9d25a8b4cb685c04cc1ae089d1cd18a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ac9d25a8b4cb685c04cc1ae089d1cd18a">UpdateLine</a> (int32 at)=0</td></tr><tr class="separator:ac9d25a8b4cb685c04cc1ae089d1cd18a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abb5f94777433cca80ce5cd02ea50c2fe"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#abb5f94777433cca80ce5cd02ea50c2fe">UpdateLine</a> (int32 storyIndex, int32 at)=0</td></tr><tr class="separator:abb5f94777433cca80ce5cd02ea50c2fe"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ade2b5df9d27fb6cc2caf4cf082d3d084"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ade2b5df9d27fb6cc2caf4cf082d3d084">SetLastValidIndex</a> (int32 index)=0</td></tr><tr class="separator:ade2b5df9d27fb6cc2caf4cf082d3d084"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a85163e74104e2a2380669587955887af"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a85163e74104e2a2380669587955887af">GetLastValidIndex</a> ()=0</td></tr><tr class="separator:a85163e74104e2a2380669587955887af"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6230d3135e38cf8211627fe2b6055595"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a6230d3135e38cf8211627fe2b6055595">GetLastValidIndex</a> (int32 storyIndex)=0</td></tr><tr class="separator:a6230d3135e38cf8211627fe2b6055595"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afea062fb88b3f605a13b34715380c719"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#afea062fb88b3f605a13b34715380c719">GetLastLineIndex</a> ()=0</td></tr><tr class="separator:afea062fb88b3f605a13b34715380c719"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ace5c503fc8e52a439397795c9ba9d7e7"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ace5c503fc8e52a439397795c9ba9d7e7">GetLastLineIndex</a> (int32 storyIndex)=0</td></tr><tr class="separator:ace5c503fc8e52a439397795c9ba9d7e7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae598244fe85d314b3e8aabc61cf1869b"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ae598244fe85d314b3e8aabc61cf1869b">GetFirstTrueTextLineIndex</a> ()=0</td></tr><tr class="separator:ae598244fe85d314b3e8aabc61cf1869b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae103de3b7864bffaf737a73a90cf90df"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ae103de3b7864bffaf737a73a90cf90df">GetFirstTrueTextLineIndex</a> (int32 storyIndex)=0</td></tr><tr class="separator:ae103de3b7864bffaf737a73a90cf90df"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a3ce97fea35f32287a4bdcdc942599a25"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a3ce97fea35f32287a4bdcdc942599a25">DeleteCacheForAllLines</a> ()=0</td></tr><tr class="separator:a3ce97fea35f32287a4bdcdc942599a25"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a47b1dae6c0b4d55e610594850725e103"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a47b1dae6c0b4d55e610594850725e103">SyncScrolling</a> (bool16 lockRelativePosition=kFalse, bool16 scrollToASelectionRange=kFalse)=0</td></tr><tr class="separator:a47b1dae6c0b4d55e610594850725e103"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aceb806a338c8f25be5962efd686ff682"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#aceb806a338c8f25be5962efd686ff682">SetUniqueIDOfLine</a> (int32 at, uint32 newID)=0</td></tr><tr class="separator:aceb806a338c8f25be5962efd686ff682"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1fc3ec86dd9f2a0a24ffb187dc76044e"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a1fc3ec86dd9f2a0a24ffb187dc76044e">FindIndexOfLineWithID</a> (uint32 id)=0</td></tr><tr class="separator:a1fc3ec86dd9f2a0a24ffb187dc76044e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abc7a954fbcb38160997ff6e24fcf51b3"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#abc7a954fbcb38160997ff6e24fcf51b3">FindIndexOfLineWithID</a> (int32 storyIndex, uint32 id)=0</td></tr><tr class="separator:abc7a954fbcb38160997ff6e24fcf51b3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a378624cda407a0a380998c8406b7dff3"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a378624cda407a0a380998c8406b7dff3">FindIndexOfLineAtTextOffset</a> (TextIndex offset, int32 &amp;offsetIntoLine, RangeData::Lean lean, bool16 checkRunBoundary=kFalse)=0</td></tr><tr class="separator:a378624cda407a0a380998c8406b7dff3"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a02f9cd7590c8e20939420dd16ca34b00"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a02f9cd7590c8e20939420dd16ca34b00">FindIndexOfLineAtDisplayOffset</a> (TextIndex offset, int32 &amp;offsetIntoLine, RangeData::Lean lean)=0</td></tr><tr class="separator:a02f9cd7590c8e20939420dd16ca34b00"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:abf8b282550f478aab1d16b4844ff85aa"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#abf8b282550f478aab1d16b4844ff85aa">FindIndexOfLineAtDisplayOffset</a> (int32 storyIndex, TextIndex offset, int32 &amp;offsetIntoLine, RangeData::Lean lean)=0</td></tr><tr class="separator:abf8b282550f478aab1d16b4844ff85aa"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7c3afccfd167b8552b207768e3070ad5"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a7c3afccfd167b8552b207768e3070ad5">DisplayRangeToLineIndices</a> (int32 storyIndex, const <a class="el" href="class_range_data.html">RangeData</a> &amp;range, int32 *low, int32 *high)=0</td></tr><tr class="separator:a7c3afccfd167b8552b207768e3070ad5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ada788fc2e4f4d7102387cd7c8d029e0e"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ada788fc2e4f4d7102387cd7c8d029e0e">FindIndexOfLineAtPoint</a> (const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;point)=0</td></tr><tr class="separator:ada788fc2e4f4d7102387cd7c8d029e0e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a39ed38571216ddaa2729245d509c18ad"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a39ed38571216ddaa2729245d509c18ad">FindIndexOfLineAtPoint</a> (int32 storyIndex, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;point)=0</td></tr><tr class="separator:a39ed38571216ddaa2729245d509c18ad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af85a4274e16a18c0d82f655b027bbc93"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#af85a4274e16a18c0d82f655b027bbc93">GetXPositionOfDisplayOffsetCharacter</a> (int32 atLineIndex, int32 displayOffsetIntoLine)=0</td></tr><tr class="separator:af85a4274e16a18c0d82f655b027bbc93"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad2bfb520c693bbaf9de337d32b2f33d6"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ad2bfb520c693bbaf9de337d32b2f33d6">GetXPositionOfDisplayOffsetCharacter</a> (int32 storyIndex, int32 atLineIndex, int32 displayOffsetIntoLine)=0</td></tr><tr class="separator:ad2bfb520c693bbaf9de337d32b2f33d6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1562491d529aa990093e9d9745e86042"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a1562491d529aa990093e9d9745e86042">GetXPositionOfCharacter</a> (int32 atLineIndex, int32 characterOffsetIntoLine, TextIndex absoluteTextOffset=-1, bool16 isEndPosition=kFalse, ExtendType extend=kDontExtend, TextIndex absoluteTextEndOffset=-1)=0</td></tr><tr class="separator:a1562491d529aa990093e9d9745e86042"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a806e2edde34eb9085e0e532f6b627e46"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a806e2edde34eb9085e0e532f6b627e46">GetXPositionOfCharacterInRun</a> (int32 atLineIndex, int32 runIndex, int32 characterOffsetIntoRun)=0</td></tr><tr class="separator:a806e2edde34eb9085e0e532f6b627e46"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a162df6355c71cbd170054c7e724bcfd5"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a162df6355c71cbd170054c7e724bcfd5">FindCharacterAtXPosition</a> (int32 atLineIndex, <a class="el" href="class_p_m_real.html">PMReal</a> &amp;xPosition, int32 &amp;offsetIntoLine)=0</td></tr><tr class="separator:a162df6355c71cbd170054c7e724bcfd5"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab43598f94baf5dcd5c68feadbe5bc399"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ab43598f94baf5dcd5c68feadbe5bc399">HitTestText</a> (int32 storyIndex, int32 *lineIndex, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;x, TextIndex *nextLine)=0</td></tr><tr class="separator:ab43598f94baf5dcd5c68feadbe5bc399"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af02c5b40a8f61d7d3094e499d2957767"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#af02c5b40a8f61d7d3094e499d2957767">GetIndexOfFirstLineInRect</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> rectToFit, bool16 partialFitOK=kTrue)=0</td></tr><tr class="separator:af02c5b40a8f61d7d3094e499d2957767"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a86e82478c3da7dbf4962bf3c47a0f632"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a86e82478c3da7dbf4962bf3c47a0f632">SetHilite</a> (TextIndex start, TextIndex end, bool16 drawHilite=kTrue, <a class="el" href="class_i_d_type.html">UID</a> extendToDeletedUID=kInvalidUID)=0</td></tr><tr class="separator:a86e82478c3da7dbf4962bf3c47a0f632"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6d78474f94e184089d9e8e79c2d269e2"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a6d78474f94e184089d9e8e79c2d269e2">SetHilite</a> (const <a class="el" href="class_range_data.html">RangeData</a> &amp;range, bool16 drawHilite=kTrue, <a class="el" href="class_i_d_type.html">UID</a> extendToDeletedUID=kInvalidUID)=0</td></tr><tr class="separator:a6d78474f94e184089d9e8e79c2d269e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7f0bdce97477f1e9c25d153f6d5d21dd"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a7f0bdce97477f1e9c25d153f6d5d21dd">GetHilite</a> (TextIndex &amp;start, TextIndex &amp;end, <a class="el" href="class_selection_extension.html">SelectionExtension</a> *extendToDeletedUIDs=nil)=0</td></tr><tr class="separator:a7f0bdce97477f1e9c25d153f6d5d21dd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8367fc745583b5457435afced339b045"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a8367fc745583b5457435afced339b045">DrawTextHighlight</a> (const <a class="el" href="class_in_design_1_1_text_range.html">InDesign::TextRange</a> &amp;newSelection, const <a class="el" href="class_in_design_1_1_text_range.html">InDesign::TextRange</a> &amp;oldSelection, <a class="el" href="class_selection_extension.html">SelectionExtension</a> *newExtension=nil, <a class="el" href="class_selection_extension.html">SelectionExtension</a> *oldExtension=nil)=0</td></tr><tr class="separator:a8367fc745583b5457435afced339b045"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a262371a1244bab4a8e468df3df08c475"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a262371a1244bab4a8e468df3df08c475">DrawLine</a> (int32 at, <a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *gPort, const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;clipRect, const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;scrollCompensationValue, <a class="el" href="class_i_p_m_font.html">IPMFont</a> *displayFont, <a class="el" href="class_p_m_real.html">PMReal</a> displaySize, bool16 topLineInDraw)=0</td></tr><tr class="separator:a262371a1244bab4a8e468df3df08c475"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac1e100831ad62e0cc98004e6298fbb1c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ac1e100831ad62e0cc98004e6298fbb1c">InvalidateLine</a> (int32 at, bool16 isFrontMost=kFalse)=0</td></tr><tr class="separator:ac1e100831ad62e0cc98004e6298fbb1c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a4431e5cbe4d2e64a70c42ebf1fbdad91"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a4431e5cbe4d2e64a70c42ebf1fbdad91">InvalidateRun</a> (int32 at, int32 whichRun, TextIndex startOffsetInRun, TextIndex endOffsetInRun, bool16 isFrontMost=kFalse)=0</td></tr><tr class="separator:a4431e5cbe4d2e64a70c42ebf1fbdad91"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0ce29bccf7479dd4a79cd4926162356a"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a0ce29bccf7479dd4a79cd4926162356a">ClearPendingInvalRect</a> ()=0</td></tr><tr class="separator:a0ce29bccf7479dd4a79cd4926162356a"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac373ea455cc3ab5eba1f78815b39e494"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ac373ea455cc3ab5eba1f78815b39e494">AddToPendingInvalRect</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;rectToAdd)=0</td></tr><tr class="separator:ac373ea455cc3ab5eba1f78815b39e494"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad456ae069ac163fe33e8ad4034b7fe48"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ad456ae069ac163fe33e8ad4034b7fe48">GetPendingInvalRect</a> ()=0</td></tr><tr class="separator:ad456ae069ac163fe33e8ad4034b7fe48"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8440f6dbab5da88246dcedb93564e9d2"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a8440f6dbab5da88246dcedb93564e9d2">PlayPendingInvals</a> (bool16 instantDraw=kFalse)=0</td></tr><tr class="separator:a8440f6dbab5da88246dcedb93564e9d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a0140e5d7f73e54f4a7c6424af9042037"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a0140e5d7f73e54f4a7c6424af9042037">SuspendPlayPendingInvals</a> ()=0</td></tr><tr class="separator:a0140e5d7f73e54f4a7c6424af9042037"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:afa8d3cfc82793e0e027dacf57e38717d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#afa8d3cfc82793e0e027dacf57e38717d">ResumePlayPendingInvals</a> ()=0</td></tr><tr class="separator:afa8d3cfc82793e0e027dacf57e38717d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7b5c56977b2dd7a540ff431e476e47c2"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a7b5c56977b2dd7a540ff431e476e47c2">GetPlayPendingInvals</a> () const =0</td></tr><tr class="separator:a7b5c56977b2dd7a540ff431e476e47c2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6459059d22147066bae10b83f96496d6"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a6459059d22147066bae10b83f96496d6">RecordUndoRedoPendingInvals</a> (const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;invals)=0</td></tr><tr class="separator:a6459059d22147066bae10b83f96496d6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1b0c1e3b12af1934b70cce1073016ece"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a1b0c1e3b12af1934b70cce1073016ece">GetPendingInvalsForUndoRedo</a> ()=0</td></tr><tr class="separator:a1b0c1e3b12af1934b70cce1073016ece"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad103a9eefef185b9575112d8baaad143"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ad103a9eefef185b9575112d8baaad143">GetPages</a> (<a class="el" href="class_p_m_rect.html">PMRect</a> rectToFit, int32 columns)=0</td></tr><tr class="separator:ad103a9eefef185b9575112d8baaad143"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae5222c3b54a66d21f487e109291baad8"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ae5222c3b54a66d21f487e109291baad8">SetRanges</a> (<a class="el" href="class_p_m_string.html">PMString</a> ranges)=0</td></tr><tr class="separator:ae5222c3b54a66d21f487e109291baad8"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a49450faf625c8f759f974f053df0611f"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a49450faf625c8f759f974f053df0611f">GetLineNumberStartEnd</a> (int32 &amp;start, int32 &amp;end)=0</td></tr><tr class="separator:a49450faf625c8f759f974f053df0611f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac8d5d46cf13259655eb6a77b0b161f0c"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ac8d5d46cf13259655eb6a77b0b161f0c">InitializeStoryCollapsedState</a> (<a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_story_state.html">StoryState</a> &gt; &amp;storyList)=0</td></tr><tr class="separator:ac8d5d46cf13259655eb6a77b0b161f0c"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab87cfb41c60ebcce8c8de451b675c93d"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ab87cfb41c60ebcce8c8de451b675c93d">ModelOffsetToDisplayOffset</a> (TextIndex modelOffset, int32 lineIndex, bool16 ignoreRunTypes=kFalse)=0</td></tr><tr class="separator:ab87cfb41c60ebcce8c8de451b675c93d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6215fa3fdcf7b82b6ec5e4409296d2f2"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a6215fa3fdcf7b82b6ec5e4409296d2f2">ModelIndexToDisplayIndex</a> (TextIndex modelIndex)=0</td></tr><tr class="separator:a6215fa3fdcf7b82b6ec5e4409296d2f2"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a397b730827768d741d147ef49c6b0994"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a397b730827768d741d147ef49c6b0994">ModelIndexToDisplayIndex</a> (int32 storyIndex, TextIndex modelIndex)=0</td></tr><tr class="separator:a397b730827768d741d147ef49c6b0994"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ac4fbb5d2c763b28b6d67e4f7cf05b2d0"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ac4fbb5d2c763b28b6d67e4f7cf05b2d0">DisplayIndexToModelIndex</a> (TextIndex displayIndex)=0</td></tr><tr class="separator:ac4fbb5d2c763b28b6d67e4f7cf05b2d0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a023777d319d9220136a1131987dea24f"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a023777d319d9220136a1131987dea24f">DisplayIndexToModelIndex</a> (int32 storyIndex, TextIndex displayIndex)=0</td></tr><tr class="separator:a023777d319d9220136a1131987dea24f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6a5654381bfa314b044d418daa0eac4b"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a6a5654381bfa314b044d418daa0eac4b">SetCurrentStoryIndex</a> (int32 i)=0</td></tr><tr class="separator:a6a5654381bfa314b044d418daa0eac4b"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5dc6bdd48c0f8f5d3d9e2a67883ec5fd"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a5dc6bdd48c0f8f5d3d9e2a67883ec5fd">GetCurrentStoryIndex</a> ()=0</td></tr><tr class="separator:a5dc6bdd48c0f8f5d3d9e2a67883ec5fd"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa527bada9303e3b1364aa121d9a169f0"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#aa527bada9303e3b1364aa121d9a169f0">GetStoryCount</a> ()=0</td></tr><tr class="separator:aa527bada9303e3b1364aa121d9a169f0"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:af9167e48c7811b1f5546c820b1c8120e"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_u_i_d_list.html">UIDList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#af9167e48c7811b1f5546c820b1c8120e">GetStoryRefList</a> ()=0</td></tr><tr class="separator:af9167e48c7811b1f5546c820b1c8120e"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa6f9fa3416885edbafb8b7273b41d45d"><td align="right" class="memItemLeft" valign="top">virtual int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#aa6f9fa3416885edbafb8b7273b41d45d">FindIndexOfStoryAtYPosition</a> (<a class="el" href="class_p_m_real.html">PMReal</a> yPosition, bool16 ExtendLastLineOfLastStoryDown=kFalse)=0</td></tr><tr class="separator:aa6f9fa3416885edbafb8b7273b41d45d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ab3c6db795fff902e36215aedf333c887"><td align="right" class="memItemLeft" valign="top">virtual const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ab3c6db795fff902e36215aedf333c887">GetStoryRef</a> (int32 storyIndex)=0</td></tr><tr class="separator:ab3c6db795fff902e36215aedf333c887"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a6eee6baa4ab9bf8bdeac4cef130c5fad"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a6eee6baa4ab9bf8bdeac4cef130c5fad">SetStoryRef</a> (const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;ref, int32 storyIndex)=0</td></tr><tr class="separator:a6eee6baa4ab9bf8bdeac4cef130c5fad"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a1388a946986b7f6bb4e3ee37e69195ac"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a1388a946986b7f6bb4e3ee37e69195ac">GetStoryYDrawStart</a> (int32 storyIndex) const =0</td></tr><tr class="separator:a1388a946986b7f6bb4e3ee37e69195ac"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a8c839c6ff21d58374203d5b9db619884"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a8c839c6ff21d58374203d5b9db619884">SetStoryYDrawStart</a> (<a class="el" href="class_p_m_real.html">PMReal</a> yStartPosition, int32 storyIndex)=0</td></tr><tr class="separator:a8c839c6ff21d58374203d5b9db619884"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a5046aeff75128e20c8a32d282f0c4dac"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a5046aeff75128e20c8a32d282f0c4dac">IsStoryCollapsed</a> (int32 storyIndex)=0</td></tr><tr class="separator:a5046aeff75128e20c8a32d282f0c4dac"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ad8f7c1786e3846e087072b79271872a7"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ad8f7c1786e3846e087072b79271872a7">SetStoryCollapseState</a> (const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; &amp;storyIndexes, bool16 collapse)=0</td></tr><tr class="separator:ad8f7c1786e3846e087072b79271872a7"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ada72d9a414041f6c627cf7f0bb27123f"><td align="right" class="memItemLeft" valign="top">virtual bool16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ada72d9a414041f6c627cf7f0bb27123f">IsStoryBarSelected</a> (int32 storyIndex)=0</td></tr><tr class="separator:ada72d9a414041f6c627cf7f0bb27123f"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:adb5f94e7b678192dd54c90f35bfbad4d"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#adb5f94e7b678192dd54c90f35bfbad4d">SetStoryBarSelected</a> (int32 storyIndex, bool16 selected)=0</td></tr><tr class="separator:adb5f94e7b678192dd54c90f35bfbad4d"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7f17f2f4c1e5448cf31fbece9cb015db"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a7f17f2f4c1e5448cf31fbece9cb015db">RemoveAllStories</a> ()=0</td></tr><tr class="separator:a7f17f2f4c1e5448cf31fbece9cb015db"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:ae12f8336acecc00dd905f248156a6363"><td align="right" class="memItemLeft" valign="top">virtual bool8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#ae12f8336acecc00dd905f248156a6363">GetUseTextRuns</a> ()=0</td></tr><tr class="separator:ae12f8336acecc00dd905f248156a6363"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a704adda27e742fe1e0aedf36c6803084"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a704adda27e742fe1e0aedf36c6803084">DrawTextDisplayHighlight</a> (int32 storyIndex, const <a class="el" href="class_range_data.html">RangeData</a> &amp;newRange, const <a class="el" href="class_range_data.html">RangeData</a> &amp;oldRange)=0</td></tr><tr class="separator:a704adda27e742fe1e0aedf36c6803084"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7f37775e46740524b1cf439a91afee71"><td align="right" class="memItemLeft" valign="top">virtual TextIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a7f37775e46740524b1cf439a91afee71">DisplayIndexToModelIndex_</a> (int32 storyIndex, TextIndex displayIndex)=0</td></tr><tr class="separator:a7f37775e46740524b1cf439a91afee71"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a7c1137e7f87fe7e3fd8ab584b0d6f8a6"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_range_data.html">RangeData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a7c1137e7f87fe7e3fd8ab584b0d6f8a6">ModelToDisplayRange</a> (int32 storyIndex, const <a class="el" href="class_range_data.html">RangeData</a> &amp;modelRange, <a class="el" href="class_i_d_type.html">UID</a> leftExtra, <a class="el" href="class_i_d_type.html">UID</a> rightExtra)=0</td></tr><tr class="separator:a7c1137e7f87fe7e3fd8ab584b0d6f8a6"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9b4b55b866afcd027576591140ac4f11"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_range_data.html">RangeData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a9b4b55b866afcd027576591140ac4f11">DisplayToModelRange</a> (int32 storyIndex, const <a class="el" href="class_range_data.html">RangeData</a> &amp;displayRange, <a class="el" href="class_i_d_type.html">UID</a> *leftExtra, <a class="el" href="class_i_d_type.html">UID</a> *rightExtra)=0</td></tr><tr class="separator:a9b4b55b866afcd027576591140ac4f11"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a38f6ed837bfb6f598adcb128b074f170"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_range_data.html">RangeData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_text_lines.html#a38f6ed837bfb6f598adcb128b074f170">AtomicRange</a> (int32 storyIndex, <a class="el" href="class_range_data.html">RangeData</a> caret, const <a class="el" href="class_range_data.html">RangeData</a> &amp;relativeTo)=0</td></tr><tr class="separator:a38f6ed837bfb6f598adcb128b074f170"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="inherit_header pub_methods_class_i_p_m_unknown"><td colspan="2" onclick="javascript:toggleInherit(&#39;pub_methods_class_i_p_m_unknown&#39;)"><img alt="-" src="closed.png" />&nbsp;Public Member Functions inherited from <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a></td></tr><tr class="memitem:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual <a class="el" href="class_i_p_m_unknown.html">IPMUnknown</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aaa3b657383c4699900aaec5dc7348864">QueryInterface</a> (<a class="el" href="class_i_d_type.html">PMIID</a> interfaceID) const =0</td></tr><tr class="separator:aaa3b657383c4699900aaec5dc7348864 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#aa90872f1896d2f2623cbb6f0bff98443">AddRef</a> () const =0</td></tr><tr class="separator:aa90872f1896d2f2623cbb6f0bff98443 inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr><tr class="memitem:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td align="right" class="memItemLeft" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_p_m_unknown.html#a9365365afb903ae6a6450593930a0f9c">Release</a> () const =0</td></tr><tr class="separator:a9365365afb903ae6a6450593930a0f9c inherit pub_methods_class_i_p_m_unknown"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><table class="memberdecls"><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a> Friends</h2></td></tr><tr class="memitem:acf0af900f12af5fc3924f31e0afdd81f"><td align="right" class="memItemLeft" valign="top"><a class="anchor" id="acf0af900f12af5fc3924f31e0afdd81f"></a> class&nbsp;</td><td class="memItemRight" valign="bottom"><b>StoryManager</b></td></tr><tr class="separator:acf0af900f12af5fc3924f31e0afdd81f"><td class="memSeparator" colspan="2">&nbsp;</td></tr></table><a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2><div class="textblock"><p>The textlines are what defines what characters are in each line of the display on the screen. These are roughly equivalent to the WaxLines in the layout view. This interface owns all line information for the galley and story views. There are methods present in this interface for getting and setting of line information. Normally, non-internal callers will be interested in getting information only. The setting is generally left up the an interaction between this interface an the <a class="el" href="class_i_quick_composer.html">IQuickComposer</a> interface. The methods are divided up into several sections... Global Attributes - like display font <a class="el" href="class_line_description.html">LineDescription</a> Access - methods to get information about a specific line Line Maintenance - Methods used to modify lines (delete or add or recompose all). Also, there are methods to inform callers how many lines there are. Searching - Methods to search through lines and find one of interest based on textIndexes mostly. Text Display - Methods to display lines on screen. View Invaliing - Methods to cause parts of view corresponding to lines to redraw. Printing - mostly internal use for changes to drawing that occur when printing. Text Offset Type Conversion - story/galley uses two different types of text indices (Display and Model). The model indices match the indices in the <a class="el" href="class_i_text_model.html">ITextModel</a> while the display indices match the order that text is actually displayed on the screen in galley/story. The methods in this section aid in the conversion between the two types. Story Management - methods that deal with the management of multiple stories in a single view. All the stories text lines that are displayed in a single view are owned by a single instance of the <a class="el" href="class_i_text_lines.html">ITextLines</a> interface. That is to say there is one instance of this interface for each story/galley view no matter how many stories are displayed in the view. The methods in the story management section help get access to each individual stories text lines.<p>Notes: For routines that do not take a storyIndex it is assumed that the operation will apply to the currently active story. See the methods <a class="el" href="class_i_text_lines.html#a5dc6bdd48c0f8f5d3d9e2a67883ec5fd">GetCurrentStoryIndex()</a> and <a class="el" href="class_i_text_lines.html#a6a5654381bfa314b044d418daa0eac4b">SetCurrentStoryIndex()</a>. InCopy can have more than one story active in a view. InDesign has a one per view approach. </div><h2 class="groupheader">Member Function Documentation</h2><a class="anchor" id="a291ae88ee559124cee62a58b6b7b45e3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::AddFrameDivider </td><td>(</td><td class="paramtype"><a class="el" href="class_i_wax_line.html">IWaxLine</a> *&nbsp;</td><td class="paramname"><em>waxLine</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>atPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>previousLineFrameUID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrontMost</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This should typically only be used internally. This is used in galley view only (not story) to add the frame and column dividers. This items are actually lines of a specific type. This routine actually decides whether it&#39;s should add a divider or not base on the parameters passed in. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">waxLine</td><td>layout wax line information for the line that is after the potential frame divider. </td></tr><tr><td class="paramname">at</td><td>index where the divider might be added before. </td></tr><tr><td class="paramname">atPosition</td><td>the x position relative to the left side of the view to add the frame divider. </td></tr><tr><td class="paramname">previousLineFrameUID</td><td>uid of the frame of the wax line before this line. </td></tr><tr><td class="paramname">isFrontMost</td><td>if view is front most then draw will occur right away otherwise it will simply invalidate and draw later. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if divider was added kFalse otherwise. </dl></div></div><a class="anchor" id="ac5c414dbccfb2324c49112b5743cb2d1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::AddLineFromLayoutLine </td><td>(</td><td class="paramtype"><a class="el" href="class_i_wax_line.html">IWaxLine</a> *&nbsp;</td><td class="paramname"><em>waxLine</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>atPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineNumber</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>lineID</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrontMost</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This should typically only be used internally. Used to create a matching galley line from a layout wax line. Not used in story view. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">waxLine</td><td>layout wax line information to create a matching galley line for. </td></tr><tr><td class="paramname">at</td><td>index of galley line. </td></tr><tr><td class="paramname">atPosition</td><td>the x position relative to the left side of the view to add the frame divider. </td></tr><tr><td class="paramname">lineNumber</td><td>used to display in the info column multiple galley lines may map to one waxline because galley lines also wrap at view edge. </td></tr><tr><td class="paramname">lineID</td><td>a matching id is stored with the waxline. </td></tr><tr><td class="paramname">isFrontMost</td><td>if view is front most then draw will occur right away otherwise it will simply invalidate and draw later. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="ac373ea455cc3ab5eba1f78815b39e494"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::AddToPendingInvalRect </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>rectToAdd</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only. Stores rectanglar area to redraw when window is frontmost which draws sooner than a system inval would. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rectToAdd</td><td></td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a11940c03c45da30954792213fd082772"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::AppendLine </td><td>(</td><td class="paramtype">const <a class="el" href="class_line_description.html">LineDescription</a> &amp;&nbsp;</td><td class="paramname"><em>line</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>autoScroll</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Warning: This should typically only be used internally. The composer will call this to append new lines of text to the view. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">line</td><td>description of the line to append </td></tr><tr><td class="paramname">autoScroll</td><td>should the view scroll to the current text cursor location after appending the line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a38f6ed837bfb6f598adcb128b074f170"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_range_data.html">RangeData</a> ITextLines::AtomicRange </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_range_data.html">RangeData</a>&nbsp;</td><td class="paramname"><em>caret</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>relativeTo</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For a given caret position return an atomic range surrounding it (internal use) <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to operate on </td></tr><tr><td class="paramname">caret</td><td>model index </td></tr><tr><td class="paramname">relativeTo</td><td>extra data for internal use. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the atomic range </dl></div></div><a class="anchor" id="a9674cfdae2c2a2012b38144514659a40"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> ITextLines::CalculateLineRect </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a rectangle describing a line bounds. The rectangle is described in local coordinates of the view. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_p_m_rect.html">PMRect</a> which describes the line. The rectangles right side will actually be a very large number not the width of the line. If the true line width is desired get the <a class="el" href="class_line_description.html">LineDescription</a> and check the width field. </dl></div></div><a class="anchor" id="aebf9f77ff330d2c67b3d17aa98d6facf"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> ITextLines::CalculateLineRect </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a rectangle describing a line bounds. The rectangle is described in local coordinates of the writingview <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get line from </td></tr><tr><td class="paramname">at</td><td>index of line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_p_m_rect.html">PMRect</a> which describes the line. The rectangles right side will actually be a very large number not the width of the line. If the true line width is desired get the <a class="el" href="class_line_description.html">LineDescription</a> and check the width field. </dl></div></div><a class="anchor" id="a0ce29bccf7479dd4a79cd4926162356a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::ClearPendingInvalRect </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only <dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="accdd33ae435473ba23d8e9b60d1cb980"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::ComposeLayout </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Deprecated (don&#39;t use won&#39;t do anything) </div></div><a class="anchor" id="a21c76f1c3fbc475b327f3602461d5b12"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::DeleteAllLines </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This should typically only be used internally. The composer will call this to remove all lines from the view. <dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a3ce97fea35f32287a4bdcdc942599a25"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::DeleteCacheForAllLines </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only <dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a0f1101d30afabde0dc598c52505f5532"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::DeleteLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This should typically only be used internally. The composer will call this to remove unneeded lines from the view. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of the line to remove. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the line was removed successfully kFalse otherwise. </dl></div></div><a class="anchor" id="ac4fbb5d2c763b28b6d67e4f7cf05b2d0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextLines::DisplayIndexToModelIndex </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>displayIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert a display text index to a model text index <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">displayIndex</td><td>index to convert </td></tr></table></dl><dl class="section return"><dt>Returns<dd>model index corresponding to given display index. </dl></div></div><a class="anchor" id="a023777d319d9220136a1131987dea24f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextLines::DisplayIndexToModelIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>displayIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert a display text index to a model text index <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to use for conversion </td></tr><tr><td class="paramname">displayIndex</td><td>index to convert </td></tr></table></dl><dl class="section return"><dt>Returns<dd>model index corresponding to given display index. </dl></div></div><a class="anchor" id="a7f37775e46740524b1cf439a91afee71"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextLines::DisplayIndexToModelIndex_ </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>displayIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert a display index to a model index <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to operate on </td></tr><tr><td class="paramname">displayIndex</td><td>display index to convert </td></tr></table></dl><dl class="section return"><dt>Returns<dd>corresponding model index </dl></div></div><a class="anchor" id="a7c3afccfd167b8552b207768e3070ad5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::DisplayRangeToLineIndices </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>range</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>low</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>high</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Finds the corresponding line indeces for a given text index range. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>to use to get the lines from the range </td></tr><tr><td class="paramname">range</td><td>find lines corresponding to this text range </td></tr><tr><td class="paramname">low</td><td>first line with a value in the given range (returned to caller) </td></tr><tr><td class="paramname">high</td><td>last line with a value in the given range (returned to caller) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a9b4b55b866afcd027576591140ac4f11"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_range_data.html">RangeData</a> ITextLines::DisplayToModelRange </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>displayRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a> *&nbsp;</td><td class="paramname"><em>leftExtra</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a> *&nbsp;</td><td class="paramname"><em>rightExtra</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert a display range to a model index range <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to operate on </td></tr><tr><td class="paramname">displayRange</td><td>display index range to convert </td></tr><tr><td class="paramname">leftExtra</td><td>external callers may ignore. </td></tr><tr><td class="paramname">rightExtra</td><td>external callers may ignore. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>corresponding model index range </dl></div></div><a class="anchor" id="a262371a1244bab4a8e468df3df08c475"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::DrawLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_graphics_port.html">IGraphicsPort</a> *&nbsp;</td><td class="paramname"><em>gPort</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>clipRect</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>scrollCompensationValue</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_p_m_font.html">IPMFont</a> *&nbsp;</td><td class="paramname"><em>displayFont</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>displaySize</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>topLineInDraw</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draws a line to the view <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to draw </td></tr><tr><td class="paramname">gPort</td><td>graphics port to draw in </td></tr><tr><td class="paramname">clipRect</td><td>rectangle to clip drawing to </td></tr><tr><td class="paramname">scrollCompensationValue</td><td>value we are to within the view. </td></tr><tr><td class="paramname">displayFont</td><td>font to display main text of line in may be overridden for special run types or missing glyphs </td></tr><tr><td class="paramname">displaySize</td><td>size to display text of line at. </td></tr><tr><td class="paramname">topLineInDraw</td><td>is this the first line draw for this round of drawing. Pass kFalse if not sure </td></tr></table></dl><dl class="section return"><dt>Returns<dd>bool16 return kTrue if the line was draw otherwise kFalse (won&#39;t draw if does fall within clipRect) </dl></div></div><a class="anchor" id="a704adda27e742fe1e0aedf36c6803084"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::DrawTextDisplayHighlight </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>newRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>oldRange</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Draw a highlight range while erasing previous range. Called internally to match selection state. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to operate on </td></tr><tr><td class="paramname">newRange</td><td>range to select (highlight) </td></tr><tr><td class="paramname">oldRange</td><td>range to deselect (unhighlight) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a8367fc745583b5457435afced339b045"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::DrawTextHighlight </td><td>(</td><td class="paramtype">const <a class="el" href="class_in_design_1_1_text_range.html">InDesign::TextRange</a> &amp;&nbsp;</td><td class="paramname"><em>newSelection</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_in_design_1_1_text_range.html">InDesign::TextRange</a> &amp;&nbsp;</td><td class="paramname"><em>oldSelection</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_selection_extension.html">SelectionExtension</a> *&nbsp;</td><td class="paramname"><em>newExtension</em> = <code>nil</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_selection_extension.html">SelectionExtension</a> *&nbsp;</td><td class="paramname"><em>oldExtension</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to draw a text highlight in the story/galley views. Should be called from the selection hiliter (BaseTextSelectionHiliter) shouldn&#39;t call from other places doing so can cause highlight draws to occur. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">newSelection</td><td>New selection range to draw </td></tr><tr><td class="paramname">oldSelection</td><td>Old selection range to erase </td></tr><tr><td class="paramname">newExtension</td><td>New selection extension uids to draw </td></tr><tr><td class="paramname">oldExtension</td><td>Old selection extension uids to erase </td></tr></table></dl><dl class="section return"><dt>Returns<dd>void </dl></div></div><a class="anchor" id="a162df6355c71cbd170054c7e724bcfd5"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::FindCharacterAtXPosition </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>atLineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a> &amp;&nbsp;</td><td class="paramname"><em>xPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>offsetIntoLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find a character at a given x (horizontal from view left) draw position <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">atLineIndex</td><td>line index within the current story </td></tr><tr><td class="paramname">xPosition</td><td>horizontal postion (from view left) </td></tr><tr><td class="paramname">offsetIntoLine</td><td>gives the offset (index) within of the line of the hit character. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>see note description below. The return value means the following: kFalse - everything went normally. All the values are accurate kTrue - The xPosition was past the end of line offsetIntoLine will contain the first character on the next line xPosition will contain the very end of the current line </dl></div></div><a class="anchor" id="a02f9cd7590c8e20939420dd16ca34b00"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::FindIndexOfLineAtDisplayOffset </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>offset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>offsetIntoLine</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">RangeData::Lean&nbsp;</td><td class="paramname"><em>lean</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Finds the line and the offset into the line of the display index requested. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">offset</td><td>text index to search for in the text lines </td></tr><tr><td class="paramname">offsetIntoLine</td><td>will contain the number of characters into the line the display index falls at. </td></tr><tr><td class="paramname">lean</td><td>for cases where the text index falls between two lines this param will facilitate the choice the method will make. LeanBack use first line while LeanForward will use the second </td></tr></table></dl><dl class="section return"><dt>Returns<dd>returns index of line that the given display index (offset param) falls in or if none found then -1 </dl></div></div><a class="anchor" id="abf8b282550f478aab1d16b4844ff85aa"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::FindIndexOfLineAtDisplayOffset </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>offset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>offsetIntoLine</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">RangeData::Lean&nbsp;</td><td class="paramname"><em>lean</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Finds the line and the offset into the line of the display index requested. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>search in this story for the display index </td></tr><tr><td class="paramname">offset</td><td>text index to search for in the text lines </td></tr><tr><td class="paramname">offsetIntoLine</td><td>will contain the number of characters into the line the display index falls at. </td></tr><tr><td class="paramname">lean</td><td>for cases where the text index falls between two lines this param will facilitate the choice the method will make. LeanBack use first line while LeanForward will use the second </td></tr></table></dl><dl class="section return"><dt>Returns<dd>returns index of line that the given display index (offset param) falls in or if none found then -1 </dl></div></div><a class="anchor" id="ada788fc2e4f4d7102387cd7c8d029e0e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::FindIndexOfLineAtPoint </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>point</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a coordinate in the view give the index of a line at this coordinate <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">point</td><td>coordinate to find line at </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of line at the given coordinate if none can be found then -1 </dl></div></div><a class="anchor" id="a39ed38571216ddaa2729245d509c18ad"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::FindIndexOfLineAtPoint </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>point</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a coordinate in the view give the index of a line at this coordinate <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">point</td><td>coordinate to find line at </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of line at the given coordinate if none can be found then -1 </dl></div></div><a class="anchor" id="a378624cda407a0a380998c8406b7dff3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::FindIndexOfLineAtTextOffset </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>offset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>offsetIntoLine</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">RangeData::Lean&nbsp;</td><td class="paramname"><em>lean</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>checkRunBoundary</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Finds the line and the offset into the line of the text index requested. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">offset</td><td>text index to search for in the text lines </td></tr><tr><td class="paramname">offsetIntoLine</td><td>will contain the number of characters into the line the text index falls at. </td></tr><tr><td class="paramname">lean</td><td>for cases where the text index falls between two lines this param will facilitate the choice the method will make. LeanBack use first line while LeanForward will use the second </td></tr><tr><td class="paramname">checkRunBoundary</td><td>if true then for deleted text if the offset is at the start of deleted text make sure we get the first line not the line at the end of the deleted text run. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>returns index of line that the given text index (offset param) falls in or if none found then -1 </dl></div></div><a class="anchor" id="a1fc3ec86dd9f2a0a24ffb187dc76044e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::FindIndexOfLineWithID </td><td>(</td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>id</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return an index of a line with a specific id. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">id</td><td>search the text lines for an id that matches this </td></tr></table></dl><dl class="section return"><dt>Returns<dd>returns index of line with matching id or -1 if none is found. </dl></div></div><a class="anchor" id="abc7a954fbcb38160997ff6e24fcf51b3"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::FindIndexOfLineWithID </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>id</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return an index of a line with a specific id. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of the story to search in. </td></tr><tr><td class="paramname">id</td><td>search the text lines for an id that matches this </td></tr></table></dl><dl class="section return"><dt>Returns<dd>returns index of line with matching id or -1 if none is found. </dl></div></div><a class="anchor" id="aa6f9fa3416885edbafb8b7273b41d45d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::FindIndexOfStoryAtYPosition </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>yPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>ExtendLastLineOfLastStoryDown</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find the index of a story at a given y view position <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">yPosition</td><td>the y view position </td></tr><tr><td class="paramname">ExtendLastLineOfStoryDown</td><td>count area below the last line of the story as belonging to the last story </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of story at the given yPosition (may be -1 if none found) </dl></div></div><a class="anchor" id="a5dc6bdd48c0f8f5d3d9e2a67883ec5fd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetCurrentStoryIndex </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Index of currently active story <dl class="section return"><dt>Returns<dd>index of active story </dl></div></div><a class="anchor" id="a9fa60083ad53f4cff1cdccd5783a12c9"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_string.html">PMString</a>&amp; ITextLines::GetDisplayFontName </td><td>(</td><td class="paramtype">IFontMgr::FontStyleBits&nbsp;</td><td class="paramname"><em>styleBits</em> = <code>IFontMgr::kNormal</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Can be used to find out the name of the display font. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">styleBits</td><td>the font variant type (see <a class="el" href="class_i_font_mgr.html">IFontMgr</a>). </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The display font name. </dl></div></div><a class="anchor" id="af41a9601ca23acfa535db0d00a4ac60f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetDisplayFontSize </td><td>(</td><td class="paramtype"><a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a>&nbsp;</td><td class="paramname"><em>capMode</em> = <code>IDrawingStyle::kCapNormal</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the point size of the display font. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">styleBits</td><td>the font variant type (see <a class="el" href="class_i_font_mgr.html">IFontMgr</a>). </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The point size. </dl></div></div><a class="anchor" id="ae598244fe85d314b3e8aabc61cf1869b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetFirstTrueTextLineIndex </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Index of first line that actually might hold text as opposed to a storyBar or other decoration <dl class="section return"><dt>Returns<dd>index of the first line with text in it. </dl></div></div><a class="anchor" id="ae103de3b7864bffaf737a73a90cf90df"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetFirstTrueTextLineIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Index of first line that actually might hold text as opposed to a storyBar or other decoration <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get first valid index of. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the first line with text in it. </dl></div></div><a class="anchor" id="a7f0bdce97477f1e9c25d153f6d5d21dd"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::GetHilite </td><td>(</td><td class="paramtype">TextIndex &amp;&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex &amp;&nbsp;</td><td class="paramname"><em>end</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_selection_extension.html">SelectionExtension</a> *&nbsp;</td><td class="paramname"><em>extendToDeletedUIDs</em> = <code>nil</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Method to get the current text highlight information. It really just returns the current selection information <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">start</td><td>the beginning of the current text selection </td></tr><tr><td class="paramname">end</td><td>the end of the current text selection </td></tr><tr><td class="paramname">extendToUIDPair</td><td>current uids for track change deleted text selection. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if selection was set. </dl></div></div><a class="anchor" id="af02c5b40a8f61d7d3094e499d2957767"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetIndexOfFirstLineInRect </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="paramname"><em>rectToFit</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>partialFitOK</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get first line that intersects the rectangle. This is a quick routine it uses a estimation to get close first then zeros in on the first line from there. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rectToFit</td><td>rectangle to check for a intersecting line </td></tr><tr><td class="paramname">partialFitOK</td><td>ok to return a line that doesn&#39;t totally fall within a rectagle </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of line that first intersects a rectangle (first means starting at text index 0 and incrementing up). </dl></div></div><a class="anchor" id="afea062fb88b3f605a13b34715380c719"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetLastLineIndex </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the index of the last line in the current story <dl class="section return"><dt>Returns<dd>index of the last line. </dl></div></div><a class="anchor" id="ace5c503fc8e52a439397795c9ba9d7e7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetLastLineIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the index of the last line in the specified story <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get the last line index of. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the last line. </dl></div></div><a class="anchor" id="a85163e74104e2a2380669587955887af"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetLastValidIndex </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the last updated line (see the <a class="el" href="class_i_text_lines.html#ac9d25a8b4cb685c04cc1ae089d1cd18a">UpdateLine()</a> method). <dl class="section return"><dt>Returns<dd>index of the last valid line. </dl></div></div><a class="anchor" id="a6230d3135e38cf8211627fe2b6055595"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetLastValidIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Return the last updated line (see the <a class="el" href="class_i_text_lines.html#ac9d25a8b4cb685c04cc1ae089d1cd18a">UpdateLine()</a> method). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get last valid line from </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of the last valid line. </dl></div></div><a class="anchor" id="a46a05aed481bf225090b8c0a51b37844"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_line_description.html">LineDescription</a> ITextLines::GetLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>returnRuns</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a rectangle describing a line bounds. The rectangle is described in local coordinates of the writingview <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get line from </td></tr><tr><td class="paramname">at</td><td>index of line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_p_m_rect.html">PMRect</a> which describes the line. The rectangles right side will actually be a very large number not the width of the line. If the true line width is desired get the <a class="el" href="class_line_description.html">LineDescription</a> and check the width field. </dl></div></div><a class="anchor" id="a4d2a115e53a4258aec70b64d10f75018"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_line_description.html">LineDescription</a> ITextLines::GetLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>returnRuns</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a full line description for a specific line. Some data in this structure may not be up to date until <a class="el" href="class_i_text_lines.html#ac9d25a8b4cb685c04cc1ae089d1cd18a">UpdateLine()</a> is called. Specifically, the text indexes associated with the line are updated with the <a class="el" href="class_i_text_lines.html#ac9d25a8b4cb685c04cc1ae089d1cd18a">UpdateLine()</a> method (in this same interface see comments by the UpdateLine method). <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get line from </td></tr><tr><td class="paramname">at</td><td>index of line. </td></tr><tr><td class="paramname">returnRuns</td><td>fill in kTrue to get the <a class="el" href="class_run_description.html">RunDescription</a> pointer filled in kFalse (default) otherwise. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_line_description.html">LineDescription</a> class that has information on what is contained in the line. </dl></div></div><a class="anchor" id="a1a40be59ff3a1ecb7b453ef7f6fa4bd1"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextLines::GetLineEndOffsetAtLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the text model index of a line end. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a text model index of the last position in the line (index of character at the start of the next line). </dl></div></div><a class="anchor" id="adb712326360f8b97324802ff8431a67b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetLineHeight </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>textOnly</em> = <code>kFalse</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the height of a line. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">textOnly</td><td>if you only want to get the text portion not the extra for line spacing pass true. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>the height of a line. </dl></div></div><a class="anchor" id="a49450faf625c8f759f974f053df0611f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::GetLineNumberStartEnd </td><td>(</td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 &amp;&nbsp;</td><td class="paramname"><em>end</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the line number (galley) of the last line and first line in a story <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">start</td><td>first line number in a story (returned) </td></tr><tr><td class="paramname">end</td><td>last line number in a story (returned) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a68a07a31812b5d44b336b0d930180dc7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextLines::GetLineStartOffsetAtLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the text model index of a line start. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a text model index of the first character in a line. </dl></div></div><a class="anchor" id="aa7b9d21152e85baf10961f17347ce104"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual LinesType ITextLines::GetLinesType </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Will describe the type of line endings in terms of the LinesType enum. <dl class="section return"><dt>Returns<dd>It will return either that the lines have kWindowLineEnds meaning that the lines are a story view. Or that the lines are kLayoutLineEnds meaning the lines are a galley view (galley view is InCopy only). </dl></div></div><a class="anchor" id="ad103a9eefef185b9575112d8baaad143"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetPages </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_rect.html">PMRect</a>&nbsp;</td><td class="paramname"><em>rectToFit</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>columns</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get number of pages to print text <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">rectToFit</td><td>specifies page height </td></tr><tr><td class="paramname">columns</td><td>number of columns to print on a page </td></tr></table></dl><dl class="section return"><dt>Returns<dd>index of page. </dl></div></div><a class="anchor" id="ad456ae069ac163fe33e8ad4034b7fe48"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a> ITextLines::GetPendingInvalRect </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only doesn&#39;t include an area to be redrawn do to a system inval <dl class="section return"><dt>Returns<dd>rectangular area to redraw </dl></div></div><a class="anchor" id="a1b0c1e3b12af1934b70cce1073016ece"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_rect.html">PMRect</a>* ITextLines::GetPendingInvalsForUndoRedo </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only. </div></div><a class="anchor" id="a7b5c56977b2dd7a540ff431e476e47c2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::GetPlayPendingInvals </td><td>(</td><td class="paramname"></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is drawing currently suspended <dl class="section return"><dt>Returns<dd>kTrue if drawing is NOT suspended. </dl></div></div><a class="anchor" id="aa527bada9303e3b1364aa121d9a169f0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual int32 ITextLines::GetStoryCount </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Returns the number of stories in displayed in the story/galley view <dl class="section return"><dt>Returns<dd>number of stories. </dl></div></div><a class="anchor" id="ab3c6db795fff902e36215aedf333c887"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual const <a class="el" href="class_u_i_d_ref.html">UIDRef</a>&amp; ITextLines::GetStoryRef </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a story ref for a given story index <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get a ref for </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_u_i_d_ref.html">UIDRef</a> of the story </dl></div></div><a class="anchor" id="af9167e48c7811b1f5546c820b1c8120e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_u_i_d_list.html">UIDList</a>* ITextLines::GetStoryRefList </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get a list (in display order) of the uidref&#39;s of all stories displayed in the story/galley view. <dl class="section return"><dt>Returns<dd>list of story ref&#39;s (<a class="el" href="classk_text_story_boss.html">kTextStoryBoss</a>) </dl></div></div><a class="anchor" id="a1388a946986b7f6bb4e3ee37e69195ac"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetStoryYDrawStart </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em></td><td>)</td><td> const</td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the yDraw position of a story <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>story index to get vertical position of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>Vertical position from the top of the view where the story will start to draw at </dl></div></div><a class="anchor" id="ae12f8336acecc00dd905f248156a6363"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool8 ITextLines::GetUseTextRuns </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Is view displaying track changes and notes. <dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a610110d066bc96ee0aa4e609225c0502"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetXPosition </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the left start X offset of a line of the current story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_p_m_real.html">PMReal</a> which is the X position of the line measured from the left edge of the view. </dl></div></div><a class="anchor" id="a1562491d529aa990093e9d9745e86042"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetXPositionOfCharacter </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>atLineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>characterOffsetIntoLine</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>absoluteTextOffset</em> = <code>-1</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isEndPosition</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">ExtendType&nbsp;</td><td class="paramname"><em>extend</em> = <code>kDontExtend</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>absoluteTextEndOffset</em> = <code>-1</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a text index offset into a line return the horizontal distance this character is drawn at on the screen from the left side of the view. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">atLineIndex</td><td>index of line we want the x-position of a character for </td></tr><tr><td class="paramname">characterOffsetIntoLine</td><td>text model index of character (offset into line not from model start) </td></tr><tr><td class="paramname">absoluteTextOffset</td><td>text model index of character (model start) </td></tr><tr><td class="paramname">isEndPosition</td><td>is this position at the end of a line. </td></tr><tr><td class="paramname">extend</td><td>used for track change deleted text (internally) if true extend distance to include the deleted text run adjacent (if present). </td></tr><tr><td class="paramname">absoluteTextEndOffset</td><td>used internally for track change deleted text leave -1 </td></tr></table></dl><dl class="section return"><dt>Returns<dd>draw horizontal distance (pixels) that the character lives at from view left. </dl></div></div><a class="anchor" id="a806e2edde34eb9085e0e532f6b627e46"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetXPositionOfCharacterInRun </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>atLineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>runIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>characterOffsetIntoRun</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given an index of a run within a line and a line index within the current story and a character offset within the run find the display distance of that character offset <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">atLineIndex</td><td>line index within the current story </td></tr><tr><td class="paramname">index</td><td>of a run within a line </td></tr><tr><td class="paramname">character</td><td>offset within the run </td></tr></table></dl><dl class="section return"><dt>Returns<dd>return the display index of the requested character offset from run left. </dl></div></div><a class="anchor" id="af85a4274e16a18c0d82f655b027bbc93"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetXPositionOfDisplayOffsetCharacter </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>atLineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>displayOffsetIntoLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a display offset into a line return the horizontal distance this character is drawn at on the screen from the left side of the view. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">atLineIndex</td><td>index of line we want the x-position of a character for </td></tr><tr><td class="paramname">displayOffsetIntoLine</td><td>display index into a line </td></tr></table></dl><dl class="section return"><dt>Returns<dd>draw horizontal distance (pixels) that the character lives at from view left. </dl></div></div><a class="anchor" id="ad2bfb520c693bbaf9de337d32b2f33d6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetXPositionOfDisplayOffsetCharacter </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>atLineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>displayOffsetIntoLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Given a display offset into a line return the horizontal distance this character is drawn at on the screen from the left side of the view. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>story that the line lives in </td></tr><tr><td class="paramname">atLineIndex</td><td>index of line we want the x-position of a character for </td></tr><tr><td class="paramname">displayOffsetIntoLine</td><td>display index into a line </td></tr></table></dl><dl class="section return"><dt>Returns<dd>draw horizontal distance (pixels) that the character lives at from view left. </dl></div></div><a class="anchor" id="a6d2ef9f4a2312566bbfdaafb63690623"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetYPosition </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the Y offset of the line. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>The y position of the top of the line. The y position of the first line in the view is 0. This is an absolute position, windows and scrolling do not come into play. </dl></div></div><a class="anchor" id="a88bcbb3bb5c085ac2a9f58506f08edc0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::GetYPosition </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Get the left start X offset of a line. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get line from. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>a <a class="el" href="class_p_m_real.html">PMReal</a> which is the X position of the line measured from the left edge of the view. </dl></div></div><a class="anchor" id="ab43598f94baf5dcd5c68feadbe5bc399"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_p_m_real.html">PMReal</a> ITextLines::HitTestText </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32 *&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_p_m_point.html">PMPoint</a> &amp;&nbsp;</td><td class="paramname"><em>x</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex *&nbsp;</td><td class="paramname"><em>nextLine</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Find line at point and return a text index hit in galley display indexes <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>story being hit tested </td></tr><tr><td class="paramname">lineIndex</td><td>index of line hit </td></tr><tr><td class="paramname">x</td><td>point to find line at </td></tr><tr><td class="paramname">nextLine</td><td>text index of the first character in the next line after the line hit (useful for the selection code) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>text index of last character in the hit line (text index is in display indexes must convert to model if you wish to use with the text model see <a class="el" href="class_i_text_lines.html#a9b4b55b866afcd027576591140ac4f11">DisplayToModelRange()</a>) </dl></div></div><a class="anchor" id="a1ebf9fdb7cadad35420bc0bdaf94068c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::InitializeLines </td><td>(</td><td class="paramtype">const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_compose_information.html">ComposeInformation</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>composeInformation</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>forceInitialization</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>scrollARangeIntoView</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Recompose all lines. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">composeInformation</td><td>list of stories to recompose </td></tr><tr><td class="paramname">forceInitialization</td><td>recompose even if already initialized if TRUE. </td></tr><tr><td class="paramname">scrollARangeIntoView</td><td>if a range is selected scroll it into view if this is TRUe </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="ac8d5d46cf13259655eb6a77b0b161f0c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::InitializeStoryCollapsedState </td><td>(</td><td class="paramtype"><a class="el" href="class_k2_vector.html">K2Vector</a>&lt; <a class="el" href="class_story_state.html">StoryState</a> &gt; &amp;&nbsp;</td><td class="paramname"><em>storyList</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set stories intial collapse or expanded state when printing <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyList</td><td>stories and their corresponding collapse state </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a9ccb9b92c85c9b6e114631e81e2e17b6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::InsertLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>beforeIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_line_description.html">LineDescription</a> &amp;&nbsp;</td><td class="paramname"><em>line</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>autoScroll</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This should typically only be used internally. The composer will call this to insert a new lines of text to the view. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">beforeIndex</td><td>text line index to insert before. </td></tr><tr><td class="paramname">line</td><td>description of the line to insert. </td></tr><tr><td class="paramname">autoScroll</td><td>should the view scroll to the current text cursor location after appending the line. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the line was inserted successfully kFalse otherwise. </dl></div></div><a class="anchor" id="ac1e100831ad62e0cc98004e6298fbb1c"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::InvalidateLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrontMost</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Invalidate line for later refresh <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to draw </td></tr><tr><td class="paramname">isFrontMost</td><td>is the view frontMost (can pass false if unsure it will still work) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a4431e5cbe4d2e64a70c42ebf1fbdad91"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::InvalidateRun </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>whichRun</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>startOffsetInRun</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>endOffsetInRun</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrontMost</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Invalidate run within a line for later refresh. Normally, InvalidateLine is fine instead of this routine and much simpler to use <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to draw </td></tr><tr><td class="paramname">whichRun</td><td>index of run within line to draw </td></tr><tr><td class="paramname">startOffsetInRun</td><td>textIndex into run to start inval at </td></tr><tr><td class="paramname">endOffsetInRun</td><td>text index into run to end inval at </td></tr><tr><td class="paramname">isFrontMost</td><td>is the view frontMost (can pass false if unsure it will still work) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="ada72d9a414041f6c627cf7f0bb27123f"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::IsStoryBarSelected </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>A story divider bar may be selected (InCopy only) see if it is selected <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story (and associated story bar to check) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>is the bar selected if so returns kTrue </dl></div></div><a class="anchor" id="a5046aeff75128e20c8a32d282f0c4dac"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::IsStoryCollapsed </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>InCopy only stories may be collapsed (hidden except for story divider) see if this is true for a given story <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index to check if collapsed </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if collapsed </dl></div></div><a class="anchor" id="a6215fa3fdcf7b82b6ec5e4409296d2f2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextLines::ModelIndexToDisplayIndex </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>modelIndex</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert a model text index to a display text index <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">modelIndex</td><td>to convert </td></tr></table></dl><dl class="section return"><dt>Returns<dd>best guess display index see <a class="el" href="class_i_text_lines.html#a7c1137e7f87fe7e3fd8ab584b0d6f8a6">ModelToDisplayRange()</a> for a more accurate conversion (more that one display index may map to a single model index). </dl></div></div><a class="anchor" id="a397b730827768d741d147ef49c6b0994"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextLines::ModelIndexToDisplayIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>modelIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert a model text index to a display text index <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>story to use for the conversion </td></tr><tr><td class="paramname">modelIndex</td><td>to convert </td></tr></table></dl><dl class="section return"><dt>Returns<dd>best guess display index (more that one display index may map to a single model index). </dl></div></div><a class="anchor" id="ab87cfb41c60ebcce8c8de451b675c93d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual TextIndex ITextLines::ModelOffsetToDisplayOffset </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>modelOffset</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>lineIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>ignoreRunTypes</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert a model text index to a display text index. Mostly for internal use see ModelIndexToDisplayIndex instead. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">modelOffset</td><td>model text index to convert </td></tr><tr><td class="paramname">lineIndex</td><td>line that the model text index lives in </td></tr><tr><td class="paramname">ignoreRunTypes</td><td>normally routine will only normally look through run types &lt; <a class="el" href="class_run_description.html#a2f1eddb263a1cdf7b3699e607e210339a793a594e6b04a3da1134658867e2f95c">RunDescription::endPrimaryStoryTypes</a> if true this routine will look through other types as well. kFalse is normally what is wanted </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a7c1137e7f87fe7e3fd8ab584b0d6f8a6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_range_data.html">RangeData</a> ITextLines::ModelToDisplayRange </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>modelRange</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>leftExtra</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>rightExtra</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Convert a model range to a display index range <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to operate on </td></tr><tr><td class="paramname">modelRange</td><td>model index range to convert </td></tr><tr><td class="paramname">leftExtra</td><td>only used for track changes external users should most likely pass kInvalidUID </td></tr><tr><td class="paramname">rightExtra</td><td>only used for track changes external users should most likely pass kInvalidUID </td></tr></table></dl><dl class="section return"><dt>Returns<dd>corresponding display range </dl></div></div><a class="anchor" id="a8440f6dbab5da88246dcedb93564e9d2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::PlayPendingInvals </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>instantDraw</em> = <code>kFalse</code></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only. Draw all pending invals now don&#39;t wait for a system inval to come through <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">instantDraw</td><td>request immediate drawing instead of inval. May not happen if drawing is suspended. Usually fine to let inval handle it. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a26b57935bd7c8361186af53f3bdfba1e"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual <a class="el" href="class_i_font_instance.html">IFontInstance</a>* ITextLines::QueryDisplayFontInstance </td><td>(</td><td class="paramtype">IFontMgr::FontStyleBits&nbsp;</td><td class="paramname"><em>styleBits</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_drawing_style.html#a2da972b60f64566576726c581f370588">IDrawingStyle::CapitalizeMode</a>&nbsp;</td><td class="paramname"><em>capMode</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Query an instance of the display font. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">styleBits</td><td>the font variant type (see <a class="el" href="class_i_font_mgr.html">IFontMgr</a>). </td></tr><tr><td class="paramname">capMode</td><td>interested instance of display font for which type kCapSmallLowercase, kCapNormal, kCapAll, kCapSmallEverything. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>instance of the display font. </dl></div></div><a class="anchor" id="a6459059d22147066bae10b83f96496d6"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::RecordUndoRedoPendingInvals </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_rect.html">PMRect</a> &amp;&nbsp;</td><td class="paramname"><em>invals</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use only. </div></div><a class="anchor" id="a7f17f2f4c1e5448cf31fbece9cb015db"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::RemoveAllStories </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Clear a view of all stories must put stories back in quickly. Should only be used internally normally <dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a101f218e48e8aa9e04245c3fefb76ac4"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::RemoveExcessLines </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>startIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>isFrontMost</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>autoScroll</em> = <code>kTrue</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This should typically only be used internally. Used to remove excess lines that may be present after compostion finishes. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">startIndex</td><td>. </td></tr><tr><td class="paramname">atPosition</td><td>the x position relative to the left side of the view to add the frame divider. </td></tr><tr><td class="paramname">lineNumber</td><td>used to display in the info column multiple galley lines may map to one waxline because galley lines also wrap at view edge. </td></tr><tr><td class="paramname">lineID</td><td>a matching id is stored with the waxline. </td></tr><tr><td class="paramname">isFrontMost</td><td>if view is front most then draw will occur right away otherwise it will simply invalidate and draw later. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a397ea2dc745db9ec9c1707563df79558"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::ReplaceLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">const <a class="el" href="class_line_description.html">LineDescription</a> &amp;&nbsp;</td><td class="paramname"><em>line</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This should typically only be used internally. The composer will call this to replace a line with a different line description. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>the index of the line to replace. </td></tr><tr><td class="paramname">line</td><td>description of the new line that will replace the old line information. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>kTrue if the line was replaced successfully kFalse otherwise. </dl></div></div><a class="anchor" id="afa8d3cfc82793e0e027dacf57e38717d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::ResumePlayPendingInvals </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Resume drawing (causes a full screen redraw) <dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a9f1e079af8f7eb7c44050437a364abd0"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetComposeLayout </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>shouldCompose</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Deprecated (don&#39;t use won&#39;t do anything) </div></div><a class="anchor" id="a6a5654381bfa314b044d418daa0eac4b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetCurrentStoryIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>i</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set the current model display index (used for all routines in <a class="el" href="class_i_text_lines.html">ITextLines</a> that don&#39;t take a storyIndex). Note that these indexes are specific to the story/galley view not the <a class="el" href="class_i_story_list.html">IStoryList</a> interface. See the <a class="el" href="class_i_text_lines.html#af9167e48c7811b1f5546c820b1c8120e">GetStoryRefList()</a> routine in this file. They are indexes into the ref list returned by <a class="el" href="class_i_text_lines.html#af9167e48c7811b1f5546c820b1c8120e">GetStoryRefList()</a>. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">i</td><td>index of story to use </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a86e82478c3da7dbf4962bf3c47a0f632"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetHilite </td><td>(</td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>start</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">TextIndex&nbsp;</td><td class="paramname"><em>end</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>drawHilite</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>extendToDeletedUID</em> = <code>kInvalidUID</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This no longer has meaning in Dragontail (depricated) Set a selection instead </div></div><a class="anchor" id="a6d78474f94e184089d9e8e79c2d269e2"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetHilite </td><td>(</td><td class="paramtype">const <a class="el" href="class_range_data.html">RangeData</a> &amp;&nbsp;</td><td class="paramname"><em>range</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>drawHilite</em> = <code>kTrue</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype"><a class="el" href="class_i_d_type.html">UID</a>&nbsp;</td><td class="paramname"><em>extendToDeletedUID</em> = <code>kInvalidUID</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>This no longer has meaning in Dragontail (depricated) Set a selection instead </div></div><a class="anchor" id="ade2b5df9d27fb6cc2caf4cf082d3d084"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetLastValidIndex </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>index</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>It&#39;s not expected 3rd parties would use this. This is only set from the composer. Improper use can cause crashes and screen draw problems. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">index</td><td>index of the last valid line </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a5992901d871f3d67ab4b0cbcf99a392b"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetLinesType </td><td>(</td><td class="paramtype">LinesType&nbsp;</td><td class="paramname"><em>lType</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Allows the caller to change the type of line endings. Should normally go through the IGalleyUtils::SetDocWindowView() to do this. This call should only be used in InCopy since InDesign doesn&#39;t support galley view only story. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">lType</td><td>can pass in either kWindowLineEnds or kLayoutLineEnds (see <a class="el" href="class_i_text_lines.html#aa7b9d21152e85baf10961f17347ce104">GetLinesType()</a>) </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="ae5222c3b54a66d21f487e109291baad8"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetRanges </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_string.html">PMString</a>&nbsp;</td><td class="paramname"><em>ranges</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set ranges of text to print <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ranges</td><td>ranges of text to print </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="adb5f94e7b678192dd54c90f35bfbad4d"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetStoryBarSelected </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>selected</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Mark a story bar as selected (internal use) <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story (and associated story bar to check) </td></tr><tr><td class="paramname">selected</td><td>value to set selected state to. kTrue if want to select. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="ad8f7c1786e3846e087072b79271872a7"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetStoryCollapseState </td><td>(</td><td class="paramtype">const <a class="el" href="class_k2_vector.html">K2Vector</a>&lt; int32 &gt; &amp;&nbsp;</td><td class="paramname"><em>storyIndexes</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>collapse</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>For a list of story indeces in a view set the collapse state <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">stories</td><td>indices to collapse or expand </td></tr><tr><td class="paramname">collapse</td><td>kTrue to collapse or false to expand </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a6eee6baa4ab9bf8bdeac4cef130c5fad"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetStoryRef </td><td>(</td><td class="paramtype">const <a class="el" href="class_u_i_d_ref.html">UIDRef</a> &amp;&nbsp;</td><td class="paramname"><em>ref</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Used to rearrange draw order of stories set a ref at a given story index. Should use the higher level <a class="el" href="classk_reorder_stories_cmd_boss.html">kReorderStoriesCmdBoss</a> to do this correctly <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">ref</td><td>story to insert </td></tr><tr><td class="paramname">storyIndex</td><td>index to place story at </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a8c839c6ff21d58374203d5b9db619884"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SetStoryYDrawStart </td><td>(</td><td class="paramtype"><a class="el" href="class_p_m_real.html">PMReal</a>&nbsp;</td><td class="paramname"><em>yStartPosition</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Internal use, set the yDraw position of a story <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">yStartPosition</td><td>where to start drawing the given story at horizontally. </td></tr><tr><td class="paramname">storyIndex</td><td>story index to set vertical position of </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="aceb806a338c8f25be5962efd686ff682"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual bool16 ITextLines::SetUniqueIDOfLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">uint32&nbsp;</td><td class="paramname"><em>newID</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Set an ID is used to connect TextLines to WaxLines. Shouldn&#39;t be called externally. Specific to galley view story doesn&#39;t care about this <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to assign an id to </td></tr><tr><td class="paramname">newID</td><td>id to store with a text line this id will match an id stored with a equivalent <a class="el" href="class_i_wax_line.html">IWaxLine</a>. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a0140e5d7f73e54f4a7c6424af9042037"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SuspendPlayPendingInvals </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Suspend drawing temporarily while we do some multiple step operations and we don&#39;t want to see the screen refreshing during these. <dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a47b1dae6c0b4d55e610594850725e103"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::SyncScrolling </td><td>(</td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>lockRelativePosition</em> = <code>kFalse</code>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>scrollToASelectionRange</em> = <code>kFalse</code>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Update the scroll bar values and scroll the view to the current selection location. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">lockRelativePosition</td><td>don&#39;t scroll just update the scroll bars used during background composition if TRUE </td></tr><tr><td class="paramname">scrollToASelectionRange</td><td>scroll to a range not just an insertion point if TRUE </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none </dl></div></div><a class="anchor" id="a5829862a3aeb3e1aa239ca109a7e2575"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::UpdateFontInfo </td><td>(</td><td class="paramtype">const <a class="el" href="class_p_m_string.html">PMString</a> *&nbsp;</td><td class="paramname"><em>fontName</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">bool16&nbsp;</td><td class="paramname"><em>initializeLines</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Allows the caller to change the display font for the view. This is really for internal use external callers should go through <a class="el" href="classk_set_galley_display_font_cmd_boss.html">kSetGalleyDisplayFontCmdBoss</a> which will end up calling this. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">fontName</td><td>name of the font to use as a display font. </td></tr><tr><td class="paramname">initializeLines</td><td>pass true to cause the lines to be recomposed with the new display font information. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="a94bd171bb1ba140226beeaca34653dae"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::UpdateLeading </td><td>(</td><td class="paramname"></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Allows the caller to change the line spacing amount for the view. This is really for internal use external callers should go through <a class="el" href="classk_set_leading_cmd_boss.html">kSetLeadingCmdBoss</a> which will end up calling this. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">fontName</td><td>name of the font to use as a display font. </td></tr><tr><td class="paramname">initializeLines</td><td>pass true to cause the lines to be recomposed with the new display font information. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="ac9d25a8b4cb685c04cc1ae089d1cd18a"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::UpdateLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em></td><td>)</td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Causes the <a class="el" href="class_line_description.html">LineDescription</a> (text index values) to be updated to match the model. This must be called prior to fetching any <a class="el" href="class_line_description.html">LineDescription</a> and looking at any of the model or display text index fields. Also, it is not a good idea to simply update through the last line index this will cause a performance hit as then every line (that is not already updated) prior to the index of the line requested will need to be updated. It is highly recommended that the routine <a class="el" href="class_i_text_lines.html#a68a07a31812b5d44b336b0d930180dc7">GetLineStartOffsetAtLine()</a> or <a class="el" href="class_i_text_lines.html#a1a40be59ff3a1ecb7b453ef7f6fa4bd1">GetLineEndOffsetAtLine()</a> be used when possible instead of this call for external users. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">at</td><td>index of line to update through. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div><a class="anchor" id="abb5f94777433cca80ce5cd02ea50c2fe"></a><div class="memitem"><div class="memproto"><table class="mlabels"><tr><td class="mlabels-left"><table class="memname"><tr><td class="memname">virtual void ITextLines::UpdateLine </td><td>(</td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>storyIndex</em>, </td></tr><tr><td class="paramkey"></td><td></td><td class="paramtype">int32&nbsp;</td><td class="paramname"><em>at</em>&nbsp;</td></tr><tr><td></td><td>)</td><td></td><td></td></tr></table></td><td class="mlabels-right"><span class="mlabels"><span class="mlabel">pure virtual</span></span></td></tr></table></div><div class="memdoc"><p>Causes the <a class="el" href="class_line_description.html">LineDescription</a> (text index values) to be updated to match the model. This must be called prior to fetching any <a class="el" href="class_line_description.html">LineDescription</a> and looking at any of the model or display text index fields. Also, it is not a good idea to simply update through the last line index this will cause a performance hit as then every line (that is not already updated) prior to the index of the line requested will need to be updated. It is highly recommended that the routine <a class="el" href="class_i_text_lines.html#a68a07a31812b5d44b336b0d930180dc7">GetLineStartOffsetAtLine()</a> or <a class="el" href="class_i_text_lines.html#a1a40be59ff3a1ecb7b453ef7f6fa4bd1">GetLineEndOffsetAtLine()</a> be used when possible instead of this call for external users. <dl class="params"><dt>Parameters<dd><table class="params"><tr><td class="paramname">storyIndex</td><td>index of story to get line from </td></tr><tr><td class="paramname">at</td><td>index of line to update through. </td></tr></table></dl><dl class="section return"><dt>Returns<dd>none. </dl></div></div></div></div><div class="navpath" id="nav-path"><ul><li class="navelem"><a class="el" href="class_i_text_lines.html">ITextLines</a><li class="footer">Generated on Sat Sep 22 2018 10:54:31 for InDesign SDK by <a href="http://www.doxygen.org/index.html"> <img alt="doxygen" class="footer" src="doxygen.png" /></a> 1.8.3.1 </ul></div></body></html>
